<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Cherno笔记(1-30) | 徒心的网络自留地</title><meta name="author" content="徒心"><meta name="copyright" content="徒心"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="💡 “Best C++ course for game development。” 同样适合作为C++初学者的入门课，讲到都是C++在工作中最重要的内容。  课程地址：Youtube上TheCherno上传的视频 翻译：神经元猫的高质量翻译 1 Welcome to C++ 如果用C++写垃圾代码，甚至有可能比虚拟机语言（C#, Java）更慢，因为后者会再运行时优化很多东西而C++不会。 2">
<meta property="og:type" content="article">
<meta property="og:title" content="Cherno笔记(1-30)">
<meta property="og:url" content="https://jkup64.github.io/2023/04/01/C-Cherno-Cherno%E7%AC%94%E8%AE%B0-1-30/index.html">
<meta property="og:site_name" content="徒心的网络自留地">
<meta property="og:description" content="💡 “Best C++ course for game development。” 同样适合作为C++初学者的入门课，讲到都是C++在工作中最重要的内容。  课程地址：Youtube上TheCherno上传的视频 翻译：神经元猫的高质量翻译 1 Welcome to C++ 如果用C++写垃圾代码，甚至有可能比虚拟机语言（C#, Java）更慢，因为后者会再运行时优化很多东西而C++不会。 2">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://jkup64.github.io/images/cpp.png">
<meta property="article:published_time" content="2023-04-01T12:10:58.000Z">
<meta property="article:modified_time" content="2023-08-19T09:09:52.673Z">
<meta property="article:author" content="徒心">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://jkup64.github.io/images/cpp.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://jkup64.github.io/2023/04/01/C-Cherno-Cherno%E7%AC%94%E8%AE%B0-1-30/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="6KEGOdCLLrPC5PX81XZwi31w2fujLtnRiMAZZjiFYow"/><meta name="baidu-site-verification" content="code-fuHCOXmgL5"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"距离文章上次更新已过去","messageNext":"天, 内容可能已过期."},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":500},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: true,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Cherno笔记(1-30)',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-08-19 17:09:52'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/images/avater2.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">46</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">16</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">16</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/images/cpp.png')"><nav id="nav"><span id="blog-info"><a href="/" title="徒心的网络自留地"><span class="site-name">徒心的网络自留地</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Cherno笔记(1-30)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-04-01T12:10:58.000Z" title="发表于 2023-04-01 20:10:58">2023-04-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-08-19T09:09:52.673Z" title="更新于 2023-08-19 17:09:52">2023-08-19</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C/">C++</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C/Cherno/">Cherno</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">6.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>25分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Cherno笔记(1-30)"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><blockquote>
<p>💡 “Best C++ course for game development。”<br>
同样适合作为C++初学者的入门课，讲到都是C++在工作中最重要的内容。</p>
</blockquote>
<p>课程地址：<a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=18c3MTX0PK0&amp;list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb&amp;index=1">Youtube上TheCherno上传的视频</a><br>
翻译：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1uy4y167h2/?spm_id_from=333.788&amp;vd_source=0d3fa48307c38b76dfdfa60ed4b44b42">神经元猫的高质量翻译</a></p>
<h1 id="1-Welcome-to-C">1 Welcome to C++</h1>
<p>如果用C++写垃圾代码，甚至有可能比虚拟机语言（C#, Java）更慢，因为后者会再运行时优化很多东西而C++不会。</p>
<h1 id="2-How-to-Setup-C-on-Windows">2 How to Setup C++ on Windows</h1>
<p>不要使用VS默认位置：地址长且包含一个空格，英伟达的某些VS安卓插件的某些部分无法正常工作。</p>
<p><strong>solution基本就是一个工作台，是一个包含多个相关project的集合</strong>，这些project可以是不同类型的，比如dll、exe、lib等，而每个project是文件的集合，然后被编译成某种目标二进制文件（比如library或executable）。</p>
<h1 id="3-How-to-Setup-C-on-Mac">3 How to Setup C++ on Mac</h1>
<p>后面的教程都是基于Visual Studio的，由于没钱买Mac，这里就跳过了。</p>
<h1 id="4-How-to-Setup-C-on-Linux">4 How to Setup C++ on Linux</h1>
<p>这节教Linux上<a target="_blank" rel="noopener" href="https://www.codeblocks.org/">Code::Blocks</a>的使用，本人在Linux上习惯用VS code，这节没认真看。</p>
<h1 id="5-How-C-Works">5 How C++ Works</h1>
<p>任何以#开头的都是<code>预处理指令（processor statement</code> ，会将对应文件进行拷贝和粘贴，它们发生在真正的编译过程之前。</p>
<p>如果你不返回任何值，它会返回0，这只适用于main()。</p>
<p><code>&lt;&lt;</code> ：被重载的符号，虽然看起来像运算符，可以把它们想象成一个函数。<br>
<code>std::cout &lt;&lt; “Hello World!” &lt;&lt; std::endl;</code> 可以想成伪代码 <code>std::cout.print(”Hello World!”).print(std::endl);</code> （后者跑不起来）。</p>
<p>防止关闭窗口：<code>std::cin.get()</code> 或 <code>system(”pause”);</code> 。</p>
<p>VS中Output Window和Error List都可以看到错误，但是Error List几乎是垃圾，它本身就是尝试在Output中寻找Error单词并把信息加入Error List，它提供的是overview，如果想要更详细的信息，还是得去Output Windows中看。<br>
双击Output中的行数，会自动将光标定位到对应位置。</p>
<ul>
<li>声明（declarations）：说该符号或者函数存在</li>
<li>定义（definitions）：说明这个函数到底是啥</li>
</ul>
<p>若声明却没有定义函数，编译器依旧完全相信你，但链接器试图寻找定义的函数时却找不到该函数就会报链接错误。如果都正确了，编译器会将每个文件但单独编译为 .obj 文件，而链接器会将他们合并为一个可执行文件，例如 exe 文件。</p>
<h1 id="6-How-the-C-Compiler-Works">6 How the C++ Compiler Works</h1>
<p>cpp文件可称为 <code>translation unit</code>，c++和Java不同：Java文件必须与class对应，而文件夹必须与package对应；而<strong>C++中文件只是向编译器喂源码的方式，一个cpp文件对应一个obj文件。</strong></p>
<p>#include 预处理指令只是会将对应文件的全部内容原原本本的复制粘贴到源码中，形成.i后缀文件（VS中需要在项目属性中打开预处理到文件，注意VS提示我们这将不会生成obj文件）。</p>
<p>可以使用如下语句控制.i文件内容：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> 条件</span></span><br><span class="line">语句块<span class="number">1</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">语句块<span class="number">2</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><strong>constant folding</strong>：编译优化时完成常数运算，而非运行时，比如 return 2 * 5 对应 mov eax 10。</p>
<p>Debug模式默认开启Od，即不优化，便于分析.asm汇编文件。</p>
<h1 id="7-How-the-C-Linker-Works">7 How the C++ Linker Works</h1>
<p>VS按<code>ctrl+F7</code>或点编译，则只会进行编译<br>
VS按<code>ctrl+F5</code>或点生成（build），则会对整个项目进行compile+link，需要entry point（可以是main()也可以是其他——在VS项目属性中定义）</p>
<p>error C2143：以C开头为编译错误，LNK2143：以LNK开头为链接时错误</p>
<h2 id="Unresolved-external-symbol">Unresolved external symbol</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ---Log.cpp---</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Logr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *message)</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---Math.cpp---</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Log</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Multiply</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">Log</span>(<span class="string">&quot;Multiply&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="built_in">Multiply</span>(<span class="number">5</span>, <span class="number">8</span>) &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>由于linker找不到Log()，build会报 LNK1120：1 unresolved external symbol。</li>
<li>若注释掉15行  <code>Log(&quot;Multiply&quot;);</code> 则不会报错，因为linker不需要去寻找Log()地址。</li>
<li>若注释20行 <code>std::cout &lt;&lt; Multiply(5, 8) &lt;&lt; std::endl;</code> 则仍然会报错，因为<strong>虽然本文件没用到Multiply()，但是其他文件生成时可能会link到Multiply()。</strong></li>
<li>若注释20行，同时在Multiply()前加上<strong>static声明</strong>（不能被其他obj文件函数引用），则不会报错。</li>
</ol>
<h2 id="重复定义">重复定义</h2>
<ol>
<li>一个文件中定义两个名称、参数、返回类型完全相同的函数会报 C2084。</li>
<li>两个文件中定义两个名称、参数、返回类型完全相同的函数会报 LNK1169。下面例子展示这种错误有多容易犯：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ---Log.h---</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Log</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *message)</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---Log.cpp---</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Log.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitLog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">Log</span>(<span class="string">&quot;Initialized Log&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---Math.cpp---</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Log.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Log</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Multiply</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">Log</span>(<span class="string">&quot;Multiply&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="built_in">Multiply</span>(<span class="number">5</span>, <span class="number">8</span>) &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>问题： Log.cpp和Math.cpp中都有 Log() 的定义，这导致linker无法选择。</p>
<p>3钟解决方式如下：</p>
<ol>
<li>推荐：<strong>.h头文件保留声明，定义放到第三个translation unit中</strong>，这里放到Log.cpp中很合适。</li>
<li>在.h中Log()前加上static：2个cpp中的Log都不能被其他obj文件链接</li>
<li>在.h中Log()前加上inline：作用是将函数调用直接替换成函数体<br>
<code>Log(&quot;Initialized Log&quot;);</code> 变成 <code>std::cout &lt;&lt; &quot;Initialized Log&quot; &lt;&lt; std::endl;</code></li>
</ol>
<h1 id="8-Variables-in-C">8 Variables in C++</h1>
<p>c++中不同变量类型之间的唯一区别是大小——创建变量时通过数据类型决定分配的内存大小。数据类型取决于程序员，并没有很多规则去束缚，但是cout等时会根据类型决定打印的结果。<br>
( Cherno这样说其实有点问题，不只是内存大小不同的问题，类型还将决定可执行的操作。)</p>
<p><code>float val = 5.5;</code> 可能会以为浮点数常量的是float类型，但在VS把光标放到<code>5.5</code>上可以看到其实是(double)(5.5)，稍后被强制转化为float。<br>
要定义浮点数要使用 <code>float val = 5.5f;</code> 或 <code>float val = 5.5F;</code> 。</p>
<p>bool类型变量只有0是false，非0都是true，打印bool变量会得到0或1。<br>
虽然存储bool类型按理来说1bit就可以，但没办法寻址1个bit的内容，内存寻址的最小单元是byte。可通过技巧解决：一个byte放8个bool。</p>
<h1 id="9-Functions">9 Functions</h1>
<ul>
<li>函数：降低重复代码的代码块。</li>
<li>方法：class中的代码块。</li>
</ul>
<p>声明应当放在头文件中，定义放在cpp文件中。</p>
<h1 id="10-Header-files">10 Header files</h1>
<p>有两种不同文件类型的概念，一种是像cpp一样编译文件，这种就有头文件概念；而另一种像C#和Java中没有头文件概念。</p>
<p>VS中文件夹是假的，文件具体放在哪个文件夹其实都可以。</p>
<p><code>#pragma once</code>: #开头的都是预处理指令，发生在编译之前。<br>
组织单个头文件被多次包含，并转换为单个翻译单元——可以被放在程序的多个位置，但一个翻译单元（一个cpp文件）只能放一次。</p>
<p><code>#pragma once</code> <strong>很简洁很好用，工业中广泛应用</strong>。<br>
另一种传统方式是添加 <code>header guides</code> 如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _LOG_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _LOG_H</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitLog</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Log</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Player</span> &#123;&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>如果被包含两次，则结果如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _LOG_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _LOG_H</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitLog</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Log</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Player</span> &#123;&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _LOG_H  <span class="comment">// false, endif前的都不会被执行</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _LOG_H</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitLog</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Log</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Player</span> &#123;&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>&lt;&gt;与“”：</p>
<ul>
<li>尖括号：告诉<strong>编译器目标路径</strong>中包含所需要包含的文件夹。</li>
<li>引号： 既包含相对于当前路径的文件，比如<code>#include “../Log.h”</code> ，又可用来指定编译器包含目录的相对路径里的文件，比如<code>#include “iostream”</code> 。</li>
<li>尖括号只用于编译器包含路径，引号可以做一切（通常用在包含相对路径）。</li>
</ul>
<p>iostream其实也是文件，只不过没有扩展名，c++设计者有意通过这点将C++标准库与C标准库区分。</p>
<h1 id="11-How-to-DUBUG-in-VS">11 How to DUBUG in VS</h1>
<p>调试的两大部分：断点 和 读取内存。</p>
<p>VS的调试模式中会给所有未初始化的局部变量赋值为<code>0xcc</code>， 在调试/窗口/内存中可以打开内存视图，输入<code>&amp;a</code>，可以查看变量地址和值。</p>
<p>str初始化后，可以通过其值（是一个字符串地址）去寻找到对应字符串，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x00609B30</span>  <span class="number">68</span> <span class="number">65</span> <span class="number">6</span>c <span class="number">6</span>c <span class="number">6f</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">48</span> <span class="number">65</span> <span class="number">6</span>c <span class="number">6</span>c <span class="number">6f</span> <span class="number">20</span> <span class="number">57</span> <span class="number">6f</span> <span class="number">72</span> <span class="number">6</span>c <span class="number">64</span> <span class="number">21</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> b0 <span class="number">40</span> <span class="number">08</span> <span class="number">9</span>c  hello...Hello World!......?@.?</span><br><span class="line"><span class="number">0x00609B4E</span>  <span class="number">60</span> <span class="number">00</span> <span class="number">18</span> <span class="number">9</span>d <span class="number">60</span> <span class="number">00</span> <span class="number">70</span> <span class="number">9</span>e <span class="number">60</span> <span class="number">00</span> <span class="number">94</span> <span class="number">9</span>e <span class="number">60</span> <span class="number">00</span> d4 <span class="number">9</span>e <span class="number">60</span> <span class="number">00</span> <span class="number">08</span> <span class="number">9f</span> <span class="number">60</span> <span class="number">00</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  `..?`.p?`.??`.??`..?`.........</span><br><span class="line"><span class="number">0x00609B6C</span>  <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">53</span> <span class="number">74</span> <span class="number">61</span> <span class="number">63</span> <span class="number">6b</span> <span class="number">20</span> <span class="number">61</span> <span class="number">72</span> <span class="number">6f</span> <span class="number">75</span> <span class="number">6</span>e <span class="number">64</span> <span class="number">20</span> <span class="number">74</span>  ................Stack around t</span><br><span class="line"><span class="number">0x00609B8A</span>  <span class="number">68</span> <span class="number">65</span> <span class="number">20</span> <span class="number">76</span> <span class="number">61</span> <span class="number">72</span> <span class="number">69</span> <span class="number">61</span> <span class="number">62</span> <span class="number">6</span>c <span class="number">65</span> <span class="number">20</span> <span class="number">27</span> <span class="number">00</span> <span class="number">27</span> <span class="number">20</span> <span class="number">77</span> <span class="number">61</span> <span class="number">73</span> <span class="number">20</span> <span class="number">63</span> <span class="number">6f</span> <span class="number">72</span> <span class="number">72</span> <span class="number">75</span> <span class="number">70</span> <span class="number">74</span> <span class="number">65</span> <span class="number">64</span> <span class="number">2</span>e  he variable <span class="string">&#x27;.&#x27;</span> was corrupted.</span><br><span class="line"><span class="number">0x00609BA8</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">54</span> <span class="number">68</span> <span class="number">65</span> <span class="number">20</span> <span class="number">76</span> <span class="number">61</span> <span class="number">72</span> <span class="number">69</span> <span class="number">61</span> <span class="number">62</span> <span class="number">6</span>c <span class="number">65</span> <span class="number">20</span> <span class="number">27</span> <span class="number">00</span> <span class="number">00</span> <span class="number">27</span> <span class="number">20</span> <span class="number">69</span> <span class="number">73</span> <span class="number">20</span> <span class="number">62</span> <span class="number">65</span> <span class="number">69</span> <span class="number">6</span>e <span class="number">67</span>  ....The variable <span class="string">&#x27;..&#x27;</span> is being</span><br><span class="line"><span class="number">0x00609BC6</span>  <span class="number">20</span> <span class="number">75</span> <span class="number">73</span> <span class="number">65</span> <span class="number">64</span> <span class="number">20</span> <span class="number">77</span> <span class="number">69</span> <span class="number">74</span> <span class="number">68</span> <span class="number">6f</span> <span class="number">75</span> <span class="number">74</span> <span class="number">20</span> <span class="number">62</span> <span class="number">65</span> <span class="number">69</span> <span class="number">6</span>e <span class="number">67</span> <span class="number">20</span> <span class="number">69</span> <span class="number">6</span>e <span class="number">69</span> <span class="number">74</span> <span class="number">69</span> <span class="number">61</span> <span class="number">6</span>c <span class="number">69</span> <span class="number">7</span>a <span class="number">65</span>   used without being initialize</span><br><span class="line"><span class="number">0x00609BE4</span>  <span class="number">64</span> <span class="number">2</span>e <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  d.............................</span><br><span class="line"><span class="number">0x00609C02</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">54</span> <span class="number">68</span> <span class="number">65</span> <span class="number">20</span> <span class="number">76</span> <span class="number">61</span> <span class="number">6</span>c <span class="number">75</span> <span class="number">65</span> <span class="number">20</span> <span class="number">6f</span> <span class="number">66</span> <span class="number">20</span> <span class="number">45</span> <span class="number">53</span> <span class="number">50</span> <span class="number">20</span> <span class="number">77</span> <span class="number">61</span> <span class="number">73</span> <span class="number">20</span> <span class="number">6</span>e <span class="number">6f</span> <span class="number">74</span>  ......The value of ESP was <span class="keyword">not</span></span><br></pre></td></tr></table></figure>
<h1 id="12-CONDITIONS-and-BRANCHES-in-C">12 CONDITIONS and BRANCHES in C++</h1>
<p>可以通过避免分支对程序进行优化。</p>
<p>可以在VS编辑区右键进入反汇编代码，静态分析反汇编代码在没有源码时非常有用，但在有源码时这是nightmare的，不过分析汇编代码可以学习一些知识：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> compare_res = x == <span class="number">5</span>;</span><br><span class="line"><span class="number">00</span>AB195C  cmp         dword ptr [x],<span class="number">5</span>  </span><br><span class="line"><span class="number">00</span>AB1960  jne         __$EncStackInitStart+<span class="number">32</span>h (<span class="number">0</span>AB196Eh)  </span><br><span class="line"><span class="number">00</span>AB1962  mov         dword ptr [ebp<span class="number">-0</span>DCh],<span class="number">1</span>  </span><br><span class="line"><span class="number">00</span>AB196C  jmp         __$EncStackInitStart+<span class="number">3</span>Ch (<span class="number">0</span>AB1978h)  </span><br><span class="line"><span class="number">00</span>AB196E  mov         dword ptr [ebp<span class="number">-0</span>DCh],<span class="number">0</span>  </span><br><span class="line"><span class="number">00</span>AB1978  movzx       eax,byte ptr [ebp<span class="number">-0</span>DCh]  </span><br><span class="line"><span class="number">00</span>AB197F  mov         byte ptr [compare_res],al</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> compare_res = <span class="number">423</span>;</span><br><span class="line"><span class="number">00F</span>B195C  mov         byte ptr [compare_res],<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><strong>不要写单行写 <code>if (x == 5)  cout &lt;&lt; “y” &lt;&lt; endl;</code> ：调试时不能进入后一句</strong>且<strong>不便于增添！</strong></p>
<p><code>else if</code> 并非什么C++关键词，其实就是 <code>else + if (条件)</code> 。</p>
<h1 id="13-BEST-Visual-Studio-Setup-for-C-Projects">13 BEST Visual Studio Setup for C++ Projects!</h1>
<p>VS中展示的并不是文件夹（folder），而是过滤器（filter）。在项目下新建的也是filter。<br>
点击“显示所有文件的图标”后展示的就是磁盘目录视图，在这里可以新建folder。推荐新建一个<code>src</code>文件夹，然后将所有cpp文件和头文件都放到里面。</p>
<p>输出目录：<code>$(SolutionDir)bin\$(Platform)\$(Configuration)\</code></p>
<p>中间件目录：<code>$(SolutionDir)bin\intermediates\$(Platform)\$(Configuration)\</code></p>
<h1 id="14-Loops-in-C-for-loops-while-loops">14 Loops in C++ (for loops, while loops)</h1>
<p>个人觉得循环没啥好讲的</p>
<h1 id="15-Control-Flow-in-C-continue-break-return">15 Control Flow in C++ (continue, break, return)</h1>
<ul>
<li>continue：只在loop中出现。</li>
<li>break：多在loop中出现，也在switch中出现。</li>
<li>return：完全退出function，在哪都可以。</li>
</ul>
<h1 id="16-POINTERS-in-C">16 POINTERS in C++</h1>
<p>目前只讨论raw pointers，不讨论smart pointers。</p>
<p>指针对manage和manipulate内存极度重要，pointer is a integer which stores a memory address。类型实际上没有意义，只是帮助推断地址所指的数据类型。</p>
<p><code>void* ptr = 0;</code>  表述此无类型（类型实际上无意义）指针为NULL，内存地址不能到0。<br>
实际上0表示NULL，或者说NULL和nullptr被define为0。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">6</span>;</span><br><span class="line"><span class="type">double</span>* ptr = (<span class="type">double</span>*)&amp;x;</span><br><span class="line">*ptr = <span class="number">10</span>;</span><br><span class="line">std::cout &lt;&lt; x &lt;&lt; std::endl;  <span class="comment">// 最终输出0</span></span><br></pre></td></tr></table></figure>
<p>编译器会根据类型设置位模式，也会根据类型解释位模式。</p>
<p><img src="/2023/04/01/C-Cherno-Cherno%E7%AC%94%E8%AE%B0-1-30/Untitled.png" alt="Untitled"></p>
<p>逆向引用：指针的*运算符通常被称为dereference运算符</p>
<p>指针也是存在于内存中的<strong>变量</strong>，可以使用double pointer。</p>
<p>指针指向堆上内存的例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* buffer = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">8</span>];</span><br><span class="line"><span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span>[] buffer;</span><br></pre></td></tr></table></figure>
<p>注意手动删除指针数组需要使用<code>delete []</code>。</p>
<h1 id="17-REFERENCES-in-C">17 REFERENCES in C++</h1>
<p>引用只是指针的扩展，是指针的语法糖，使它更容易容易阅读、更容易理解。<br>
<strong>没有什么引用能做而指针不能做的事情</strong>，指针更有用更强大，但是很多情况下使用引用更简单。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// --- 指针 ---</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increase</span><span class="params">(<span class="type">int</span> *val)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//(*val)++;  // 必须加括号, ++优先级比*高</span></span><br><span class="line">  ++(*val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> a = <span class="number">8</span>;</span><br><span class="line">  <span class="built_in">increase</span>(&amp;a);</span><br><span class="line">  std::cout &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">  std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --- 引用 ---</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increase</span><span class="params">(<span class="type">int</span> &amp;val)</span> </span>&#123;</span><br><span class="line">  ++val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> a = <span class="number">8</span>;</span><br><span class="line">  <span class="built_in">increase</span>(a);</span><br><span class="line">  std::cout &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">  std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>引用是引用现有变量的方式，<strong>引用本身只是别名，不是变量，不占内存</strong>，不像指针可以传创建一个新指针变量然后设置它等于空指针或者类似的东西。<br>
<strong>定义引用后无法修改，声明时必须立即赋值。</strong></p>
<p><code>int&amp; alias = a;</code>  &amp;是类型的一部分，这与指针中使用到的取地址符不同，这里alias只是别名，通过汇编代码去看的话，只有一个变量</p>
<blockquote>
<p>💡 引用和指针的区别：<br>
本质上指针是存储地址的对象（变量），而引用是对象的别名，因此：</p>
<ol>
<li>指针占内存空间；而引用不占。</li>
<li>指针不必初始化（这时使用默认初始化）；而引用必须初始化。</li>
<li>指针可以重新赋值；而引用不能。</li>
<li>可以存在指针的指针等；而不存在引用的引用。<br>
个人理解：引用是指针的语法糖，它自带顶层const属性。</li>
</ol>
<p>PS：<br>
顶层const（top-level const）：本身是个常量。<br>
底层const（low-level const）：所指对象是一个常量。</p>
</blockquote>
<h1 id="18-CLASSES-in-C">18 CLASSES in C++</h1>
<p>类只是方便组合数据和函数的一种简单方式。<strong>任何使用class做的事情，不用class也能做，class并没有提供新的functionality。</strong></p>
<p>类是一种变量类型，是自定义数据类型的基础。</p>
<h1 id="19-CLASSES-vs-STRUCTS-in-C">19 CLASSES vs STRUCTS in C++</h1>
<p>类和结构体唯一区别是：类默认是private的，结构体默认是public的。<br>
struct在c++中唯一存在的原因是，C++希望与C保持向后兼容性。</p>
<p>如果想要所有成员都是public的，然而又不想写上public，应该使用struct吗？——是的，它就算这样的微不足道。 （这个问题不绝对，取决于编程风格）</p>
<p>从技术上讲，<strong>除了visibility，二者可能没有太大区别</strong>，然而实际的使用情况会有所不同。——继承，<strong>不要在struct中使用继承</strong>，若要有一个完整的类层次，使用类。</p>
<h1 id="20-How-to-Write-a-C-Class">20 How to Write a C++ Class</h1>
<p>这节讲类讲的非常简单，本节给出了一个Log类的例子，第23节[”ENUMS in C++“](./# ENUMS in C++)中给出了此Log类例子的升级版。</p>
<h1 id="21-Static-in-C">21 Static in C++</h1>
<p>static在C++中根据上下文有两种意思，一种是在类或结构体外使用static关键字，一种是在类或结构体内部使用static。</p>
<ul>
<li>类外的static，声明为static的符号链接将只在内部，这意味着它只对定义所在的翻译单元可见。</li>
<li>类或结构体内的static，意味着该变量实际上将与类所有实例共享内存，静态变量只有1个实例。</li>
</ul>
<p><strong>不同文件中不能有同名的全局变量</strong>，除非使用static修饰，或者在某个文件中使用 <code>extern</code> 声明。</p>
<p>全局变量不好，一定要尽可能使用static，除非真的需要跨翻译单元链接。</p>
<h1 id="22-Static-for-Classes-and-Structs-in-C">22 Static for Classes and Structs in C++</h1>
<p>通过类实例引用静态变量无意义，因为类静态变量就像类的全局实例一样。<br>
静态方法也是一样，<strong>无法访问类的实例</strong>，静态方法不需要通过类的实例被调用，而在静态方法内部，不能写引用到类实例的代码，<strong>静态方法也不能访问非静态变量</strong>。</p>
<blockquote>
<p>💡 在类中写的每个非静态方法总会获得当前类的一个实例作为参数，而静态方法不会获得那个隐藏参数，所以不能访问非静态变量。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> x, y;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; y = &quot;</span> &lt;&lt; y &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Entity::x, Entity::y;  <span class="comment">// 一定要声明</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Entity e1;</span><br><span class="line">  e1.x = <span class="number">2</span>;</span><br><span class="line">  e1.y = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Entity e2 = &#123;5, 8&#125;;  // 加上static后x和y不再是成员变量，不能这样初始化</span></span><br><span class="line">  Entity e2;</span><br><span class="line">  e2.x = <span class="number">5</span>;</span><br><span class="line">  e2.y = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">  e1.<span class="built_in">print</span>();</span><br><span class="line">  e2.<span class="built_in">print</span>();</span><br><span class="line">  <span class="comment">// Entity::print(); 如果成员方法不加static不能这样: 调用非静态成员函数需要一个对象</span></span><br><span class="line">  <span class="comment">// 如果加上static, 既可通过对象,又可通过Entity::print();</span></span><br><span class="line"></span><br><span class="line">  std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// === 输出 ===</span></span><br><span class="line">x = <span class="number">5</span> y = <span class="number">8</span></span><br><span class="line">x = <span class="number">5</span> y = <span class="number">8</span></span><br></pre></td></tr></table></figure>
<h1 id="23-ENUMS-in-C">23 ENUMS in C++</h1>
<p>enumeration 是一组值的集合，是一种<strong>命名值的方式</strong>（枚举数其实就是一个<strong>整数</strong>）。<br>
当想使用整数来表示某些状态或某些数值时，它非常有用。</p>
<ul>
<li>第一个元素默认是0，第二个往后默认增1</li>
<li>enum元素类型默认是int，可以通过如下方式修改为<code>unsigned char</code></li>
<li>第6行后value的类型可以写 unsigned char，也可以写Example**，写后者的话就限制在A、B、C三个值中（当然也可以绕过）**。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Example</span> : <span class="type">unsigned</span> <span class="type">char</span> &#123;</span><br><span class="line">  A = <span class="number">5</span>, B, C</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Example value = B;</span><br><span class="line">  <span class="keyword">if</span> (value == <span class="number">6</span>) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;value = 6&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">  std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面给出一个更偏实际的例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Log</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">enum</span>  <span class="title class_">Level</span> &#123;</span><br><span class="line">		LevelError = <span class="number">0</span>, LevelWarning, LevelInfo  <span class="comment">// 不要用Error: 和Error函数同名</span></span><br><span class="line">	&#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Level m_LogLevel = LevelInfo;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">SetLevel</span><span class="params">(Level level)</span> </span>&#123;</span><br><span class="line">		m_LogLevel = level;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Error</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (m_LogLevel &gt;= LevelError) &#123;</span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;[ERROR]:&quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Warn</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (m_LogLevel &gt;= LevelWarning) &#123;</span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;[WARNING]:&quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Info</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (m_LogLevel &gt;= LevelInfo) &#123;</span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;[INFO]:&quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Log log;</span><br><span class="line">	log.<span class="built_in">SetLevel</span>(Log::LevelError);  <span class="comment">// 这里Level只是普通的枚举数，不是枚举类，Level不是真正的命名空间</span></span><br><span class="line">	log.<span class="built_in">Error</span>(<span class="string">&quot;Hello!&quot;</span>);</span><br><span class="line">	log.<span class="built_in">Warn</span>(<span class="string">&quot;Hello!&quot;</span>);</span><br><span class="line">	log.<span class="built_in">Info</span>(<span class="string">&quot;Hello!&quot;</span>);</span><br><span class="line">	std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="24-Constructors-in-C">24 Constructors in C++</h1>
<p>构造函数最通用用法：创建类的实例时<strong>初始化该类，确保初始化了所有的内存</strong>。</p>
<p>Java等语言对于数据基本类型，比如int和float会自动初始化为0，但是C++不会，必须手动初始化所有基本类型。</p>
<p>可以写多个构造函数，前提是它们有不同的参数（函数重载：<strong>同域</strong>下的同名函数的不同版本）。</p>
<p><strong>若不实例化对象，将不会运行构造方法，比如只使用一个类的静态方法。</strong><br>
当使用new创建一个对象时，也会调用构造方法。</p>
<blockquote>
<p>💡 <strong>删除构造函数的方法：</strong></p>
<ol>
<li>设置private隐藏构造函数</li>
<li><code>Log() = delete;</code></li>
</ol>
</blockquote>
<h1 id="25-Destructors-in-C">25 Destructors in C++</h1>
<p>任何时候，一个对象要被销毁时，析构函数将被调用。</p>
<p>析构函数同样适用于堆和栈分配的对象，堆：调用delete时析构函数将被调用；栈：当作用域结束时，栈对象将被删除——不要主动调用，<strong>否则会造成double destruct</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">float</span> X, Y;</span><br><span class="line">  <span class="built_in">Entity</span>() &#123;</span><br><span class="line">    X = <span class="number">0.0f</span>, Y = <span class="number">0.0f</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Created Entity!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Entity</span>(<span class="type">float</span> x, <span class="type">float</span> y) &#123;  <span class="comment">// 重载构造函数</span></span><br><span class="line">    X = x, Y = y;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">Entity</span>() &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Destroyed Entity!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; X &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; Y &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">Entity <span class="title">e</span><span class="params">(<span class="number">0.1</span>, <span class="number">9.9</span>)</span></span>;</span><br><span class="line">  e.<span class="built_in">Print</span>();  <span class="comment">// 作用域结束时，栈对象被删除，析构函数被调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">Function</span>();</span><br><span class="line">  std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="26-Inheritance">26 Inheritance</h1>
<p><strong>继承：避免代码重复，扩展现有类并为基类提供新功能的一种方式。</strong></p>
<p>父类是子类的子集，子类是父类的超集。如果开始重写函数和Player类，就需要维护一个虚函数表（V表），需要额外占用内存。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">float</span> X, Y;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">move</span><span class="params">(<span class="type">float</span> x, <span class="type">float</span> y)</span> </span>&#123;</span><br><span class="line">    X = x, Y = y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> : <span class="keyword">public</span> Entity &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span>* name;  <span class="comment">// x86下为4字节，x64下地址占8字节</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">printName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; name &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="keyword">sizeof</span> Entity &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; <span class="keyword">sizeof</span> Player &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  Player player;</span><br><span class="line">  player.<span class="built_in">move</span>(<span class="number">5</span>, <span class="number">5</span>);</span><br><span class="line">  player.X = <span class="number">2</span>;</span><br><span class="line">  std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意上述代码中 <code>sizeof Player</code> 的结果在x86和x64下不同，地址位数不同。</p>
<p><strong>多态：使用一种类型表示多种类型，比如Player不只是Player也是Entity</strong>，可以在任何需要使用Entity的地方使用Player。</p>
<h1 id="27-Virtual-Functions">27 Virtual Functions</h1>
<p>虚函数允许在子类中重写方法：若B是A的子类，可以在A类中创建一个方法，标记为virtual，可选择在B类中重写那个方法，让它做其他事情。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">std::string <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;Entity&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> : <span class="keyword">public</span> Entity &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  std::string m_name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Player</span>(<span class="type">const</span> std::string &amp;name)</span><br><span class="line">    : <span class="built_in">m_name</span>(name) &#123;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function">std::string <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_name; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Entity* e = <span class="keyword">new</span> <span class="built_in">Entity</span>();</span><br><span class="line">  std::cout &lt;&lt; e-&gt;<span class="built_in">getName</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  Player* p = <span class="keyword">new</span> <span class="built_in">Player</span>(<span class="string">&quot;JKA&quot;</span>);</span><br><span class="line">  std::cout &lt;&lt; p-&gt;<span class="built_in">getName</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  Entity* entity = p;</span><br><span class="line">  std::cout &lt;&lt; entity-&gt;<span class="built_in">getName</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --- 输出 ---</span></span><br><span class="line">Entity</span><br><span class="line">JKA</span><br><span class="line">Entity </span><br></pre></td></tr></table></figure>
<p>上面代码中， Player类型的p被赋值给声明为Entity的变量，调用getName()的是Entity的getName()。</p>
<p>原因：通常在我们声明函数时，我们的方法通常在类内部起作用，然后当要调用方法时，会调用属于该类的方法。可以通过虚函数解决此问题。</p>
<p><strong>虚函数引入了一种称为Dynamic Dispatch（动态联编）的东西，它通常通过v表（虚函数表）来实现编译，v表就是一个表，它包含基类中所有虚函数的映射，这样就可在运行时将它们映射到正确的覆写（override）函数。</strong><br>
如果想覆写一个函数，必须将基类中的基函数标记为虚函数：</p>
<ol>
<li>父类加上virtual关键字。</li>
<li>子类加上override关键字（C++11），好处：1.易读；2.减少错误：如果函数名称写错了——和父类函数名不同，就报错提醒。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> std::string <span class="title">GetName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;Entity&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> : <span class="keyword">public</span> Entity &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  std::string m_name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Player</span>(<span class="type">const</span> std::string &amp;name)</span><br><span class="line">    : <span class="built_in">m_name</span>(name) &#123;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function">std::string <span class="title">GetName</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> m_name; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --- 输出 ---</span></span><br><span class="line">Entity</span><br><span class="line">JKA</span><br><span class="line">JKA</span><br></pre></td></tr></table></figure>
<p>虚函数有两种<strong>运行时成本</strong>：</p>
<ol>
<li><strong>存储v表</strong>内存：基类中要有一个成员指针，指向v表。</li>
<li>每次调用虚函数时，需要<strong>遍历</strong>这个表，来确定映射到哪个函数。</li>
</ol>
<h1 id="28-Interfaces-in-C-Pure-Virtual-Functions">28 Interfaces in C++ (Pure Virtual Functions)</h1>
<p>C++中<strong>纯虚函数允许我们在基类中定义一个没有实现的函数，然后强制子类去实现该函数</strong>。确保每个类都有一个特定的方法，可以将该抽象类作为参数（类型）放入一个通用函数中。C++11中无interface关键字，其实还是一个类，<strong>只不过有一个未实现的虚函数。</strong></p>
<p>类中的接口只包含未实现的方法，作为模版。<br>
由于此接口类实际不包含方法实现，实际上不可能实例化那个类，在子类中实现后可以实例化。</p>
<p>纯虚函数应该理解为<strong>虚函数 + 类不可实例化标记。</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Printable</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> std::string <span class="title">GetClasName</span><span class="params">()</span> </span>= <span class="number">0</span>;  <span class="comment">// 函数体=0，表示为纯虚函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="29-Visibility-in-C">29 Visibility in C++</h1>
<p>可见性指类的某些成员或者方法实际上有多可见，是对程序实际运行方式完全没有影响的东西，对程序的性能和类似的东西也没有影响（可见性不是cpu需要理解的东西）。</p>
<p>C++中有三个基础的可见性修饰符：<code>private</code>、<code>protected</code> 和 <code>public</code>，class中如果不写则默认为private，struct中默认为public。<br>
扩展：Java中还可以使用default（不写）可见修饰符，C#中还有internal。</p>
<ul>
<li>private意味着只有<strong>友元</strong>和<strong>目标类可以访问private变量，子类也不能访问</strong>。<br>
在C++中有个叫friend的东西，可让其他类或者函数成为目标类的友元，实际上可以从类中访问私有成员。</li>
<li><strong>protected意味着目标类和层次结构中的所有子类可以访问这些符号。</strong></li>
</ul>
<p>可见性的好处：确保人们不会调用不该调用的代码该破坏。<br>
一个关于UI的例子：使用按钮改变位置时如果只是修改X=5，显示器会使用内存中旧的X值，一个做法是声明X为private（提醒自己和他人不要通过赋值修改X），而给出一个public的SetX()其中实现修改X并刷新显示器的功能。</p>
<h1 id="30-Arrays-in-C">30 Arrays in C++</h1>
<p><code>arr[-1]=0</code> Memory access violation。<br>
在Debug模式下会得到一个程序崩溃的错误信息。<br>
但在Release模式下可能不会得到报错信息，已经写入了不属于你的内存。</p>
<p><code>&lt;=</code> 运算时，在做小于以及等于的比较——影响性能</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误</span></span><br><span class="line"><span class="type">int</span> count = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> arr[count];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> count = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> arr[count];</span><br></pre></td></tr></table></figure>
<p><code>int arr[5];</code> 是在栈上创建数组，作用域结束时内存释放。<br>
<code>**int* arr = new int[5];</code> 在堆上创建数组，直到程序把它销毁之前都存在，销毁：<code>delete[] arr;</code> 。**</p>
<p>在堆上创建数组的原因：最大的原因是生存期：**如果有一个函数需要返回一个数组，这个数组在函数中创建，则必须使用new，**另一个原因是数据量太大，堆上放不下。</p>
<p><strong>sizeof 栈数组 得到数组大小</strong>，sizeof 堆数组 只能得到数组地址大小。</p>
<p>在堆上创建内存会导致 <strong>内存间接寻址（Memory Indirection）</strong>：一个指针，指向另一个内存块（保存实际的数组）。内存中跳跃影响性能，还可能会导致内存碎片（Memory fragmentation），缓存丢失（cache miss）。</p>
<p>标准数组：std::array 内置在C++库。优点：边界检查，记录数组大小，这会带来较小的性能损耗。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::array&lt;<span class="type">int</span>, 5&gt; another;</span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://jkup64.github.io">徒心</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://jkup64.github.io/2023/04/01/C-Cherno-Cherno%E7%AC%94%E8%AE%B0-1-30/">https://jkup64.github.io/2023/04/01/C-Cherno-Cherno%E7%AC%94%E8%AE%B0-1-30/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://jkup64.github.io" target="_blank">徒心的网络自留地</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/images/cpp.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/12/26/%E7%AE%97%E6%B3%95-AcWing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE-2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="第2讲 数据结构"><img class="cover" src="/images/summer_fever.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">第2讲 数据结构</div></div></a></div><div class="next-post pull-right"><a href="/2023/04/07/C-Cherno-Cherno%E7%AC%94%E8%AE%B0-31-50/" title="Cherno笔记(31-50)"><img class="cover" src="/images/cpp.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Cherno笔记(31-50)</div></div></a></div></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="waline-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-Welcome-to-C"><span class="toc-text">1 Welcome to C++</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-How-to-Setup-C-on-Windows"><span class="toc-text">2 How to Setup C++ on Windows</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-How-to-Setup-C-on-Mac"><span class="toc-text">3 How to Setup C++ on Mac</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-How-to-Setup-C-on-Linux"><span class="toc-text">4 How to Setup C++ on Linux</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-How-C-Works"><span class="toc-text">5 How C++ Works</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-How-the-C-Compiler-Works"><span class="toc-text">6 How the C++ Compiler Works</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-How-the-C-Linker-Works"><span class="toc-text">7 How the C++ Linker Works</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Unresolved-external-symbol"><span class="toc-text">Unresolved external symbol</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E5%A4%8D%E5%AE%9A%E4%B9%89"><span class="toc-text">重复定义</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-Variables-in-C"><span class="toc-text">8 Variables in C++</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-Functions"><span class="toc-text">9 Functions</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-Header-files"><span class="toc-text">10 Header files</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11-How-to-DUBUG-in-VS"><span class="toc-text">11 How to DUBUG in VS</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#12-CONDITIONS-and-BRANCHES-in-C"><span class="toc-text">12 CONDITIONS and BRANCHES in C++</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#13-BEST-Visual-Studio-Setup-for-C-Projects"><span class="toc-text">13 BEST Visual Studio Setup for C++ Projects!</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#14-Loops-in-C-for-loops-while-loops"><span class="toc-text">14 Loops in C++ (for loops, while loops)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#15-Control-Flow-in-C-continue-break-return"><span class="toc-text">15 Control Flow in C++ (continue, break, return)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#16-POINTERS-in-C"><span class="toc-text">16 POINTERS in C++</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#17-REFERENCES-in-C"><span class="toc-text">17 REFERENCES in C++</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#18-CLASSES-in-C"><span class="toc-text">18 CLASSES in C++</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#19-CLASSES-vs-STRUCTS-in-C"><span class="toc-text">19 CLASSES vs STRUCTS in C++</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#20-How-to-Write-a-C-Class"><span class="toc-text">20 How to Write a C++ Class</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#21-Static-in-C"><span class="toc-text">21 Static in C++</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#22-Static-for-Classes-and-Structs-in-C"><span class="toc-text">22 Static for Classes and Structs in C++</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#23-ENUMS-in-C"><span class="toc-text">23 ENUMS in C++</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#24-Constructors-in-C"><span class="toc-text">24 Constructors in C++</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#25-Destructors-in-C"><span class="toc-text">25 Destructors in C++</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#26-Inheritance"><span class="toc-text">26 Inheritance</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#27-Virtual-Functions"><span class="toc-text">27 Virtual Functions</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#28-Interfaces-in-C-Pure-Virtual-Functions"><span class="toc-text">28 Interfaces in C++ (Pure Virtual Functions)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#29-Visibility-in-C"><span class="toc-text">29 Visibility in C++</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#30-Arrays-in-C"><span class="toc-text">30 Arrays in C++</span></a></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By 徒心</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"><script>(() => {
  const initWaline = () => {
    const waline = Waline.init(Object.assign({
      el: '#waline-wrap',
      serverURL: 'https://waline-server-jkup64.vercel.app',
      pageview: false,
      dark: 'html[data-theme="dark"]',
      path: window.location.pathname,
      comment: false,
    }, null))
  }

  const loadWaline = async () => {
    if (typeof Waline === 'object') initWaline()
    else {
      await getCSS('https://cdn.jsdelivr.net/npm/@waline/client/dist/waline.min.css')
      await getScript('https://cdn.jsdelivr.net/npm/@waline/client/dist/waline.min.js')
      initWaline()
    }
  }

  if ('Waline' === 'Waline' || !true) {
    if (true) btf.loadComment(document.getElementById('waline-wrap'),loadWaline)
    else setTimeout(loadWaline, 0)
  } else {
    window.loadOtherComment = loadWaline
  }
})()</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>