<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>徒心的网络自留地</title><meta name="author" content="徒心"><meta name="copyright" content="徒心"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="要温柔，要快乐">
<meta property="og:type" content="website">
<meta property="og:title" content="徒心的网络自留地">
<meta property="og:url" content="https://jkup64.github.io/index.html">
<meta property="og:site_name" content="徒心的网络自留地">
<meta property="og:description" content="要温柔，要快乐">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://jkup64.github.io/images/avater2.jpg">
<meta property="article:author" content="徒心">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://jkup64.github.io/images/avater2.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://jkup64.github.io/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="6KEGOdCLLrPC5PX81XZwi31w2fujLtnRiMAZZjiFYow"/><meta name="baidu-site-verification" content="code-fuHCOXmgL5"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"距离文章上次更新已过去","messageNext":"天, 内容可能已过期."},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":500},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: true,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '徒心的网络自留地',
  isPost: false,
  isHome: true,
  isHighlightShrink: false,
  isToc: false,
  postUpdate: '2024-03-17 11:40:22'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/images/avater2.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">50</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">16</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="page" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="徒心的网络自留地"><span class="site-name">徒心的网络自留地</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div class="recent-posts" id="recent-posts"><div class="recent-post-item"><div class="post_cover right"><a href="/2024/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-CSAPP-ch12-concurrency/" title="经典并发问题- C/C++实现"><img class="post-bg" src="/images/csapp.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="经典并发问题- C/C++实现"></a></div><div class="recent-post-info"><a class="article-title" href="/2024/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-CSAPP-ch12-concurrency/" title="经典并发问题- C/C++实现">经典并发问题- C/C++实现</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-03-14T16:00:00.000Z" title="发表于 2024-03-15 00:00:00">2024-03-15</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/CSAPP/">CSAPP</a></span></div><div class="content">同步问题：step1、2、3
Q: 对于如下的代码，如何使得 foo1 的 step1 和  step2 以及 foo2 中的 step3 按照 step1、2、3 的顺序执行：
12345678910111213141516void *foo1(void *) &#123;  printf(&quot;step 1 is done\n&quot;);  printf(&quot;step 3 is done\n&quot;);&#125;void *foo2(void *) &#123; printf(&quot;step 2 is done\n&quot;); &#125;int main() &#123;  pthread_t tid1;  pthread_t tid2;  Pthread_create(&amp;tid1, NULL, foo1, NULL);  Pthread_create(&amp;tid2, NULL, foo2, NULL);  Pthread_join(tid1, NULL);  Pthread_join(tid2, NULL);  exit(0);& ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2024/01/02/C-%E3%80%8AC-Primer-5th%E3%80%8B-ch16-%E6%A8%A1%E6%9D%BF%E5%92%8C%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/" title="第16章 模板和泛型编程"><img class="post-bg" src="/images/cpp.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第16章 模板和泛型编程"></a></div><div class="recent-post-info"><a class="article-title" href="/2024/01/02/C-%E3%80%8AC-Primer-5th%E3%80%8B-ch16-%E6%A8%A1%E6%9D%BF%E5%92%8C%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/" title="第16章 模板和泛型编程">第16章 模板和泛型编程</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-01-02T09:45:58.000Z" title="发表于 2024-01-02 17:45:58">2024-01-02</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/C/%E3%80%8AC-Primer-5th%E3%80%8B/">《C++ Primer 5th》</a></span></div><div class="content">面向对象编程和泛型编程都能处理在编写程序时不知道类型的情况。

OOP能处理类型在程序运行之前都未知的情况
泛型编程中，在编译时就可以获知类型

定义模板

模板：模板是泛型编程的基础。一个模板就是一个创建类或函数的蓝图或者说公式。

函数模板


template &lt;typename T&gt; int compare(const T &amp;v1, const T &amp;v2) &#123;&#125;


模板定义以关键字 template开始，后接模板形参表，模板形参表是用尖括号&lt;&gt;括住的一个或多个模板形参的列表，用逗号分隔，不能为空。


使用模板时，我们显式或隐式地指定模板实参，将其绑定到模板参数上。


模板类型参数：类型参数前必须使用关键字class或者typename，这两个关键字含义相同，可以互换使用。旧的程序只能使用class。
注意每个参数前都要加class或typename，比如这样是错误的：template &lt;typename T, U&gt; T calc(const T&amp;, const U&amp;); U之前必须加 ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2024/01/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-CSAPP-l5-shlab/" title="CSAPP - Shell Lab 详解"><img class="post-bg" src="/images/csapp.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CSAPP - Shell Lab 详解"></a></div><div class="recent-post-info"><a class="article-title" href="/2024/01/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-CSAPP-l5-shlab/" title="CSAPP - Shell Lab 详解">CSAPP - Shell Lab 详解</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-01-02T08:35:04.000Z" title="发表于 2024-01-02 16:35:04">2024-01-02</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/CSAPP/">CSAPP</a></span></div><div class="content">

Shell Lab [Updated 7/28/03]  (README, Writeup, Release Notes, Self-Study Handout)

Students implement their own simple Unix shell program with job control, including the ctrl-c and ctrl-z keystrokes, fg, bg, and jobs commands. This is the students’ first introduction to application level concurrency, and gives them a clear idea of Unix process control, signals, and signal handling.



前言
本篇博客将会详细介绍 CSAPP 之 ShellLab 的完成过程，实现一个简易（lou）的 shell。tsh 拥有以下功能：

可以执行外部程序
支持四个内建命令，名称和功能为：

quit：退出终端
jobs ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2023/12/11/C-%E3%80%8AC-Primer-5th%E3%80%8B-ch15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" title="第15章 面向对象程序设计"><img class="post-bg" src="/images/cpp.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第15章 面向对象程序设计"></a></div><div class="recent-post-info"><a class="article-title" href="/2023/12/11/C-%E3%80%8AC-Primer-5th%E3%80%8B-ch15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" title="第15章 面向对象程序设计">第15章 面向对象程序设计</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2023-12-11T13:45:58.000Z" title="发表于 2023-12-11 21:45:58">2023-12-11</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/C/%E3%80%8AC-Primer-5th%E3%80%8B/">《C++ Primer 5th》</a></span></div><div class="content">OOP：概述

面向对象程序设计（object-oriented programming）的核心思想是数据抽象、继承和动态绑定。
数据抽象：通过使用数据抽象，可以将类的接口和实现分离。
继承（inheritance）：

通过继承联系在一起的类构成一种层次关系。
通常在层次关系的根部有一个基类（base class）。
其他类直接或者简介从基类继承而来，这些继承得到的类成为派生类（derived class）。
基类负责定义在层次关系中所有类共同拥有的成员，而每个派生类定义各自特有的成员。
对于某些函数，基类希望它的派生类个自定义适合自己的版本，此时基类就将这些函数声明成虚函数（virtual function）。
派生类必须通过使用类派生列表（class derivation list）明确指出它是从哪个基类继承而来。形式：一个冒号，后面紧跟以逗号分隔的基类列表，每个基类前都可以有访问说明符。class Bulk_quote : public Quote&#123;&#125;;
派生类必须在其内部对所有重新定义的虚函数进行声明。可以在函数之前加上virtual关键字，也可以不加。C ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2023/12/04/C-%E3%80%8AC-Primer-5th%E3%80%8B-ch14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/" title="第14章 重载运算与类型转换"><img class="post-bg" src="/images/cpp.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第14章 重载运算与类型转换"></a></div><div class="recent-post-info"><a class="article-title" href="/2023/12/04/C-%E3%80%8AC-Primer-5th%E3%80%8B-ch14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/" title="第14章 重载运算与类型转换">第14章 重载运算与类型转换</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2023-12-04T13:45:58.000Z" title="发表于 2023-12-04 21:45:58">2023-12-04</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/C/%E3%80%8AC-Primer-5th%E3%80%8B/">《C++ Primer 5th》</a></span></div><div class="content">基本概念

重载运算符是具有特殊名字的函数：由关键字operator和其后要定义的运算符号共同组成。
除了重载的函数调用运算符()外，其他重载运算符不能含有默认实参。
当一个重载的运算符是成员函数时，this绑定到左侧运算对象。动态运算符符函数的参数数量比运算对象的数量少一个。
只能重载大多数的运算符，而不能发明新的运算符号。
重载运算符的优先级和结合律跟对应的内置运算符保持一致。
调用方式：

data1 + data2;
operator+(data1, data2); 成员
data1.operator+=(data2); 非成员



运算符:



可以被重载
不可以被重载




+, -, *, /, %, ^
::, .*, ., ? :,


&amp;, `
, ~`, `!`, `,`, `=`


&lt;, &gt;, &lt;=, &gt;=, ++, --



&lt;&lt;, &gt;&gt;, ==, !=, &amp;&amp;, `



+=, -=, /=, %=, ^=, &amp;=



|=, *=, &lt;&lt;=, &gt; ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2023/12/03/C-%E3%80%8AC-Primer-5th%E3%80%8B-ch13-%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6/" title="第13章 拷贝控制"><img class="post-bg" src="/images/cpp.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第13章 拷贝控制"></a></div><div class="recent-post-info"><a class="article-title" href="/2023/12/03/C-%E3%80%8AC-Primer-5th%E3%80%8B-ch13-%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6/" title="第13章 拷贝控制">第13章 拷贝控制</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2023-12-03T13:45:58.000Z" title="发表于 2023-12-03 21:45:58">2023-12-03</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/C/%E3%80%8AC-Primer-5th%E3%80%8B/">《C++ Primer 5th》</a></span></div><div class="content">拷贝控制操作（copy control）

拷贝构造函数（copy constructor）
拷贝赋值运算符（copy-assignment operator）
移动构造函数（move constructor）
移动赋值运算符（move-assignement operator）
析构函数（destructor）

拷贝和移动构造函数定义了当用同类型的另一个对象初始化本对象时做什么，拷贝和移动赋值运算符定义了将一个对象赋予同类型的另一个对象时做什么。
拷贝、赋值和销毁
拷贝构造函数


如果一个构造函数的第一个参数是自身类类型的引用，且任何额外参数都有默认值，则此构造函数是拷贝构造函数。

注意：拷贝构造函数的第一个参数必须是一个引用类型，虽然可以定义接受非const引用的拷贝构造函数，但此参数几乎总是一个const引用。
为什么要引用类型：拷贝构造函数被用来初始化非引用类类型参数（非引用形参采取值复制，复制会调用拷贝构造函数），如果其参数不是引用类型，那么调用永远不会成功——为了调用拷贝构造函数，必须拷贝其实参，但为了拷贝实参，我们又需要调用拷贝构造函数，如此无限循环。



cla ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2023/11/30/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95-Archlinux-WSL-Segment-Fault/" title="Archlinux WSL Segment Fault on Cypthon"><img class="post-bg" src="/images/archlinux.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Archlinux WSL Segment Fault on Cypthon"></a></div><div class="recent-post-info"><a class="article-title" href="/2023/11/30/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95-Archlinux-WSL-Segment-Fault/" title="Archlinux WSL Segment Fault on Cypthon">Archlinux WSL Segment Fault on Cypthon</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2023-11-30T06:51:05.000Z" title="发表于 2023-11-30 14:51:05">2023-11-30</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/">踩坑记录</a></span></div><div class="content">先上结论：不要使用Archlinux WSL
重要的事情说三遍：

不要使用Archlinux WSL
不要使用Archlinux WSL
不要使用Archlinux WSL

看看Archlinux on WSL? / Other Architectures / Arch Linux Forums中大伙的评论：

It seems to be a set of initial unconfigured packages that you have to configure yourself.
It isn’t Arch, and it isn’t supported by the community.
Or is it maybe something unacceptable about it?
Correct, see http://archlinux.2023198.n4.nabble.com/ … l#a4718292

官方和社区都不支持，那还玩啥？
问题
下面给出一个我在使用ArchLinux WSL中遇到的问题：
当使用python运行一个使用了Cpython的脚本时，引 ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2023/11/18/C-%E3%80%8AC-Primer-5th%E3%80%8B-ch12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/" title="第12章 动态内存"><img class="post-bg" src="/images/cpp.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第12章 动态内存"></a></div><div class="recent-post-info"><a class="article-title" href="/2023/11/18/C-%E3%80%8AC-Primer-5th%E3%80%8B-ch12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/" title="第12章 动态内存">第12章 动态内存</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2023-11-18T03:03:58.000Z" title="发表于 2023-11-18 11:03:58">2023-11-18</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/C/%E3%80%8AC-Primer-5th%E3%80%8B/">《C++ Primer 5th》</a></span></div><div class="content">

对象的生命周期：

全局对象在程序启动时分配，结束时销毁。
局部对象在进入程序块时创建，离开块时销毁。
局部static对象在第一次使用前分配，在程序结束时销毁。
动态分配对象：只能显式地被释放。



对象的内存位置：

静态内存用来保存局部static对象、类static对象、定义在任何函数之外的变量。
栈内存用来保存定义在函数内的非static对象。
堆内存，又称自由空间，用来存储动态分配的对象。



如果忘记释放内存就会产生内存泄漏；如果在尚有指针引用的情况下就释放就会产生引用非法内存的指针。


动态内存与智能指针

动态内存管理：

new：在动态内存中为对象分配空间并返回一个指向该对象的指针。
delete：接受一个动态对象的指针，销毁该对象，并释放与之关联的内存。


智能指针：

管理动态对象。
行为类似常规指针。
负责自动释放所指向的对象。
智能指针也是模板。
定义在memory头文件中。



shared_ptr类
shared_ptr和unique_ptr都支持的操作：



操作
解释




shared_ptr&lt;T&gt; sp  uniqu ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2023/11/15/C-%E3%80%8AC-Primer-5th%E3%80%8B-ch11-%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/" title="第11章 关联容器"><img class="post-bg" src="/images/cpp.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第11章 关联容器"></a></div><div class="recent-post-info"><a class="article-title" href="/2023/11/15/C-%E3%80%8AC-Primer-5th%E3%80%8B-ch11-%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/" title="第11章 关联容器">第11章 关联容器</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2023-11-15T14:48:58.000Z" title="发表于 2023-11-15 22:48:58">2023-11-15</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/C/%E3%80%8AC-Primer-5th%E3%80%8B/">《C++ Primer 5th》</a></span></div><div class="content">
关联容器和顺序容器的不同：关联容器中的元素时按照关键字来保存和访问的。
关联容器支持通过关键字来高效地查找和读取元素，基本的关联容器类型是 map和 set。

关联容器类型：

map和multimap在头文件map中；set和multiset在头文件set中
无序容器分别定义在unordered_map和unordered_set中
当从map中提取一个元素时，会得到一个pair类型的对象
pair是一个模版类型，保存两个名为first和second的（公有）数据成员
set的底层实现是红黑树




容器类型
解释




按顺序存储



map
关键数组：保存关键字-值对


set
关键字即值，即只保存关键字的容器


multimap
支持同一个键多次出现的map


multiset
支持同一个键多次出现的set


无序集合



unordered_map
用哈希函数组织的map


unordered_set
用哈希函数组织的set


unordered_multimap
哈希组织的map，关键字可以重复出现


unordered_multiset
哈希组织 ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2023/11/08/%E5%88%86%E5%B8%83%E5%BC%8F-%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%EF%BC%88B%EF%BC%89-lab2/" title="lab2 分布式文件系统"><img class="post-bg" src="/images/summer_fever.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="lab2 分布式文件系统"></a></div><div class="recent-post-info"><a class="article-title" href="/2023/11/08/%E5%88%86%E5%B8%83%E5%BC%8F-%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%EF%BC%88B%EF%BC%89-lab2/" title="lab2 分布式文件系统">lab2 分布式文件系统</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2023-11-08T13:42:04.000Z" title="发表于 2023-11-08 21:42:04">2023-11-08</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%EF%BC%88B%EF%BC%89/">大数据系统基础（B）</a></span></div><div class="content">掌握Hadoop DFS常用指令
1. Hadoop 使用方法
在服务器上，我们通过Linux 指令对本地文件系统进行操作，如使用 ls 查看文件/目录信息、使用 cp进行文件复制、使用 cat 查看文件内容。在分布式文件系统中，也有一套相似的指令，接下来我们需要掌握一些基本的指令。（本题 1 分）
1234567891011121314xxxxxxxxxx@thumm01:~$ hadoop fs -ls /Found 2 itemsdrwxr-xr-x   - root  supergroup          0 2023-10-06 20:48 /dsjxtjcdrwxrwxrwx   - jtliu supergroup          0 2020-12-21 23:25 /tmpxxxxxxxxxx@thumm01:~$ hadoop fs -ls /dsjxtjc/xxxxxxxxxxxxxxxxxxxx@thumm01:~$ touch test.txtxxxxxxxxxx@thumm01:~$ echo &quot;Hello Hadoop&quot; &gt;  ...</div></div></div><nav id="pagination"><div class="pagination"><span class="page-number current">1</span><a class="page-number" href="/page/2/#content-inner">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/#content-inner">5</a><a class="extend next" rel="next" href="/page/2/#content-inner"><i class="fas fa-chevron-right fa-fw"></i></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/images/avater2.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">徒心</div><div class="author-info__description">要温柔，要快乐</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">50</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">16</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/jkup64" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:919863493@q.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">暂无公告</div></div><div class="sticky_layout"><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-CSAPP-ch12-concurrency/" title="经典并发问题- C/C++实现">经典并发问题- C/C++实现</a><time datetime="2024-03-14T16:00:00.000Z" title="发表于 2024-03-15 00:00:00">2024-03-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/01/02/C-%E3%80%8AC-Primer-5th%E3%80%8B-ch16-%E6%A8%A1%E6%9D%BF%E5%92%8C%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/" title="第16章 模板和泛型编程">第16章 模板和泛型编程</a><time datetime="2024-01-02T09:45:58.000Z" title="发表于 2024-01-02 17:45:58">2024-01-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/01/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-CSAPP-l5-shlab/" title="CSAPP - Shell Lab 详解">CSAPP - Shell Lab 详解</a><time datetime="2024-01-02T08:35:04.000Z" title="发表于 2024-01-02 16:35:04">2024-01-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/12/11/C-%E3%80%8AC-Primer-5th%E3%80%8B-ch15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" title="第15章 面向对象程序设计">第15章 面向对象程序设计</a><time datetime="2023-12-11T13:45:58.000Z" title="发表于 2023-12-11 21:45:58">2023-12-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/12/04/C-%E3%80%8AC-Primer-5th%E3%80%8B-ch14-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/" title="第14章 重载运算与类型转换">第14章 重载运算与类型转换</a><time datetime="2023-12-04T13:45:58.000Z" title="发表于 2023-12-04 21:45:58">2023-12-04</time></div></div></div></div><div class="card-widget card-categories"><div class="item-headline">
            <i class="fas fa-folder-open"></i>
            <span>分类</span>
            <a class="card-more-btn" href="/categories/" title="查看更多">
    <i class="fas fa-angle-right"></i></a>
            </div>
            <ul class="card-category-list" id="aside-cat-list">
            <li class="card-category-list-item "><a class="card-category-list-link" href="/categories/C/"><span class="card-category-list-name">C++</span><span class="card-category-list-count">21</span></a><ul class="card-category-list child"><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/C/Cherno/"><span class="card-category-list-name">Cherno</span><span class="card-category-list-count">4</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/C/%E3%80%8AC-Primer-5th%E3%80%8B/"><span class="card-category-list-name">《C++ Primer 5th》</span><span class="card-category-list-count">16</span></a></li></ul></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/Go/"><span class="card-category-list-name">Go</span><span class="card-category-list-count">1</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"><span class="card-category-list-name">分布式</span><span class="card-category-list-count">8</span></a><ul class="card-category-list child"><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/MIT6-5840/"><span class="card-category-list-name">MIT6.5840</span><span class="card-category-list-count">6</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%EF%BC%88B%EF%BC%89/"><span class="card-category-list-name">大数据系统基础（B）</span><span class="card-category-list-count">2</span></a></li></ul></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93/"><span class="card-category-list-name">技巧总结</span><span class="card-category-list-count">1</span></a></li>
            </ul></div><div class="card-widget card-tags"><div class="item-headline"><i class="fas fa-tags"></i><span>标签</span></div><div class="card-tag-cloud"><a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" style="font-size: 1.1em; color: #999">分布式</a> <a href="/tags/%E3%80%8A%E5%89%91%E6%8C%87offer%E3%80%8B/" style="font-size: 1.1em; color: #999">《剑指offer》</a> <a href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" style="font-size: 1.1em; color: #999">并发编程</a> <a href="/tags/Hexo/" style="font-size: 1.1em; color: #999">Hexo</a> <a href="/tags/%E9%9A%90%E7%A7%81%E8%AE%A1%E7%AE%97/" style="font-size: 1.23em; color: #999ea6">隐私计算</a> <a href="/tags/CSAPP/" style="font-size: 1.5em; color: #99a9bf">CSAPP</a> <a href="/tags/DP/" style="font-size: 1.23em; color: #999ea6">DP</a> <a href="/tags/butterfly/" style="font-size: 1.1em; color: #999">butterfly</a> <a href="/tags/Linux/" style="font-size: 1.1em; color: #999">Linux</a> <a href="/tags/%E7%AE%97%E6%B3%95%E9%A3%8E%E6%A0%BC/" style="font-size: 1.1em; color: #999">算法风格</a> <a href="/tags/%E6%95%B0%E4%BD%8DDP/" style="font-size: 1.1em; color: #999">数位DP</a> <a href="/tags/MIT6-5840%E8%AE%B2%E4%B9%89/" style="font-size: 1.37em; color: #99a4b2">MIT6.5840讲义</a> <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/" style="font-size: 1.37em; color: #99a4b2">分布式系统</a> <a href="/tags/PSI/" style="font-size: 1.23em; color: #999ea6">PSI</a> <a href="/tags/Go/" style="font-size: 1.1em; color: #999">Go</a> <a href="/tags/%E8%B4%AA%E5%BF%83/" style="font-size: 1.1em; color: #999">贪心</a> <a href="/tags/%E8%81%94%E9%82%A6%E5%AD%A6%E4%B9%A0/" style="font-size: 1.1em; color: #999">联邦学习</a></div></div><div class="card-widget card-archives"><div class="item-headline"><i class="fas fa-archive"></i><span>归档</span><a class="card-more-btn" href="/archives/" title="查看更多">
    <i class="fas fa-angle-right"></i></a></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/03/"><span class="card-archive-list-date">三月 2024</span><span class="card-archive-list-count">1</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/01/"><span class="card-archive-list-date">一月 2024</span><span class="card-archive-list-count">2</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/12/"><span class="card-archive-list-date">十二月 2023</span><span class="card-archive-list-count">3</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/11/"><span class="card-archive-list-date">十一月 2023</span><span class="card-archive-list-count">5</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/10/"><span class="card-archive-list-date">十月 2023</span><span class="card-archive-list-count">3</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/09/"><span class="card-archive-list-date">九月 2023</span><span class="card-archive-list-count">7</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/08/"><span class="card-archive-list-date">八月 2023</span><span class="card-archive-list-count">1</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/06/"><span class="card-archive-list-date">六月 2023</span><span class="card-archive-list-count">2</span></a></li></ul></div><div class="card-widget card-webinfo"><div class="item-headline"><i class="fas fa-chart-line"></i><span>网站资讯</span></div><div class="webinfo"><div class="webinfo-item"><div class="item-name">文章数目 :</div><div class="item-count">50</div></div><div class="webinfo-item"><div class="item-name">本站总字数 :</div><div class="item-count">208.1k</div></div><div class="webinfo-item"><div class="item-name">本站访客数 :</div><div class="item-count" id="busuanzi_value_site_uv"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">本站总访问量 :</div><div class="item-count" id="busuanzi_value_site_pv"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">最后更新时间 :</div><div class="item-count" id="last-push-date" data-lastPushDate="2024-03-17T03:40:21.711Z"><i class="fa-solid fa-spinner fa-spin"></i></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 徒心</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>